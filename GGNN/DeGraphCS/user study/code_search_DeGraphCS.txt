----------------------------QUERY-------------------------------
write a byte to output buffer of device
########################rank 1#############################
size_t
_write(int handle, const unsigned char *buffer, size_t size)
{
  int data_idx;
  for(data_idx = 0; data_idx < size; data_idx++) {
    __io_putchar(*buffer++);
  }
  return size;
}
########################rank 2#############################
static ID_INLINE void SafeFS_Write( const void *buffer, int len, fileHandle_t f )
{
  if( FS_Write( buffer, len, f ) < len )
    Com_Error( ERR_DROP, "Failed to write avi file\n" );
}
########################rank 3#############################
static int write_data(void *addr, int count)
{
	int i;
	int status;
	for(i = 0; i<count; i+= 4)
	{
		do{
			status = IO_MEM_STICK_STATUS;
			if (status & MS_TIME_OUT) return -3;
		}while(!(status & MS_FIFO_RW));
		IO_MEM_STICK_DATA = *((volatile int*)(addr + i));
	}
	return 0;
}
########################rank 4#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 5#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 6#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 7#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 8#############################
void write_() { char c = pop(); write(1, &c, 1); }
void writed() { int v = pop(); printf("%d\n", v); }
int fetch_int() {
  int now = 0;
  while(isdigit(s[ip])) {
    now = now * 10 + s[ip] - '0';
    ip++;
  }
  --ip;
  return now;
}
########################rank 9#############################
void Write16(unsigned char* pByte, unsigned short value)
{
    pByte[0] = (unsigned char)value;    
    pByte[1] = (unsigned char)(value >> 8);    
}
########################rank 10#############################
static void io_write_03F5() {
    if (!GetMSRReadyWrite) {
        return;
    } else {
        SetMSRProcWrite;
    }
    vfdc.data.cmd[vfdc.data.rwCount++] = vport.data.ioByte;
    switch (vfdc.data.cmd[0]) {
    case CMD_SPECIFY:
        if (vfdc.data.rwCount == 3) {
            ExecCmdSpecify();
        }
        break;
    case CMD_SENSE_DRIVE_STATUS:
        if (vfdc.data.rwCount == 2) {
            ExecCmdSenseDriveStatus();
        }
        break;
    case CMD_RECALIBRATE:
        if (vfdc.data.rwCount == 2) {
            ExecCmdRecalibrate();
        }
        break;
    case CMD_SENSE_INTERRUPT:
        if (vfdc.data.rwCount == 1) {
            ExecCmdSenseInterrupt();
        }
        break;
    case CMD_SEEK:
        if (vfdc.data.rwCount == 3) {
            ExecCmdSeek();
        }
        break;
    case CMD_READ_TRACK:
        if (vfdc.data.rwCount == 9) {
            ExecCmdReadTrack();
        }
        break;
    case CMD_READ_ID:
        if (vfdc.data.rwCount == 2) {
            ExecCmdReadID();
        }
        break;
    case CMD_FORMAT_TRACK:
        if (vfdc.data.rwCount == 6) {
            ExecCmdFormatTrack();
        }
        break;
    case CMD_WRITE_DATA:
        if (vfdc.data.rwCount == 9) {
            ExecCmdWriteData();
        }
        break;
    case CMD_READ_DATA_ALL:
        if (vfdc.data.rwCount == 9) {
            ExecCmdReadDataAll();
        }
        break;
    case CMD_WRITE_DELETED_DATA:
        if (vfdc.data.rwCount == 9) {
            ExecCmdWriteDeletedData();
        }
        break;
    case CMD_READ_DELETED_DATA:
        if (vfdc.data.rwCount == 9) {
            ExecCmdReadDeletedData();
        }
        break;
    case CMD_SCAN_EQUAL_ALL:
        if (vfdc.data.rwCount == 9) {
            ExecCmdScanEqualAll();
        }
        break;
    case CMD_READ_DATA:
        if (vfdc.data.rwCount == 9) {
            ExecCmdReadData();
        }
        break;
    case CMD_SCAN_EQUAL:
        if (vfdc.data.rwCount == 9) {
            ExecCmdScanEqual();
        }
        break;
    default:
        ExecCmdError();
        break;
    }
}
----------------------------QUERY-------------------------------
insert a new value into list
########################rank 1#############################
l_int32
listInsertBefore(DLLIST  **phead,
                 DLLIST   *elem,
                 void     *data)
{
DLLIST  *cell, *head;
    PROCNAME("listInsertBefore");
    if (!phead)
        return ERROR_INT("&head not defined", procName, 1);
    head = *phead;
    if (!data)
        return ERROR_INT("data not defined", procName, 1);
    if ((!head && elem) || (head && !elem))
        return ERROR_INT("head and elem not consistent", procName, 1);
    if ((cell = (DLLIST *)CALLOC(1, sizeof(DLLIST))) == NULL)
        return ERROR_INT("cell not made", procName, 1);
    cell->data = data;
    if (!head) {  /* start the list; initialize the ptrs */
        cell->prev = NULL;
        cell->next = NULL;
        *phead = cell;
    }
    else if (head == elem) {  /* insert before head of list */
        cell->prev = NULL;
        cell->next = head;
        head->prev = cell;
        *phead = cell;
    }
    else  {   /* insert before elem and after head of list */
        cell->prev = elem->prev;
        cell->next = elem;
        elem->prev->next = cell;
        elem->prev = cell;
    }
    return 0;
}
########################rank 2#############################
void _i_insert_value(List* list, list_value value)
{
	register List *head, *ent;
	if (!_i_find_value(list, value))
	{	
		ent = (List *)malloc(sizeof(List));
		ent->value=value;
		ent->destruct = list->destruct;  /* destruction method */
		ent->next=list->next;
		ent->prev=(List *)0;
		if ((head=list->next)) head->prev=ent;
		list->next=ent;
	}
}
########################rank 3#############################
l_int32
listAddToHead(DLLIST  **phead,
              void     *data)
{
DLLIST  *cell, *head;
    PROCNAME("listAddToHead");
    if (!phead)
        return ERROR_INT("&head not defined", procName, 1);
    head = *phead;
    if (!data)
        return ERROR_INT("data not defined", procName, 1);
    if ((cell = (DLLIST *)CALLOC(1, sizeof(DLLIST))) == NULL)
        return ERROR_INT("cell not made", procName, 1);
    cell->data = data;
    if (!head) {  /* start the list; initialize the ptrs */
        cell->prev = NULL;
        cell->next = NULL;
    }
    else {
        cell->prev = NULL;
        cell->next = head;
        head->prev = cell;
    }
    *phead = cell;
    return 0;
}
########################rank 4#############################
l_int32
listInsertAfter(DLLIST  **phead,
                DLLIST   *elem,
                void     *data)
{
DLLIST  *cell, *head;
    PROCNAME("listInsertAfter");
    if (!phead)
        return ERROR_INT("&head not defined", procName, 1);
    head = *phead;
    if (!data)
        return ERROR_INT("data not defined", procName, 1);
    if ((!head && elem) || (head && !elem))
        return ERROR_INT("head and elem not consistent", procName, 1);
    if ((cell = (DLLIST *)CALLOC(1, sizeof(DLLIST))) == NULL)
        return ERROR_INT("cell not made", procName, 1);
    cell->data = data;
    if (!head) {  /* start the list; initialize the ptrs */
        cell->prev = NULL;
        cell->next = NULL;
        *phead = cell;
    }
    else if (elem->next == NULL) {  /* insert after last */
        cell->prev = elem;
        cell->next = NULL;
        elem->next = cell;
    }
    else  {  /* insert after elem and before the end */
        cell->prev = elem;
        cell->next = elem->next;
        elem->next->prev = cell;
        elem->next = cell;
    }
    return 0;
}
########################rank 5#############################
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
	listTEST_LIST_INTEGRITY( pxList );
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	mtCOVERAGE_TEST_DELAY();
	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;
	pxNewListItem->pvContainer = ( void * ) pxList;
	( pxList->uxNumberOfItems )++;
}
########################rank 6#############################
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
	listTEST_LIST_INTEGRITY( pxList );
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
	If the list already contains a list item with the same item value then the
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
	}
	else
	{
		If you find your application is crashing here then likely causes are
		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
		more tips, and ensure configASSERT() is defined!
		http://www.freertos.org/a00110.html#configASSERT
			1) Stack overflow -
			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
			2) Incorrect interrupt priority assignment, especially on Cortex-M
			   parts where numerically high priority values denote low actual
			   interrupt priorities, which can seem counter intuitive.  See
			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
			   http://www.freertos.org/a00110.html
			3) Calling an API function from within a critical section or when
			   the scheduler is suspended, or calling an API function that does
			   not end in "FromISR" from an interrupt.
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
		{
			insertion position. */
		}
	}
	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
	( pxList->uxNumberOfItems )++;
}
########################rank 7#############################
void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
volatile xListItem * pxIndex;
	pxIndex = pxList->pxIndex;
	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pvContainer = ( void * ) pxList;
	( pxList->uxNumberOfItems )++;
}
########################rank 8#############################
void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;
	xValueOfInsertion = pxNewListItem->xItemValue;
	the new list item should be placed after it.  This ensures that TCB's which
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
	}
	else
	{
		If you find your application is crashing here then likely causes are:
			1) Stack overflow -
			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
			2) Incorrect interrupt priority assignment, especially on Cortex-M3
			   parts where numerically high priority values denote low actual
			   interrupt priories, which can seem counter intuitive.  See
			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
			3) Calling an API function from within a critical section or when
			   the scheduler is suspended.
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
		{
			wanted insertion position. */
		}
	}
	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
	( pxList->uxNumberOfItems )++;
}
########################rank 9#############################
int list_add_item(List_t * list, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// No head yet
	if(!list->head){
		list->head = li;
		return(1);
	}
	// Move to the end of the list
	while(nextItem->next){
		nextItem = nextItem->next;
	}
	// Made it to the end of the list
	// add the new item to the list.
	if(!li->next){
		nextItem->next = li;
	}else{
		return(0);
	}
	return(1);
}
########################rank 10#############################
int list_add_item_before(List_t * list, int idx, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// Move to right before list index or return 1 if no such index
	while(idx-1 > 0){
		// Insert after last item in list
		if(!nextItem->next){ // Index doesn't exist
			return(0);
		}else{
			nextItem = nextItem->next;
			idx--;
		}
	}
	// Add item after current "nextItem" pointed too.
	if(nextItem->next){ // Middle of list
		if(!li->next){
			ListItem_t * tmpItem = list_item_initialize();
			// Save next item in list
			tmpItem = nextItem->next;
			// Attach new item to current item's next pointer
			nextItem->next = li;
			// Attach "old" next item pointer 
			li->next = tmpItem;
			return(1);
		}else{
			return(0);
		}
	}else if(!nextItem->next){ // End of list
		if(!li->next){
			nextItem->next = li;
			return(1);
		}else{
			return(0);
		}
	}
	return(0);
}
----------------------------QUERY-------------------------------
check string is suffix of another string
########################rank 1#############################
char *
stralloc(char *s)
{
	return (strcpy(mymalloc(strlen(s) + 1), s));
}
########################rank 2#############################
char *strupr( char *s )
{
  int i;
  for(i=0; i<strlen(s); i++ ) {
    s[i] = toupper(s[i]);
  }
  return s;
}
########################rank 3#############################
l_int32
stringCat(char        *dest,
          size_t       size,
          const char  *src)
{
l_int32  i, n;
l_int32  lendest, lensrc;
    PROCNAME("stringCat");
    if (!dest)
        return ERROR_INT("dest not defined", procName, -1);
    if (size < 1)
        return ERROR_INT("size < 1; too small", procName, -1);
    if (!src)
        return 0;
    lendest = stringLength(dest, size);
    if (lendest == size)
        return ERROR_INT("no terminating nul byte", procName, -1);
    lensrc = stringLength(src, size);
    if (lensrc == 0)
        return 0;
    n = (lendest + lensrc > size - 1 ? size - lendest - 1 : lensrc);
    if (n < 1)
        return ERROR_INT("dest too small for append", procName, -1);
    for (i = 0; i < n; i++)
        dest[lendest + i] = src[i];
    dest[lendest + n] = '\0';
    return n;
}
########################rank 4#############################
int strlen(char s[]) {
    int i = 0;
    while (s[i] != '\0') ++i;
    return i;
}
########################rank 5#############################
char *Com_StringContains( char *str1, char *str2, int casesensitive ) {
	int len, i, j;
	len = strlen( str1 ) - strlen( str2 );
	for ( i = 0; i <= len; i++, str1++ ) {
		for ( j = 0; str2[j]; j++ ) {
			if ( casesensitive ) {
				if ( str1[j] != str2[j] ) {
					break;
				}
			} else {
				if ( toupper( str1[j] ) != toupper( str2[j] ) ) {
					break;
				}
			}
		}
		if ( !str2[j] ) {
			return str1;
		}
	}
	return NULL;
}
########################rank 6#############################
char *Com_StringContains( char *str1, char *str2, int casesensitive ) {
	int len, i, j;
	len = strlen( str1 ) - strlen( str2 );
	for ( i = 0; i <= len; i++, str1++ ) {
		for ( j = 0; str2[j]; j++ ) {
			if ( casesensitive ) {
				if ( str1[j] != str2[j] ) {
					break;
				}
			} else {
				if ( toupper( str1[j] ) != toupper( str2[j] ) ) {
					break;
				}
			}
		}
		if ( !str2[j] ) {
			return str1;
		}
	}
	return NULL;
}
########################rank 7#############################
const char *Com_StringContains( const char *str1, const char *str2, int casesensitive ) {
	int len, i, j;
	len = strlen( str1 ) - strlen( str2 );
	for ( i = 0; i <= len; i++, str1++ ) {
		for ( j = 0; str2[j]; j++ ) {
			if ( casesensitive ) {
				if ( str1[j] != str2[j] ) {
					break;
				}
			} else {
				if ( toupper( str1[j] ) != toupper( str2[j] ) ) {
					break;
				}
			}
		}
		if ( !str2[j] ) {
			return str1;
		}
	}
	return NULL;
}
########################rank 8#############################
BINN_PRIVATE BOOL is_bool_str(char *str, BOOL *pbool) {
  int64  vint;
  double vdouble;
  if (str == NULL || pbool == NULL) return FALSE;
  if (stricmp(str, "true") == 0) goto loc_true;
  if (stricmp(str, "yes") == 0) goto loc_true;
  if (stricmp(str, "on") == 0) goto loc_true;
  //if (stricmp(str, "1") == 0) goto loc_true;
  if (stricmp(str, "false") == 0) goto loc_false;
  if (stricmp(str, "no") == 0) goto loc_false;
  if (stricmp(str, "off") == 0) goto loc_false;
  //if (stricmp(str, "0") == 0) goto loc_false;
  if (is_integer(str)) {
    vint = atoi64(str);
    *pbool = (vint != 0) ? TRUE : FALSE;
    return TRUE;
  } else if (is_float(str)) {
    vdouble = atof(str);
    *pbool = (vdouble != 0) ? TRUE : FALSE;
    return TRUE;
  }
  return FALSE;
loc_true:
  *pbool = TRUE;
  return TRUE;
loc_false:
  *pbool = FALSE;
  return TRUE;
}
########################rank 9#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 10#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
----------------------------QUERY-------------------------------
remove all elements in list
########################rank 1#############################
void list_remove(list_t list, void *item)
{
	struct list *l, *r;
	if (*list == NULL) {
		return;
	}
	r = NULL;
	for (l = *list; l != NULL; l = l->next) {
		if (l == item) {
			if (r == NULL) {
				*list = l->next;
			} else {
				r->next = l->next;
			}
			l->next = NULL;
			return;
		}
		r = l;
	}
}
########################rank 2#############################
void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
	pxList = ( xList * ) pxItemToRemove->pvContainer;
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}
	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
}
########################rank 3#############################
alpm_list_t SYMEXPORT *alpm_list_remove_dupes(const alpm_list_t *list)
{
	const alpm_list_t *lp = list;
	alpm_list_t *newlist = NULL;
	while(lp) {
		if(!alpm_list_find_ptr(newlist, lp->data)) {
			newlist = alpm_list_add(newlist, lp->data);
		}
		lp = lp->next;
	}
	return newlist;
}
########################rank 4#############################
int list_remove(List_t * list, list_item_remove_callback_func cb){
	// Loop through entire list removing each item
	while(1){
		if( list_remove_item_head(list, cb) ){
			if(!list->head){
				break;
			}
		}else{
			return(0);
		}
	}
	return(1);
}
########################rank 5#############################
void *
listRemoveFromHead(DLLIST  **phead)
{
DLLIST  *head;
void    *data;
    PROCNAME("listRemoveFromHead");
    if (!phead)
        return (void *)ERROR_PTR("&head not defined", procName, NULL);
    if ((head = *phead) == NULL)
        return (void *)ERROR_PTR("head not defined", procName, NULL);
    if (head->next == NULL)  /* only one */
        *phead = NULL;
    else {
        head->next->prev = NULL;
        *phead = head->next;
    }
    data = head->data;
    FREE(head);
    return data;
}
########################rank 6#############################
void
list_clear(linked_list_t *list)
{
    list_entry_t *e;
    while((e = shift_entry(list)) != NULL)
    {
        * let's free memory also for it */
        if(e->tagged && e->value)
            list_destroy_tagged_value_internal((tagged_value_t *)e->value, list->free_value_cb);
        else if (list->free_value_cb)
            list->free_value_cb(e->value);
        destroy_entry(e);
    }
}
########################rank 7#############################
void *
listRemoveFromTail(DLLIST  **phead,
                   DLLIST  **ptail)
{
DLLIST  *head, *tail;
void    *data;
    PROCNAME("listRemoveFromTail");
    if (!phead)
        return (void *)ERROR_PTR("&head not defined", procName, NULL);
    if ((head = *phead) == NULL)
        return (void *)ERROR_PTR("head not defined", procName, NULL);
    if (!ptail)
        return (void *)ERROR_PTR("&tail not defined", procName, NULL);
    if ((tail = *ptail) == NULL)
        tail = listFindTail(head);
    if (head->next == NULL) { /* only one */
        *phead = NULL;
        *ptail = NULL;
    }
    else {
        tail->prev->next = NULL;
        *ptail = tail->prev;
    }
    data = tail->data;
    FREE(tail);
    return data;
}
########################rank 8#############################
void *list_pop(list_t list)
{
	struct list *l;
	l = *list;
	if (*list != NULL) {
		*list = ((struct list *)*list)->next;
	}
	return l;
}
########################rank 9#############################
void *
listRemoveElement(DLLIST  **phead,
                  DLLIST   *elem)
{
void    *data;
DLLIST  *head;
    PROCNAME("listRemoveElement");
    if (!phead)
        return (void *)ERROR_PTR("&head not defined", procName, NULL);
    head = *phead;
    if (!head)
        return (void *)ERROR_PTR("head not defined", procName, NULL);
    if (!elem)
        return (void *)ERROR_PTR("elem not defined", procName, NULL);
    data = elem->data;
    if (head->next == NULL) {  /* only one */
        if (elem != head)
            return (void *)ERROR_PTR("elem must be head", procName, NULL);
        *phead = NULL;
    }
    else if (head == elem) {   /* first one */
        elem->next->prev = NULL;
        *phead = elem->next;
    }
    else if (elem->next == NULL) {   /* last one */
        elem->prev->next = NULL;
    }
    else {  /* neither the first nor the last one */
        elem->next->prev = elem->prev;
        elem->prev->next = elem->next;
    }
    FREE(elem);
    return data;
}
########################rank 10#############################
void list_delete_at(list_t *list, int i)
{
    if(i >= list->num_objs || i < 0)
        return;
    list->obj_free(list->obj_arr[i]);
    for(; i < list->num_objs - 1; i++)
        list->obj_arr[i] = list->obj_arr[i+1];
    list->obj_arr[i] = NULL;
    list->num_objs--;
}
----------------------------QUERY-------------------------------
stop logging messages to syslog
########################rank 1#############################
void
zed_log_syslog_close(void)
{
	if (_ctx.do_syslog) {
		_ctx.do_syslog = 0;
		closelog();
	}
}
########################rank 2#############################
void
zed_log_pipe_open(void)
{
	if ((_ctx.pipe_fd[0] != -1) || (_ctx.pipe_fd[1] != -1))
		zed_log_die("Invalid use of zed_log_pipe_open in PID %d",
		    (int) getpid());
	if (pipe(_ctx.pipe_fd) < 0)
		zed_log_die("Failed to create daemonize pipe in PID %d: %s",
		    (int) getpid(), strerror(errno));
}
########################rank 3#############################
FILE *logfile;
void ErrorLog(char *fmt, ...)
{
    va_list argptr;
    static char data[1024];
    va_start(argptr, fmt);
    vsprintf(data, fmt, argptr);
    va_end(argptr);
	if (!logfile)
		logfile = Sys_fopen("error.log", "w");
	if (!logfile)
		Sys_Error("Q613: Error writing error.log: %s\nTry using -nolog" , strerror(errno));
    fprintf(logfile, data);
    //close(f);
}
########################rank 4#############################
static uint16_t current_mid = 0;
coap_status_t coap_error_code = NO_ERROR;
const char *coap_error_message = "";
static
uint16_t
coap_log_2(uint16_t value)
{
  uint16_t result = 0;
  do {
    value = value >> 1;
    result++;
  } while (value);
  return result ? result - 1 : result;
}
########################rank 5#############################
static uint16_t current_mid = 0;
coap_status_t coap_error_code = NO_ERROR;
const char *coap_error_message = "";
static
uint16_t
coap_log_2(uint16_t value)
{
  uint16_t result = 0;
  do {
    value = value >> 1;
    result++;
  } while (value);
  return result ? result - 1 : result;
}
########################rank 6#############################
extern double log2(double x)
{
  if (x == 2.0)
    return 1.0;
  else
    return log10(x) / log10(2);
}
########################rank 7#############################
void
log(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vlog(fmt, ap);
	va_end(ap);
}
########################rank 8#############################
void Con_DebugLog(char *file, char *fmt, ...)
{
    va_list argptr; 
    static char data[1024];
    int fd;
    va_start(argptr, fmt);
    vsprintf(data, fmt, argptr);
    va_end(argptr);
    fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0666);
    write(fd, data, strlen(data));
    close(fd);
}
########################rank 9#############################
void Con_DebugLog(char *file, char *fmt, ...)
{
    va_list argptr; 
    static char data[1024];
    int fd;
    va_start(argptr, fmt);
    vsprintf(data, fmt, argptr);
    va_end(argptr);
    fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0666);
    write(fd, data, strlen(data));
    close(fd);
}
########################rank 10#############################
void Con_DebugLog(char *file, char *fmt, ...)
{
    va_list argptr; 
    static char data[1024];
    int fd;
    va_start(argptr, fmt);
    vsprintf(data, fmt, argptr);
    va_end(argptr);
    fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0666);
    write(fd, data, strlen(data));
    close(fd);
}
----------------------------QUERY-------------------------------
render bignum into decimal
########################rank 1#############################
void bignum_fromint(bignum* b, unsigned int num) {
	b->length = 1;
	if(b->capacity < b->length) {
		b->capacity = b->length;
		b->data = realloc(b->data, b->capacity * sizeof(word));
	}
	b->data[0] = num;
}
########################rank 2#############################
static void PH7_PHP_ROUND_HALF_ODD_Const(ph7_value *pVal,void *pUserData)
{
	ph7_value_int(pVal,4);
	SXUNUSED(pUserData);
}
########################rank 3#############################
static void PH7_PHP_ROUND_HALF_UP_Const(ph7_value *pVal,void *pUserData)
{
	ph7_value_int(pVal,1);
	SXUNUSED(pUserData);
}
########################rank 4#############################
static void PH7_PHP_ROUND_HALF_DOWN_Const(ph7_value *pVal,void *pUserData)
{
	ph7_value_int(pVal,2);
	SXUNUSED(pUserData);
}
########################rank 5#############################
int bignum_jacobi(bignum* ac, bignum* nc) {
	bignum *remainder = bignum_init(), *twos = bignum_init();
	bignum *temp = bignum_init(), *a = bignum_init(), *n = bignum_init();
	int mult = 1, result = 0;
	bignum_copy(ac, a);
	bignum_copy(nc, n);
	while(bignum_greater(a, &NUMS[1]) && !bignum_equal(a, n)) {
		bignum_imodulate(a, n);
		if(bignum_leq(a, &NUMS[1]) || bignum_equal(a, n)) break;
		bignum_fromint(twos, 0);
		while(a->data[0] % 2 == 0) {
			bignum_iadd(twos, &NUMS[1]);
			bignum_idivide(a, &NUMS[2]);
		}
		if(bignum_greater(twos, &NUMS[0]) && twos->data[0] % 2 == 1) {
			bignum_remainder(n, &NUMS[8], remainder);
			if(!bignum_equal(remainder, &NUMS[1]) && !bignum_equal(remainder, &NUMS[7])) {
				mult *= -1;
			}
		}
		if(bignum_leq(a, &NUMS[1]) || bignum_equal(a, n)) break;
		bignum_remainder(n, &NUMS[4], remainder);
		bignum_remainder(a, &NUMS[4], temp);
		if(!bignum_equal(remainder, &NUMS[1]) && !bignum_equal(temp, &NUMS[1])) mult *= -1;
		bignum_copy(a, temp);
		bignum_copy(n, a);
		bignum_copy(temp, n);
	}
	if(bignum_equal(a, &NUMS[1])) result = mult;
	else result = 0;
	bignum_deinit(remainder);
	bignum_deinit(twos);
	bignum_deinit(temp);
	bignum_deinit(a);
	bignum_deinit(n);
	return result;
}
########################rank 6#############################
static void PH7_PHP_ROUND_HALF_EVEN_Const(ph7_value *pVal,void *pUserData)
{
	ph7_value_int(pVal,3);
	SXUNUSED(pUserData);
}
########################rank 7#############################
char *bignum_decimal(Bignum x)
{
  int ndigits, ndigit;
  int i, iszero;
  BignumInt carry;
  char *ret;
  BignumInt *workspace;
   * First, estimate the number of digits. Since log(10)/log(2)
   * is just greater than 93/28 (the joys of continued fraction
   * approximations...) we know that for every 93 bits, we need
   * at most 28 digits. This will tell us how much to malloc.
   *
   * Formally: if x has i bits, that means x is strictly less
   * than 2^i. Since 2 is less than 10^(28/93), this is less than
   * 10^(28i/93). We need an integer power of ten, so we must
   * round up (rounding down might make it less than x again).
   * Therefore if we multiply the bit count by 28/93, rounding
   * up, we will have enough digits.
   *
   * i=0 (i.e., x=0) is an irritating special case.
   */
  i = bignum_bitcount(x);
  if (!i)
    ndigits = 1; /* x = 0 */
  else
    ndigits = (28 * i + 92) / 93; /* multiply by 28/93 and round up */
  ndigits++;                      /* allow for trailing \0 */
  ret = snewn(ndigits, char);
   * Now allocate some workspace to hold the binary form as we
   * repeatedly divide it by ten. Initialise this to the
   * big-endian form of the number.
   */
  workspace = snewn(x[0], BignumInt);
  for (i = 0; i < (int)x[0]; i++)
    workspace[i] = x[x[0] - i];
   * Next, write the decimal number starting with the last digit.
   * We use ordinary short division, dividing 10 into the
   * workspace.
   */
  ndigit = ndigits - 1;
  ret[ndigit] = '\0';
  do {
    iszero = 1;
    carry = 0;
    for (i = 0; i < (int)x[0]; i++) {
       * Conceptually, we want to compute
       *
       *   (carry << BIGNUM_INT_BITS) + workspace[i]
       *   -----------------------------------------
       *                      10
       *
       * but we don't have an integer type longer than BignumInt
       * to work with. So we have to do it in pieces.
       */
      BignumInt q, r;
      q = workspace[i] / 10;
      r = workspace[i] % 10;
      q += carry * ((BIGNUM_INT_MASK - 9) / 10 + 1);
      r += carry * ((BIGNUM_INT_MASK - 9) % 10);
      q += r / 10;
      r %= 10;
      workspace[i] = q;
      carry = r;
      if (workspace[i])
        iszero = 0;
    }
    ret[--ndigit] = (char)(carry + '0');
  } while (!iszero);
   * There's a chance we've fallen short of the start of the
   * string. Correct if so.
   */
  if (ndigit > 0)
    memmove(ret, ret + ndigit, ndigits - ndigit);
   * Done.
   */
  smemclr(workspace, x[0] * sizeof(*workspace));
  sfree(workspace);
  return ret;
}
########################rank 8#############################
static void Int24_To_Int32(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src  = (unsigned char*)sourceBuffer;
    PaInt32 *dest = (PaInt32*)  destinationBuffer;
    PaInt32 temp;
    (void) ditherGenerator; 
    while( count-- )
    {
#if defined(PA_LITTLE_ENDIAN)
        temp = (((long)src[0]) << 8);  
        temp = temp | (((long)src[1]) << 16);
        temp = temp | (((long)src[2]) << 24);
#elif defined(PA_BIG_ENDIAN)
        temp = (((long)src[0]) << 24);
        temp = temp | (((long)src[1]) << 16);
        temp = temp | (((long)src[2]) << 8);
#endif
        *dest = temp;
        src += sourceStride * 3;
        dest += destinationStride;
    }
}
########################rank 9#############################
int ssh2_bignum_length(Bignum bn)
{
  return 4 + (bignum_bitcount(bn) + 8) / 8;
}
########################rank 10#############################
static void Int24_To_Int16(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    unsigned char *src = (unsigned char*)sourceBuffer;
    PaInt16 *dest = (PaInt16*)destinationBuffer;
    PaInt16 temp;
    (void) ditherGenerator; 
    while( count-- )
    {
#if defined(PA_LITTLE_ENDIAN)
        temp = (((PaInt16)src[1]));
        temp = temp | (PaInt16)(((PaInt16)src[2]) << 8);
#elif defined(PA_BIG_ENDIAN)
        temp = (PaInt16)(((PaInt16)src[0]) << 8);
        temp = temp | (((PaInt16)src[1]));
#endif
        *dest = temp;
        src += sourceStride * 3;
        dest += destinationStride;
    }
}
----------------------------QUERY-------------------------------
look for match name in system dictionary
########################rank 1#############################
int
match(dp, class, type)
	register struct databuf *dp;
	register int class, type;
{
	dprintf(5, (ddt, "match(0x%x, %d, %d) %d, %d\n",
		    dp, class, type, dp->d_class, dp->d_type));
	if (dp->d_class != class && class != C_ANY)
		return (0);
	if (dp->d_type != type && type != T_ANY)
		return (0);
	return (1);
}
########################rank 2#############################
file_t *the_files = NULL;
int nr_files = 0;
char *c_top = ":TOP";
char *norm_name(char *name)
{    return name == NULL ? c_top : name;
}
########################rank 3#############################
ThrowCode pfExecIfDefined( const char *CString )
{
    ThrowCode result = 0;
    if( NAME_BASE != (cell_t)NULL)
    {
        ExecToken  XT;
        if( ffFindC( CString, &XT ) )
        {
            result = pfCatch( XT );
        }
    }
    return result;
}
########################rank 4#############################
cell_t pfExecIfDefined( const char *CString )
{
	int result = 0;
	if( NAME_BASE != (cell_t)NULL)
	{
		ExecToken  XT;
		if( ffFindC( CString, &XT ) )
		{
			result = pfCatch( XT );
		}
	}
	return result;
}
########################rank 5#############################
struct DomainPointer
entry_name(const struct DBEntry *entry)
{
    struct DomainPointer result;
    result.length = entry->domain_length;
    result.name = entry->buf;
    return result;
}
########################rank 6#############################
static int
entry_is(PathCheckType check, trash_entry_t *entry, const char other[])
{
	char other_real[PATH_MAX*2 + 1];
	make_real_path(other, other_real, sizeof(other_real));
	const char *entry_real = get_real_trash_name(entry);
	return (check == PREFIXED_WITH)
	     ? path_starts_with(entry_real, other_real)
	     : (stroscmp(entry_real, other_real) == 0);
}
########################rank 7#############################
static int __config_name_compare(const char *a, const char *b)
{
  const char *p, *q;
  for(p = a, q = b; ; p++, q++)
  {
    int pd = ((! *p) || strchr(PATH_TOKENS, *p));
    int qd = ((! *q) || strchr(PATH_TOKENS, *q));
    if(pd && qd)
      break;
    else if(pd)
      return(-1);
    else if(qd)
      return(1);
    else if(*p < *q)
      return(-1);
    else if(*p > *q)
      return(1);
  }
  return(0);
}
########################rank 8#############################
static int unicode_find_name(const char *name_table, const char *name)
{
    const char *p, *r;
    int pos;
    size_t name_len, len;
    p = name_table;
    pos = 0;
    name_len = strlen(name);
    while (*p) {
        for(;;) {
            r = strchr(p, ',');
            if (!r)
                len = strlen(p);
            else
                len = r - p;
            if (len == name_len && !memcmp(p, name, name_len))
                return pos;
            p += len + 1;
            if (!r)
                break;
        }
        pos++;
    }
    return -1;
}
########################rank 9#############################
int match()
{
   char   *l;        /* Line pointer       */
   for (l = lbuf; *l; ++l) {
      if (pmatch(l, pbuf))
         return(1);
   }
   return(0);
}
########################rank 10#############################
int iniparser_find_entry(const dictionary * ini, const char * entry)
{
    int found=0 ;
    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {
        found = 1 ;
    }
    return found ;
}
----------------------------QUERY-------------------------------
remove an element from a row vector
########################rank 1#############################
void
sm_row_remove(prow, col)
register sm_row *prow;
register int col;
{
    register sm_element *p;
    for(p = prow->first_col; p != 0 && p->col_num < col; p = p->next_col)
	;
    if (p != 0 && p->col_num == col) {
	dll_unlink(p, prow->first_col, prow->last_col, 
			    next_col, prev_col, prow->length);
	sm_element_free(p);
    }
}
########################rank 2#############################
SQLITE_PRIVATE void sqlite3RowSetClear(RowSet *p){
  struct RowSetChunk *pChunk, *pNextChunk;
  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){
    pNextChunk = pChunk->pNextChunk;
    sqlite3DbFree(p->db, pChunk);
  }
  p->pChunk = 0;
  p->nFresh = 0;
  p->pEntry = 0;
  p->pLast = 0;
  p->pForest = 0;
  p->rsFlags = ROWSET_SORTED;
}
########################rank 3#############################
int removeNulls_execute(unsigned char *input, long int input_len, unsigned char *changed) {
    long int i, j;
    changed[0] = '0';
    i = j = 0;
    while(i < input_len) {
        if (input[i] == '\0') {
            changed[0] = '1';
        } else {
            input[j] = input[i];
            j++;
        }
        i++;
    }
    return j;
}
########################rank 4#############################
int removeWhitespace_execute(unsigned char *input, long int input_len, unsigned char *changed) {
    long int i, j;
    changed[0] = '0';
    i = j = 0;
    while(i < input_len) {
        if (isspace(input[i])||(input[i] == NBSP)) {
            changed[0] = '1';
        } else {
            input[j] = input[i];
            j++;
        }
        i++;
    }
    return j;
}
########################rank 5#############################
static void UI_RemoveBotsMenu_DeleteEvent( void* ptr, int event ) {
	if (event != QM_ACTIVATED) {
		return;
	}
	trap_Cmd_ExecuteText( EXEC_APPEND, va("clientkick %i\n", removeBotsMenuInfo.botClientNums[removeBotsMenuInfo.baseBotNum + removeBotsMenuInfo.selectedBotNum]) );
}
########################rank 6#############################
static void UI_RemoveBotsMenu_DeleteEvent( void* ptr, int event ) {
	if (event != QM_ACTIVATED) {
		return;
	}
	trap_Cmd_ExecuteText( EXEC_APPEND, va("clientkick %i\n", removeBotsMenuInfo.botClientNums[removeBotsMenuInfo.baseBotNum + removeBotsMenuInfo.selectedBotNum]) );
}
########################rank 7#############################
void
rangelist_remove_all(struct RangeList *tasks)
{
    if (tasks->list) {
        free(tasks->list);
        memset(tasks, 0, sizeof(*tasks));
    }
}
########################rank 8#############################
void
rangelist_remove_all(struct RangeList *tasks)
{
    if (tasks->list) {
        free(tasks->list);
        memset(tasks, 0, sizeof(*tasks));
    }
}
########################rank 9#############################
int libinjection_xss(const char* s, size_t len)
{
    if (libinjection_is_xss(s, len, DATA_STATE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_NO_QUOTE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_SINGLE_QUOTE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_DOUBLE_QUOTE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_BACK_QUOTE)) {
        return 1;
    }
    return 0;
}
########################rank 10#############################
int libinjection_xss(const char* s, size_t len)
{
    if (libinjection_is_xss(s, len, DATA_STATE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_NO_QUOTE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_SINGLE_QUOTE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_DOUBLE_QUOTE)) {
        return 1;
    }
    if (libinjection_is_xss(s, len, VALUE_BACK_QUOTE)) {
        return 1;
    }
    return 0;
}
----------------------------QUERY-------------------------------
load a bignum from int
########################rank 1#############################
void bignum_fromint(bignum* b, unsigned int num) {
	b->length = 1;
	if(b->capacity < b->length) {
		b->capacity = b->length;
		b->data = realloc(b->data, b->capacity * sizeof(word));
	}
	b->data[0] = num;
}
########################rank 2#############################
int ssh2_bignum_length(Bignum bn)
{
  return 4 + (bignum_bitcount(bn) + 8) / 8;
}
########################rank 3#############################
int bignum_jacobi(bignum* ac, bignum* nc) {
	bignum *remainder = bignum_init(), *twos = bignum_init();
	bignum *temp = bignum_init(), *a = bignum_init(), *n = bignum_init();
	int mult = 1, result = 0;
	bignum_copy(ac, a);
	bignum_copy(nc, n);
	while(bignum_greater(a, &NUMS[1]) && !bignum_equal(a, n)) {
		bignum_imodulate(a, n);
		if(bignum_leq(a, &NUMS[1]) || bignum_equal(a, n)) break;
		bignum_fromint(twos, 0);
		while(a->data[0] % 2 == 0) {
			bignum_iadd(twos, &NUMS[1]);
			bignum_idivide(a, &NUMS[2]);
		}
		if(bignum_greater(twos, &NUMS[0]) && twos->data[0] % 2 == 1) {
			bignum_remainder(n, &NUMS[8], remainder);
			if(!bignum_equal(remainder, &NUMS[1]) && !bignum_equal(remainder, &NUMS[7])) {
				mult *= -1;
			}
		}
		if(bignum_leq(a, &NUMS[1]) || bignum_equal(a, n)) break;
		bignum_remainder(n, &NUMS[4], remainder);
		bignum_remainder(a, &NUMS[4], temp);
		if(!bignum_equal(remainder, &NUMS[1]) && !bignum_equal(temp, &NUMS[1])) mult *= -1;
		bignum_copy(a, temp);
		bignum_copy(n, a);
		bignum_copy(temp, n);
	}
	if(bignum_equal(a, &NUMS[1])) result = mult;
	else result = 0;
	bignum_deinit(remainder);
	bignum_deinit(twos);
	bignum_deinit(temp);
	bignum_deinit(a);
	bignum_deinit(n);
	return result;
}
########################rank 4#############################
char *bignum_decimal(Bignum x)
{
  int ndigits, ndigit;
  int i, iszero;
  BignumInt carry;
  char *ret;
  BignumInt *workspace;
   * First, estimate the number of digits. Since log(10)/log(2)
   * is just greater than 93/28 (the joys of continued fraction
   * approximations...) we know that for every 93 bits, we need
   * at most 28 digits. This will tell us how much to malloc.
   *
   * Formally: if x has i bits, that means x is strictly less
   * than 2^i. Since 2 is less than 10^(28/93), this is less than
   * 10^(28i/93). We need an integer power of ten, so we must
   * round up (rounding down might make it less than x again).
   * Therefore if we multiply the bit count by 28/93, rounding
   * up, we will have enough digits.
   *
   * i=0 (i.e., x=0) is an irritating special case.
   */
  i = bignum_bitcount(x);
  if (!i)
    ndigits = 1; /* x = 0 */
  else
    ndigits = (28 * i + 92) / 93; /* multiply by 28/93 and round up */
  ndigits++;                      /* allow for trailing \0 */
  ret = snewn(ndigits, char);
   * Now allocate some workspace to hold the binary form as we
   * repeatedly divide it by ten. Initialise this to the
   * big-endian form of the number.
   */
  workspace = snewn(x[0], BignumInt);
  for (i = 0; i < (int)x[0]; i++)
    workspace[i] = x[x[0] - i];
   * Next, write the decimal number starting with the last digit.
   * We use ordinary short division, dividing 10 into the
   * workspace.
   */
  ndigit = ndigits - 1;
  ret[ndigit] = '\0';
  do {
    iszero = 1;
    carry = 0;
    for (i = 0; i < (int)x[0]; i++) {
       * Conceptually, we want to compute
       *
       *   (carry << BIGNUM_INT_BITS) + workspace[i]
       *   -----------------------------------------
       *                      10
       *
       * but we don't have an integer type longer than BignumInt
       * to work with. So we have to do it in pieces.
       */
      BignumInt q, r;
      q = workspace[i] / 10;
      r = workspace[i] % 10;
      q += carry * ((BIGNUM_INT_MASK - 9) / 10 + 1);
      r += carry * ((BIGNUM_INT_MASK - 9) % 10);
      q += r / 10;
      r %= 10;
      workspace[i] = q;
      carry = r;
      if (workspace[i])
        iszero = 0;
    }
    ret[--ndigit] = (char)(carry + '0');
  } while (!iszero);
   * There's a chance we've fallen short of the start of the
   * string. Correct if so.
   */
  if (ndigit > 0)
    memmove(ret, ret + ndigit, ndigits - ndigit);
   * Done.
   */
  smemclr(workspace, x[0] * sizeof(*workspace));
  sfree(workspace);
  return ret;
}
########################rank 5#############################
void sfact_while(int x, int *dest)
{
    int val = 1;
    while (x > 0) {
	val *= x;
	x--;
    }
    *dest = val;
}
########################rank 6#############################
void sfact_while(int x, int *dest)
{
    int val = 1;
    while (x > 0) {
	val *= x;
	x--;
    }
    *dest = val;
}
########################rank 7#############################
static inline small mod3_freeze(crypto_int32 a)
{
  a -= 3 * ((10923 * a) >> 15);
  a -= 3 * ((89478485 * a + 134217728) >> 28);
  return a;
}
########################rank 8#############################
uint32_t readU32LittleEndian(uint8_t *in)
{
	return ((uint32_t)in[0])
		| ((uint32_t)in[1] << 8)
		| ((uint32_t)in[2] << 16)
		| ((uint32_t)in[3] << 24);
}
########################rank 9#############################
static int ecp_mod_p256k1( mbedtls_mpi *N )
{
    static mbedtls_mpi_uint Rp[] = {
        BYTES_TO_T_UINT_8( 0xD1, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };
    return( ecp_mod_koblitz( N, Rp, 256 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
}
########################rank 10#############################
static int ecp_mod_p224k1( mbedtls_mpi *N )
{
    static mbedtls_mpi_uint Rp[] = {
        BYTES_TO_T_UINT_8( 0x93, 0x1A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };
#if defined(MBEDTLS_HAVE_INT64)
    return( ecp_mod_koblitz( N, Rp, 4, 1, 32, 0xFFFFFFFF ) );
#else
    return( ecp_mod_koblitz( N, Rp, 224 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
#endif
}
----------------------------QUERY-------------------------------
grab a lock on a mutex
########################rank 1#############################
SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){
  int rc = SQLITE_OK;
  if( p ){
    assert( sqlite3GlobalConfig.mutex.xMutexTry );
    return sqlite3GlobalConfig.mutex.xMutexTry(p);
  }
  return rc;
}
########################rank 2#############################
SQLITE_PRIVATE int sqlite3MutexEnd(void){
  int rc = SQLITE_OK;
  if( sqlite3GlobalConfig.mutex.xMutexEnd ){
    rc = sqlite3GlobalConfig.mutex.xMutexEnd();
  }
#ifdef SQLITE_DEBUG
  GLOBAL(int, mutexIsInit) = 0;
#endif
  return rc;
}
########################rank 3#############################
int
__objc_mutex_lock(objc_mutex_t mutex)
{
  if (pthread_mutex_lock((pthread_mutex_t *)mutex->backend) == 0)
    return 0;
  else
    return -1;
}
########################rank 4#############################
void Sys_Mutex_Lock( qmutex_t *mutex ) {
	pthread_mutex_lock( &mutex->m );
}
########################rank 5#############################
static void pthreadMutexLeave(keen_io_sqlite3_mutex *p){
  assert( pthreadMutexHeld(p) );
#if SQLITE_MUTEX_NREF
  p->nRef--;
  if( p->nRef==0 ) p->owner = 0;
#endif
  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
  if( p->nRef==0 ){
    pthread_mutex_unlock(&p->mutex);
  }
#else
  pthread_mutex_unlock(&p->mutex);
#endif
#ifdef SQLITE_DEBUG
  if( p->trace ){
    printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
  }
#endif
}
########################rank 6#############################
a_mutex_lock(plock)
volatile a_mutex_t *plock;
{
    Disable_Int();
    while (mutex_lock_failed(plock))
    {
	Enable_Int();
	while (*plock)
	    continue;
	Disable_Int();
    }
}
########################rank 7#############################
static void pthreadMutexLeave(systemdata_sqlite3_mutex *p){
  assert( pthreadMutexHeld(p) );
#if SQLITE_MUTEX_NREF
  p->nRef--;
  if( p->nRef==0 ) p->owner = 0;
#endif
  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
  if( p->nRef==0 ){
    pthread_mutex_unlock(&p->mutex);
  }
#else
  pthread_mutex_unlock(&p->mutex);
#endif
#ifdef SQLITE_DEBUG
  if( p->trace ){
    printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
  }
#endif
}
########################rank 8#############################
static void pthreadMutexEnter(keen_io_sqlite3_mutex *p){
  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
  ** our own.  This implementation assumes that pthread_equal()
  ** is atomic - that it cannot be deceived into thinking self
  ** and p->owner are equal if p->owner changes between two values
  ** that are not equal to self while the comparison is taking place.
  ** This implementation also assumes a coherent cache - that 
  ** separate processes cannot read different values from the same
  ** address at the same time.  If either of these two conditions
  ** are not met, then the mutexes will fail and problems will result.
  */
  {
    pthread_t self = pthread_self();
    if( p->nRef>0 && pthread_equal(p->owner, self) ){
      p->nRef++;
    }else{
      pthread_mutex_lock(&p->mutex);
      assert( p->nRef==0 );
      p->owner = self;
      p->nRef = 1;
    }
  }
#else
  */
  pthread_mutex_lock(&p->mutex);
#if SQLITE_MUTEX_NREF
  assert( p->nRef>0 || p->owner==0 );
  p->owner = pthread_self();
  p->nRef++;
#endif
#endif
#ifdef SQLITE_DEBUG
  if( p->trace ){
    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
  }
#endif
}
########################rank 9#############################
SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){
  if( p ){
    assert( sqlite3GlobalConfig.mutex.xMutexLeave );
    sqlite3GlobalConfig.mutex.xMutexLeave(p);
  }
}
########################rank 10#############################
SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){
  if( p ){
    assert( sqlite3GlobalConfig.mutex.xMutexEnter );
    sqlite3GlobalConfig.mutex.xMutexEnter(p);
  }
}
----------------------------QUERY-------------------------------
advance a carray cursor to next row of output
########################rank 1#############################
static int carrayNext(sqlite3_vtab_cursor *cur){
  carray_cursor *pCur = (carray_cursor*)cur;
  pCur->iRowid++;
  return SQLITE_OK;
}
########################rank 2#############################
static int expertColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
  ExpertCsr *pCsr = (ExpertCsr*)cur;
  sqlite3_value *pVal;
  pVal = sqlite3_column_value(pCsr->pData, i);
  if( pVal ){
    sqlite3_result_value(ctx, pVal);
  }
  return SQLITE_OK;
}
########################rank 3#############################
static int completionConnect(
  sqlite3 *db,
  void *pAux,
  int argc, const char *const*argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  completion_vtab *pNew;
  int rc;
  (void)(pAux);    /* Unused parameter */
  (void)(argc);    /* Unused parameter */
  (void)(argv);    /* Unused parameter */
  (void)(pzErr);   /* Unused parameter */
#define COMPLETION_COLUMN_CANDIDATE 0  /* Suggested completion of the input */
#define COMPLETION_COLUMN_PREFIX    1  /* Prefix of the word to be completed */
#define COMPLETION_COLUMN_WHOLELINE 2  /* Entire line seen so far */
#define COMPLETION_COLUMN_PHASE     3  /* ePhase - used for debugging only */
  rc = sqlite3_declare_vtab(db,
      "CREATE TABLE x("
      "  candidate TEXT,"
      "  prefix TEXT HIDDEN,"
      "  wholeline TEXT HIDDEN,"
      "  phase INT HIDDEN"        /* Used for debugging only */
      ")");
  if( rc==SQLITE_OK ){
    pNew = sqlite3_malloc( sizeof(*pNew) );
    *ppVtab = (sqlite3_vtab*)pNew;
    if( pNew==0 ) return SQLITE_NOMEM;
    memset(pNew, 0, sizeof(*pNew));
    pNew->db = db;
  }
  return rc;
}
########################rank 4#############################
static int idxFindCompatible(
  int *pRc,                       /* OUT: Error code */
  sqlite3* dbm,                   /* Database to search */
  IdxScan *pScan,                 /* Scan for table to search for index on */
  IdxConstraint *pEq,             /* List of == constraints */
  IdxConstraint *pTail            /* List of range constraints */
){
  const char *zTbl = pScan->pTab->zName;
  sqlite3_stmt *pIdxList = 0;
  IdxConstraint *pIter;
  int nEq = 0;                    /* Number of elements in pEq */
  int rc;
  for(pIter=pEq; pIter; pIter=pIter->pLink) nEq++;
  rc = idxPrintfPrepareStmt(dbm, &pIdxList, 0, "PRAGMA index_list=%Q", zTbl);
  while( rc==SQLITE_OK && sqlite3_step(pIdxList)==SQLITE_ROW ){
    int bMatch = 1;
    IdxConstraint *pT = pTail;
    sqlite3_stmt *pInfo = 0;
    const char *zIdx = (const char*)sqlite3_column_text(pIdxList, 1);
    for(pIter=pEq; pIter; pIter=pIter->pLink) pIter->bFlag = 0;
    rc = idxPrintfPrepareStmt(dbm, &pInfo, 0, "PRAGMA index_xInfo=%Q", zIdx);
    while( rc==SQLITE_OK && sqlite3_step(pInfo)==SQLITE_ROW ){
      int iIdx = sqlite3_column_int(pInfo, 0);
      int iCol = sqlite3_column_int(pInfo, 1);
      const char *zColl = (const char*)sqlite3_column_text(pInfo, 4);
      if( iIdx<nEq ){
        for(pIter=pEq; pIter; pIter=pIter->pLink){
          if( pIter->bFlag ) continue;
          if( pIter->iCol!=iCol ) continue;
          if( sqlite3_stricmp(pIter->zColl, zColl) ) continue;
          pIter->bFlag = 1;
          break;
        }
        if( pIter==0 ){
          bMatch = 0;
          break;
        }
      }else{
        if( pT ){
          if( pT->iCol!=iCol || sqlite3_stricmp(pT->zColl, zColl) ){
            bMatch = 0;
            break;
          }
          pT = pT->pLink;
        }
      }
    }
    idxFinalize(&rc, pInfo);
    if( rc==SQLITE_OK && bMatch ){
      sqlite3_finalize(pIdxList);
      return 1;
    }
  }
  idxFinalize(&rc, pIdxList);
  *pRc = rc;
  return 0;
}
########################rank 5#############################
static int completionRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
  completion_cursor *pCur = (completion_cursor*)cur;
  *pRowid = pCur->iRowid;
  return SQLITE_OK;
}
########################rank 6#############################
static int fts5VocabRowidMethod(
  sqlite3_vtab_cursor *pCursor, 
  sqlite_int64 *pRowid
){
  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
  *pRowid = pCsr->rowid;
  return SQLITE_OK;
}
########################rank 7#############################
static int fts3MatchinfoLcs(Fts3Cursor *pCsr, MatchInfo *pInfo){
  LcsIterator *aIter;
  int i;
  int iCol;
  int nToken = 0;
  ** contains one element for each matchable phrase in the query.
  **/
  aIter = sqlite3_malloc(sizeof(LcsIterator) * pCsr->nPhrase);
  if( !aIter ) return SQLITE_NOMEM;
  memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);
  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);
  for(i=0; i<pInfo->nPhrase; i++){
    LcsIterator *pIter = &aIter[i];
    nToken -= pIter->pExpr->pPhrase->nToken;
    pIter->iPosOffset = nToken;
  }
  for(iCol=0; iCol<pInfo->nCol; iCol++){
    int nLcs = 0;                 /* LCS value for this column */
    int nLive = 0;                /* Number of iterators in aIter not at EOF */
    for(i=0; i<pInfo->nPhrase; i++){
      int rc;
      LcsIterator *pIt = &aIter[i];
      rc = sqlite3Fts3EvalPhrasePoslist(pCsr, pIt->pExpr, iCol, &pIt->pRead);
      if( rc!=SQLITE_OK ) return rc;
      if( pIt->pRead ){
        pIt->iPos = pIt->iPosOffset;
        fts3LcsIteratorAdvance(&aIter[i]);
        nLive++;
      }
    }
    while( nLive>0 ){
      LcsIterator *pAdv = 0;      /* The iterator to advance by one position */
      int nThisLcs = 0;           /* LCS for the current iterator positions */
      for(i=0; i<pInfo->nPhrase; i++){
        LcsIterator *pIter = &aIter[i];
        if( pIter->pRead==0 ){
          nThisLcs = 0;
        }else{
          if( pAdv==0 || pIter->iPos<pAdv->iPos ){
            pAdv = pIter;
          }
          if( nThisLcs==0 || pIter->iPos==pIter[-1].iPos ){
            nThisLcs++;
          }else{
            nThisLcs = 1;
          }
          if( nThisLcs>nLcs ) nLcs = nThisLcs;
        }
      }
      if( fts3LcsIteratorAdvance(pAdv) ) nLive--;
    }
    pInfo->aMatchinfo[iCol] = nLcs;
  }
  sqlite3_free(aIter);
  return SQLITE_OK;
}
########################rank 8#############################
static int fts3tokConnectMethod(
  sqlite3 *db,                    /* Database connection */
  void *pHash,                    /* Hash table of tokenizers */
  int argc,                       /* Number of elements in argv array */
  const char * const *argv,       /* xCreate/xConnect argument array */
  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */
  char **pzErr                    /* OUT: sqlite3_malloc'd error message */
){
  Fts3tokTable *pTab = 0;
  const sqlite3_tokenizer_module *pMod = 0;
  sqlite3_tokenizer *pTok = 0;
  int rc;
  char **azDequote = 0;
  int nDequote;
  rc = sqlite3_declare_vtab(db, FTS3_TOK_SCHEMA);
  if( rc!=SQLITE_OK ) return rc;
  nDequote = argc-3;
  rc = fts3tokDequoteArray(nDequote, &argv[3], &azDequote);
  if( rc==SQLITE_OK ){
    const char *zModule;
    if( nDequote<1 ){
      zModule = "simple";
    }else{
      zModule = azDequote[0];
    }
    rc = fts3tokQueryTokenizer((Fts3Hash*)pHash, zModule, &pMod, pzErr);
  }
  assert( (rc==SQLITE_OK)==(pMod!=0) );
  if( rc==SQLITE_OK ){
    const char * const *azArg = (const char * const *)&azDequote[1];
    rc = pMod->xCreate((nDequote>1 ? nDequote-1 : 0), azArg, &pTok);
  }
  if( rc==SQLITE_OK ){
    pTab = (Fts3tokTable *)sqlite3_malloc(sizeof(Fts3tokTable));
    if( pTab==0 ){
      rc = SQLITE_NOMEM;
    }
  }
  if( rc==SQLITE_OK ){
    memset(pTab, 0, sizeof(Fts3tokTable));
    pTab->pMod = pMod;
    pTab->pTok = pTok;
    *ppVtab = &pTab->base;
  }else{
    if( pTok ){
      pMod->xDestroy(pTok);
    }
  }
  sqlite3_free(azDequote);
  return rc;
}
########################rank 9#############################
static int fts5VocabConnectMethod(
  sqlite3 *db,                    /* Database connection */
  void *pAux,                     /* Pointer to tokenizer hash table */
  int argc,                       /* Number of elements in argv array */
  const char * const *argv,       /* xCreate/xConnect argument array */
  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */
  char **pzErr                    /* OUT: sqlite3_malloc'd error message */
){
  return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr);
}
########################rank 10#############################
static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){
  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;
  int rc;
  TRACE_IDX_INPUTS(p);
  rc = pVtab->pModule->xBestIndex(pVtab, p);
  TRACE_IDX_OUTPUTS(p);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM ){
      sqlite3OomFault(pParse->db);
    }else if( !pVtab->zErrMsg ){
      sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));
    }else{
      sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
    }
  }
  sqlite3_free(pVtab->zErrMsg);
  pVtab->zErrMsg = 0;
#if 0
  ** Search for "xBestIndex malfunction" below */
  for(i=0; i<p->nConstraint; i++){
    if( !p->aConstraint[i].usable && p->aConstraintUsage[i].argvIndex>0 ){
      sqlite3ErrorMsg(pParse, 
          "table %s: xBestIndex returned an invalid plan", pTab->zName);
    }
  }
#endif
  return pParse->nErr;
}
----------------------------QUERY-------------------------------
split string into args respecting backwhack and quote
########################rank 1#############################
int string_split_quotes(char *str, int *argc, char ***argv)
{
	*argc = 0;
	*argv = malloc((strlen(str) + 1) * sizeof(char *));
	if(!*argv)
		return 0;
	while(*str) {
		while(isspace((int) *str)) {
			str++;
		}
		if(!*str)
			break;
		(*argv)[(*argc)++] = str;
		while(*str) {
			if(*str == '\\') {
				memmove(str, str + 1, strlen(str));
				if(*str)
					str++;
			} else if(isspace((int) *str)) {
				*str = 0;
				str++;
				break;
			} else if(*str == '\'' || *str == '\"') {
				char quote = *str;
				memmove(str, str + 1, strlen(str));
				while(*str) {
					if(*str == '\\') {
						memmove(str, str + 1, strlen(str));
						if(*str)
							str++;
					} else if(*str == quote) {
						memmove(str, str + 1, strlen(str));
						break;
					} else {
						str++;
					}
				}
			} else if(!*str) {
				break;
			} else {
				str++;
			}
		}
	}
	(*argv)[*argc] = 0;
	return 1;
}
########################rank 2#############################
const char *L10n_TranslateString( const char *domainname, const char *string ) {
	const podomain_t *podomain;
	const char *result;
	if( !string || !*string ) {
		return string;
	}
	podomain = L10n_FindPODomain( domainname );
	if( podomain ) {
		result = L10n_LookupString( podomain, string );
		if( result ) {
			return result;
		}
	}
	podomain = podomain_common;
	if( podomain ) {
		result = L10n_LookupString( podomain, string );
		if( result ) {
			return result;
		}
	}
	return NULL;
}
########################rank 3#############################
static obj_t entry_string_equalp(obj_t env, obj_t op_env, obj_t operator, obj_t operands)
{
  obj_t arg1, arg2;
  eval_args(operator->operator.name, env, op_env, operands, 2, &arg1, &arg2);
  unless(TYPE(arg1) == TYPE_STRING)
    error("%s: first argument must be a string", operator->operator.name);
  unless(TYPE(arg2) == TYPE_STRING)
    error("%s: second argument must be a string", operator->operator.name);
  return make_bool(string_equalp(arg1, arg2));
}
########################rank 4#############################
static void StutterString(unsigned long Arg)
{
  static int Flag = 1;
  STUTTER_PARAM *ps = (STUTTER_PARAM*)Arg;
  if(ps->Count == ps->Strlen)
	{
	  ps->EndDelay--;
	  if(ps->EndDelay <= 0)
		{
		  StopBlinking = 1;
		  Flag = 1;
		  if(ps->Next)
			PrintStutterString(ps->Next);
		  KillCurProc();
		  if(ps->Proc)
			ps->Proc(0);
		}
	  else if(Flag)
		{
		  BlinkCursor(ps->Win, 1);
		  Flag = 0;
		}
	  return;
	}
  PrintChar(ps->Win, ps->String[ps->Count]);
  ps->Count++;
}
########################rank 5#############################
static char *my_string(char *s)
{  int length; char *str;
   while (isspace((unsigned char)*s)) s++;
   str = s; length = 0;
   while (isalnum((unsigned char)*s) || *s == '.' || *s == '_') { length++; s++; }
   if (length == 0) return NULL;
   else {
      if (length + 1 > POOLSIZE - poolsize)
         fatal("Out of memory %s\n", s);
      strncpy(stringpool+poolsize, str, length);
      str = stringpool + poolsize;
      s = stringpool + poolsize + length;
      *s = '\0';
      lastpoolsize = poolsize;
      poolsize += length+1;
      return str; 
   }
}
########################rank 6#############################
int rl_str_pfadd(unsigned char *str, long strlen, int argc, unsigned char **argv, long *argvlen, unsigned char **_str, long *_strlen) {
    struct hllhdr *hdr;
    int updated = 0, j;
    if (str == NULL) {
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */
        if (createHLLObject(&str, &strlen)) {
            return -1;
        }
        updated++;
    } else {
        if (isHLLObject(str, strlen) != 0) return -1;
    }
    for (j = 0; j < argc; j++) {
        int retval = hllAdd(str, strlen, argv[j], argvlen[j], &str, &strlen);
        switch(retval) {
        case 1:
            updated++;
            break;
        case -1:
            return -1;
        }
    }
    hdr = (struct hllhdr *)str;
    if (updated) {
        HLL_INVALIDATE_CACHE(hdr);
    }
    *_str = str;
    *_strlen = strlen;
    return updated ? 1 : 0;
}
########################rank 7#############################
int parsetimearg( int argcount, char *args[], char *string, int *result)
{
    int i;
    if ((i = findoption( argcount, args, string)) > 0)
    {
	if (parsetime(args[i] + 1 + strlen( string), result))
	    return TRUE;
	argerrornum(args[i]+1, ME_NOTIME);
    }
    return FALSE;
}
########################rank 8#############################
extern int str_len(const struct str * str) {
    return SIZE(str->data);
}
########################rank 9#############################
int opt_String(int argc, char *argv[], int argi, opt_Option *opt) {
    if (argv[0] == NULL)
        return argi;
    if (argi == argc)
        opt_Error(opt_Missing, opt, NULL);
    else {
        char *arg = argv[argi];
        int len = strlen(arg);
        if ((opt->min != 0 || opt->max != 0) &&
            (len < opt->min || len > opt->max))
            opt_Error(opt_Range, opt, arg);
        else
            *(char **)opt->value = arg;
        argi++;
    }
    return argi;
}
########################rank 10#############################
int opt_String(int argc, char *argv[], int argi, opt_Option *opt) {
    if (argv[0] == NULL)
        return argi;
    if (argi == argc)
        opt_Error(opt_Missing, opt, NULL);
    else {
        char *arg = argv[argi];
        int len = strlen(arg);
        if ((opt->min != 0 || opt->max != 0) &&
            (len < opt->min || len > opt->max))
            opt_Error(opt_Range, opt, arg);
        else
            *(char **)opt->value = arg;
        argi++;
    }
    return argi;
}
----------------------------QUERY-------------------------------
retrieve page from the pager cache
########################rank 1#############################
SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}
########################rank 2#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( sqlite3_mutex_held(pBt->mutex) );
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 3#############################
SQLITE_PRIVATE int
sqlite3BtreeGetPage(BtShared * pBt,	/* The btree */
		    Pgno pgno,	/* Number of the page to fetch */
		    MemPage ** ppPage,	/* Return the page in this parameter */
		    int noContent	/* Do not load page content if true */
	)
{
	int rc;
	MemPage *pPage;
	DbPage *pDbPage;
	assert(sqlite3_mutex_held(pBt->mutex));
	rc = sqlite3PagerAcquire(pBt->pPager, pgno, (DbPage **) & pDbPage, noContent);
	if(rc)
		return rc;
	pPage = (MemPage *) sqlite3PagerGetExtra(pDbPage);
	pPage->aData = sqlite3PagerGetData(pDbPage);
	pPage->pDbPage = pDbPage;
	pPage->pBt = pBt;
	pPage->pgno = pgno;
	pPage->hdrOffset = pPage->pgno == 1 ? 100 : 0;
	*ppPage = pPage;
	return SQLITE_OK;
}
########################rank 4#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( wx_sqlite3_mutex_held(pBt->mutex) );
  rc = wx_sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 5#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( systemdata_sqlite3_mutex_held(pBt->mutex) );
  rc = systemdata_sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 6#############################
SQLITE_PRIVATE int sqlite3PagerAcquire(
  Pager *pPager,      /* The pager open on the database file */
  Pgno pgno,          /* Page number to fetch */
  DbPage **ppPage,    /* Write a pointer to the page here */
  int noContent       /* Do not bother reading content from disk if true */
){
  int rc;
  PgHdr *pPg;
  assert( pPager->eState>=PAGER_READER );
  assert( assert_pager_state(pPager) );
  if( pgno==0 ){
    return SQLITE_CORRUPT_BKPT;
  }
  ** Otherwise, request the page from the PCache layer. */
  if( pPager->errCode!=SQLITE_OK ){
    rc = pPager->errCode;
  }else{
    rc = sqlite3PcacheFetch(pPager->pPCache, pgno, 1, ppPage);
  }
  if( rc!=SQLITE_OK ){
    ** pager was already in the error-state when this function was called.
    ** Set pPg to 0 and jump to the exception handler.  */
    pPg = 0;
    goto pager_acquire_err;
  }
  assert( (*ppPage)->pgno==pgno );
  assert( (*ppPage)->pPager==pPager || (*ppPage)->pPager==0 );
  if( (*ppPage)->pPager && !noContent ){
    ** the page. Return without further ado.  */
    assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );
    pPager->nHit++;
    return SQLITE_OK;
  }else{
    ** be initialized.  */
    pPg = *ppPage;
    pPg->pPager = pPager;
    ** number greater than this, or the unused locking-page, is requested. */
    if( pgno>PAGER_MAX_PGNO || pgno==PAGER_MJ_PGNO(pPager) ){
      rc = SQLITE_CORRUPT_BKPT;
      goto pager_acquire_err;
    }
    if( MEMDB || pPager->dbSize<pgno || noContent || !isOpen(pPager->fd) ){
      if( pgno>pPager->mxPgno ){
        rc = SQLITE_FULL;
        goto pager_acquire_err;
      }
      if( noContent ){
        ** It merely means that we might do some extra work to journal a 
        ** page that does not need to be journaled.  Nevertheless, be sure 
        ** to test the case where a malloc error occurs while trying to set 
        ** a bit in a bit vector.
        */
        sqlite3BeginBenignMalloc();
        if( pgno<=pPager->dbOrigSize ){
          TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);
          testcase( rc==SQLITE_NOMEM );
        }
        TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);
        testcase( rc==SQLITE_NOMEM );
        sqlite3EndBenignMalloc();
      }
      memset(pPg->pData, 0, pPager->pageSize);
      IOTRACE(("ZERO %p %d\n", pPager, pgno));
    }else{
      assert( pPg->pPager==pPager );
      pPager->nMiss++;
      rc = readDbPage(pPg);
      if( rc!=SQLITE_OK ){
        goto pager_acquire_err;
      }
    }
    pager_set_pagehash(pPg);
  }
  return SQLITE_OK;
pager_acquire_err:
  assert( rc!=SQLITE_OK );
  if( pPg ){
    sqlite3PcacheDrop(pPg);
  }
  pagerUnlockIfUnused(pPager);
  *ppPage = 0;
  return rc;
}
########################rank 7#############################
SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){
  int rc = SQLITE_OK;
  ** function may be called from within PagerOpen(), before the state
  ** of the Pager object is internally consistent.
  **
  ** At one point this function returned an error if the pager was in 
  ** PAGER_ERROR state. But since PAGER_ERROR state guarantees that
  ** there is at least one outstanding page reference, this function
  ** is a no-op for that case anyhow.
  */
  u32 pageSize = *pPageSize;
  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );
  if( (pPager->memDb==0 || pPager->dbSize==0)
   && sqlite3PcacheRefCount(pPager->pPCache)==0 
   && pageSize && pageSize!=(u32)pPager->pageSize 
  ){
    char *pNew = NULL;             /* New temp space */
    i64 nByte = 0;
    if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){
      rc = sqlite3OsFileSize(pPager->fd, &nByte);
    }
    if( rc==SQLITE_OK ){
      pNew = (char *)sqlite3PageMalloc(pageSize);
      if( !pNew ) rc = SQLITE_NOMEM_BKPT;
    }
    if( rc==SQLITE_OK ){
      pager_reset(pPager);
      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
    }
    if( rc==SQLITE_OK ){
      sqlite3PageFree(pPager->pTmpSpace);
      pPager->pTmpSpace = pNew;
      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);
      pPager->pageSize = pageSize;
    }else{
      sqlite3PageFree(pNew);
    }
  }
  *pPageSize = pPager->pageSize;
  if( rc==SQLITE_OK ){
    if( nReserve<0 ) nReserve = pPager->nReserve;
    assert( nReserve>=0 && nReserve<1000 );
    pPager->nReserve = (i16)nReserve;
    pagerReportSize(pPager);
    pagerFixMaplimit(pPager);
  }
  return rc;
}
########################rank 8#############################
static int pagerStress(void *p, PgHdr *pPg){
  Pager *pPager = (Pager *)p;
  int rc = SQLITE_OK;
  assert( pPg->pPager==pPager );
  assert( pPg->flags&PGHDR_DIRTY );
  ** journal (and adding a new header) is not allowed.  This occurs
  ** during calls to systemdata_sqlite3PagerWrite() while trying to journal multiple
  ** pages belonging to the same sector.
  **
  ** The doNotSpill ROLLBACK and OFF bits inhibits all cache spilling
  ** regardless of whether or not a sync is required.  This is set during
  ** a rollback or by user request, respectively.
  **
  ** Spilling is also prohibited when in an error state since that could
  ** lead to database corruption.   In the current implementation it 
  ** is impossible for systemdata_sqlite3PcacheFetch() to be called with createFlag==3
  ** while in the error state, hence it is impossible for this routine to
  ** be called in the error state.  Nevertheless, we include a NEVER()
  ** test for the error state as a safeguard against future changes.
  */
  if( NEVER(pPager->errCode) ) return SQLITE_OK;
  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );
  testcase( pPager->doNotSpill & SPILLFLAG_OFF );
  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );
  if( pPager->doNotSpill
   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0
      || (pPg->flags & PGHDR_NEED_SYNC)!=0)
  ){
    return SQLITE_OK;
  }
  pPg->pDirty = 0;
  if( pagerUseWal(pPager) ){
    rc = subjournalPageIfRequired(pPg); 
    if( rc==SQLITE_OK ){
      rc = pagerWalFrames(pPager, pPg, 0, 0);
    }
  }else{
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
    if( pPager->tempFile==0 ){
      rc = systemdata_sqlite3JournalCreate(pPager->jfd);
      if( rc!=SQLITE_OK ) return pager_error(pPager, rc);
    }
#endif
    if( pPg->flags&PGHDR_NEED_SYNC 
     || pPager->eState==PAGER_WRITER_CACHEMOD
    ){
      rc = syncJournal(pPager, 1);
    }
    if( rc==SQLITE_OK ){
      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );
      rc = pager_write_pagelist(pPager, pPg);
    }
  }
  if( rc==SQLITE_OK ){
    PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));
    systemdata_sqlite3PcacheMakeClean(pPg);
  }
  return pager_error(pPager, rc); 
}
########################rank 9#############################
static int pagerStress(void *p, PgHdr *pPg){
  Pager *pPager = (Pager *)p;
  int rc = SQLITE_OK;
  assert( pPg->pPager==pPager );
  assert( pPg->flags&PGHDR_DIRTY );
  ** journal (and adding a new header) is not allowed.  This occurs
  ** during calls to wx_sqlite3PagerWrite() while trying to journal multiple
  ** pages belonging to the same sector.
  **
  ** The doNotSpill ROLLBACK and OFF bits inhibits all cache spilling
  ** regardless of whether or not a sync is required.  This is set during
  ** a rollback or by user request, respectively.
  **
  ** Spilling is also prohibited when in an error state since that could
  ** lead to database corruption.   In the current implementation it 
  ** is impossible for wx_sqlite3PcacheFetch() to be called with createFlag==3
  ** while in the error state, hence it is impossible for this routine to
  ** be called in the error state.  Nevertheless, we include a NEVER()
  ** test for the error state as a safeguard against future changes.
  */
  if( NEVER(pPager->errCode) ) return SQLITE_OK;
  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );
  testcase( pPager->doNotSpill & SPILLFLAG_OFF );
  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );
  if( pPager->doNotSpill
   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0
      || (pPg->flags & PGHDR_NEED_SYNC)!=0)
  ){
    return SQLITE_OK;
  }
  pPager->aStat[PAGER_STAT_SPILL]++;
  pPg->pDirty = 0;
  if( pagerUseWal(pPager) ){
    rc = subjournalPageIfRequired(pPg); 
    if( rc==SQLITE_OK ){
      rc = pagerWalFrames(pPager, pPg, 0, 0);
    }
  }else{
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
    if( pPager->tempFile==0 ){
      rc = wx_sqlite3JournalCreate(pPager->jfd);
      if( rc!=SQLITE_OK ) return pager_error(pPager, rc);
    }
#endif
    if( pPg->flags&PGHDR_NEED_SYNC 
     || pPager->eState==PAGER_WRITER_CACHEMOD
    ){
      rc = syncJournal(pPager, 1);
    }
    if( rc==SQLITE_OK ){
      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );
      rc = pager_write_pagelist(pPager, pPg);
    }
  }
  if( rc==SQLITE_OK ){
    PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));
    wx_sqlite3PcacheMakeClean(pPg);
  }
  return pager_error(pPager, rc); 
}
########################rank 10#############################
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ){
    Pager *pPager = pPg->pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
}
----------------------------QUERY-------------------------------
round up to nearest integer
########################rank 1#############################
long unsigned umul1(long unsigned x, long unsigned y)
{
    return x*y;
}
########################rank 2#############################
int absdiff_e(int x, int y) {
    return x < y ? y-x : x-y; 
} 
int lcount = 0; 
int absdiff_se(int x, int y) {
    return x < y ? (lcount++, y-x) : x-y; 
} 
int gotodiff_alt(int x, int y) {
    int result;
    if (x < y) 
	goto true;
    result = x - y;
    goto done;
 true: //line:asm:abs:false
    result =  y - x;
 done:
    return result;
} 
int main(int argc, char *argv[]) {
  int x = atoi(argv[1]);
  int y = atoi(argv[2]);
  int z1 = absdiff(x,y);
  int z2 = gotodiff(x,y);
  int z3 = cmovdiff(x,y);
  printf("x = %d, y = %d, |x-y| = (%d,%d,%d)\n", x, y, z1, z2, z3);
  return 0;
}
########################rank 3#############################
int absdiff_e(int x, int y) {
    return x < y ? y-x : x-y; 
} 
int lcount = 0; 
int absdiff_se(int x, int y) {
    return x < y ? (lcount++, y-x) : x-y; 
} 
int gotodiff_alt(int x, int y) {
    int result;
    if (x < y) 
	goto true;
    result = x - y;
    goto done;
 true: //line:asm:abs:false
    result =  y - x;
 done:
    return result;
} 
int main(int argc, char *argv[]) {
  int x = atoi(argv[1]);
  int y = atoi(argv[2]);
  int z1 = absdiff(x,y);
  int z2 = gotodiff(x,y);
  int z3 = cmovdiff(x,y);
  printf("x = %d, y = %d, |x-y| = (%d,%d,%d)\n", x, y, z1, z2, z3);
  return 0;
}
########################rank 4#############################
void rfact2(long int x, long int *result)
{
  if (x <= 1) 
    *result = 1;
  else {
    long int temp;
    rfact2(x-1,&temp);
    *result = x * temp;
  }
  return;
}
########################rank 5#############################
double factorial(const double x)
{
	return tgamma(x+1.);
}
########################rank 6#############################
int Round(double arg)
{
    return ((int)floor(arg + 0.5));
}
########################rank 7#############################
unsigned srl(unsigned x, int k) { 
    unsigned xsra = (int) x >> k; 
    return xsra; /* keeps gcc from complaining */
} 
int sra(int x, int k) { 
    int xsrl = (unsigned) x >> k; 
    return xsrl; /* keeps gcc from complaining */
}
#####################################################
int absdiff(int x, int y) {
    if (x < y) 
	return y - x; 
    else 
	return x - y; 
} 
int gotodiff(int x, int y) {
    int result;
    if (x >= y) 
	goto x_ge_y;   //line:asm:abs:goto
    result =  y - x; //line:asm:abs:cyx
    goto done;
 x_ge_y: //line:asm:abs:xgey
    result = x - y;
 done:
    return result;
} 
int absdiff2(int x, int y) { 
    int result; 
    if (x < y) 
	result = y-x; 
    else 
	result = x-y; 
    return result; 
} 
int cmovdiff(int x, int y) {
    int tval = y-x;
    int rval = x-y;
    int test = x < y;
       single instruction: */
    if (test) rval = tval; //line:asm:abs:cmovdiff:xfer
    return rval;
}
########################rank 9#############################
int absdiff(int x, int y) {
    if (x < y) 
	return y - x; 
    else 
	return x - y; 
} 
int gotodiff(int x, int y) {
    int result;
    if (x >= y) 
	goto x_ge_y;   //line:asm:abs:goto
    result =  y - x; //line:asm:abs:cyx
    goto done;
 x_ge_y: //line:asm:abs:xgey
    result = x - y;
 done:
    return result;
} 
int absdiff2(int x, int y) { 
    int result; 
    if (x < y) 
	result = y-x; 
    else 
	result = x-y; 
    return result; 
} 
int cmovdiff(int x, int y) {
    int tval = y-x;
    int rval = x-y;
    int test = x < y;
       single instruction: */
    if (test) rval = tval; //line:asm:abs:cmovdiff:xfer
    return rval;
}
########################rank 10#############################
static int ucomp3(int x)	
{
   int s, p, y, t, u, u0, sign;
   sign = 0;
   if (x < 0)
   {
      x = -x;
      sign = 0x0080;
   }
   if (x > 8031)
      x = 8031;
   x += 33;
   t = x;
   for (s = 0; s < 15; s++)
   {
      if (t & 0x4000)
	 break;
      t <<= 1;
   }
   y = x << s;
   p = (y >> 10) & 0x0f;	/* position */
   s = 9 - s;			/* segment */
   u0 = (((s << 4) | p) & 0x7f) | sign;
   u = u0 ^ 0xff;
   return u;
}
----------------------------QUERY-------------------------------
create a new thread safe queue of size siz
########################rank 1#############################
QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
	( void ) ucQueueType;
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
	if( uxItemSize == ( UBaseType_t ) 0 )
	{
		xQueueSizeInBytes = ( size_t ) 0;
	}
	else
	{
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
	if( pxNewQueue != NULL )
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
		}
		else
		{
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
		}
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
		pxNewQueue->uxItemSize = uxItemSize;
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			pxNewQueue->ucQueueType = ucQueueType;
		}
		#endif /* configUSE_TRACE_FACILITY */
		#if( configUSE_QUEUE_SETS == 1 )
		{
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */
		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
	configASSERT( xReturn );
	return xReturn;
}
########################rank 2#############################
int
__objc_mutex_allocate(objc_mutex_t mutex)
{
  mutex->backend = objc_malloc(sizeof(pthread_mutex_t));
  if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))
    {
      objc_free(mutex->backend);
      mutex->backend = NULL;
      return -1;
    }
  return 0;
}
########################rank 3#############################
thread_t *
thread_new(thread_master_t * m)
{
	thread_t *new;
	if (m->unuse.head) {
		new = thread_trim_head(&m->unuse);
		memset(new, 0, sizeof (thread_t));
		return new;
	}
	new = (thread_t *) MALLOC(sizeof (thread_t));
	m->alloc++;
	return new;
}
########################rank 4#############################
static const l_int32  INITIAL_BUFFER_ARRAYSIZE = 1024;  
 *                         L_Queue create/destroy                           *
 *--------------------------------------------------------------------------*/
 *  lqueueCreate()
 *
 *      Input:  size of ptr array to be alloc'd (0 for default)
 *      Return: lqueue, or null on error
 *
 *  Notes:
 *      (1) Allocates a ptr array of given size, and initializes counters.
 */
L_QUEUE *
lqueueCreate(l_int32  nalloc)
{
L_QUEUE  *lq;
    PROCNAME("lqueueCreate");
    if (nalloc < MIN_BUFFER_SIZE)
        nalloc = INITIAL_BUFFER_ARRAYSIZE;
    if ((lq = (L_QUEUE *)CALLOC(1, sizeof(L_QUEUE))) == NULL)
        return (L_QUEUE *)ERROR_PTR("lq not made", procName, NULL);
    if ((lq->array = (void **)CALLOC(nalloc, sizeof(void *))) == NULL)
        return (L_QUEUE *)ERROR_PTR("ptr array not made", procName, NULL);
    lq->nalloc = nalloc;
    lq->nhead = lq->nelem = 0;
    return lq;
}
########################rank 5#############################
void
_malloc_prefork(void)
{
	unsigned i;
	malloc_spin_lock(&arenas_lock);
	for (i = 0; i < narenas; i++) {
		if (arenas[i] != NULL)
			malloc_spin_lock(&arenas[i]->lock);
	}
	malloc_spin_unlock(&arenas_lock);
	malloc_mutex_lock(&base_mtx);
	malloc_mutex_lock(&huge_mtx);
#ifdef MALLOC_DSS
	malloc_mutex_lock(&dss_mtx);
#endif
}
########################rank 6#############################
void queueCreate(Queue *queue, int maxSize) {
    if (queue == NULL) return;
    queue->in.top = queue->out.top = NULL;
}
########################rank 7#############################
thrqueue_t *
thrqueue_new(size_t sz)
{
	thrqueue_t *queue;
	if (!(queue = malloc(sizeof(thrqueue_t))))
		goto out0;
	if (!(queue->data = malloc(sz * sizeof(void*))))
		goto out1;
	if (pthread_mutex_init(&queue->mutex, NULL))
		goto out2;
	if (pthread_cond_init(&queue->notempty, NULL))
		goto out3;
	if (pthread_cond_init(&queue->notfull, NULL))
		goto out4;
	queue->sz = sz;
	queue->n = 0;
	queue->in = 0;
	queue->out = 0;
	queue->block_enqueue = 1;
	queue->block_dequeue = 1;
	return queue;
out4:
	pthread_cond_destroy(&queue->notempty);
out3:
	pthread_mutex_destroy(&queue->mutex);
out2:
	free(queue->data);
out1:
	free(queue);
out0:
	return NULL;
}
########################rank 8#############################
static void
smack_stage1_generate_fails(struct SMACK * smack)
{
    unsigned s;
    unsigned a;
    struct Queue *queue;
    queue = queue_create();
    for (a=0; a<ALPHABET_SIZE; a++) {
        s = GOTO(BASE_STATE,a);
        if (s != BASE_STATE) {
            enqueue(queue, s);
            GOTO_FAIL(s) = BASE_STATE;
        }
    }
    while (queue_has_more_items(queue)) {
        unsigned r;
        r = dequeue(queue);
        for (a=0; a<ALPHABET_SIZE; a++) {
            unsigned f;
            s = GOTO(r, a);
            if (s == FAIL)
                continue;
            if (s == r)
                continue; /* snmp_hack, space_hack */
            enqueue(queue, s); /* Breadth first search on states */
            f = GOTO_FAIL(r);
            while (GOTO(f,a) == FAIL)
                f = GOTO_FAIL(f);
            GOTO_FAIL(s) = GOTO(f,a);
            if (smack->m_match[GOTO(f,a)].m_count)
                smack_copy_matches(
                    &smack->m_match[s],
                    smack->m_match[GOTO(f,a)].m_ids,
                    smack->m_match[GOTO(f,a)].m_count
                    );
        }
    }
    queue_destroy(queue);
}
########################rank 9#############################
static void
smack_stage1_generate_fails(struct SMACK * smack)
{
    unsigned s;
    unsigned a;
    struct Queue *queue;
    queue = queue_create();
    for (a=0; a<ALPHABET_SIZE; a++) {
        s = GOTO(BASE_STATE,a);
        if (s != BASE_STATE) {
            enqueue(queue, s);
            GOTO_FAIL(s) = BASE_STATE;
        }
    }
    while (queue_has_more_items(queue)) {
        unsigned r;
        r = dequeue(queue);
        for (a=0; a<ALPHABET_SIZE; a++) {
            unsigned f;
            s = GOTO(r, a);
            if (s == FAIL)
                continue;
            if (s == r)
                continue; /* snmp_hack, space_hack */
            enqueue(queue, s); /* Breadth first search on states */
            f = GOTO_FAIL(r);
            while (GOTO(f,a) == FAIL)
                f = GOTO_FAIL(f);
            GOTO_FAIL(s) = GOTO(f,a);
            if (smack->m_match[GOTO(f,a)].m_count)
                smack_copy_matches(
                    &smack->m_match[s],
                    smack->m_match[GOTO(f,a)].m_ids,
                    smack->m_match[GOTO(f,a)].m_count
                    );
        }
    }
    queue_destroy(queue);
}
########################rank 10#############################
static void
smack_stage1_generate_fails(struct SMACK * smack)
{
    unsigned s;
    unsigned a;
    struct Queue *queue;
    queue = queue_create();
    for (a=0; a<ALPHABET_SIZE; a++) {
        s = GOTO(BASE_STATE,a);
        if (s != BASE_STATE) {
            enqueue(queue, s);
            GOTO_FAIL(s) = BASE_STATE;
        }
    }
    while (queue_has_more_items(queue)) {
        unsigned r;
        r = dequeue(queue);
        for (a=0; a<ALPHABET_SIZE; a++) {
            unsigned f;
            s = GOTO(r, a);
            if (s == FAIL)
                continue;
            if (s == r)
                continue; /* snmp_hack, space_hack */
            enqueue(queue, s); /* Breadth first search on states */
            f = GOTO_FAIL(r);
            while (GOTO(f,a) == FAIL)
                f = GOTO_FAIL(f);
            GOTO_FAIL(s) = GOTO(f,a);
            if (smack->m_match[GOTO(f,a)].m_count)
                smack_copy_matches(
                    &smack->m_match[s],
                    smack->m_match[GOTO(f,a)].m_ids,
                    smack->m_match[GOTO(f,a)].m_count
                    );
        }
    }
    queue_destroy(queue);
}
----------------------------QUERY-------------------------------
push integer to end of list
########################rank 1#############################
int mlt_deque_push_back_int( mlt_deque self, int item )
{
	int error = mlt_deque_allocate( self );
	if ( error == 0 )
		self->list[ self->count ++ ].value = item;
	return error;
}
########################rank 2#############################
void list_push(list_t list, void *item)
{
	list_remove(list, item);
	((struct list *)item)->next = *list;
	*list = item;
}
########################rank 3#############################
void pvl_push(pvl_list L, void *d)
{
    struct pvl_elem_t *E = pvl_new_element(d, 0, L->tail);
       E->next = 0;
       E->prior = L->tail;
     */
    if (L->tail != 0) {
        L->tail->next = E;
    }
    if (L->head == 0) {
        L->head = E;
    }
    L->tail = E;
    L->count++;
}
########################rank 4#############################
static void
push()
{
    stack_over = STACK_FULL;            /* BOS? */
    if (!stack_over) {
        --sp;
        *sp = stack[8];                 /* copy current parameters */
        stack_sel -= 1<<2;
    }
}
########################rank 5#############################
static inline void push_cbuf(zbuf *a,uint8 data) {
	//printf("Push cbuf %d %d\n",a->cb_pos,data);
	a->cbuf[a->cb_pos++]=data;
	if (a->cb_pos>=32*1024) a->cb_pos=0;
}
########################rank 6#############################
static void pushReward(sfxHandle_t sfx, qhandle_t shader, int rewardCount) {
	if (cg.rewardStack < (MAX_REWARDSTACK-1)) {
		cg.rewardStack++;
		cg.rewardSound[cg.rewardStack] = sfx;
		cg.rewardShader[cg.rewardStack] = shader;
		cg.rewardCount[cg.rewardStack] = rewardCount;
	}
}
########################rank 7#############################
static void pushReward(sfxHandle_t sfx, qhandle_t shader, int rewardCount) {
	if (cg.rewardStack < (MAX_REWARDSTACK-1)) {
		cg.rewardStack++;
		cg.rewardSound[cg.rewardStack] = sfx;
		cg.rewardShader[cg.rewardStack] = shader;
		cg.rewardCount[cg.rewardStack] = rewardCount;
	}
}
########################rank 8#############################
static void push_bcode_history(struct v7 *v7, enum opcode op) {
  size_t i;
  if (op == OP_CHECK_CALL || op == OP_CALL || op == OP_NEW) return;
  for (i = ARRAY_SIZE(v7->last_ops) - 1; i > 0; i--) {
    v7->last_ops[i] = v7->last_ops[i - 1];
  }
  v7->last_ops[0] = op;
}
########################rank 9#############################
int append_to_list(char ***list_ptr, int *list_len, int *i, char *item)
{
   char **tmp_ptr;
   if (*i >= *list_len)
    {
       *list_len += LIST_CHUNK_SIZE;
       tmp_ptr = realloc(*list_ptr, (sizeof(**list_ptr) * *list_len));
       if (NULL == tmp_ptr)
	{
	   free(*list_ptr);
	   *list_ptr = NULL;
	   return(APPEND_FAILURE);
	} else {
	   *list_ptr = tmp_ptr;
	}
       *list_ptr = tmp_ptr;
    }
   (*list_ptr)[*i] = item;
   (*i)++;
   return(APPEND_SUCCESS);
}
########################rank 10#############################
DUK_LOCAL void duk__push_stridx(duk_context *ctx, duk_bitdecoder_ctx *bd) {
	duk_small_uint_t n;
	n = (duk_small_uint_t) duk_bd_decode(bd, DUK__STRIDX_BITS);
	DUK_ASSERT_DISABLE(n >= 0);  
	DUK_ASSERT(n < DUK_HEAP_NUM_STRINGS);
	duk_push_hstring_stridx(ctx, n);
}
----------------------------QUERY-------------------------------
restart timer from current point in time
########################rank 1#############################
void
stimer_restart(struct stimer *t)
{
  t->start = clock_seconds();
}
########################rank 2#############################
void
restart_inactivity_timer(uint32_t timeout)
{
    struct timeval now;
    if (g_this_event.ssn == NULL  ||  g_this_event.ssn->ssn_is_valid != TRUE)   return;
    gettimeofday(&now, NULL);
    timeval_add_ms(&now, timeout);
    CANCEL(g_this_event.ssn->ssn_InactivityTimer);
    g_this_event.ssn->ssn_InactivityTimer = event_add(&now, state_inactivity_timeout, g_this_event.ssn);
}
########################rank 3#############################
void CL_RestartTimeDeltas( int newTimeDelta ) {
	int i;
	cl.serverTimeDelta = cl.newServerTimeDelta = newTimeDelta;
	for( i = 0; i < MAX_TIMEDELTAS_BACKUP; i++ )
		cl.serverTimeDeltas[i] = newTimeDelta;
	if( cl_debug_timeDelta->integer ) {
		Com_Printf( S_COLOR_CYAN "***** timeDelta restarted\n" );
	}
}
########################rank 4#############################
void CL_MapRestart_f( void ) {
	if ( !com_cl_running ) {
		return;
	}
	if ( !com_cl_running->integer ) {
		return;
	}
	Com_Printf( "This command is no longer functional.\nUse \"loadgame current\" to load the current map." );
}
########################rank 5#############################
void
uip_timer_restart(struct uip_timer *t)
{
  t->start = clock_time();
}
########################rank 6#############################
static void SV_CheckPostUpdateRestart( void ) {
	// do not if there has been any activity in last 5 minutes
	if( ( svc.lastActivity + 300000 ) > Sys_Milliseconds() ) {
		return;
	}
	// if there are any new filesystem entries, restart
	if( FS_GetNotifications() & FS_NOTIFY_NEWPAKS ) {
		if( sv.state != ss_dead ) {
			// restart the current map, SV_Map also rescans the filesystem
			Com_Printf( "The server will now restart...\n\n" );
			// start the default map if current map isn't available
			Cbuf_ExecuteText( EXEC_APPEND, va( "map %s\n", svs.mapcmd[0] ? svs.mapcmd : sv_defaultmap->string ) );
		}
	}
}
########################rank 7#############################
void FS_Restart( int checksumFeed ) {
	// free anything we currently have loaded
	FS_Shutdown(qfalse);
	// set the checksum feed
	fs_checksumFeed = checksumFeed;
	// clear pak references
	FS_ClearPakReferences(0);
	// try to start up normally
	FS_Startup( BASEGAME );
#ifndef STANDALONE
	FS_CheckPak0( );
#endif
	// if we can't find default.cfg, assume that the paths are
	// busted and error out now, rather than getting an unreadable
	// graphics screen when the font fails to load
	if ( FS_ReadFile( "default.cfg", NULL ) <= 0 ) {
		// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3
		// (for instance a TA demo server)
		if (lastValidBase[0]) {
			FS_PureServerSetLoadedPaks("", "");
			Cvar_Set("fs_basepath", lastValidBase);
			Cvar_Set("fs_gamedirvar", lastValidGame);
			lastValidBase[0] = '\0';
			lastValidGame[0] = '\0';
			FS_Restart(checksumFeed);
			Com_Error( ERR_DROP, "Invalid game folder\n" );
			return;
		}
		Com_Error( ERR_FATAL, "Couldn't load default.cfg" );
	}
	if ( Q_stricmp(fs_gamedirvar->string, lastValidGame) ) {
		// skip the q3config.cfg if "safe" is on the command line
		if ( !Com_SafeMode() ) {
			Cbuf_AddText ("exec " Q3CONFIG_CFG "\n");
		}
	}
	Q_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));
	Q_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));
}
########################rank 8#############################
void timer_stop( int n )
{
    double t, now;
    now = elapsed_time();
    t = now - start[n];
    elapsed[n] += t;
}
########################rank 9#############################
void FS_Restart( int checksumFeed ) {
	// free anything we currently have loaded
	FS_Shutdown( qfalse );
	// set the checksum feed
	fs_checksumFeed = checksumFeed;
	// clear pak references
	FS_ClearPakReferences( 0 );
	// try to start up normally
	FS_Startup( BASEGAME );
	// see if we are going to allow add-ons
	FS_SetRestrictions();
	// if we can't find default.cfg, assume that the paths are
	// busted and error out now, rather than getting an unreadable
	// graphics screen when the font fails to load
	if ( FS_ReadFile( "default.cfg", NULL ) <= 0 ) {
		// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3
		// (for instance a TA demo server)
		if ( lastValidBase[0] ) {
			FS_PureServerSetLoadedPaks( "", "" );
			Cvar_Set( "fs_basepath", lastValidBase );
			Cvar_Set( "fs_gamedirvar", lastValidGame );
			lastValidBase[0] = '\0';
			lastValidGame[0] = '\0';
			Cvar_Set( "fs_restrict", "0" );
			FS_Restart( checksumFeed );
			Com_Error( ERR_DROP, "Invalid game folder\n" );
			return;
		}
		Com_Error( ERR_FATAL, "Couldn't load default.cfg" );
	}
	// bk010116 - new check before safeMode
	if ( Q_stricmp( fs_gamedirvar->string, lastValidGame ) ) {
		// skip the wolfconfig.cfg if "safe" is on the command line
		if ( !Com_SafeMode() ) {
			Cbuf_AddText( "exec wolfconfig_mp.cfg\n" );
		}
	}
	Q_strncpyz( lastValidBase, fs_basepath->string, sizeof( lastValidBase ) );
	Q_strncpyz( lastValidGame, fs_gamedirvar->string, sizeof( lastValidGame ) );
}
########################rank 10#############################
void CL_ClearState( void ) {
	if( cl.cms ) {
		CM_ReleaseReference( cl.cms );
		cl.cms = NULL;
	}
	if( cl.frames_areabits ) {
		Mem_Free( cl.frames_areabits );
		cl.frames_areabits = NULL;
	}
	if( cl.cmds ) {
		Mem_Free( cl.cmds );
		cl.cmds = NULL;
	}
	if( cl.cmd_time ) {
		Mem_Free( cl.cmd_time );
		cl.cmd_time = NULL;
	}
	if( cl.snapShots ) {
		Mem_Free( cl.snapShots );
		cl.snapShots = NULL;
	}
	// wipe the entire cl structure
	memset( &cl, 0, sizeof( client_state_t ) );
	memset( cl_baselines, 0, sizeof( cl_baselines ) );
	cl.cmds = Mem_ZoneMalloc( sizeof( *cl.cmds ) * CMD_BACKUP );
	cl.cmd_time = Mem_ZoneMalloc( sizeof( *cl.cmd_time ) * CMD_BACKUP );
	cl.snapShots = Mem_ZoneMalloc( sizeof( *cl.snapShots ) * CMD_BACKUP );
	//userinfo_modified = true;
	cls.lastExecutedServerCommand = 0;
	cls.reliableAcknowledge = 0;
	cls.reliableSequence = 0;
	cls.reliableSent = 0;
	memset( cls.reliableCommands, 0, sizeof( cls.reliableCommands ) );
	// reset ucmds buffer
	cls.ucmdHead = 0;
	cls.ucmdSent = 0;
	cls.ucmdAcknowledged = 0;
	//restart realtime and lastPacket times
	cls.realtime = 0;
	cls.gametime = 0;
	cls.lastPacketSentTime = 0;
	cls.lastPacketReceivedTime = 0;
	if( cls.wakelock ) {
		Sys_ReleaseWakeLock( cls.wakelock );
		cls.wakelock = NULL;
	}
}
----------------------------QUERY-------------------------------
return file name in path
########################rank 1#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 2#############################
char path_file_name[256];
char * getfilename(int idx) {
  sprintf(path_file_name,"%d", idx);
  return path_file_name;
}
########################rank 3#############################
const char *Sys_Basename( char *path )
{
	return basename( path );
}
########################rank 4#############################
char *
basename(char *path)
{
    char *p, *b;
    static char base[256];
    b = path;
    for (p=path; *p; ++p) {
        if (*p == '/')
            b = p + 1;
    }
    strcpy(base, b);
    for (p=base; *p; ++p) {
        if (*p == '.') {
            *p = 0;
            break;
        }
    }
    return base;
}
########################rank 5#############################
static const char* bt_get_basename(const char* path)
{
	const char* p = strchr(path, '\0') - 1;
	for (; p >= path && *p != '/' && *p != '\\'; p--);
	return (p + 1);
}
########################rank 6#############################
char *
filename_get_directory(const char *filename)
{
    char *filename2;
    size_t len = strlen(filename);
    char *result;
    while (len && filename[len] != '/' && filename[len] != '\\')
        len--;
    filename2 = malloc(len+1);
    if (filename2 == NULL)
        exit(1);
    memcpy(filename2, filename, len+1);
    filename2[len] = '\0';
    if (filename_is_absolute(filename2))
        result = filename_combine(filename2, "");
    else {
        char buf[512];
        if (getcwd(buf, sizeof(buf)) == NULL)
            exit(1);
        result = filename_combine(buf, filename2);
    }
    free(filename2);
    return result;
}
########################rank 7#############################
int make_valid_path(char *dir, mode_t mode)
{
    struct stat st;
    char *tmp = NULL, *path = stripslash(strdup(dir));
    int retval;
    if (stat(path, &st) == 0) { /* file exists */
        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
        else { retval = 0; goto end; } /* not a directory.  Oops. */
    }
    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
    retval = 1;
end:
    if (tmp != NULL) free(tmp);
    if (path != NULL) free(path);
    return retval;
}
########################rank 8#############################
char* dir2vpath(assetdir_t* dir)
{
    if(dir != root) {
        assetdir_t* parent = afs_finddir(dir, "..");
        if(parent != NULL) {
            const char* dirname = "";
            char* parent_path, *path;
            for(int i = 0; i < darray_length(parent->dir); i++) {
                if(parent->dir[i].contents == dir) {
                    dirname = parent->dir[i].name;
                    break;
                }
            }
            parent_path = dir2vpath(parent);
            if(*parent_path != '\0')
                path = join_path(parent_path, dirname);
            else
                path = clone_str(dirname);
            free(parent_path);
            return path;
        }
        else
            return pathify(""); /* this shouldn't happen */
    }
    else
        return pathify("");
}
########################rank 9#############################
char* FileName(char *name, char *ext)
{
	char *str;
	int len;
	int i;
	if(ext == EMPTY_EXT){
		return name;
	}
	i = len = strlen(name);
	while (i > 0 && name[i - 1] != '.'){
		i--;
	}
	if(i > 0){
		len = i - 1;
	}
	str = Alloc(len + strlen(ext)+1);
	strncpy(str,name,len);
	str[len] = '\0';
	strcat(str,ext);	
	return str;		
}
########################rank 10#############################
static int
isRootDirPath(const char *path)
{
    return findRootDirPath(path) != NULL;
}
----------------------------QUERY-------------------------------
get name of current executable
########################rank 1#############################
const char *
HBF_GetProperty(HBF *handle, const char *propertyName)
{
	return hbfProperty(handle, propertyName);
}
########################rank 2#############################
static char* GetAccessName(Symbol p)
{
	if (p->aname != NULL)
		return p->aname;
	switch (p->kind)
	{
	case SK_Constant:
		// movl $4, -4(%ebp)
		p->aname = FormatName("$%s", p->name);
		break;
	case SK_String:
	case SK_Label:
		// .str0:	.string	"%d \012"		
		p->aname = FormatName(".%s", p->name);
		break;
	case SK_Variable:
	case SK_Temp:		
		if (p->level == 0 || p->sclass == TK_EXTERN){
			p->aname = p->name;
		}
		else if (p->sclass == TK_STATIC)
		{
				int main(){	
					static int c = 5;
					...
				}
				c.0:	.long	5	
				Because it is illegal to declare a global var in C language as following:
					int c.0;	
				So there is no conflict to generate a name 'c.0' for static variable in 
				assembly output.
			 */
			p->aname = FormatName("%s.%d", p->name, TempNum++);
		}
		else
		{
				typedef struct{
					int arr[10];
				}Data;
				int main(){
					Data dt ;				
					dt.arr[5] = 100;		
				}
			 */
			// movl 20(%ebp), %eax			
			p->aname = FormatName("%d(%%ebp)", AsVar(p)->offset);
		}
		break;
	case SK_Function:
			.globl	f
			f:
		**/
		p->aname = p->name;
		break;
	case SK_Offset:
		{
			Symbol base = p->link;
			int n = AsVar(p)->offset;
				typedef struct{
					int a;
					int b;
					int c;
					int d;
				}Data;
				Data dt2;
				int main(){
					Data dt1;
					dt1.c = 100;
					dt2.d = 200;
					return 0;
				}
				.lcomm	__va_arg_tmp,4
				.comm	dt2,16
				.text
				.globl	main
				main:
					pushl %ebp
					pushl %ebx
					pushl %esi
					pushl %edi
					movl %esp, %ebp
					subl $24, %esp
					leal -16(%ebp), %eax
					movl $100, -8(%ebp)	----------- -8(%ebp)
					leal dt2, %ecx
					movl $200, dt2+12		-----------dt2 + 12
					movl $0, %eax
					jmp .BB0
			*/
			if (base->level == 0 || base->sclass == TK_STATIC || base->sclass == TK_EXTERN)
			{
				p->aname = FormatName("%s%s%d", GetAccessName(base), n >= 0 ? "+" : "", n);
			}
			else
			{
					typedef struct{
						int arr[10];
					}Data;
					int main(){
						Data dt ;				----	dt is SK_Variable
						dt.arr[5] = 100;		----  dt.arr[5] is SK_Offset
					}
				 */
				n += AsVar(base)->offset;
				p->aname = FormatName("%d(%%ebp)", n);
			}
		}
		break;
	default:
		assert(0);
	}
	return p->aname;
}
########################rank 3#############################
LIBTCCAPI void *tcc_get_symbol(TCCState *s, const char *name)
{
    return (void*)(uintptr_t)get_elf_sym_addr(s, name, 0);
}
########################rank 4#############################
const char *Sys_Library_GetFullName( const char *name ) {
	return FS_AbsoluteNameForBaseFile( name );
}
########################rank 5#############################
int my_system_property_get(const char *name, char *value)
{
	return property_get(name, value, NULL);
}
########################rank 6#############################
char *get_otherdirndesc() {
  return recvdirnstr;
}
########################rank 7#############################
char *get_currentdirndesc() {
  return senddirnstr;
}
########################rank 8#############################
char *
selaGetBrickName(SELA    *sela,
                 l_int32  hsize,
                 l_int32  vsize)
{
l_int32  i, nsels, sx, sy;
SEL     *sel;
    PROCNAME("selaGetBrickName");
    if (!sela)
        return (char *)ERROR_PTR("sela not defined", procName, NULL);
    nsels = selaGetCount(sela);
    for (i = 0; i < nsels; i++) {
        sel = selaGetSel(sela, i);
        selGetParameters(sel, &sy, &sx, NULL, NULL);
        if (hsize == sx && vsize == sy)
            return stringNew(selGetName(sel));
    }
    return (char *)ERROR_PTR("sel not found", procName, NULL);
}
########################rank 9#############################
static int get_lang(char *b)
{
	char *s;
	s = getenv("LANG");
	if (!s || strlen(s) < 2)
		return -1;
	b[0] = s[0];
	b[1] = s[1];
	b[2] = '\0';
	return 0;
}
########################rank 10#############################
static int
p_get_var_name(value vvar, type tvar, value vname, type tname)
{
    dident      dname;
    Check_Output_Atom_Or_Nil(vname, tname);
    if (IsRef(tvar) && IsNamed(tvar.kernel))
    {
	dname = TagDid(tvar.kernel);
	Return_Unify_Atom(vname, tname, dname);
    }
    else
    {
	Set_Bip_Error(0);
	Fail_;
    }
}
----------------------------QUERY-------------------------------
read machine uptime
########################rank 1#############################
static int
kvs_get(strm_stream* strm, int argc, strm_value* args, strm_value* ret)
{
  strm_kvs* k = get_kvs(argc, args);
  strm_string key = strm_str_intern_str(strm_to_str(args[1]));
  khiter_t i;
  if (!k) {
    strm_raise(strm, "no kvs given");
    return STRM_NG;
  }
  pthread_mutex_lock(&k->lock);
  i = kh_get(kvs, k->kv, key);
  if (i == kh_end(k->kv)) {
    *ret = strm_nil_value();
  }
  else {
    *ret = kh_value(k->kv, i);
  }
  pthread_mutex_unlock(&k->lock);
  return STRM_OK;
}
########################rank 2#############################
static inline ssize_t
udpsockread(z_strm *strm, void *buf, size_t sze)
{
	ssize_t ret;
	struct udp_strm *s = &strm->hdl.udp;
	socklen_t slen = sizeof(s->saddr);
	ret = recvfrom(s->sock, buf, sze, 0, (struct sockaddr *)&s->saddr, &slen);
	if (ret <= 0)
		return ret;
	s->srcaddr[0] = '\0';
	switch (s->saddr.sin6_family) {
		case PF_INET:
			inet_ntop(s->saddr.sin6_family,
					&((struct sockaddr_in *)&s->saddr)->sin_addr,
					s->srcaddr, s->srcaddrlen);
			break;
		case PF_INET6:
			inet_ntop(s->saddr.sin6_family, &s->saddr.sin6_addr,
					s->srcaddr, s->srcaddrlen);
			break;
	}
	return ret;
}
########################rank 3#############################
static HB_Error  Load_LigatureArray( HB_LigatureArray*  la,
				     HB_UShort           num_classes,
				     HB_Stream           stream )
{
  HB_Error  error;
  HB_UShort            n, m, count;
  HB_UInt             cur_offset, new_offset, base_offset;
  HB_LigatureAttach*  lat;
  base_offset = FILE_Pos();
  if ( ACCESS_Frame( 2L ) )
    return error;
  count = la->LigatureCount = GET_UShort();
  FORGET_Frame();
  la->LigatureAttach = NULL;
  if ( ALLOC_ARRAY( la->LigatureAttach, count, HB_LigatureAttach ) )
    return error;
  lat = la->LigatureAttach;
  for ( n = 0; n < count; n++ )
  {
    if ( ACCESS_Frame( 2L ) )
      goto Fail;
    new_offset = GET_UShort() + base_offset;
    FORGET_Frame();
    cur_offset = FILE_Pos();
    if ( FILE_Seek( new_offset ) ||
	 ( error = Load_LigatureAttach( &lat[n], num_classes,
					stream ) ) != HB_Err_Ok )
      goto Fail;
    (void)FILE_Seek( cur_offset );
  }
  return HB_Err_Ok;
Fail:
  for ( m = 0; m < n; m++ )
    Free_LigatureAttach( &lat[m], num_classes );
  FREE( lat );
  return error;
}
########################rank 4#############################
static inline ssize_t
sockread(z_strm *strm, void *buf, size_t sze)
{
	return read(strm->hdl.sock, buf, sze);
}
########################rank 5#############################
static void Controls_UpdateModel( int anim ) {
	VectorClear( s_controls.playerViewangles );
	VectorClear( s_controls.playerMoveangles );
	s_controls.playerViewangles[YAW] = 180 - 30;
	s_controls.playerMoveangles[YAW] = s_controls.playerViewangles[YAW];
	s_controls.playerLegs		     = LEGS_IDLE;
	s_controls.playerTorso			 = TORSO_STAND;
	s_controls.playerWeapon			 = -1;
	s_controls.playerChat			 = qfalse;
	switch( anim ) {
	case ANIM_RUN:	
		s_controls.playerLegs = LEGS_RUN;
		break;
	case ANIM_WALK:	
		s_controls.playerLegs = LEGS_WALK;
		break;
	case ANIM_BACK:	
		s_controls.playerLegs = LEGS_BACK;
		break;
	case ANIM_JUMP:	
		s_controls.playerLegs = LEGS_JUMP;
		break;
	case ANIM_CROUCH:	
		s_controls.playerLegs = LEGS_IDLECR;
		break;
	case ANIM_TURNLEFT:
		s_controls.playerViewangles[YAW] += 90;
		break;
	case ANIM_TURNRIGHT:
		s_controls.playerViewangles[YAW] -= 90;
		break;
	case ANIM_STEPLEFT:
		s_controls.playerLegs = LEGS_WALK;
		s_controls.playerMoveangles[YAW] = s_controls.playerViewangles[YAW] + 90;
		break;
	case ANIM_STEPRIGHT:
		s_controls.playerLegs = LEGS_WALK;
		s_controls.playerMoveangles[YAW] = s_controls.playerViewangles[YAW] - 90;
		break;
	case ANIM_LOOKUP:
		s_controls.playerViewangles[PITCH] = -45;
		break;
	case ANIM_LOOKDOWN:
		s_controls.playerViewangles[PITCH] = 45;
		break;
	case ANIM_WEAPON1:
		s_controls.playerWeapon = WP_GAUNTLET;
		break;
	case ANIM_WEAPON2:
		s_controls.playerWeapon = WP_MACHINEGUN;
		break;
	case ANIM_WEAPON3:
		s_controls.playerWeapon = WP_SHOTGUN;
		break;
	case ANIM_WEAPON4:
		s_controls.playerWeapon = WP_GRENADE_LAUNCHER;
		break;
	case ANIM_WEAPON5:
		s_controls.playerWeapon = WP_ROCKET_LAUNCHER;
		break;
	case ANIM_WEAPON6:
		s_controls.playerWeapon = WP_LIGHTNING;
		break;
	case ANIM_WEAPON7:
		s_controls.playerWeapon = WP_RAILGUN;
		break;
	case ANIM_WEAPON8:
		s_controls.playerWeapon = WP_PLASMAGUN;
		break;
	case ANIM_WEAPON9:
		s_controls.playerWeapon = WP_BFG;
		break;
	case ANIM_WEAPON10:
		s_controls.playerWeapon = WP_GRAPPLING_HOOK;
		break;
	case ANIM_ATTACK:
		s_controls.playerTorso = TORSO_ATTACK;
		break;
	case ANIM_GESTURE:
		s_controls.playerTorso = TORSO_GESTURE;
		break;
	case ANIM_DIE:
		s_controls.playerLegs = BOTH_DEATH1;
		s_controls.playerTorso = BOTH_DEATH1;
		s_controls.playerWeapon = WP_NONE;
		break;
	case ANIM_CHAT:
		s_controls.playerChat = qtrue;
		break;
	default:
		break;
	}
	UI_PlayerInfo_SetInfo( &s_controls.playerinfo, s_controls.playerLegs, s_controls.playerTorso, s_controls.playerViewangles, s_controls.playerMoveangles, s_controls.playerWeapon, s_controls.playerChat );
}
########################rank 6#############################
static void Controls_UpdateModel( int anim ) {
	VectorClear( s_controls.playerViewangles );
	VectorClear( s_controls.playerMoveangles );
	s_controls.playerViewangles[YAW] = 180 - 30;
	s_controls.playerMoveangles[YAW] = s_controls.playerViewangles[YAW];
	s_controls.playerLegs		     = LEGS_IDLE;
	s_controls.playerTorso			 = TORSO_STAND;
	s_controls.playerWeapon			 = -1;
	s_controls.playerChat			 = qfalse;
	switch( anim ) {
	case ANIM_RUN:	
		s_controls.playerLegs = LEGS_RUN;
		break;
	case ANIM_WALK:	
		s_controls.playerLegs = LEGS_WALK;
		break;
	case ANIM_BACK:	
		s_controls.playerLegs = LEGS_BACK;
		break;
	case ANIM_JUMP:	
		s_controls.playerLegs = LEGS_JUMP;
		break;
	case ANIM_CROUCH:	
		s_controls.playerLegs = LEGS_IDLECR;
		break;
	case ANIM_TURNLEFT:
		s_controls.playerViewangles[YAW] += 90;
		break;
	case ANIM_TURNRIGHT:
		s_controls.playerViewangles[YAW] -= 90;
		break;
	case ANIM_STEPLEFT:
		s_controls.playerLegs = LEGS_WALK;
		s_controls.playerMoveangles[YAW] = s_controls.playerViewangles[YAW] + 90;
		break;
	case ANIM_STEPRIGHT:
		s_controls.playerLegs = LEGS_WALK;
		s_controls.playerMoveangles[YAW] = s_controls.playerViewangles[YAW] - 90;
		break;
	case ANIM_LOOKUP:
		s_controls.playerViewangles[PITCH] = -45;
		break;
	case ANIM_LOOKDOWN:
		s_controls.playerViewangles[PITCH] = 45;
		break;
	case ANIM_WEAPON1:
		s_controls.playerWeapon = WP_GAUNTLET;
		break;
	case ANIM_WEAPON2:
		s_controls.playerWeapon = WP_MACHINEGUN;
		break;
	case ANIM_WEAPON3:
		s_controls.playerWeapon = WP_SHOTGUN;
		break;
	case ANIM_WEAPON4:
		s_controls.playerWeapon = WP_GRENADE_LAUNCHER;
		break;
	case ANIM_WEAPON5:
		s_controls.playerWeapon = WP_ROCKET_LAUNCHER;
		break;
	case ANIM_WEAPON6:
		s_controls.playerWeapon = WP_LIGHTNING;
		break;
	case ANIM_WEAPON7:
		s_controls.playerWeapon = WP_RAILGUN;
		break;
	case ANIM_WEAPON8:
		s_controls.playerWeapon = WP_PLASMAGUN;
		break;
	case ANIM_WEAPON9:
		s_controls.playerWeapon = WP_BFG;
		break;
	case ANIM_WEAPON10:
		s_controls.playerWeapon = WP_GRAPPLING_HOOK;
		break;
	case ANIM_ATTACK:
		s_controls.playerTorso = TORSO_ATTACK;
		break;
	case ANIM_GESTURE:
		s_controls.playerTorso = TORSO_GESTURE;
		break;
	case ANIM_DIE:
		s_controls.playerLegs = BOTH_DEATH1;
		s_controls.playerTorso = BOTH_DEATH1;
		s_controls.playerWeapon = WP_NONE;
		break;
	case ANIM_CHAT:
		s_controls.playerChat = qtrue;
		break;
	default:
		break;
	}
	UI_PlayerInfo_SetInfo( &s_controls.playerinfo, s_controls.playerLegs, s_controls.playerTorso, s_controls.playerViewangles, s_controls.playerMoveangles, s_controls.playerWeapon, s_controls.playerChat );
}
########################rank 7#############################
int
vmir_load(ir_unit_t *iu, const uint8_t *u8, int len)
{
  bcbitstream_t bs = {0};
  bs.rdata = u8;
  bs.bytes_length = len;
  TAILQ_INIT(&iu->iu_functions_with_bodies);
  if(setjmp(iu->iu_parser_jmp)) {
    iu_cleanup(iu);
    return VMIR_ERR_LOAD_ERROR;
  }
#ifdef VMIR_VM_JIT
  jit_init(iu);
#endif
  const uint32_t magic = read_bits(&bs, 32);
  iu->iu_data_ptr = 4096;
  switch(magic) {
  case 0x6d736100: // WebAssembly
    iu->iu_mode = VMIR_WASM;
    wasm_parse_module(iu, u8 + 4, u8 + len);
    break;
  case 0xdec04342: // LLVM Bitcode
    // WebAssembly need memory at 0. Bitcode don't really.
    ir_parse_blocks(iu, 2, NULL, NULL, &bs);
    break;
  default:
    return VMIR_ERR_NOT_BITCODE;
  }
  free(iu->iu_text_alloc);
#ifdef VMIR_VM_JIT
  jit_seal_code(iu);
#endif
  iu->iu_heap_start = VMIR_ALIGN(iu->iu_data_ptr, 4096);
  iu->iu_stats.data_size = iu->iu_heap_start;
  vmir_heap_init(iu);
  initialize_globals(iu, iu->iu_mem);
  libc_initialize(iu);
  iu->iu_vm_funcs  = calloc(VECTOR_LEN(&iu->iu_functions), sizeof(void *));
  iu->iu_function_table = calloc(VECTOR_LEN(&iu->iu_functions), sizeof(void *));
  for(int i = 0; i < VECTOR_LEN(&iu->iu_functions); i++) {
    ir_function_t *f = VECTOR_ITEM(&iu->iu_functions, i);
    iu->iu_vm_funcs[i]  = f->if_vm_text;
    iu->iu_function_table[i] = f->if_ext_func;
    if(f->if_used && f->if_vm_text == NULL && f->if_ext_func == NULL) {
      vmir_log(iu, VMIR_LOG_ERROR, "Function %s() is not defined", f->if_name);
      if(!(iu->iu_debug_flags & VMIR_DBG_IGNORE_UNRESOLVED_FUNCTIONS)) {
        parser_error(iu, "Function %s() is not defined", f->if_name);
      }
    }
  }
  run_global_ctors(iu);
  iu_cleanup(iu);
  return 0;
}
########################rank 8#############################
static int
kvs_new(strm_stream* strm, int argc, strm_value* args, strm_value* ret)
{
  struct strm_kvs *k = malloc(sizeof(struct strm_kvs));
  if (!k) return STRM_NG;
  k->ns = ns_kvs;
  k->type = STRM_PTR_AUX;
  k->kv = kh_init(kvs);
  k->serial = 1;
  pthread_mutex_init(&k->lock, NULL);
  *ret = strm_ptr_value(k);
  return STRM_OK;
}
########################rank 9#############################
static void Controls_Update( void ) {
	int		i;
	int		j;
	int		y;
	menucommon_s	**controls;
	menucommon_s	*control;
	// disable all controls in all groups
	for( i = 0; i < C_MAX; i++ ) {
		controls = g_controls[i];
		for( j = 0;  (control = controls[j]) ; j++ ) {
			control->flags |= (QMF_HIDDEN|QMF_INACTIVE);
		}
	}
	controls = g_controls[s_controls.section];
	// enable controls in active group (and count number of items for vertical centering)
	for( j = 0;  (control = controls[j]) ; j++ ) {
		control->flags &= ~(QMF_GRAYED|QMF_HIDDEN|QMF_INACTIVE);
	}
	// position controls
	y = ( SCREEN_HEIGHT - j * SMALLCHAR_HEIGHT ) / 2;
	for( j = 0;	(control = controls[j]) ; j++, y += SMALLCHAR_HEIGHT ) {
		control->x      = 320;
		control->y      = y;
		control->left   = 320 - 19*SMALLCHAR_WIDTH;
		control->right  = 320 + 21*SMALLCHAR_WIDTH;
		control->top    = y;
		control->bottom = y + SMALLCHAR_HEIGHT;
	}
	if( s_controls.waitingforkey ) {
		// disable everybody
		for( i = 0; i < s_controls.menu.nitems; i++ ) {
			((menucommon_s*)(s_controls.menu.items[i]))->flags |= QMF_GRAYED;
		}
		// enable action item
		((menucommon_s*)(s_controls.menu.items[s_controls.menu.cursor]))->flags &= ~QMF_GRAYED;
		// don't gray out player's name
		s_controls.name.generic.flags &= ~QMF_GRAYED;
		return;
	}
	// enable everybody
	for( i = 0; i < s_controls.menu.nitems; i++ ) {
		((menucommon_s*)(s_controls.menu.items[i]))->flags &= ~QMF_GRAYED;
	}
	// makes sure flags are right on the group selection controls
	s_controls.looking.generic.flags  &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.movement.generic.flags &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.weapons.generic.flags  &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.misc.generic.flags     &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.looking.generic.flags  |= QMF_PULSEIFFOCUS;
	s_controls.movement.generic.flags |= QMF_PULSEIFFOCUS;
	s_controls.weapons.generic.flags  |= QMF_PULSEIFFOCUS;
	s_controls.misc.generic.flags     |= QMF_PULSEIFFOCUS;
	// set buttons
	switch( s_controls.section ) {
	case C_MOVEMENT:
		s_controls.movement.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.movement.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;
	case C_LOOKING:
		s_controls.looking.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.looking.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;
	case C_WEAPONS:
		s_controls.weapons.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.weapons.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;		
	case C_MISC:
		s_controls.misc.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.misc.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;
	}
}
########################rank 10#############################
static void Controls_Update( void ) {
	int		i;
	int		j;
	int		y;
	menucommon_s	**controls;
	menucommon_s	*control;
	// disable all controls in all groups
	for( i = 0; i < C_MAX; i++ ) {
		controls = g_controls[i];
		// bk001204 - parentheses
		for( j = 0;  (control = controls[j]) ; j++ ) {
			control->flags |= (QMF_HIDDEN|QMF_INACTIVE);
		}
	}
	controls = g_controls[s_controls.section];
	// enable controls in active group (and count number of items for vertical centering)
	// bk001204 - parentheses
	for( j = 0;  (control = controls[j]) ; j++ ) {
		control->flags &= ~(QMF_GRAYED|QMF_HIDDEN|QMF_INACTIVE);
	}
	// position controls
	y = ( SCREEN_HEIGHT - j * SMALLCHAR_HEIGHT ) / 2;
	// bk001204 - parentheses
	for( j = 0;	(control = controls[j]) ; j++, y += SMALLCHAR_HEIGHT ) {
		control->x      = 320;
		control->y      = y;
		control->left   = 320 - 19*SMALLCHAR_WIDTH;
		control->right  = 320 + 21*SMALLCHAR_WIDTH;
		control->top    = y;
		control->bottom = y + SMALLCHAR_HEIGHT;
	}
	if( s_controls.waitingforkey ) {
		// disable everybody
		for( i = 0; i < s_controls.menu.nitems; i++ ) {
			((menucommon_s*)(s_controls.menu.items[i]))->flags |= QMF_GRAYED;
		}
		// enable action item
		((menucommon_s*)(s_controls.menu.items[s_controls.menu.cursor]))->flags &= ~QMF_GRAYED;
		// don't gray out player's name
		s_controls.name.generic.flags &= ~QMF_GRAYED;
		return;
	}
	// enable everybody
	for( i = 0; i < s_controls.menu.nitems; i++ ) {
		((menucommon_s*)(s_controls.menu.items[i]))->flags &= ~QMF_GRAYED;
	}
	// makes sure flags are right on the group selection controls
	s_controls.looking.generic.flags  &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.movement.generic.flags &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.weapons.generic.flags  &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.misc.generic.flags     &= ~(QMF_GRAYED|QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
	s_controls.looking.generic.flags  |= QMF_PULSEIFFOCUS;
	s_controls.movement.generic.flags |= QMF_PULSEIFFOCUS;
	s_controls.weapons.generic.flags  |= QMF_PULSEIFFOCUS;
	s_controls.misc.generic.flags     |= QMF_PULSEIFFOCUS;
	// set buttons
	switch( s_controls.section ) {
	case C_MOVEMENT:
		s_controls.movement.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.movement.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;
	case C_LOOKING:
		s_controls.looking.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.looking.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;
	case C_WEAPONS:
		s_controls.weapons.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.weapons.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;		
	case C_MISC:
		s_controls.misc.generic.flags &= ~QMF_PULSEIFFOCUS;
		s_controls.misc.generic.flags |= (QMF_HIGHLIGHT|QMF_HIGHLIGHT_IF_FOCUS);
		break;
	}
}
----------------------------QUERY-------------------------------
store integer into register
########################rank 1#############################
void op_int_store(struct svm *svm)
{
    unsigned int reg = next_byte(svm);
    BOUNDS_TEST_REGISTER(reg);
    unsigned int val1 = next_byte(svm);
    unsigned int val2 = next_byte(svm);
    int value = BYTES_TO_ADDR(val1, val2);
    if (getenv("DEBUG") != NULL)
        printf("STORE_INT(Reg:%02x) => %04d [Hex:%04x]\n", reg, value, value);
    if ((svm->registers[reg].type == STRING) && (svm->registers[reg].content.string))
        free(svm->registers[reg].content.string);
    svm->registers[reg].content.integer = value;
    svm->registers[reg].type = INTEGER;
    svm->ip += 1;
}
########################rank 2#############################
void gen_add_reg_reg_reg(int t, int s1, int s)
{
  printf("%c=%c+%c;\n",t+'A',s1+'A',s+'A');
}
########################rank 3#############################
gen_unsigned_greater_or_equal()
{
    output_line("lw\t$t1, 16($sp)");
    output_line("addiu\t$sp, 4");
    output_line("sltu\t$v0, $t1, $v0");   //tos < primary
    output_line("xori\t$v0, 1");    //tos >= primary
    //gcall ("^uge");
    stkp = stkp + INTSIZE;
}
########################rank 4#############################
void gen_mov_reg_reg_reg(int t, int s)
{
  printf("%c=%c;\n",t+'A',s+'A');
}
########################rank 5#############################
gen_equal()
{
    output_line("lw\t$t1, 16($sp)");
    output_line("sltu\t$t2, $v0, $t1");
    output_line("sltu\t$v0, $t1, $v0");
    output_line("or\t$v0, $t2");
    output_line("xori\t$v0, 1");
    output_line("addiu\t$sp, 4");
    //gcall ("^eq");
    stkp = stkp + INTSIZE;
}
########################rank 6#############################
gen_unsigned_less_or_equal()
{
    output_line("lw\t$t1, 16($sp)");
    output_line("addiu\t$sp, 4");
    output_line("sltu\t$v0, $v0, $t1"); // primary < tos
    output_line("xori\t$v0, 1");  // primary >= tos
    //gcall ("^ule");
    stkp = stkp + INTSIZE;
}
########################rank 7#############################
gen_and()
{
    //output_line ("and.l\t(%sp)+,%d0");
    output_line ("lw\t$t1, 16($sp)");
    output_line ("addiu\t$sp, 4");
    output_line ("and\t$v0, $t1");
    stkp = stkp + INTSIZE;
}
########################rank 8#############################
void SCU_SpecIntRunModeConfig(FunctionalState NewState)
{
  if (NewState == ENABLE)
  SCU->PWRMNG |=0x8;
  else
  SCU->PWRMNG &=~0x8;
}
########################rank 9#############################
BNO055_RETURN_FUNCTION_TYPE bno055_set_tilt_unit(u8 v_tilt_unit_u8)
{
BNO055_RETURN_FUNCTION_TYPE com_rslt = ERROR;
u8 v_data_u8r = BNO055_ZERO_U8X;
u8 v_prev_opmode_u8 = OPERATION_MODE_CONFIG;
s8 v_stat_s8 = ERROR;
if (p_bno055 == BNO055_ZERO_U8X) {
	return E_NULL_PTR;
	} else {
		mode is in config mode, this part of code is checking the
		current operation mode and set the config mode */
		v_stat_s8 = bno055_get_operation_mode(&v_prev_opmode_u8);
		if (v_stat_s8 == SUCCESS) {
			if (v_prev_opmode_u8 != OPERATION_MODE_CONFIG)
				v_stat_s8 += bno055_set_operation_mode
				(OPERATION_MODE_CONFIG);
			if (v_stat_s8 == SUCCESS) {
				com_rslt = p_bno055->BNO055_BUS_READ_FUNC
				(p_bno055->dev_addr,
				BNO055_TILT_UNIT__REG,
				&v_data_u8r, BNO055_ONE_U8X);
				if (com_rslt == SUCCESS) {
					v_data_u8r =
					BNO055_SET_BITSLICE(v_data_u8r,
					BNO055_TILT_UNIT, v_tilt_unit_u8);
					com_rslt +=
					p_bno055->BNO055_BUS_WRITE_FUNC
					(p_bno055->dev_addr,
					BNO055_TILT_UNIT__REG,
					&v_data_u8r, BNO055_ONE_U8X);
				}
			} else {
			com_rslt = ERROR;
			}
		} else {
		com_rslt = ERROR;
		}
	}
	if (v_prev_opmode_u8 != OPERATION_MODE_CONFIG)
		of previous operation mode*/
		com_rslt += bno055_set_operation_mode
		(v_prev_opmode_u8);
	return com_rslt;
}
########################rank 10#############################
void gen_rpush_reg(int s)
{
  printf("rsp=(rsp+1)&0x7FFF;rstack[rsp]=%c;\n",s+'A');
}
----------------------------QUERY-------------------------------
stop stream server
########################rank 1#############################
PaError Pa_StopStream(  PortAudioStream *stream )
{
    return Pa_KillStream( stream, 0 );
}
########################rank 2#############################
static int
_local_io_close(stream_id nst)
{
    int err;
    Check_Stream_Owner(nst);
    if (IsSocket(nst))
    {
	if (SocketUnix(nst) != D_UNKNOWN)
	    (void) ec_unlink(DidName(SocketUnix(nst)));
	(void) ec_stream_reset_sigio(nst, SWRITE);
	if (SocketInputStream(nst))
	    (void) ec_stream_reset_sigio(nst, SREAD);
    }
#if defined(HAVE_READLINE)
    if (IsReadlineStream(nst)) {
	if (fclose(StreamFILE(nst)) < 0)
	{
	    Set_Errno
	    return(SYS_ERROR);
	}
    }
#endif
    if ((err = StreamMethods(nst).close(StreamUnit(nst))) != PSUCCEED)
    {
	return err;
    }
#if _WIN32
    if (IsSocket(nst))
    {
	int dummy;
	stream_id inst;
	if (nst->signal_thread)
	{
	    ec_thread_wait(nst->signal_thread, &dummy, THREAD_TIMEOUT);
	    if (ec_thread_terminate(nst->signal_thread, THREAD_TIMEOUT) < 0)
		return SYS_ERROR;
	    nst->signal_thread = 0;
	}
	if ((inst = SocketInputStream(nst)) && inst->signal_thread)
	{
	    ec_thread_wait(inst->signal_thread, &dummy, THREAD_TIMEOUT);
	    if (ec_thread_terminate(inst->signal_thread, THREAD_TIMEOUT) < 0)
		return SYS_ERROR;
	    inst->signal_thread = 0;
	}
    }
#endif
    return(PSUCCEED);
}
########################rank 3#############################
static cc_result GZip_StreamClose(struct Stream* stream) {
	struct GZipState* state = (struct GZipState*)stream->Meta.Inflate;
	cc_uint8 data[8];
	cc_result res;
	if ((res = Deflate_StreamClose(stream))) return res;
	Stream_SetU32_LE(&data[0], state->Crc32 ^ 0xFFFFFFFFUL);
	Stream_SetU32_LE(&data[4], state->Size);
	return Stream_Write(state->Base.Dest, data, sizeof(data));
}
########################rank 4#############################
static
void  ft_close_stream( FT_Stream stream ) {
	fclose( STREAM_FILE( stream ) );
	stream->descriptor.pointer = NULL;
	stream->size               = 0;
	stream->base               = 0;
}
########################rank 5#############################
static PaError CloseStream( PaStream* s )
{
    PaError result = paNoError;
    PaSkeletonStream *stream = (PaSkeletonStream*)s;
        IMPLEMENT ME:
            - additional stream closing + cleanup
    */
    PaUtil_TerminateBufferProcessor( &stream->bufferProcessor );
    PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
    PaUtil_FreeMemory( stream );
    return result;
}
########################rank 6#############################
PaError Pa_CloseStream( PortAudioStream* stream)
{
    PaError   result;
    internalPortAudioStream   *past;
    DBUG(("Pa_CloseStream()\n"));
    if( stream == NULL ) return paBadStreamPtr;
    past = (internalPortAudioStream *) stream;
    Pa_AbortStream( past );
    result = PaHost_CloseStream( past );
    if( past->past_InputBuffer ) PaHost_FreeFastMemory( past->past_InputBuffer, past->past_InputBufferSize );
    if( past->past_OutputBuffer ) PaHost_FreeFastMemory( past->past_OutputBuffer, past->past_OutputBufferSize );
    PaHost_FreeFastMemory( past, sizeof(internalPortAudioStream) );
    return result;
}
########################rank 7#############################
static inline void reset_stream(stream_context  stream)
{
  if (stream.is_h262)
  {
    if (stream.u.h262->last_item)
      free_h262_item(&stream.u.h262->last_item);
  }
  else
  {
    reset_access_unit_context(stream.u.h264);
  }
}
########################rank 8#############################
void SNAP_StopDemoRecording( int demofile ) {
	int i;
	// finishup
	i = LittleLong( -1 );
	FS_Write( &i, 4, demofile );
}
########################rank 9#############################
FileStream * ffConvertSourceIDToStream( cell_t id )
{
    FileStream *stream;
    if( id == 0 )
    {
        stream = PF_STDIN;
    }
    else if( id == -1 )
    {
        stream = NULL;
    }
    else
    {
        stream = (FileStream *) id;
    }
    return stream;
}
########################rank 10#############################
static void SV_Web_ResetStream( sv_http_stream_t *stream ) {
	stream->header_done = false;
	stream->header_length = 0;
	stream->header_buf_p = 0;
	if( stream->content &&
		( stream->content < stream->header_buf
		  || stream->content >= stream->header_buf + sizeof( stream->header_buf ) ) ) {
		Mem_Free( stream->content );
	}
	stream->content_range.begin = stream->content_range.end = 0;
	stream->content = NULL;
	stream->content_length = 0;
	stream->content_p = 0;
}
----------------------------QUERY-------------------------------
get length of UCS2 string
########################rank 1#############################
int der_length_utctime(ltc_utctime *utctime, unsigned long *outlen) {
    LTC_ARGCHK(outlen != NULL);
    LTC_ARGCHK(utctime != NULL);
    if ((utctime->off_hh == 0) && (utctime->off_mm == 0)) {
        *outlen = 2 + 13;
    } else {
        *outlen = 2 + 17;
    }
    return CRYPT_OK;
}
########################rank 2#############################
int der_length_printable_string(const unsigned char *octets, unsigned long noctets, unsigned long *outlen) {
    unsigned long x;
    LTC_ARGCHK(outlen != NULL);
    LTC_ARGCHK(octets != NULL);
    for (x = 0; x < noctets; x++) {
        if (der_printable_char_encode(octets[x]) == -1) {
            return CRYPT_INVALID_ARG;
        }
    }
    if (noctets < 128) {
        *outlen = 2 + noctets;
    } else if (noctets < 256) {
        *outlen = 3 + noctets;
    } else if (noctets < 65536UL) {
        *outlen = 4 + noctets;
    } else if (noctets < 16777216UL) {
        *outlen = 5 + noctets;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
########################rank 3#############################
int der_length_ia5_string(const unsigned char *octets, unsigned long noctets, unsigned long *outlen) {
    unsigned long x;
    LTC_ARGCHK(outlen != NULL);
    LTC_ARGCHK(octets != NULL);
    for (x = 0; x < noctets; x++) {
        if (der_ia5_char_encode(octets[x]) == -1) {
            return CRYPT_INVALID_ARG;
        }
    }
    if (noctets < 128) {
        *outlen = 2 + noctets;
    } else if (noctets < 256) {
        *outlen = 3 + noctets;
    } else if (noctets < 65536UL) {
        *outlen = 4 + noctets;
    } else if (noctets < 16777216UL) {
        *outlen = 5 + noctets;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
########################rank 4#############################
l_int32
stringLength(const char  *src,
             size_t       size)
{
l_int32  i;
    PROCNAME("stringLength");
    if (!src)
        return ERROR_INT("src not defined", procName, 0);
    if (size < 1)
        return 0;
    for (i = 0; i < size; i++) {
        if (src[i] == '\0')
            return i;
    }
    return size;
}
########################rank 5#############################
static int len_0_to_n(int n)
{
    int len = 1; /* Counting 0 as a bit of a special case */
    int i;
    for (i = 1; i < n; i *= 10) {
        len += max(n - i, 0);
    }
    return len;
}
########################rank 6#############################
int
length(s)
        char	*s;
{
	register int	l;
	register char	*p;
	l = 0;
	p = s;
	while (*p++)
		l++;
	return(l);
}
########################rank 7#############################
size_t ucs4len(ucs4 const *s)
{
  size_t len = 0;
  if (s) while (*s++) 
    len++;
  return len;
}
########################rank 8#############################
size_t ucs2len(ucs2 const *s)
{
  size_t len = 0;
  if (s) while (*s++) 
    len++;
  return len;
}
########################rank 9#############################
int len(char *s) {
    return strlen(s);
}
########################rank 10#############################
int len(char *s) {
    return strlen(s);
}
----------------------------QUERY-------------------------------
contrain maximum of a range
########################rank 1#############################
static inline void range_done_decoding(void)
{   range_dec_normalize();      
}
########################rank 2#############################
static void
rangelist_remove_range(struct RangeList *targets, unsigned begin, unsigned end)
{
    unsigned i;
    struct Range x;
    x.begin = begin;
    x.end = end;
     * list */
    for (i = 0; i < targets->count; i++) {
        if (!range_is_overlap(targets->list[i], x))
            continue;
         * it completely */
        if (begin <= targets->list[i].begin && end >= targets->list[i].end) {
            rangelist_remove_at(targets, i);
            i--;
            continue;
        }
         * the lower end and add a new high-end */
        if (begin > targets->list[i].begin && end < targets->list[i].end) {
            struct Range newrange;
            newrange.begin = end+1;
            newrange.end = targets->list[i].end;
            targets->list[i].end = begin-1;
            rangelist_add_range(targets, newrange.begin, newrange.end);
            i--;
            continue;
        }
        if (end >= targets->list[i].begin && end < targets->list[i].end) {
            targets->list[i].begin = end+1;
        }
        if (begin > targets->list[i].begin && begin <= targets->list[i].end) {
             targets->list[i].end = begin-1;
        }
        //assert(!"impossible");
    }
}
########################rank 3#############################
int
range_is_valid(struct Range range)
{
    return range.begin <= range.end;
}
########################rank 4#############################
int
range_is_valid(struct Range range)
{
    return range.begin <= range.end;
}
########################rank 5#############################
void
rangelist_remove_range(struct RangeList *task, unsigned begin, unsigned end)
{
    unsigned i;
    struct Range x;
    x.begin = begin;
    x.end = end;
    for (i = 0; i < task->count; i++) {
        if (!range_is_overlap(task->list[i], x))
            continue;
         * it completely */
        if (begin <= task->list[i].begin && end >= task->list[i].end) {
            todo_remove_at(task, i);
            i--;
            continue;
        }
         * the lower end and add a new high-end */
        if (begin > task->list[i].begin && end < task->list[i].end) {
            struct Range newrange;
            newrange.begin = end+1;
            newrange.end = task->list[i].end;
            task->list[i].end = begin-1;
            rangelist_add_range(task, newrange.begin, newrange.end);
            i--;
            continue;
        }
        if (end >= task->list[i].begin && end < task->list[i].end) {
            task->list[i].begin = end+1;
        }
        if (begin > task->list[i].begin && begin <= task->list[i].end) {
             task->list[i].end = begin-1;
        }
        //assert(!"impossible");
    }
}
########################rank 6#############################
void
rangelist_remove_range(struct RangeList *task, unsigned begin, unsigned end)
{
    unsigned i;
    struct Range x;
    x.begin = begin;
    x.end = end;
    for (i = 0; i < task->count; i++) {
        if (!range_is_overlap(task->list[i], x))
            continue;
         * it completely */
        if (begin <= task->list[i].begin && end >= task->list[i].end) {
            todo_remove_at(task, i);
            i--;
            continue;
        }
         * the lower end and add a new high-end */
        if (begin > task->list[i].begin && end < task->list[i].end) {
            struct Range newrange;
            newrange.begin = end+1;
            newrange.end = task->list[i].end;
            task->list[i].end = begin-1;
            rangelist_add_range(task, newrange.begin, newrange.end);
            i--;
            continue;
        }
        if (end >= task->list[i].begin && end < task->list[i].end) {
            task->list[i].begin = end+1;
        }
        if (begin > task->list[i].begin && begin <= task->list[i].end) {
             task->list[i].end = begin-1;
        }
        //assert(!"impossible");
    }
}
########################rank 7#############################
PIXA *
pixaSelectRange(PIXA    *pixas,
                l_int32  first,
                l_int32  last,
                l_int32  copyflag)
{
l_int32  n, npix, i;
PIX     *pix;
PIXA    *pixad;
    PROCNAME("pixaSelectRange");
    if (!pixas)
        return (PIXA *)ERROR_PTR("pixas not defined", procName, NULL);
    if (copyflag != L_COPY && copyflag != L_CLONE)
        return (PIXA *)ERROR_PTR("invalid copyflag", procName, NULL);
    n = pixaGetCount(pixas);
    first = L_MAX(0, first);
    if (last <= 0) last = n - 1;
    if (first >= n)
        return (PIXA *)ERROR_PTR("invalid first", procName, NULL);
    if (first > last)
        return (PIXA *)ERROR_PTR("first > last", procName, NULL);
    npix = last - first + 1;
    pixad = pixaCreate(npix);
    for (i = first; i <= last; i++) {
        pix = pixaGetPix(pixas, i, copyflag);
        pixaAddPix(pixad, pix, L_INSERT);
    }
    return pixad;
}
########################rank 8#############################
uint64_t
rangelist_exclude(  struct RangeList *targets, 
              const struct RangeList *excludes)
{
    uint64_t count = 0;
    unsigned i;
    for (i=0; i<excludes->count; i++) {
        struct Range range = excludes->list[i];
        count += range.end - range.begin + 1;
        rangelist_remove_range(targets, range.begin, range.end);
    }
    return count;
}
########################rank 9#############################
uint64_t
rangelist_exclude(  struct RangeList *targets,
                  const struct RangeList *excludes)
{
    uint64_t count = 0;
    unsigned i;
    for (i=0; i<excludes->count; i++) {
        struct Range range = excludes->list[i];
        count += range.end - range.begin + 1;
        rangelist_remove_range(targets, range.begin, range.end);
    }
    return count;
}
########################rank 10#############################
PIXAA *
pixaaSelectRange(PIXAA   *paas,
                 l_int32  first,
                 l_int32  last,
                 l_int32  copyflag)
{
l_int32  n, npixa, i;
PIXA    *pixa;
PIXAA   *paad;
    PROCNAME("pixaaSelectRange");
    if (!paas)
        return (PIXAA *)ERROR_PTR("paas not defined", procName, NULL);
    if (copyflag != L_COPY && copyflag != L_CLONE)
        return (PIXAA *)ERROR_PTR("invalid copyflag", procName, NULL);
    n = pixaaGetCount(paas, NULL);
    first = L_MAX(0, first);
    if (last <= 0) last = n - 1;
    if (first >= n)
        return (PIXAA *)ERROR_PTR("invalid first", procName, NULL);
    if (first > last)
        return (PIXAA *)ERROR_PTR("first > last", procName, NULL);
    npixa = last - first + 1;
    paad = pixaaCreate(npixa);
    for (i = first; i <= last; i++) {
        pixa = pixaaGetPixa(paas, i, copyflag);
        pixaaAddPixa(paad, pixa, L_INSERT);
    }
    return paad;
}
----------------------------QUERY-------------------------------
pad given buffer with len padding characters
########################rank 1#############################
static LJ_NOINLINE void bcread_fill(LexState *ls, MSize len, int need)
{
  lua_assert(len != 0);
  if (len > LJ_MAX_BUF || ls->c < 0)
    bcread_error(ls, LJ_ERR_BCBAD);
  do {
    const char *buf;
    size_t sz;
    char *p = sbufB(&ls->sb);
    MSize n = (MSize)(ls->pe - ls->p);
    if (n) {  
      if (sbuflen(&ls->sb)) {  /* Move down in buffer. */
	lua_assert(ls->pe == sbufP(&ls->sb));
	if (ls->p != p) memmove(p, ls->p, n);
      } else {  /* Copy from buffer provided by reader. */
	p = lj_buf_need(&ls->sb, len);
	memcpy(p, ls->p, n);
      }
      ls->p = p;
      ls->pe = p + n;
    }
    setsbufP(&ls->sb, p + n);
    buf = ls->rfunc(ls->L, ls->rdata, &sz);  /* Get more data from reader. */
    if (buf == NULL || sz == 0) {  /* EOF? */
      if (need) bcread_error(ls, LJ_ERR_BCBAD);
      ls->c = -1;  /* Only bad if we get called again. */
      break;
    }
    if (n) {  /* Append to buffer. */
      n += (MSize)sz;
      p = lj_buf_need(&ls->sb, n < len ? len : n);
      memcpy(sbufP(&ls->sb), buf, sz);
      setsbufP(&ls->sb, p + n);
      ls->p = p;
      ls->pe = p + n;
    } else {  /* Return buffer provided by reader. */
      ls->p = buf;
      ls->pe = buf + sz;
    }
  } while (ls->p + len > ls->pe);
}
########################rank 2#############################
static LJ_NOINLINE void bcread_fill(LexState *ls, MSize len, int need)
{
  lua_assert(len != 0);
  if (len > LJ_MAX_BUF || ls->c < 0)
    bcread_error(ls, LJ_ERR_BCBAD);
  do {
    const char *buf;
    size_t sz;
    char *p = sbufB(&ls->sb);
    MSize n = (MSize)(ls->pe - ls->p);
    if (n) {  
      if (sbuflen(&ls->sb)) {  /* Move down in buffer. */
	lua_assert(ls->pe == sbufP(&ls->sb));
	if (ls->p != p) memmove(p, ls->p, n);
      } else {  /* Copy from buffer provided by reader. */
	p = lj_buf_need(&ls->sb, len);
	memcpy(p, ls->p, n);
      }
      ls->p = p;
      ls->pe = p + n;
    }
    setsbufP(&ls->sb, p + n);
    buf = ls->rfunc(ls->L, ls->rdata, &sz);  /* Get more data from reader. */
    if (buf == NULL || sz == 0) {  /* EOF? */
      if (need) bcread_error(ls, LJ_ERR_BCBAD);
      ls->c = -1;  /* Only bad if we get called again. */
      break;
    }
    if (n) {  /* Append to buffer. */
      n += (MSize)sz;
      p = lj_buf_need(&ls->sb, n < len ? len : n);
      memcpy(sbufP(&ls->sb), buf, sz);
      setsbufP(&ls->sb, p + n);
      ls->p = p;
      ls->pe = p + n;
    } else {  /* Return buffer provided by reader. */
      ls->p = buf;
      ls->pe = buf + sz;
    }
  } while (ls->p + len > ls->pe);
}
########################rank 3#############################
static LJ_NOINLINE void bcread_fill(LexState *ls, MSize len, int need)
{
  lua_assert(len != 0);
  if (len > LJ_MAX_BUF || ls->c < 0)
    bcread_error(ls, LJ_ERR_BCBAD);
  do {
    const char *buf;
    size_t sz;
    char *p = sbufB(&ls->sb);
    MSize n = (MSize)(ls->pe - ls->p);
    if (n) {  
      if (sbuflen(&ls->sb)) {  /* Move down in buffer. */
	lua_assert(ls->pe == sbufP(&ls->sb));
	if (ls->p != p) memmove(p, ls->p, n);
      } else {  /* Copy from buffer provided by reader. */
	p = lj_buf_need(&ls->sb, len);
	memcpy(p, ls->p, n);
      }
      ls->p = p;
      ls->pe = p + n;
    }
    setsbufP(&ls->sb, p + n);
    buf = ls->rfunc(ls->L, ls->rdata, &sz);  /* Get more data from reader. */
    if (buf == NULL || sz == 0) {  /* EOF? */
      if (need) bcread_error(ls, LJ_ERR_BCBAD);
      ls->c = -1;  /* Only bad if we get called again. */
      break;
    }
    if (n) {  /* Append to buffer. */
      n += (MSize)sz;
      p = lj_buf_need(&ls->sb, n < len ? len : n);
      memcpy(sbufP(&ls->sb), buf, sz);
      setsbufP(&ls->sb, p + n);
      ls->p = p;
      ls->pe = p + n;
    } else {  /* Return buffer provided by reader. */
      ls->p = buf;
      ls->pe = buf + sz;
    }
  } while (ls->p + len > ls->pe);
}
########################rank 4#############################
static LJ_NOINLINE void bcread_fill(LexState *ls, MSize len, int need)
{
  lua_assert(len != 0);
  if (len > LJ_MAX_BUF || ls->c < 0)
    bcread_error(ls, LJ_ERR_BCBAD);
  do {
    const char *buf;
    size_t sz;
    char *p = sbufB(&ls->sb);
    MSize n = (MSize)(ls->pe - ls->p);
    if (n) {  
      if (sbuflen(&ls->sb)) {  /* Move down in buffer. */
	lua_assert(ls->pe == sbufP(&ls->sb));
	if (ls->p != p) memmove(p, ls->p, n);
      } else {  /* Copy from buffer provided by reader. */
	p = lj_buf_need(&ls->sb, len);
	memcpy(p, ls->p, n);
      }
      ls->p = p;
      ls->pe = p + n;
    }
    setsbufP(&ls->sb, p + n);
    buf = ls->rfunc(ls->L, ls->rdata, &sz);  /* Get more data from reader. */
    if (buf == NULL || sz == 0) {  /* EOF? */
      if (need) bcread_error(ls, LJ_ERR_BCBAD);
      ls->c = -1;  /* Only bad if we get called again. */
      break;
    }
    if (n) {  /* Append to buffer. */
      n += (MSize)sz;
      p = lj_buf_need(&ls->sb, n < len ? len : n);
      memcpy(sbufP(&ls->sb), buf, sz);
      setsbufP(&ls->sb, p + n);
      ls->p = p;
      ls->pe = p + n;
    } else {  /* Return buffer provided by reader. */
      ls->p = buf;
      ls->pe = buf + sz;
    }
  } while (ls->p + len > ls->pe);
}
########################rank 5#############################
static LJ_NOINLINE void bcread_fill(LexState *ls, MSize len, int need)
{
  lua_assert(len != 0);
  if (len > LJ_MAX_BUF || ls->c < 0)
    bcread_error(ls, LJ_ERR_BCBAD);
  do {
    const char *buf;
    size_t sz;
    char *p = sbufB(&ls->sb);
    MSize n = (MSize)(ls->pe - ls->p);
    if (n) {  
      if (sbuflen(&ls->sb)) {  /* Move down in buffer. */
	lua_assert(ls->pe == sbufP(&ls->sb));
	if (ls->p != p) memmove(p, ls->p, n);
      } else {  /* Copy from buffer provided by reader. */
	p = lj_buf_need(&ls->sb, len);
	memcpy(p, ls->p, n);
      }
      ls->p = p;
      ls->pe = p + n;
    }
    setsbufP(&ls->sb, p + n);
    buf = ls->rfunc(ls->L, ls->rdata, &sz);  /* Get more data from reader. */
    if (buf == NULL || sz == 0) {  /* EOF? */
      if (need) bcread_error(ls, LJ_ERR_BCBAD);
      ls->c = -1;  /* Only bad if we get called again. */
      break;
    }
    if (n) {  /* Append to buffer. */
      n += (MSize)sz;
      p = lj_buf_need(&ls->sb, n < len ? len : n);
      memcpy(sbufP(&ls->sb), buf, sz);
      setsbufP(&ls->sb, p + n);
      ls->p = p;
      ls->pe = p + n;
    } else {  /* Return buffer provided by reader. */
      ls->p = buf;
      ls->pe = buf + sz;
    }
  } while (ls->p + len > ls->pe);
}
########################rank 6#############################
static bool buf_grow(struct template_buffer *buf, size_t len)
{
	size_t off = buf->dptr - buf->data, left = buf->size - off;
	if (len <= left)
		return true;
	size_t diff = len - left;
	if (diff < 1024)
		diff = 1024;
	char *data = realloc(buf->data, buf->size + diff);
	if (data == NULL)
		return false;
	buf->data  = data;
	buf->dptr  = data + off;
	buf->size += diff;
	return true;
}
########################rank 7#############################
static void pad(unsigned char *buf, int len)
{
	for (int i = 0; i < len; i++)
		buf[i] = PADDING_CHAR;
}
########################rank 8#############################
uint32_t buffer_get_varlen(MOBIBuffer *buf, size_t *len) {
    return _buffer_get_varlen(buf, len, 1);
}
########################rank 9#############################
l_int32
bbufferExtendArray(BBUFFER  *bb,
                   l_int32   nbytes)
{
    PROCNAME("bbufferExtendArray");
    if (!bb)
        return ERROR_INT("bb not defined", procName, 1);
    if ((bb->array = (l_uint8 *)reallocNew((void **)&bb->array,
                                bb->nalloc,
                                bb->nalloc + nbytes)) == NULL)
            return ERROR_INT("new ptr array not returned", procName, 1);
    bb->nalloc += nbytes;
    return 0;
}
########################rank 10#############################
fill_input_buf(
	RECSTREAM *rstrm)
{
	caddr_t where;
	u_long i;
	long len;
	where = rstrm->in_base;
	i = (uintptr_t)rstrm->in_boundry % BYTES_PER_XDR_UNIT;
	where += i;
	len = rstrm->in_size - i;
	if ((len = (*(rstrm->readit))(rstrm->tcp_handle, where, len)) == -1)
		return (FALSE);
	rstrm->in_finger = where;
	where += len;
	rstrm->in_boundry = where;
	return (TRUE);
}
----------------------------QUERY-------------------------------
write data in output buffers to client
########################rank 1#############################
size_t
_write(int handle, const unsigned char *buffer, size_t size)
{
  int data_idx;
  for(data_idx = 0; data_idx < size; data_idx++) {
    __io_putchar(*buffer++);
  }
  return size;
}
########################rank 2#############################
static ID_INLINE void SafeFS_Write( const void *buffer, int len, fileHandle_t f )
{
  if( FS_Write( buffer, len, f ) < len )
    Com_Error( ERR_DROP, "Failed to write avi file\n" );
}
########################rank 3#############################
static int write_data(void *addr, int count)
{
	int i;
	int status;
	for(i = 0; i<count; i+= 4)
	{
		do{
			status = IO_MEM_STICK_STATUS;
			if (status & MS_TIME_OUT) return -3;
		}while(!(status & MS_FIFO_RW));
		IO_MEM_STICK_DATA = *((volatile int*)(addr + i));
	}
	return 0;
}
########################rank 4#############################
ssize_t write( int fd, const void *vbuffer, size_t length )
{
	ssize_t total = 0;
	ssize_t actual = 0;
	const char *buffer = vbuffer;
	while(length>0) {
		actual = syscall(SYS_write,fd,buffer,length);
		if(actual<=0) break;
		total += actual;
		buffer += actual;
		length -= actual;
	}
	if(total>0) {
		return total;
	} else {
		return actual;
	}
}
########################rank 5#############################
static size_t blocking_write(int fd, const void *buf, size_t count)
{
    size_t left = count;
    ssize_t r;
    while (left > 0 && ((r = write(fd, buf, left)) >= 0 || errno == EINTR)) {
        buf += r;
        left -= r;
    }
    return count - left;
}
########################rank 6#############################
l_int32
jbDataWrite(const char  *rootout,
            JBDATA      *jbdata)
{
char     buf[L_BUF_SIZE];
l_int32  w, h, nclass, npages, cellw, cellh, ncomp, i, x, y, iclass, ipage;
NUMA    *naclass, *napage;
PTA     *ptaul;
PIX     *pixt;
FILE    *fp;
    PROCNAME("jbDataWrite");
    if (!rootout)
        return ERROR_INT("no rootout", procName, 1);
    if (!jbdata)
        return ERROR_INT("no jbdata", procName, 1);
    npages = jbdata->npages;
    w = jbdata->w;
    h = jbdata->h;
    pixt = jbdata->pix;
    nclass = jbdata->nclass;
    cellw = jbdata->latticew;
    cellh = jbdata->latticeh;
    naclass = jbdata->naclass;
    napage = jbdata->napage;
    ptaul = jbdata->ptaul;
    snprintf(buf, L_BUF_SIZE, "%s%s", rootout, JB_TEMPLATE_EXT); 
    pixWrite(buf, pixt, IFF_PNG);
    snprintf(buf, L_BUF_SIZE, "%s%s", rootout, JB_DATA_EXT); 
    if ((fp = fopenWriteStream(buf, "wb")) == NULL)
        return ERROR_INT("stream not opened", procName, 1);
    ncomp = ptaGetCount(ptaul);
    fprintf(fp, "jb data file\n");
    fprintf(fp, "num pages = %d\n", npages);
    fprintf(fp, "page size: w = %d, h = %d\n", w, h);
    fprintf(fp, "num components = %d\n", ncomp);
    fprintf(fp, "num classes = %d\n", nclass);
    fprintf(fp, "template lattice size: w = %d, h = %d\n", cellw, cellh);
    for (i = 0; i < ncomp; i++) {
        numaGetIValue(napage, i, &ipage);
        numaGetIValue(naclass, i, &iclass);
        ptaGetIPt(ptaul, i, &x, &y);
        fprintf(fp, "%d %d %d %d\n", ipage, iclass, x, y);
    }
    fclose(fp);
    return 0;
}
########################rank 7#############################
static
int v2_write(struct id3_file *file,
	     id3_byte_t const *data, id3_length_t length)
{
  assert(!data || length > 0);
  if (data &&
      ((file->ntags == 1 && !(file->flags & ID3_FILE_FLAG_ID3V1)) ||
       (file->ntags == 2 &&  (file->flags & ID3_FILE_FLAG_ID3V1))) &&
      file->tags[0].length == length) {
    if (fseek(file->iofile, file->tags[0].location, SEEK_SET) == -1 ||
	fwrite(data, length, 1, file->iofile) != 1 ||
	fflush(file->iofile) == EOF)
      return -1;
    goto done;
  }
 done:
  return 0;
}
########################rank 8#############################
void Write16(unsigned char* pByte, unsigned short value)
{
    pByte[0] = (unsigned char)value;    
    pByte[1] = (unsigned char)(value >> 8);    
}
########################rank 9#############################
static int  bw_fd  = -1;
static long bw_pos = 0;
static char bw_outbuf[OUTBUFSZ];
long int
blocking_write(int outf, char *buffer, long num){
  long int words=0,temp;
  while(words<num){
    temp=write(outf,buffer+words,num-words);
    if(temp==-1){
      if(errno!=EINTR && errno!=EAGAIN)
	return(-1);
      temp=0;
    }
    words+=temp;
  }
  return(0);
}
########################rank 10#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
----------------------------QUERY-------------------------------
generate trace call to print
########################rank 1#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  GCtrace *T = trace_save_alloc(J);  
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  /* Patch FORI, too. */
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J, T);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
  );
}
########################rank 2#############################
void BotAI_Trace( bsp_trace_t *bsptrace, vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int passent, int contentmask ) {
	trace_t trace;
	trap_Trace( &trace, start, mins, maxs, end, passent, contentmask );
	//copy the trace information
	bsptrace->allsolid = trace.allsolid;
	bsptrace->startsolid = trace.startsolid;
	bsptrace->fraction = trace.fraction;
	VectorCopy( trace.endpos, bsptrace->endpos );
	bsptrace->plane.dist = trace.plane.dist;
	VectorCopy( trace.plane.normal, bsptrace->plane.normal );
	bsptrace->plane.signbits = trace.plane.signbits;
	bsptrace->plane.type = trace.plane.type;
	bsptrace->surface.value = trace.surfaceFlags;
	bsptrace->ent = trace.entityNum;
	bsptrace->exp_dist = 0;
	bsptrace->sidenum = 0;
	bsptrace->contents = 0;
}
########################rank 3#############################
void BotAI_Trace(bsp_trace_t *bsptrace, vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int passent, int contentmask) {
	trace_t trace;
	trap_Trace(&trace, start, mins, maxs, end, passent, contentmask);
	//copy the trace information
	bsptrace->allsolid = trace.allsolid;
	bsptrace->startsolid = trace.startsolid;
	bsptrace->fraction = trace.fraction;
	VectorCopy(trace.endpos, bsptrace->endpos);
	bsptrace->plane.dist = trace.plane.dist;
	VectorCopy(trace.plane.normal, bsptrace->plane.normal);
	bsptrace->plane.signbits = trace.plane.signbits;
	bsptrace->plane.type = trace.plane.type;
	bsptrace->surface.value = trace.surfaceFlags;
	bsptrace->ent = trace.entityNum;
	bsptrace->exp_dist = 0;
	bsptrace->sidenum = 0;
	bsptrace->contents = 0;
}
########################rank 4#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  GCtrace *T = trace_save_alloc(J);  
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  /* Patch FORI, too. */
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  case BC_CALLM:
  case BC_CALL:
  case BC_ITERC:
    traceref(J, J->exitno)->link = traceno;
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J, T);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
  );
}
########################rank 5#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  GCtrace *T = J->curfinal;
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  case BC_CALLM:
  case BC_CALL:
  case BC_ITERC:
    traceref(J, J->exitno)->link = traceno;
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J, T);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
  );
}
########################rank 6#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  GCtrace *T = J->curfinal;
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  case BC_CALLM:
  case BC_CALL:
  case BC_ITERC:
    traceref(J, J->exitno)->link = traceno;
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J, T);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
  );
}
########################rank 7#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  GCtrace *T = J->curfinal;
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  case BC_CALLM:
  case BC_CALL:
  case BC_ITERC:
    traceref(J, J->exitno)->link = traceno;
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J, T);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
  );
}
########################rank 8#############################
void
tgl_trace(const char *format, ...)
{
#ifndef NO_DEBUG_OUTPUT
  va_list args;
  va_start(args, format);
  fprintf(stderr, "*DEBUG* ");
  vfprintf(stderr, format, args);
  va_end(args);
#endif /* !NO_DEBUG_OUTPUT */
}
########################rank 9#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
  );
}
########################rank 10#############################
static void trace_stop(jit_State *J)
{
  BCIns *pc = mref(J->cur.startpc, BCIns);
  BCOp op = bc_op(J->cur.startins);
  GCproto *pt = &gcref(J->cur.startpt)->pt;
  TraceNo traceno = J->cur.traceno;
  lua_State *L;
  switch (op) {
  case BC_FORL:
    setbc_op(pc+bc_j(J->cur.startins), BC_JFORI);  
  case BC_LOOP:
  case BC_ITERL:
  case BC_FUNCF:
    setbc_op(pc, (int)op+(int)BC_JLOOP-(int)BC_LOOP);
    setbc_d(pc, traceno);
  addroot:
    J->cur.nextroot = pt->trace;
    pt->trace = (TraceNo1)traceno;
    break;
  case BC_RET:
  case BC_RET0:
  case BC_RET1:
    *pc = BCINS_AD(BC_JLOOP, J->cur.snap[0].nslots, traceno);
    goto addroot;
  case BC_JMP:
    lua_assert(J->parent != 0 && J->cur.root != 0);
    lj_asm_patchexit(J, traceref(J, J->parent), J->exitno, J->cur.mcode);
    traceref(J, J->parent)->snap[J->exitno].count = SNAPCOUNT_DONE;
    {
      GCtrace *root = traceref(J, J->cur.root);
      root->nchild++;
      J->cur.nextside = root->nextside;
      root->nextside = (TraceNo1)traceno;
    }
    break;
  default:
    lua_assert(0);
    break;
  }
  lj_mcode_commit(J, J->cur.mcode);
  J->postproc = LJ_POST_NONE;
  trace_save(J);
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "stop"));
    setintV(L->top++, traceno);
  );
}
----------------------------QUERY-------------------------------
get dimensions of given bmp file
########################rank 1#############################
void bmp_get_size(struct bmp_decdata *bmp, int *width, int *height)
{
    *width = bmp->width;
    *height = bmp->height;
}
########################rank 2#############################
void bmp_get_size(struct bmp_decdata *bmp, int *width, int *height)
{
    *width = bmp->width;
    *height = bmp->height;
}
########################rank 3#############################
void bmp_get_size(struct bmp_decdata *bmp, int *width, int *height)
{
    *width = bmp->width;
    *height = bmp->height;
}
########################rank 4#############################
l_int32
ptraaGetSize(L_PTRAA  *paa,
             l_int32  *psize)
{
    PROCNAME("ptraaGetSize");
    if (!paa)
        return ERROR_INT("paa not defined", procName, 1);
    if (!psize)
        return ERROR_INT("&size not defined", procName, 1);
    *psize = paa->nalloc;
    return 0;
}
########################rank 5#############################
static void get_geometry(struct ipod_t* ipod)
{
    ipod->num_heads = 255;
    ipod->sectors_per_track = 63;
}
########################rank 6#############################
od_val16 od_pvq_cos(od_val32 x) {
#if defined(OD_FLOAT_PVQ)
  return cos(x);
#else
  x = x & 0x0001ffff;
  if (x > (1 << 16)) {
    x = (1 << 17) - x;
  }
  if (x & 0x00007fff) {
    if (x < (1 << 15)) {
       return od_pvq_cos_pi_2((int16_t)x);
    }
    else {
      return -od_pvq_cos_pi_2((int16_t)(65536 - x));
    }
  }
  else {
    if (x & 0x0000ffff) {
      return 0;
    }
    else if (x & 0x0001ffff) {
      return -32767;
    }
    else {
      return 32767;
    }
  }
#endif
}
########################rank 7#############################
lzg_uint32_t LZG_MaxEncodedSize(lzg_uint32_t insize)
{
    return LZG_HEADER_SIZE + insize;
}
########################rank 8#############################
lzg_uint32_t LZG_MaxEncodedSize(lzg_uint32_t insize)
{
    return LZG_HEADER_SIZE + insize;
}
########################rank 9#############################
char *readfile_stdc(const char *filename, size_t *filesize)
{
	// If filesize is a NULL pointer, return an error.
	if(filesize == NULL)
		return NULL;
	*filesize = 0;
	// If filename is NULL, return an error.
	if(filename == NULL)
		return NULL;
	// Try to open the file for reading, check for error.
	FILE *f = fopen(filename, "r");
	if(f == NULL)
	{
		perror("fopen");
		return NULL;
	}
	   out the size of the file. Note that in standard C, this is not
	   guaranteed to work if we had fopen()'d the file in binary
	   mode. For more information, see:
	   https://www.securecoding.cert.org/confluence/display/c/FIO19-C.+Do+not+use+fseek()+and+ftell()+to+compute+the+size+of+a+regular+file
	*/
	// Seek to end of file, check for error.
	if(fseek(f, 0L, SEEK_END) != 0)
	{
		perror("fseek");
		fclose(f);
		return NULL;
	}
	// Get our current position in the file (i.e., at the end), check
	// for error
	long size = ftell(f);
	if(size == -1)
	{
		perror("ftell");
		fclose(f);
		return NULL;
	}
	// Seek back to the beginning of the file, check for error.
	if(fseek(f, 0L, SEEK_SET) != 0)
	{
		perror("fseek");
		fclose(f);
		return NULL;
	}
	// Store the size of the file in the pointer passed into this
	// function.
	*filesize = (size_t) size;
	// Try to allocate space to store file.
	char *fileContents = (char*) malloc(sizeof(char) * size);
	if(fileContents == NULL)
	{
		fprintf(stderr, "malloc() failed.\n");
		fclose(f);
		return NULL;
	}
	// Try to all bytes in the file. If we read less than we should,
	// return an error.
	if(fread(fileContents, 1, *filesize, f) < *filesize)
	{
		perror("fread");
		fprintf(stderr, "We read less from the file than we expected due to the problem above.\n");
		free(fileContents);
		fclose(f);
		return NULL;
	}
	   happen at any point after we have read the bytes from the
	   file. However, depending on the situation, this may or may not
	   be considered an error. */
	char oneMoreByte;
	if(fread(&oneMoreByte, 1, 1, f) == 1)
	{
		fprintf(stderr, "File increased in size unexpectedly.\n");
		free(fileContents);
		fclose(f);
		return NULL;
	}
	return fileContents;
}
########################rank 10#############################
static
FT_Error  Load_SBit_Range_Codes( TT_SBit_Range*  range,
								 FT_Stream stream,
								 FT_Bool load_offsets ) {
	FT_Error error;
	FT_ULong count, n, size;
	FT_Memory memory = stream->memory;
	if ( READ_ULong( count ) ) {
		goto Exit;
	}
	range->num_glyphs = count;
	if ( load_offsets ) {
		if ( ALLOC_ARRAY( range->glyph_offsets, count, FT_ULong ) ) {
			goto Exit;
		}
		size = count * 4L;
	} else {
		size = count * 2L;
	}
	if ( ALLOC_ARRAY( range->glyph_codes, count, FT_UShort ) ||
		 ACCESS_Frame( size )                                 ) {
		goto Exit;
	}
	for ( n = 0; n < count; n++ )
	{
		range->glyph_codes[n] = GET_UShort();
		if ( load_offsets ) {
			range->glyph_offsets[n] = (FT_ULong)range->image_offset +
									  GET_UShort();
		}
	}
	FORGET_Frame();
Exit:
	return error;
}
----------------------------QUERY-------------------------------
add extension to filename
########################rank 1#############################
char* FileName(char *name, char *ext)
{
	char *str;
	int len;
	int i;
	if(ext == EMPTY_EXT){
		return name;
	}
	i = len = strlen(name);
	while (i > 0 && name[i - 1] != '.'){
		i--;
	}
	if(i > 0){
		len = i - 1;
	}
	str = Alloc(len + strlen(ext)+1);
	strncpy(str,name,len);
	str[len] = '\0';
	strcat(str,ext);	
	return str;		
}
########################rank 2#############################
const char *COM_FileExtension( const char *filename ) {
	const char *src, *last;
	last = strrchr( filename, '/' );
	src = strrchr( last ? last : filename, '.' );
	if( src && *( src + 1 ) ) {
		return src;
	}
	return NULL;
}
########################rank 3#############################
const char *simple_basename(const char *name)
{
    const char *p;
    p=name+strlen(name)-1;
    while(*p=='/'){
        if(p==name)
            return name;
        p--;
    }
    while(p!=name){
        if(*p=='/')
            return p+1;
        p--;
    }
    return name;
}
########################rank 4#############################
static char *S_FileExtension(const char *fni)
{
	// we should search from the ending to the last '/'
	char *fn = (char *) fni + strlen(fni) - 1;
	char *eptr = NULL;
	while(*fn != '/' && fn != fni)
	{
		if(*fn == '.')
		{
			eptr = fn;
			break;
		}
		fn--;
	}
	return eptr;
}
########################rank 5#############################
void Com_DefaultExtension( char *path, int maxSize, const char *extension ) {
	char oldPath[MAX_QPATH];
	char    *src;
//
// if path doesn't have a .EXT, append extension
// (extension should include the .)
//
	src = path + strlen( path ) - 1;
	while ( *src != '/' && src != path ) {
		if ( *src == '.' ) {
			return;                 // it has an extension
		}
		src--;
	}
	Q_strncpyz( oldPath, path, sizeof( oldPath ) );
	Com_sprintf( path, maxSize, "%s%s", oldPath, extension );
}
########################rank 6#############################
void COM_DefaultExtension( char *path, int maxSize, const char *extension ) {
	char oldPath[MAX_QPATH];
	char    *src;
//
// if path doesn't have a .EXT, append extension
// (extension should include the .)
//
	src = path + strlen( path ) - 1;
	while ( *src != '/' && src != path ) {
		if ( *src == '.' ) {
			return;                 // it has an extension
		}
		src--;
	}
	Q_strncpyz( oldPath, path, sizeof( oldPath ) );
	Com_sprintf( path, maxSize, "%s%s", oldPath, extension );
}
########################rank 7#############################
void COM_DefaultExtension( char *path, int maxSize, const char *extension ) {
	char oldPath[MAX_QPATH];
	char    *src;
//
// if path doesn't have a .EXT, append extension
// (extension should include the .)
//
	src = path + strlen( path ) - 1;
	while ( *src != '/' && src != path ) {
		if ( *src == '.' ) {
			return;                 // it has an extension
		}
		src--;
	}
	Q_strncpyz( oldPath, path, sizeof( oldPath ) );
	Com_sprintf( path, maxSize, "%s%s", oldPath, extension );
}
########################rank 8#############################
void COM_StripExtension( char *filename ) {
	char *src, *last = NULL;
	last = strrchr( filename, '/' );
	src = strrchr( last ? last : filename, '.' );
	if( src && *( src + 1 ) ) {
		*src = 0;
	}
}
########################rank 9#############################
bool extension(int ext, unsigned long extensions) {
	return (extensions & ext);
}
########################rank 10#############################
static int __config_validate_name(const char *name)
{
  const char *p = name;
  if(*p == '\0')
    return(CONFIG_FALSE);
  if(! isalpha((int)*p) && (*p != '*'))
    return(CONFIG_FALSE);
  for(++p; *p; ++p)
  {
    if(! (isalpha((int)*p) || isdigit((int)*p) || strchr("*_-", (int)*p)))
      return(CONFIG_FALSE);
  }
  return(CONFIG_TRUE);
}
----------------------------QUERY-------------------------------
read one word from onboard RAM
########################rank 1#############################
static uint16_t
ram_readw(uint32_t addr, void *priv)
{
    mem_mapping_t *map = (mem_mapping_t *)priv;
    memdev_t *dev = (memdev_t *)map->dev;
    uint16_t ret = 0xffff;
    ret = *(uint16_t *)(dev->ram + (addr - map->base));
    return(ret);
}
########################rank 2#############################
Lib3dsIntd
lib3ds_io_read_intd(Lib3dsIo *io)
{
  Lib3dsByte b[4];
  Lib3dsDword d;        
  ASSERT(io);
  lib3ds_io_read(io, b, 4);
  d=((Lib3dsDword)b[3] << 24) |
    ((Lib3dsDword)b[2] << 16) |
    ((Lib3dsDword)b[1] << 8) |
    ((Lib3dsDword)b[0]);
  return((Lib3dsIntd)d);
}
########################rank 3#############################
uint32_t gpioReadBank1(void) { return (*(gpioReg + GPLEV0)); }
uint32_t gpioReadBank2(void) { return (*(gpioReg + GPLEV1)); }
void gpioClearBank1(uint32_t bits) { *(gpioReg + GPCLR0) = bits; }
void gpioClearBank2(uint32_t bits) { *(gpioReg + GPCLR1) = bits; }
void gpioSetBank1(uint32_t bits) { *(gpioReg + GPSET0) = bits; }
void gpioSetBank2(uint32_t bits) { *(gpioReg + GPSET1) = bits; }
unsigned gpioHardwareRevision(void)
{
   static unsigned rev = 0;
   FILE *filp;
   char buf[512];
   char term;
   int chars=4; /* number of chars in revision string */
   filp = fopen ("/proc/cpuinfo", "r");
   if (filp != NULL)
   {
      while (fgets(buf, sizeof(buf), filp) != NULL)
      {
         if (!strncasecmp("revision", buf, 8))
         {
            if (sscanf(buf+strlen(buf)-(chars+1),
               "%x%c", &rev, &term) == 2)
            {
               if (term != '\n') rev = 0;
               else rev &= 0xFFFFFF; /* mask out warranty bit */
            }
         }
      }
      fclose(filp);
   }
   filp = fopen("/proc/device-tree/soc/ranges" , "rb");
   if (filp != NULL)
   {
      if (fread(buf, 1, sizeof(buf), filp) >= 8)
      {
         piPeriphBase = buf[4]<<24 | buf[5]<<16 | buf[6]<<8 | buf[7];
         if (!piPeriphBase)
            piPeriphBase = buf[8]<<24 | buf[9]<<16 | buf[10]<<8 | buf[11];
         if (piPeriphBase == 0xFE000000) pi_is_2711 = 1;
      }
      fclose(filp);
   }
   return rev;
}
########################rank 4#############################
int ReadWordIndex(FILE *fin) {
  char word[MAX_STRING];
  ReadWord(word, fin);
  if (feof(fin)) return -1;
  return SearchVocab(word);
}
########################rank 5#############################
uint8_t mfxstm32l152_ReadReg(uint16_t DeviceAddr, uint8_t RegAddr)
{
  return(MFX_IO_Read((uint8_t) DeviceAddr, RegAddr));
}
########################rank 6#############################
static void io_read_00A0() {
    io_read_00x0(&vpic2);
}
########################rank 7#############################
static void io_read_0021() {
    io_read_00x1(&vpic1);
}
########################rank 8#############################
static void io_read_00A1() {
    io_read_00x1(&vpic2);
}
########################rank 9#############################
static void io_read_03F5() {
    if (!GetMSRReadyRead) {
        return;
    } else {
        SetMSRProcRead;
    }
    vport.data.ioByte = vfdc.data.ret[vfdc.data.rwCount++];
    switch (vfdc.data.cmd[0]) {
    case CMD_SPECIFY:
        if (vfdc.data.rwCount >= 0) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_SENSE_DRIVE_STATUS:
        if (vfdc.data.rwCount >= 1) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_RECALIBRATE:
        if (vfdc.data.rwCount >= 0) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_SENSE_INTERRUPT:
        if (vfdc.data.rwCount >= 2) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_SEEK:
        if (vfdc.data.rwCount >= 0) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_READ_TRACK:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_READ_ID:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_FORMAT_TRACK:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_WRITE_DATA:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_READ_DATA_ALL:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_WRITE_DELETED_DATA:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_READ_DELETED_DATA:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_SCAN_EQUAL_ALL:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_READ_DATA:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    case CMD_SCAN_EQUAL:
        if (vfdc.data.rwCount >= 7) {
            SetMSRReadyWrite;
        }
        break;
    default:
        if (vfdc.data.rwCount >= 1) {
            SetMSRReadyWrite;
        }
        break;
    }
}
########################rank 10#############################
cell read_character(void) {
	char	buf[10], msg[50];
	int	i, c = 0; /*LINT*/
	for (i=0; i<sizeof(buf)-1; i++) {
		c = readc();
		if (i > 0 && !isalpha(c))
			break;
		buf[i] = c;
	}
	reject(c);
	buf[i] = 0;
	if (i == 0)
		c = ' ';
	else if (i == 1)
		c = buf[0];
	else if (!strcmp_ci(buf, "space"))
		c = ' ';
	else if (!strcmp_ci(buf, "newline"))
		c = '\n';
	else {
		sprintf(msg, "unknown character: #\\%s", buf);
		error(msg, NOEXPR);
		c = 0;
	}
	return make_char(c);
}
----------------------------QUERY-------------------------------
encode ucs2 string into utf8 string
########################rank 1#############################
ON_FLASH V7_PRIVATE void embed_string(struct mbuf *m, size_t offset,
                                      const char *p, size_t len, int zero_term,
                                      int unesc) {
  char *old_base = m->buf;
  int p_backed_by_mbuf = p >= old_base && p < old_base + m->len;
  size_t n = unesc ? unescape(p, len, NULL) : len;
  int k = calc_llen(n); /* Calculate how many bytes length takes */
  size_t tot_len = k + n + zero_term;
  mbuf_insert(m, offset, NULL, tot_len); /* Allocate  buffer */
  if (p_backed_by_mbuf) {
    p += m->buf - old_base;
  }
  encode_varint(n, (unsigned char *) m->buf + offset); /* Write length */
  if (p != 0) {
    if (unesc) {
      unescape(p, len, m->buf + offset + k);
    } else {
      memcpy(m->buf + offset + k, p, len);
    }
  }
  if (zero_term) {
    m->buf[offset + tot_len - 1] = '\0';
  }
}
########################rank 2#############################
void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
    if (len < 64) {
        buf[0] = len | LP_ENCODING_6BIT_STR;
        memcpy(buf+1,s,len);
    } else if (len < 4096) {
        buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
        buf[1] = len & 0xff;
        memcpy(buf+2,s,len);
    } else {
        buf[0] = LP_ENCODING_32BIT_STR;
        buf[1] = len & 0xff;
        buf[2] = (len >> 8) & 0xff;
        buf[3] = (len >> 16) & 0xff;
        buf[4] = (len >> 24) & 0xff;
        memcpy(buf+5,s,len);
    }
}
########################rank 3#############################
void base64_encode(unsigned char *out,const unsigned char *in,int inlen)
{
   for (; inlen >= 3; inlen -= 3) {
      *out++ = base64digits[in[0] >> 2];
      *out++ = base64digits[((in[0] << 4) & 0x30) | (in[1] >> 4)];
      *out++ = base64digits[((in[1] << 2) & 0x3c) | (in[2] >> 6)];
      *out++ = base64digits[in[2] & 0x3f];
      in += 3;
   }
   if (inlen > 0) {
      unsigned char fragment;
      *out++ = base64digits[in[0] 
	  >> 2];
      fragment = (in[0] << 4) & 0x30;
      if (inlen > 1)
         fragment |= in[1] >> 4;
      *out++ = base64digits[fragment];
      *out++ = (inlen < 2) ? '=' : base64digits[(in[1] << 2) & 0x3c];
      *out++ = '=';
   }
   *out = '\0';
}
########################rank 4#############################
char *
encodeAscii85(l_uint8  *inarray,
              l_int32   insize,
              l_int32  *poutsize)
{
char    *chara;
char    *outbuf;
l_int32  maxsize, i, index, outindex, linecount, nbout, eof;
    PROCNAME("encodeAscii85");
    if (!inarray)
        return (char *)ERROR_PTR("inarray not defined", procName, NULL);
    maxsize = (l_int32)(80. + (insize * 5. / 4.) *
                        (1. + 2. / MAX_85_LINE_COUNT));
    if ((chara = (char *)CALLOC(maxsize, sizeof(char))) == NULL)
        return (char *)ERROR_PTR("chara not made", procName, NULL);
    if ((outbuf = (char *)CALLOC(8, sizeof(char))) == NULL)
        return (char *)ERROR_PTR("outbuf not made", procName, NULL);
    linecount = 0;
    index = 0;
    outindex = 0;
    while (1) {
        eof = convertChunkToAscii85(inarray, insize, &index, outbuf, &nbout);
        for (i = 0; i < nbout; i++) {
            chara[outindex++] = outbuf[i];
            linecount++;
            if (linecount >= MAX_85_LINE_COUNT) {
                chara[outindex++] = '\n';
                linecount = 0;
            }
        }
        if (eof == TRUE) {
            if (linecount != 0)
                chara[outindex++] = '\n';
            chara[outindex++] = '~';
            chara[outindex++] = '>';
            chara[outindex++] = '\n';
            break;
        }
    }
    FREE(outbuf);
    *poutsize = outindex;
    return chara;
}
########################rank 5#############################
ON_FLASH void base64_encode(const unsigned char *src, int src_len, char *dst) {
  static const char *b64 =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  int i, j, a, b, c;
  for (i = j = 0; i < src_len; i += 3) {
    a = src[i];
    b = i + 1 >= src_len ? 0 : src[i + 1];
    c = i + 2 >= src_len ? 0 : src[i + 2];
    dst[j++] = b64[a >> 2];
    dst[j++] = b64[((a & 3) << 4) | (b >> 4)];
    if (i + 1 < src_len) {
      dst[j++] = b64[(b & 15) << 2 | (c >> 6)];
    }
    if (i + 2 < src_len) {
      dst[j++] = b64[c & 63];
    }
  }
  while (j % 4 != 0) {
    dst[j++] = '=';
  }
  dst[j++] = '\0';
}
########################rank 6#############################
char *encode_base64(int size, char *src)
{
    int i;
    char *out, *p;
    if (!src) {
        return NULL;
    }
    if (!size) {
        size = strlen((char *)src);
    }
    out = (char *)calloc(sizeof(char), size * 4 / 3 + 4);
    if (!out) {
        return NULL;
    }
    p = out;
    for (i = 0; i < size; i += 3) {
        unsigned char b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0, b7 = 0;
        b1 = src[i];
        if (i + 1 < size) {
            b2 = src[i + 1];
        }
        if (i + 2 < size) {
            b3 = src[i + 2];
        }
        b4 = b1 >> 2;
        b5 = ((b1 & 0x3) << 4) | (b2 >> 4);
        b6 = ((b2 & 0xf) << 2) | (b3 >> 6);
        b7 = b3 & 0x3f;
        *p++ = encode(b4);
        *p++ = encode(b5);
        if (i + 1 < size) {
            *p++ = encode(b6);
        } else {
            *p++ = '=';
        }
        if (i + 2 < size) {
            *p++ = encode(b7);
        } else {
            *p++ = '=';
        }
    }
    return out;
}
########################rank 7#############################
size_t
base64_encode(void *vdst, size_t sizeof_dst, 
              const void *vsrc, size_t sizeof_src)
{
    static const char *b64 =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789"
        "+/";
    size_t i = 0;
    size_t d = 0;
    unsigned char *dst = (unsigned char *)vdst;
    const unsigned char *src = (const unsigned char *)vsrc;
    while (i + 3 <= sizeof_src) {
        unsigned n;
        if (d + 4 > sizeof_dst)
            return d;
        n = src[i]<<16 | src[i+1]<<8 | src[i+2];
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = b64[ (n>> 6) & 0x3F ];
        dst[d+3] = b64[ (n>> 0) & 0x3F ];
        i += 3;
        d += 4;
    }
     * have to append a '=' or '==' to the output to compensate */
    if (i + 2 <= sizeof_src && d + 4 <= sizeof_dst) {
        unsigned n = src[i]<<16 | src[i+1]<<8;
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = b64[ (n>> 6) & 0x3F ];
        dst[d+3] = '=';
        d += 4;
    } else if (i + 1 <= sizeof_src && d + 4 <= sizeof_dst) {
        unsigned n = src[i]<<16 | src[i+1]<<8;
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = '=';
        dst[d+3] = '=';
        d += 4;
    }
    return d;
}
########################rank 8#############################
size_t
base64_encode(void *vdst, size_t sizeof_dst, 
              const void *vsrc, size_t sizeof_src)
{
    static const char *b64 =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789"
        "+/";
    size_t i = 0;
    size_t d = 0;
    unsigned char *dst = (unsigned char *)vdst;
    const unsigned char *src = (const unsigned char *)vsrc;
    while (i + 3 <= sizeof_src) {
        unsigned n;
        if (d + 4 > sizeof_dst)
            return d;
        n = src[i]<<16 | src[i+1]<<8 | src[i+2];
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = b64[ (n>> 6) & 0x3F ];
        dst[d+3] = b64[ (n>> 0) & 0x3F ];
        i += 3;
        d += 4;
    }
     * have to append a '=' or '==' to the output to compensate */
    if (i + 2 <= sizeof_src && d + 4 <= sizeof_dst) {
        unsigned n = src[i]<<16 | src[i+1]<<8;
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = b64[ (n>> 6) & 0x3F ];
        dst[d+3] = '=';
        d += 4;
    } else if (i + 1 <= sizeof_src && d + 4 <= sizeof_dst) {
        unsigned n = src[i]<<16 | src[i+1]<<8;
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = '=';
        dst[d+3] = '=';
        d += 4;
    }
    return d;
}
########################rank 9#############################
size_t
base64_encode(void *vdst, size_t sizeof_dst, 
              const void *vsrc, size_t sizeof_src)
{
    static const char *b64 =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789"
        "+/";
    size_t i = 0;
    size_t d = 0;
    unsigned char *dst = (unsigned char *)vdst;
    const unsigned char *src = (const unsigned char *)vsrc;
    while (i + 3 <= sizeof_src) {
        unsigned n;
        if (d + 4 > sizeof_dst)
            return d;
        n = src[i]<<16 | src[i+1]<<8 | src[i+2];
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = b64[ (n>> 6) & 0x3F ];
        dst[d+3] = b64[ (n>> 0) & 0x3F ];
        i += 3;
        d += 4;
    }
     * have to append a '=' or '==' to the output to compensate */
    if (i + 2 <= sizeof_src && d + 4 <= sizeof_dst) {
        unsigned n = src[i]<<16 | src[i+1]<<8;
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = b64[ (n>> 6) & 0x3F ];
        dst[d+3] = '=';
        d += 4;
    } else if (i + 1 <= sizeof_src && d + 4 <= sizeof_dst) {
        unsigned n = src[i]<<16;
        dst[d+0] = b64[ (n>>18) & 0x3F ];
        dst[d+1] = b64[ (n>>12) & 0x3F ];
        dst[d+2] = '=';
        dst[d+3] = '=';
        d += 4;
    }
    return d;
}
########################rank 10#############################
static void bt_bencode_str(torrent_ctx* ctx, const char* name, const char* str)
{
	size_t len = strlen(str);
	int num_len;
	char* p;
	if (name) bt_str_append(ctx, name);
	if (!bt_str_ensure_length(ctx, ctx->content.length + len + 21)) return;
	p = ctx->content.str + ctx->content.length;
	p += (num_len = rhash_sprintI64(p, len));
	ctx->content.length += len + num_len + 1;
	*(p++) = ':';
	memcpy(p, str, len + 1); /* copy with trailing '\0' */
}
----------------------------QUERY-------------------------------
check pointer is in the heap
########################rank 1#############################
void Z_CheckHeap( void ) {
	memblock_t  *block;
	for ( block = mainzone->blocklist.next ; ; block = block->next ) {
		if ( block->next == &mainzone->blocklist ) {
			break;          // all blocks have been hit
		}
		if ( (byte *)block + block->size != (byte *)block->next ) {
			Com_Error( ERR_FATAL, "Z_CheckHeap: block size does not touch the next block\n" );
		}
		if ( block->next->prev != block ) {
			Com_Error( ERR_FATAL, "Z_CheckHeap: next block doesn't have proper back link\n" );
		}
		if ( !block->tag && !block->next->tag ) {
			Com_Error( ERR_FATAL, "Z_CheckHeap: two consecutive free blocks\n" );
		}
	}
}
########################rank 2#############################
void Z_CheckHeap( void ) {
	memblock_t  *block;
	for ( block = mainzone->blocklist.next ; ; block = block->next ) {
		if ( block->next == &mainzone->blocklist ) {
			break;          // all blocks have been hit
		}
		if ( (byte *)block + block->size != (byte *)block->next ) {
			Com_Error( ERR_FATAL, "Z_CheckHeap: block size does not touch the next block\n" );
		}
		if ( block->next->prev != block ) {
			Com_Error( ERR_FATAL, "Z_CheckHeap: next block doesn't have proper back link\n" );
		}
		if ( !block->tag && !block->next->tag ) {
			Com_Error( ERR_FATAL, "Z_CheckHeap: two consecutive free blocks\n" );
		}
	}
}
########################rank 3#############################
static int try_realloc(void **ptr, size_t new_size) {
    void *reallocated_ptr = NULL;
    if (new_size == 0) {
        return JSONFailure;
    }
    reallocated_ptr = PARSON_REALLOC(*ptr, new_size);
    if (reallocated_ptr == NULL) {
        return JSONFailure;
    }
    *ptr = reallocated_ptr;
    return JSONSuccess;
}
########################rank 4#############################
static int try_realloc(void **ptr, size_t new_size) {
    void *reallocated_ptr = parson_realloc(*ptr, new_size);
    if (!reallocated_ptr) { return ERROR; }
    *ptr = reallocated_ptr;
    return SUCCESS;
}
########################rank 5#############################
static int try_realloc(void **ptr, size_t new_size) {
    void *reallocated_ptr = parson_realloc(*ptr, new_size);
    if (!reallocated_ptr) { return ERROR; }
    *ptr = reallocated_ptr;
    return SUCCESS;
}
########################rank 6#############################
void
addrmatchlist_add_other(struct Cfg_AddrMatchList *list, const struct Cfg_AddrMatchList *other, unsigned is_not)
{
    struct Cfg_AddrMatchElement *element;
    list->elements = REALLOC2(list->elements, sizeof(list->elements[0]), list->elements_count + 1);
    element = &list->elements[list->elements_count++];
    memset(element, 0, sizeof(*element));
    element->is_not = is_not;
    element->version = 1;
    element->ip.other = other;
}
########################rank 7#############################
static void
popNewPixel(L_QUEUE  *lq,
            l_int32  *px,
            l_int32  *py)
{
L_NEWPIXEL  *np;
    PROCNAME("popNewPixel");
    if (!lq) {
        L_ERROR(procName, "lqueue not defined");
        return;
    }
    if ((np = (L_NEWPIXEL *)lqueueRemove(lq)) == NULL)
        return;
    *px = np->x;
    *py = np->y;
    lstackAdd(lq->stack, np);  /* save for re-use */
    return;
}
########################rank 8#############################
BINN_PRIVATE BOOL CheckAllocation(binn *item, int add_size) {
  int  alloc_size;
  void *ptr;
  if (item->used_size + add_size > item->alloc_size) {
    if (item->pre_allocated) return FALSE;
    alloc_size = CalcAllocation(item->used_size + add_size, item->alloc_size);
    ptr = realloc_fn(item->pbuf, alloc_size);
    if (ptr == NULL) return FALSE;
    item->pbuf = ptr;
    item->alloc_size = alloc_size;
  }
  return TRUE;
}
########################rank 9#############################
static
void bsPutUChar(EState *s, UChar c) {
    bsW(s, 8, (UInt32) c);
}
########################rank 10#############################
SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;
  sqlite3_int64 nUsed;
#ifndef SQLITE_OMIT_AUTOINIT
  int rc = sqlite3_initialize();
  if( rc ) return -1;
#endif
  sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.alarmThreshold;
  if( n<0 ){
    sqlite3_mutex_leave(mem0.mutex);
    return priorLimit;
  }
  if( mem0.hardLimit>0 && (n>mem0.hardLimit || n==0) ){
    n = mem0.hardLimit;
  }
  mem0.alarmThreshold = n;
  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
  mem0.nearlyFull = (n>0 && n<=nUsed);
  sqlite3_mutex_leave(mem0.mutex);
  excess = sqlite3_memory_used() - n;
  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
  return priorLimit;
}
----------------------------QUERY-------------------------------
search a file in directory recursively
########################rank 1#############################
gtwrkf(dir, file)
char *file, *dir;
{
	register int i;
	if (Nfiles-- <= 0) {
		Nfiles = 0;
		return 0;
	}
	sprintf(file, "%s/%s", dir, Filent[0]);
	for (i=0; i<Nfiles;i++)
		strcpy(Filent[i], Filent[i+1]);
	return 1;
}
########################rank 2#############################
static void
make_directory_records(PDIR_RECORD d)
{
    PDIR_RECORD new_d;
    DIR *dirp;
    struct dirent *entry;
    char *old_end_source;
    struct stat stbuf;
    char buf[MAX_PATH];
    d->first_record = NULL;
#ifdef HAVE_D_TYPE
    dirp = opendir(source);
    if (dirp != NULL)
    {
        while ((entry = readdir(dirp)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue; // skip self and parent
            if (entry->d_type == DT_REG) // normal file
            {
                // Check for an absolute path
                if (source[0] == DIR_SEPARATOR_CHAR)
                {
                    strcpy(buf, source);
                    strcat(buf, DIR_SEPARATOR_STRING);
                    strcat(buf, entry->d_name);
                }
                else
                {
                    if (!getcwd(buf, sizeof(buf)))
                        error_exit("Cannot get CWD: %s\n", strerror(errno));
                    strcat(buf, DIR_SEPARATOR_STRING);
                    strcat(buf, source);
                    strcat(buf, entry->d_name);
                }
                if (stat(buf, &stbuf) == -1)
                {
                    error_exit("Cannot access '%s' (%s)\n", buf, strerror(errno));
                    return;
                }
                if (strcmp(entry->d_name, DIRECTORY_TIMESTAMP) == 0)
                {
                    convert_date_and_time(&d->date_and_time, &stbuf.st_ctime);
                }
                else
                {
                    if (verbosity == VERBOSE)
                    {
                        printf("%d: file %s\n", d->level, buf);
                    }
                    (void) new_directory_record(entry, &stbuf, d);
                }
            }
        }
        closedir(dirp);
    }
    else
    {
        error_exit("Cannot open '%s'\n", source);
        return;
    }
    dirp = opendir(source);
    if (dirp != NULL)
    {
        while ((entry = readdir(dirp)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue; // skip self and parent
            if (entry->d_type == DT_DIR) // directory
            {
                old_end_source = end_source;
                append_string_to_source(entry->d_name);
                *end_source++ = DIR_SEPARATOR_CHAR;
                *end_source = 0;
                if (verbosity == VERBOSE)
                {
                    printf("%d: directory %s\n", d->level + 1, source);
                }
                if (d->level < MAX_LEVEL)
                {
                    // Check for an absolute path
                    if (source[0] == DIR_SEPARATOR_CHAR)
                    {
                        strcpy(buf, source);
                    }
                    else
                    {
                        if (!getcwd(buf, sizeof(buf)))
                            error_exit("Cannot get CWD: %s\n", strerror(errno));
                        strcat(buf, DIR_SEPARATOR_STRING);
                        strcat(buf, source);
                    }
                    if (stat(buf, &stbuf) == -1)
                    {
                        error_exit("Cannot access '%s' (%s)\n", buf, strerror(errno));
                        return;
                    }
                    new_d = new_directory_record(entry, &stbuf, d);
                    new_d->next_in_path_table = root.next_in_path_table;
                    root.next_in_path_table = new_d;
                    new_d->level = d->level + 1;
                    make_directory_records(new_d);
                }
                else
                {
                    error_exit("Directory is nested too deep");
                }
                end_source = old_end_source;
                *end_source = 0;
            }
        }
        closedir(dirp);
    }
    else
    {
        error_exit("Cannot open '%s'\n", source);
        return;
    }
#else
    dirp = opendir(source);
    if (dirp != NULL)
    {
        while ((entry = readdir(dirp)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue; // skip self and parent
            // Check for an absolute path
            if (source[0] == DIR_SEPARATOR_CHAR)
            {
                strcpy(buf, source);
                strcat(buf, DIR_SEPARATOR_STRING);
                strcat(buf, entry->d_name);
            }
            else
            {
                if (!getcwd(buf, sizeof(buf)))
                    error_exit("Cannot get CWD: %s\n", strerror(errno));
                strcat(buf, DIR_SEPARATOR_STRING);
                strcat(buf, source);
                strcat(buf, entry->d_name);
            }
            if (stat(buf, &stbuf) == -1)
            {
                error_exit("Cannot access '%s' (%s)\n", buf, strerror(errno));
                return;
            }
            if (S_ISDIR(stbuf.st_mode))
            {
                old_end_source = end_source;
                append_string_to_source(entry->d_name);
                *end_source++ = DIR_SEPARATOR_CHAR;
                *end_source = 0;
                if (verbosity == VERBOSE)
                {
                    printf("%d: directory %s\n", d->level + 1, source);
                }
                if (d->level < MAX_LEVEL)
                {
                    new_d = new_directory_record(entry, &stbuf, d);
                    new_d->next_in_path_table = root.next_in_path_table;
                    root.next_in_path_table = new_d;
                    new_d->level = d->level + 1;
                    make_directory_records(new_d);
                }
                else
                {
                    error_exit("Directory is nested too deep");
                }
                end_source = old_end_source;
                *end_source = 0;
            }
            else if (S_ISREG(stbuf.st_mode))
            {
                if (strcmp(entry->d_name, DIRECTORY_TIMESTAMP) == 0)
                {
                    convert_date_and_time(&d->date_and_time, &stbuf.st_ctime);
                }
                else
                {
                    if (verbosity == VERBOSE)
                    {
                        printf("%d: file %s\n", d->level, buf);
                    }
                    (void) new_directory_record(entry, &stbuf, d);
                }
            }
        }
        closedir(dirp);
    }
    else
    {
        error_exit("Cannot open '%s'\n", source);
        return;
    }
#endif
    // sort directory
    d->first_record = sort_linked_list(d->first_record, 0, compare_directory_order);
}
########################rank 3#############################
char *
filename_combine(const char *dirname, const char *filename)
{
	char *result;
	unsigned dirname_length;
	unsigned filename_length;
	unsigned dirname_offset = 0;
	unsigned result_offset = 0;
	unsigned result_max;
	static const struct Keyword slash = {"/", 1};
	struct Keyword prefix;
	unsigned prefix_length;
	filename_length = (unsigned)strlen(filename);
	if (dirname == NULL || dirname[0] == '\0') {
		result = (char*)malloc(filename_length+1);
        if (result == NULL)
            exit(1);
		memcpy(result, filename, filename_length+1);
		return result;
	}
	dirname_length = (unsigned)strlen(dirname);
	while (filename_length && (filename[0] == '/' || filename[0] == '\\')) {
		filename_length--;
		filename++;
	}
	while (dirname_length && (dirname[dirname_length-1] == '/' || filename[0] == '\\'))
		dirname_length--;
	result_max = dirname_length + filename_length + 2;
	result = (char*)malloc(result_max + 1);
    if (result == NULL)
        exit(1);
	 * Get the prefix, which is something like "C:\" on Windows,
	 * or "\\" or "//" also on Windows, or "/" on Unix 
	 */
	prefix = keyword_get_file_prefix(dirname, &dirname_offset, dirname_length);
	keyword_append(result, &result_offset, result_max, prefix);
	if (result_offset && result[result_offset - 1] != '/' && result[result_offset - 1] != '\\')
		keyword_append(result, &result_offset, result_max, slash);
	prefix_length = result_offset;
	combine_elements(result, &result_offset, result_max, prefix_length, dirname, dirname_offset, dirname_length);
	combine_elements(result, &result_offset, result_max, prefix_length, filename, 0, filename_length);
	return result;
}
########################rank 4#############################
static int
regression_load_zonefile(struct Grind *grind, const char *directory_name)
{
    void *directory;
	directory = pixie_opendir(directory_name);
	if (directory == NULL)
        return Failure; 
    for (;;) {
        const char *filename;
        char *tmp;
        filename = pixie_readdir(directory);
        if (filename == 0)
            break;
        if (!ends_with(filename, ".zone"))
            continue;
        tmp = filename_combine(directory_name, filename);
        if (grind_load_zonefile(grind, tmp, ROOT, 0) == 0) {
            free(tmp);
            fprintf(stdout, "%s:fail: error reading zonefile file\n", filename);
            return Failure;
        }
        free(tmp);
    }
    pixie_closedir(directory);
    return Success; /* success so far */
}
########################rank 5#############################
void inlib(const char *file)
{
	const char *p, *cp;
	if ((p = getenv("LIBPATH")) == NULL)
		p = "/lib:/usr/lib";
	cp = path(p, file, R_OK);
	input(cp ? cp : file);
}
########################rank 6#############################
static int bftw_file_open(struct bftw_cache *cache, struct bftw_file *file, const char *path) {
	int at_fd = AT_FDCWD;
	const char *at_path = path;
	struct bftw_file *base = bftw_file_base(file, &at_fd, &at_path);
	int fd = bftw_file_openat(cache, file, base, at_fd, at_path);
	if (fd >= 0 || errno != ENAMETOOLONG) {
		return fd;
	}
	// Handle ENAMETOOLONG by manually traversing the path component-by-component
	// -1 to include the root, which has depth == 0
	size_t offset = base ? base->depth : -1;
	size_t levels = file->depth - offset;
	if (levels < 2) {
		return fd;
	}
	struct bftw_file **parents = malloc(levels * sizeof(*parents));
	if (!parents) {
		return fd;
	}
	struct bftw_file *parent = file;
	for (size_t i = levels; i-- > 0;) {
		parents[i] = parent;
		parent = parent->parent;
	}
	for (size_t i = 0; i < levels; ++i) {
		fd = bftw_file_openat(cache, parents[i], base, at_fd, parents[i]->name);
		if (fd < 0) {
			break;
		}
		base = parents[i];
		at_fd = fd;
	}
	free(parents);
	return fd;
}
########################rank 7#############################
char * file_basename(char * file) {
	char * c = strrchr(file, '/');
	if (!c) return file;
	return (c+1);
}
########################rank 8#############################
int find_ref(file, name) char *file, *name;
   returns appropriate return value. */
{   file_t *tfile = the_files;
    link_t *link;    
    DEBUG_P2("find_ref(%s, %s)\n", file, name);
    if (is_URL(file)/* || !is_html(file)*/)
        return REF_OKAY;
    while (tfile != NULL && strcmp(tfile->name, file) < 0)
        tfile = tfile->next;
    if (tfile == NULL || strcmp(tfile->name, file))
        return REF_FILE_NOT_FOUND;
    if (!tfile->exists)
        return REF_FILE_NOT_FOUND;
    if (tfile->ignore)
        return REF_FILE_IGNORED;
    if (!(tfile->read & R_INCLUDED))
        return REF_FILE_NOT_INC;
    if (name[0] == '\0')
        return REF_OKAY;
    if (!is_html(file))
        return name[0] == '\0' ? REF_NAME_NOT_FOUND : REF_OKAY;
    for (link = tfile->link; link != NULL; link = link->next)
        if (link->kind == A_NAME && streq(link->info.name.name, name))
            return   link->info.name.exists
                   ? (link->copied ? REF_OKAY : REF_NAME_NOT_INC)
                   : REF_NAME_NOT_FOUND;
    return REF_NAME_NOT_FOUND;
}
########################rank 9#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 10#############################
int
gtwvec(file, dir, wkpre, wrkvec)
char *dir, *wkpre, **wrkvec;
register char *file;
{
	register int nargs, n;
	n = 0;
	while ((nargs = anlwrk(file, wrkvec)) == 0) {
		if (++n > 3 || !iswrk(file, "get", dir, wkpre))
			return 0;
	}
	return nargs;
}
----------------------------QUERY-------------------------------
compress block of raw data
########################rank 1#############################
static
int fx_compress_block(const FX_STATE state, const u8* ibuf,
                      const uint32_t ilen){
    static u8* obuf;
    static size_t obuf_len;
    unsigned int compressed_len;
    int rc;
    if(ilen<=4){
        rc = fx_write_block(state, KIND_UNCOMPRESSED, ilen, ibuf);
        return rc<0 ? -1 : 0;
    }
    rc = mem_resize(&obuf, &obuf_len, ilen);
    if(rc<0) return -1;
    compressed_len = ilen - 4; 
    rc = lzfx_compress(ibuf, ilen, obuf+4, &compressed_len);
    if(rc<0 && rc != LZFX_ESIZE){
        fprintf(stderr, "Compression error (code %d)\n", rc);
        return -1;
    }
    if(rc == LZFX_ESIZE || !compressed_len){
        rc = fx_write_block(state, KIND_UNCOMPRESSED, ilen, ibuf);
        if(rc<0) return -1;
    } else {
        obuf[0] = ilen >> 24;
        obuf[1] = ilen >> 16;
        obuf[2] = ilen >> 8;
        obuf[3] = ilen;
        rc = fx_write_block(state, KIND_COMPRESSED, compressed_len+4, obuf);
        if(rc<0) return -1;
    }
    return 0;
}
########################rank 2#############################
static size_t LZ5F_getBlockSize(unsigned blockSizeID)
{
    static const size_t blockSizes[7] = { 64 KB, 256 KB, 1 MB, 4 MB, 16 MB, 64 MB, 256 MB };
    if (blockSizeID == 0) blockSizeID = LZ5F_BLOCKSIZEID_DEFAULT;
    blockSizeID -= 1;
    if (blockSizeID >= 7) return (size_t)-LZ5F_ERROR_maxBlockSize_invalid;
  //  printf("LZ5F_getBlockSize %d %d\n", blockSizeID+1, (int)blockSizes[blockSizeID]);
    return blockSizes[blockSizeID];
}
########################rank 3#############################
static size_t LZ4F_getBlockSize(unsigned blockSizeID)
{
    static const size_t blockSizes[4] = { 64 KB, 256 KB, 1 MB, 4 MB };
    if (blockSizeID == 0) blockSizeID = LZ4F_BLOCKSIZEID_DEFAULT;
    blockSizeID -= 4;
    if (blockSizeID > 3) return (size_t)-LZ4F_ERROR_maxBlockSize_invalid;
    return blockSizes[blockSizeID];
}
########################rank 4#############################
static size_t LZ4F_getBlockSize(unsigned blockSizeID)
{
    static const size_t blockSizes[4] = { 64 KB, 256 KB, 1 MB, 4 MB };
    if (blockSizeID == 0) blockSizeID = LZ4F_BLOCKSIZEID_DEFAULT;
    blockSizeID -= 4;
    if (blockSizeID > 3) return (size_t)-ERROR_maxBlockSize_invalid;
    return blockSizes[blockSizeID];
}
########################rank 5#############################
size_t LZ4F_compressFrameBound(size_t srcSize, const LZ4F_preferences_t* preferencesPtr)
{
    LZ4F_preferences_t prefs = { 0 };
    size_t headerSize;
    size_t streamSize;
    if (preferencesPtr!=NULL) prefs = *preferencesPtr;
    {
        blockSizeID_t proposedBSID = max64KB;
        size_t maxBlockSize = 64 KB;
        while (prefs.frameInfo.blockSizeID > proposedBSID)
        {
            if (srcSize <= maxBlockSize)
            {
                prefs.frameInfo.blockSizeID = proposedBSID;
                break;
            }
            proposedBSID++;
            maxBlockSize <<= 2;
        }
    }
    prefs.autoFlush = 1;
    headerSize = 7;      
    streamSize = LZ4F_compressBound(srcSize, &prefs);
    return headerSize + streamSize;
}
########################rank 6#############################
size_t LZ5F_compressEnd(LZ5F_compressionContext_t compressionContext, void* dstBuffer, size_t dstMaxSize, const LZ5F_compressOptions_t* compressOptionsPtr)
{
    LZ5F_cctx_t* cctxPtr = (LZ5F_cctx_t*)compressionContext;
    BYTE* const dstStart = (BYTE*)dstBuffer;
    BYTE* dstPtr = dstStart;
    size_t errorCode;
    errorCode = LZ5F_flush(compressionContext, dstBuffer, dstMaxSize, compressOptionsPtr);
    if (LZ5F_isError(errorCode)) return errorCode;
    dstPtr += errorCode;
    LZ5F_writeLE32(dstPtr, 0);
    dstPtr+=4;   /* endMark */
    if (cctxPtr->prefs.frameInfo.contentChecksumFlag == LZ5F_contentChecksumEnabled)
    {
        U32 xxh = XXH32_digest(&(cctxPtr->xxh));
        LZ5F_writeLE32(dstPtr, xxh);
        dstPtr+=4;   /* content Checksum */
    }
    cctxPtr->cStage = 0;   /* state is now re-usable (with identical preferences) */
    if (cctxPtr->prefs.frameInfo.contentSize)
    {
        if (cctxPtr->prefs.frameInfo.contentSize != cctxPtr->totalInSize)
            return (size_t)-LZ5F_ERROR_frameSize_wrong;
    }
    return dstPtr - dstStart;
}
########################rank 7#############################
size_t ZBUFF_compressFlush(ZBUFF_CCtx* zbc, void* dst, size_t* maxDstSizePtr)
{
    size_t srcSize = 0;
    ZBUFF_compressContinue_generic(zbc, dst, maxDstSizePtr, &srcSize, &srcSize, 1);  
    return zbc->outBuffContentSize - zbc->outBuffFlushedSize;
}
########################rank 8#############################
static size_t LZ4F_decodeHeader(LZ4F_dctx_internal_t* dctxPtr, const BYTE* srcPtr, size_t srcSize)
{
    BYTE FLG, BD, HC;
    unsigned version, blockMode, blockChecksumFlag, contentSizeFlag, contentChecksumFlag, dictFlag, blockSizeID;
    size_t bufferNeeded;
    if (srcSize < 7) return (size_t)-ERROR_GENERIC;   /* minimal header size */
    if (LZ4F_readLE32(srcPtr) != LZ4F_MAGICNUMBER) return (size_t)-ERROR_GENERIC;
    srcPtr += 4;
    FLG = srcPtr[0];
    version = (FLG>>6)&_2BITS;
    blockMode = (FLG>>5) & _1BIT;
    blockChecksumFlag = (FLG>>4) & _1BIT;
    contentSizeFlag = (FLG>>3) & _1BIT;
    contentChecksumFlag = (FLG>>2) & _1BIT;
    dictFlag = (FLG>>0) & _1BIT;
    BD = srcPtr[1];
    blockSizeID = (BD>>4) & _3BITS;
    HC = LZ4F_headerChecksum(srcPtr, 2);
    if (HC != srcPtr[2]) return (size_t)-ERROR_GENERIC;   /* Bad header checksum error */
    if (version != 1) return (size_t)-ERROR_GENERIC;   /* Version Number, only supported value */
    if (blockChecksumFlag != 0) return (size_t)-ERROR_GENERIC;   /* Only supported value for the time being */
    if (contentSizeFlag != 0) return (size_t)-ERROR_GENERIC;   /* Only supported value for the time being */
    if (((FLG>>1)&_1BIT) != 0) return (size_t)-ERROR_GENERIC;   /* Reserved bit */
    if (dictFlag != 0) return (size_t)-ERROR_GENERIC;   /* Only supported value for the time being */
    if (((BD>>7)&_1BIT) != 0) return (size_t)-ERROR_GENERIC;   /* Reserved bit */
    if (blockSizeID < 4) return (size_t)-ERROR_GENERIC;   /* Only supported values for the time being */
    if (((BD>>0)&_4BITS) != 0) return (size_t)-ERROR_GENERIC;   /* Reserved bits */
    dctxPtr->frameInfo.blockMode = blockMode;
    dctxPtr->frameInfo.contentChecksumFlag = contentChecksumFlag;
    dctxPtr->frameInfo.blockSizeID = blockSizeID;
    dctxPtr->maxBlockSize = LZ4F_getBlockSize(blockSizeID);
    if (contentChecksumFlag) XXH32_reset(&(dctxPtr->xxh), 0);
    bufferNeeded = dctxPtr->maxBlockSize + ((dctxPtr->frameInfo.blockMode==blockLinked) * 128 KB);
    if (bufferNeeded > dctxPtr->maxBufferSize)   /* tmp buffers too small */
    {
        FREEMEM(dctxPtr->tmpIn);
        FREEMEM(dctxPtr->tmpOutBuffer);
        dctxPtr->maxBufferSize = bufferNeeded;
        dctxPtr->tmpIn = ALLOCATOR(dctxPtr->maxBlockSize);
        if (dctxPtr->tmpIn == NULL) return (size_t)-ERROR_GENERIC;
        dctxPtr->tmpOutBuffer= ALLOCATOR(dctxPtr->maxBufferSize);
        if (dctxPtr->tmpOutBuffer== NULL) return (size_t)-ERROR_GENERIC;
    }
    dctxPtr->tmpInSize = 0;
    dctxPtr->tmpInTarget = 0;
    dctxPtr->dict = dctxPtr->tmpOutBuffer;
    dctxPtr->dictSize = 0;
    dctxPtr->tmpOut = dctxPtr->tmpOutBuffer;
    dctxPtr->tmpOutStart = 0;
    dctxPtr->tmpOutSize = 0;
    return 7;
}
########################rank 9#############################
local int gz_comp(state, flush)
    gz_statep state;
    int flush;
{
    int ret, got;
    unsigned have;
    z_streamp strm = &(state->strm);
    if (state->size == 0 && gz_init(state) == -1)
        return -1;
    if (state->direct) {
        got = write(state->fd, strm->next_in, strm->avail_in);
        if (got < 0 || (unsigned)got != strm->avail_in) {
            gz_error(state, Z_ERRNO, zstrerror());
            return -1;
        }
        strm->avail_in = 0;
        return 0;
    }
    ret = Z_OK;
    do {
           doing Z_FINISH then don't write until we get to Z_STREAM_END */
        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
            (flush != Z_FINISH || ret == Z_STREAM_END))) {
            have = (unsigned)(strm->next_out - state->x.next);
            if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
                         (unsigned)got != have)) {
                gz_error(state, Z_ERRNO, zstrerror());
                return -1;
            }
            if (strm->avail_out == 0) {
                strm->avail_out = state->size;
                strm->next_out = state->out;
            }
            state->x.next = strm->next_out;
        }
        have = strm->avail_out;
        ret = deflate(strm, flush);
        if (ret == Z_STREAM_ERROR) {
            gz_error(state, Z_STREAM_ERROR,
                      "internal error: deflate stream corrupt");
            return -1;
        }
        have -= strm->avail_out;
    } while (have);
    if (flush == Z_FINISH)
        deflateReset(strm);
    return 0;
}
########################rank 10#############################
void BZ2_compressBlock(EState *s, Bool is_last_block) {
    if (s->nblock > 0) {
        BZ_FINALISE_CRC (s->blockCRC);
        s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);
        s->combinedCRC ^= s->blockCRC;
        if (s->blockNo > 1) s->numZ = 0;
        if (s->verbosity >= 2)
            VPrintf4("    block %d: crc = 0x%08x, "
                             "combined CRC = 0x%08x, size = %d\n",
                     s->blockNo, s->blockCRC, s->combinedCRC, s->nblock);
        BZ2_blockSort(s);
    }
    s->zbits = (UChar *) (&((UChar *) s->arr2)[s->nblock]);
    if (s->blockNo == 1) {
        BZ2_bsInitWrite(s);
        bsPutUChar(s, BZ_HDR_B);
        bsPutUChar(s, BZ_HDR_Z);
        bsPutUChar(s, BZ_HDR_h);
        bsPutUChar(s, (UChar) (BZ_HDR_0 + s->blockSize100k));
    }
    if (s->nblock > 0) {
        bsPutUChar(s, 0x31);
        bsPutUChar(s, 0x41);
        bsPutUChar(s, 0x59);
        bsPutUChar(s, 0x26);
        bsPutUChar(s, 0x53);
        bsPutUChar(s, 0x59);
        bsPutUInt32(s, s->blockCRC);
           Now a single bit indicating (non-)randomisation.
           As of version 0.9.5, we use a better sorting algorithm
           which makes randomisation unnecessary.  So always set
           the randomised bit to 'no'.  Of course, the decoder
           still needs to be able to handle randomised blocks
           so as to maintain backwards compatibility with
           older versions of bzip2.
        --*/
        bsW(s, 1, 0);
        bsW(s, 24, s->origPtr);
        generateMTFValues(s);
        sendMTFValues(s);
    }
    if (is_last_block) {
        bsPutUChar(s, 0x17);
        bsPutUChar(s, 0x72);
        bsPutUChar(s, 0x45);
        bsPutUChar(s, 0x38);
        bsPutUChar(s, 0x50);
        bsPutUChar(s, 0x90);
        bsPutUInt32(s, s->combinedCRC);
        if (s->verbosity >= 2)
            VPrintf1("    final combined CRC = 0x%08x\n   ", s->combinedCRC);
        bsFinishWrite(s);
    }
}
----------------------------QUERY-------------------------------
allocate and clean buffer
########################rank 1#############################
static void * SyOSHeapAlloc(sxu32 nByte)
{
	void *pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(), 0, nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
########################rank 2#############################
static void * SyOSHeapAlloc(sxu32 nByte)
{
	void *pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(),0,nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
########################rank 3#############################
static void * SyOSHeapAlloc(sxu32 nByte)
{
	void *pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(), 0, nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
########################rank 4#############################
static void * SyOSHeapAlloc(sxu32 nByte)
{
	void *pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(), 0, nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
########################rank 5#############################
static void * SyOSHeapAlloc(sxu32 nByte)
{
	void *pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(), 0, nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
########################rank 6#############################
static void * SyOSHeapAlloc(sxu32 nByte)
{
	void *pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(), 0, nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
########################rank 7#############################
void dynamic_buffer_overrun_030()
{
	int i,j;
	char ** doubleptr=(char**) malloc(10*sizeof(char*));
	for(i=0;i<10;i++)
	{
		doubleptr[i]=(char*) malloc(10*sizeof(char));
	}
	for(i=0;i<10;i++)
	{
		for(j=0;j<=10;j++)
		{
		  doubleptr[i][j]='a';    	/*Tool should detect this line as error*/ /*ERROR:Buffer overrun*/
		}
		free(doubleptr[i]);
	}	
	free(doubleptr);
}
########################rank 8#############################
void *Z_Malloc( int size ) {
	void *buf = malloc( size );
	Com_Memset( buf, 0, size );
	return buf;
}
########################rank 9#############################
char *malloc_payload_buffer(int msg_sz)
{
	char * msg_buf = malloc(msg_sz);
	if (!msg_buf) {
		fprintf(stderr, "ERROR: %s() failed in malloc() (caller: 0x%p)\n",
			__func__, __builtin_return_address(0));
		exit(EXIT_FAIL_MEM);
	}
	memset(msg_buf, 0, msg_sz);
	if (verbose)
		fprintf(stderr, " - malloc(msg_buf) = %d bytes\n", msg_sz);
	return msg_buf;
}
########################rank 10#############################
int alloc_vsprintf(char **strp, const char *fmt, va_list va) {
  va_list va_tmp;
  char *s;
  int size = 32;
  int n;
  s = NULL;
  size = 32;
  for (;;) {
    s = (char *)safe_realloc(s, size);
#ifdef WIN32
    va_tmp = va;
#else
    va_copy(va_tmp, va);
#endif
    n = vsnprintf(s, size, fmt, va_tmp);
    va_end(va_tmp);
    if (n >= size)
      size = n + 1;
    else if (n < 0)
      size = size * 2;
    else
      break;
  }
  *strp = s;
  return n;
}
----------------------------QUERY-------------------------------
receive N byte from socket
########################rank 1#############################
int sock_recv(socket_t *sock, socket_t *from, char *data, int len)
{
    int bytes_recv = 0;
    socket_t tmp;
    switch(sock->type)
    {
        case SOCK_STREAM:
            bytes_recv = recv(sock->fd, data, len, 0);
            break;
        case SOCK_DGRAM:
            if(!from)
                from = &tmp; /* In case caller wants to ignore from socket */
            from->fd = sock->fd;
            from->addr_len = sock->addr_len;
            bytes_recv = recvfrom(from->fd, data, len, 0,
                                  SOCK_ADDR(from), &from->addr_len);
            break;
    }
    PERROR_GOTO(bytes_recv < 0, "recv", error);
    ERROR_GOTO(bytes_recv == 0, "disconnect", disconnect);
    if(debug_level >= DEBUG_LEVEL3)
    {
        printf("sock_recv: type=%d, fd=%d, bytes=%d\n",
               sock->type, sock->fd, bytes_recv);
        print_hexdump(data, bytes_recv);
    }
    return bytes_recv;
  disconnect:
    return 0;
  error:
    return -1;
}
########################rank 2#############################
int tcp_receive_buffer(int newSocket, char *return_buffer)
{
	static int bytes_received = 0;
	static char message_received[MAX_MSG_LEN];
	static int count = 0;
	int offset;
	offset = 0;
	while (1) {
		if (bytes_received == 0) {
			memset(message_received, 0x0, MAX_MSG_LEN);	/* init buffer */
			count =
			    recvfrom(newSocket, message_received, MAX_MSG_LEN,
				     0, (struct sockaddr *)&tcpClientAddr,
				     &tcpClientLen);
			if (count < 0) {
				perror(" cannot receive data ");
				return ERROR;
			} else if (count == 0) {
				printf(" connection closed by client\n");
				close(newSocket);
				if (count) {
				}
				return ERROR;
			}
		}
		while (*(message_received + bytes_received) != END_LINE
		       && bytes_received < count) {
			memcpy(return_buffer + offset,
			       message_received + bytes_received, 1);
			offset++;
			bytes_received++;
		}
		if (bytes_received == count - 1) {
			*(return_buffer + offset) = END_LINE;
			bytes_received = 0;
			return ++offset;
		}
		if (bytes_received < count - 1) {
			*(return_buffer + offset) = END_LINE;
			bytes_received++;
			return ++offset;
		}
		if (bytes_received == count) {
			bytes_received = 0;
			return offset;
		}
	}			/* while */
}
########################rank 3#############################
int tcp_recv(int sock, const char *arg)
{
	int count = -1; // stop at first read
	int ret;
	int max;
	if (arg[1]) {
		count = atoi(arg + 1);
		if (count < 0) {
			fprintf(stderr, "recv count must be >= 0 or unset (was %d)\n", count);
			return -2;
		}
	}
	while (1) {
		max = (count > 0) ? count : INT_MAX;
		if (max > sizeof(trash))
			max = sizeof(trash);
		ret = recv(sock, trash, max, MSG_NOSIGNAL | MSG_TRUNC);
		if (ret < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				dolog("recv %d\n", ret);
				return -1;
			}
			while (!wait_on_fd(sock, POLLIN));
			continue;
		}
		dolog("recv %d\n", ret);
		if (!ret)
			break;
		if (!count)
			continue;
		else if (count > 0)
			count -= ret;
		if (count <= 0)
			break;
	}
	return 0;
}
########################rank 4#############################
signed int getshell_conn(char *hostname,unsigned short port){
 signed int sock=0;
 struct hostent *he;
 struct sockaddr_in sa;
 if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
  printe("getshell_conn(): socket() failed.",1);
 sa.sin_family=AF_INET;
 if((sa.sin_addr.s_addr=inet_addr(hostname))){
  if(!(he=gethostbyname(hostname)))
   printe("getshell_conn(): couldn't resolve.",1);
  memcpy((char *)&sa.sin_addr,(char *)he->h_addr,
  sizeof(sa.sin_addr));
 }
 sa.sin_port=htons(port);
 signal(SIGALRM,sig_alarm);
 printf("[*] attempting to connect: %s:%d.\n",hostname,port);
 alarm(TIMEOUT);
 if(connect(sock,(struct sockaddr *)&sa,sizeof(sa))){
  printf("[!] connection failed: %s:%d.\n",hostname,port);
  exit(1);
 }
 alarm(0);
 printf("[*] successfully connected: %s:%d.\n\n",hostname,port);
 return(sock);
}
########################rank 5#############################
static int run_syscall_accept(struct state *state,
			      int script_accepted_fd,
			      int live_accepted_fd,
			      struct sockaddr *live_addr,
			      int live_addrlen, char **error)
{
	struct socket *socket = NULL;
	struct fd_state *fd = NULL;
	struct ip_address ip;
	u16 port = 0;
	DEBUGP("run_syscall_accept\n");
	ip_from_sockaddr(live_addr, live_addrlen, &ip, &port);
	if (ip.address_family == AF_INET6) {
		struct ip_address ipv4;
		if (ipv6_map_to_ipv4(ip, &ipv4) == STATUS_OK)
			ip = ipv4;
	}
	for (fd = state->fds; fd != NULL; fd = fd->next) {
		if (fd->ops->type != FD_SOCKET)
			continue;
		socket = fd_to_socket(fd);
		if (DEBUG_LOGGING) {
			char remote_string[ADDR_STR_LEN];
			DEBUGP("socket state=%d script addr: %s:%d\n",
			       socket->state,
			       ip_to_string(&socket->script.remote.ip,
					    remote_string),
			       socket->script.remote.port);
		}
		if ((socket->state == SOCKET_PASSIVE_SYNACK_SENT) ||  /* TFO */
		    (socket->state == SOCKET_PASSIVE_SYNACK_ACKED)) {
			assert(is_equal_ip(&socket->live.remote.ip, &ip));
			assert(is_equal_port(socket->live.remote.port,
					     htons(port)));
			socket->fd.script_fd	= script_accepted_fd;
			socket->fd.live_fd	= live_accepted_fd;
			return STATUS_OK;
		}
	}
	if (!state->config->is_wire_client) {
		asprintf(error, "unable to find socket matching accept() call");
		return STATUS_ERR;
	}
	 * sees the system call action for this socket. Create a child
	 * passive socket for this accept call, and fill in what we
	 * know about the socket. Any further packets in the test
	 * script will be directed to this child socket.
	 */
	socket = socket_new(state);
	state->socket_under_test = socket;
	assert(socket->state == SOCKET_INIT);
	socket->address_family		= ip.address_family;
	socket->live.remote.ip		= ip;
	socket->live.remote.port	= port;
	socket->live.local.ip		= state->config->live_local_ip;
	socket->live.local.port		= htons(state->config->live_bind_port);
	socket->fd.live_fd		= live_accepted_fd;
	socket->fd.script_fd		= script_accepted_fd;
	if (DEBUG_LOGGING) {
		char local_string[ADDR_STR_LEN];
		char remote_string[ADDR_STR_LEN];
		DEBUGP("live: local: %s.%d\n",
		       ip_to_string(&socket->live.local.ip, local_string),
		       ntohs(socket->live.local.port));
		DEBUGP("live: remote: %s.%d\n",
		       ip_to_string(&socket->live.remote.ip, remote_string),
		       ntohs(socket->live.remote.port));
	}
	return STATUS_OK;
}
########################rank 6#############################
static bool NET_SocketMakeNonBlocking( socket_handle_t handle ) {
	ioctl_param_t _true = 1;
	if( Sys_NET_SocketIoctl( handle, FIONBIO, &_true ) == SOCKET_ERROR ) {
		NET_SetErrorStringFromLastError( "Sys_NET_SocketIoctl" );
		return false;
	}
	return true;
}
########################rank 7#############################
int tcpHandshake(struct handover *ho) {
	int packetLen;
	if(ho->ipV == 4)
		packetLen = packetLen4;
	else
		packetLen = packetLen6;
       	ph.usec += INTERVAL;	
       	ph.length1 = packetLen;
       	ph.length2 = packetLen;
	ho->seq=rand() & 0xfff;
	ho->seq+=1;
	ho->ack_seq=0;
	//client to server SYN
	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	//replace that with a sprintf and a single write
	write(fileno(outFile), ho->toEther, sizeof(ho->toEther)-1);
       	craftTcp(NULL, 0, TO_SERVER, TH_SYN, ho);  //direction 0 - client to server
	ho->ack_seq=rand() & 0xfff;
	ho->ack_seq+=1;
	ho->seq+=1;
	//and now send the SYN/ACK
	ph.usec+=INTERVAL;
       	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	write(fileno(outFile), ho->fromEther, sizeof(ho->fromEther)-1);
	craftTcp(NULL,0, FROM_SERVER, TH_SYN|TH_ACK, ho);	//direction 1 - server to client
	ho->ack_seq+=1;
	//client to server ACK
       	ph.usec += INTERVAL;	
	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	write(fileno(outFile), ho->toEther, sizeof(ho->toEther)-1);
       	craftTcp(NULL, 0, TO_SERVER, TH_ACK, ho);  //direction 0 - client to server
	ho->time = ph.time;
	ho->usec = ph.usec;
return 0;
}
########################rank 8#############################
int make_socket_non_blocking(int fd) {
    int flags, s;
    flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
        log_err("fcntl");
        return -1;
    }
    flags |= O_NONBLOCK;
    s = fcntl(fd, F_SETFL, flags);
    if (s == -1) {
        log_err("fcntl");
        return -1;
    }
    return 0;
}
########################rank 9#############################
static void
tcpcon_send_packet(
    struct TCP_ConnectionTable *tcpcon,
    struct TCP_Control_Block *tcb,
    unsigned tcp_flags,
    const unsigned char *payload, size_t payload_length,
    unsigned ctrl)
{
    struct PacketBuffer *response = 0;
    int err = 0;
    uint64_t wait = 100;
    for (err=1; err; ) {
        err = rte_ring_sc_dequeue(tcpcon->packet_buffers, (void**)&response);
        if (err != 0) {
            static int is_warning_printed = 0;
            if (!is_warning_printed) {
                LOG(0, "packet buffers empty (should be impossible)\n");
                is_warning_printed = 1;
            }
            fflush(stdout);
            pixie_usleep(wait = (uint64_t)(wait *1.5)); /* no packet available */
        }
        //if (wait != 100)
        //    ; //printf("\n");FIXME
    }
    if (response == NULL)
        return;
     * four types of packets:
     * 1. a SYN-ACK packet with no payload
     * 2. an ACK packet with no payload
     * 3. a RST packet with no pacyload
     * 4. a PSH-ACK packet WITH PAYLOAD
     */
    response->length = tcp_create_packet(
        tcpcon->pkt_template,
        tcb->ip_them, tcb->port_them,
        tcb->ip_me, tcb->port_me,
        tcb->seqno_me, tcb->seqno_them,
        tcp_flags,
        payload, payload_length,
        response->px, sizeof(response->px)
        );
     * KLUDGE:
     */
    if (ctrl & CTRL_SMALL_WINDOW) {
        tcp_set_window(response->px, response->length, 600);
    }
    //tcp_set_window(response->px, response->length, 600);
     * 1. remember the payload so we can resend it
     */
    tcb->payload = payload;
    tcb->payload_length = (unsigned short)payload_length;
     * from a transmit-thread only, and this function is being called
     * from a receive-thread. Therefore, instead of transmiting ourselves,
     * we hae to queue it up for later transmission. */
    for (err=1; err; ) {
        err = rte_ring_sp_enqueue(tcpcon->transmit_queue, response);
        if (err != 0) {
            LOG(0, "transmit queue full (should be impossible)\n");
            pixie_usleep(100); /* no space available */
        }
    }
}
########################rank 10#############################
static void
tcpcon_send_packet(
    struct TCP_ConnectionTable *tcpcon,
    struct TCP_Control_Block *tcb,
    unsigned tcp_flags,
    const unsigned char *payload, size_t payload_length,
    unsigned ctrl)
{
    struct PacketBuffer *response = 0;
    int err = 0;
    uint64_t wait = 100;
    for (err=1; err; ) {
        err = rte_ring_sc_dequeue(tcpcon->packet_buffers, (void**)&response);
        if (err != 0) {
            static int is_warning_printed = 0;
            if (!is_warning_printed) {
                LOG(0, "packet buffers empty (should be impossible)\n");
                is_warning_printed = 1;
            }
            fflush(stdout);
            pixie_usleep(wait = (uint64_t)(wait *1.5)); /* no packet available */
        }
        //if (wait != 100)
        //    ; //printf("\n");FIXME
    }
    if (response == NULL)
        return;
     * four types of packets:
     * 1. a SYN-ACK packet with no payload
     * 2. an ACK packet with no payload
     * 3. a RST packet with no pacyload
     * 4. a PSH-ACK packet WITH PAYLOAD
     */
    response->length = tcp_create_packet(
        tcpcon->pkt_template,
        tcb->ip_them, tcb->port_them,
        tcb->ip_me, tcb->port_me,
        tcb->seqno_me, tcb->seqno_them,
        tcp_flags,
        payload, payload_length,
        response->px, sizeof(response->px)
        );
     * KLUDGE:
     */
    if (ctrl & CTRL_SMALL_WINDOW) {
        tcp_set_window(response->px, response->length, 600);
    }
    //tcp_set_window(response->px, response->length, 600);
     * 1. remember the payload so we can resend it
     */
    tcb->payload = payload;
    tcb->payload_length = (unsigned short)payload_length;
     * from a transmit-thread only, and this function is being called
     * from a receive-thread. Therefore, instead of transmiting ourselves,
     * we hae to queue it up for later transmission. */
    for (err=1; err; ) {
        err = rte_ring_sp_enqueue(tcpcon->transmit_queue, response);
        if (err != 0) {
            LOG(0, "transmit queue full (should be impossible)\n");
            pixie_usleep(100); /* no space available */
        }
    }
}
----------------------------QUERY-------------------------------
lookup key in a hash map
########################rank 1#############################
int Jim_ReplaceHashEntry(Jim_HashTable *ht, const void *key, void *val)
{
    Jim_HashEntry *entry;
     * does not exists Jim_AddHashEntry will suceed. */
    if (Jim_AddHashEntry(ht, key, val) == JIM_OK)
        return JIM_OK;
    entry = Jim_FindHashEntry(ht, key);
    Jim_FreeEntryVal(ht, entry);
    Jim_SetHashVal(ht, entry, val);
    return JIM_OK;
}
########################rank 2#############################
uint32_t htHash(unsigned char *s, size_t len) {
    uint32_t hash = 5381;
    for (size_t i = 0; i < len; i++)
	hash = hash * 33 + s[i];
    return hash % HT_TABLE_SIZE;
}
########################rank 3#############################
static unsigned dictionary_hash(char *key)
{
	int len;
	unsigned hash;
	int i;
	len = strlen(key);
	for(hash = 0, i = 0; i < len; i++) {
		hash += (unsigned)key[i];
		hash += (hash << 10);
		hash ^= (hash >> 6);
	}
	hash += (hash << 3);
	hash ^= (hash >> 11);
	hash += (hash << 15);
	return hash;
}
########################rank 4#############################
unsigned dictionary_hash(char * key)
{
	int			len ;
	unsigned	hash ;
	int			i ;
	len = strlen(key);
	for (hash=0, i=0 ; i<len ; i++) {
		hash += (unsigned)key[i] ;
		hash += (hash<<10);
		hash ^= (hash>>6) ;
	}
	hash += (hash <<3);
	hash ^= (hash >>11);
	hash += (hash <<15);
	return hash ;
}
########################rank 5#############################
unsigned dictionary_hash(const char * key)
{
    int         len ;
    unsigned    hash ;
    int         i ;
    len = strlen(key);
    for (hash=0, i=0 ; i<len ; i++) {
        hash += (unsigned)key[i] ;
        hash += (hash<<10);
        hash ^= (hash>>6) ;
    }
    hash += (hash <<3);
    hash ^= (hash >>11);
    hash += (hash <<15);
    return hash ;
}
########################rank 6#############################
unsigned dictionary_hash(const char * key)
{
    int         len ;
    unsigned    hash ;
    int         i ;
    len = strlen(key);
    for (hash=0, i=0 ; i<len ; i++) {
        hash += (unsigned)key[i] ;
        hash += (hash<<10);
        hash ^= (hash>>6) ;
    }
    hash += (hash <<3);
    hash ^= (hash >>11);
    hash += (hash <<15);
    return hash ;
}
########################rank 7#############################
unsigned dictionary_hash(const char * key)
{
    size_t      len ;
    unsigned    hash ;
    size_t      i ;
    if (!key)
        return 0 ;
    len = strlen(key);
    for (hash=0, i=0 ; i<len ; i++) {
        hash += (unsigned)key[i] ;
        hash += (hash<<10);
        hash ^= (hash>>6) ;
    }
    hash += (hash <<3);
    hash ^= (hash >>11);
    hash += (hash <<15);
    return hash ;
}
########################rank 8#############################
int hash(char *name)
{
	register int hashval;
	for (hashval = 0; *name;)
		hashval += *name++;
	return(hashval % HASHSIZE);
}
########################rank 9#############################
static int binHash(const void *pKey, int nKey){
  int h = 0;
  const char *z = (const char *)pKey;
  while( nKey-- > 0 ){
    h = (h<<3) ^ h ^ *(z++);
  }
  return h & 0x7fffffff;
}
########################rank 10#############################
int Jim_DeleteHashEntry(Jim_HashTable *ht, const void *key)
{
    unsigned int h;
    Jim_HashEntry *he, *prevHe;
    if (ht->size == 0)
        return JIM_ERR;
    h = Jim_HashKey(ht, key) & ht->sizemask;
    he = ht->table[h];
    prevHe = NULL;
    while (he) {
        if (Jim_CompareHashKeys(ht, key, he->key)) {
            if (prevHe)
                prevHe->next = he->next;
            else
                ht->table[h] = he->next;
            Jim_FreeEntryKey(ht, he);
            Jim_FreeEntryVal(ht, he);
            Jim_Free(he);
            ht->used--;
            return JIM_OK;
        }
        prevHe = he;
        he = he->next;
    }
    return JIM_ERR; /* not found */
}
----------------------------QUERY-------------------------------
fast integral power function
########################rank 1#############################
static int Power2(unsigned int u)
{
	int n;
	if (u > 1 && (u &(u - 1)) == 0)
	{
		for (n = 0; u; u >>= 1, n++)
		{
			if (u & 1)
				return n;
		}
	}
	return 0;
}
########################rank 2#############################
static ogg_uint32_t bitreverse(ogg_uint32_t x){
  x=    ((x>>16)&0x0000ffff) | ((x<<16)&0xffff0000);
  x=    ((x>> 8)&0x00ff00ff) | ((x<< 8)&0xff00ff00);
  x=    ((x>> 4)&0x0f0f0f0f) | ((x<< 4)&0xf0f0f0f0);
  x=    ((x>> 2)&0x33333333) | ((x<< 2)&0xcccccccc);
  return((x>> 1)&0x55555555) | ((x<< 1)&0xaaaaaaaa);
}
########################rank 3#############################
static int64_t power(int64_t base, int64_t exp)
{
    int64_t result = 1;
    while(exp)
    {
        result *= base; exp--;
    }
    return result;
}
########################rank 4#############################
static int64_t power(int64_t base, int64_t exp)
{
    int64_t result = 1;
    while(exp)
    {
        result *= base; exp--;
    }
    return result;
}
########################rank 5#############################
static inline uint32_t ror(uint32_t x, unsigned y)
{
    return (x << (31 & -y)) | (x >> (31 & y));
}
########################rank 6#############################
int mpi_mul_int( mpi *X, const mpi *A, t_sint b )
{
    mpi _B;
    t_uint p[1];
    _B.s = 1;
    _B.n = 1;
    _B.p = p;
    p[0] = b;
    return( mpi_mul_mpi( X, A, &_B ) );
}
########################rank 7#############################
static inline uint32_t rol(uint32_t x, unsigned y)
{
    return (x << (31 & y)) | (x >> (31 & -y));
}
########################rank 8#############################
static uint32_t bitreverse(uint32_t x,int n)
{
    int i;
    uint32_t mask = 1<<(n-1);
    uint32_t res = 0;
    for (i=0; i<n; i++)
    {
        if (x & 1)
            res |=  mask;
        x >>= 1;
        mask >>= 1;
    }
    return res;
}
########################rank 9#############################
long
mp_base_mul(BNS *rop, BNS *op1, BNS *op2, BNI len1, BNI len2)
{
    long i, j;			/* counters */
    BNI value;			/* intermediate result */
    BNS carry;			/* carry value */
    long size = len1 + len2;
    if (op1[0]) {
	value = (BNI)(op1[0]) * op2[0];
	rop[0] = value;
	carry = (BNS)(value >> BNSBITS);
	for (j = 1; j < len2; j++) {
	    value = (BNI)(op1[0]) * op2[j] + carry;
	    rop[j] = value;
	    carry = (BNS)(value >> BNSBITS);
	}
	rop[j] = carry;
    }
    for (i = 1; i < len1; i++) {
	if (op1[i]) {
	    value = (BNI)(op1[i]) * op2[0] + rop[i];
	    rop[i] = value;
	    carry = (BNS)(value >> BNSBITS);
	    for (j = 1; j < len2; j++) {
		value = (BNI)(op1[i]) * op2[j] + rop[i + j] + carry;
		rop[i + j] = value;
		carry = (BNS)(value >> BNSBITS);
	    }
	    rop[i + j] = carry;
	}
    }
    if (size > 1 && rop[size - 1] == 0)
	--size;
    return (size);
}
########################rank 10#############################
void rfact2(long int x, long int *result)
{
  if (x <= 1) 
    *result = 1;
  else {
    long int temp;
    rfact2(x-1,&temp);
    *result = x * temp;
  }
  return;
}
----------------------------QUERY-------------------------------
check if directory is empty
########################rank 1#############################
static bool is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st))
		return 0;
	return S_ISDIR(st.st_mode);
}
########################rank 2#############################
static bool FS_DirentIsDir( const struct dirent64 *d, const char *base ) {
#if ( defined( _DIRENT_HAVE_D_TYPE ) || defined( __ANDROID__ ) ) && defined( DT_DIR )
	return ( d->d_type == DT_DIR );
#else
	size_t pathSize;
	char *path;
	struct stat st;
	pathSize = strlen( base ) + 1 + strlen( d->d_name ) + 1;
	path = alloca( pathSize );
	Q_snprintfz( path, pathSize, "%s/%s", base, d->d_name );
	if( stat( path, &st ) ) {
		return false;
	}
	return S_ISDIR( st.st_mode ) != 0;
#endif
}
########################rank 3#############################
static int shl__is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st) < 0)
		return -errno;
	return S_ISDIR(st.st_mode);
}
########################rank 4#############################
int
TIFFCreateDirectory(TIFF* tif)
{
    TIFFDefaultDirectory(tif);
    tif->tif_diroff = 0;
    tif->tif_nextdiroff = 0;
    tif->tif_curoff = 0;
    tif->tif_row = (uint32) -1;
    tif->tif_curstrip = (tstrip_t) -1;
    return 0;
}
########################rank 5#############################
static dir_scan_ret_t de_hasentry( cpfs_fs_t *fs, struct cpfs_dir_entry *de, void *farg )
{
    (void) fs;
    (void) farg;
    if( de->inode == 0 )    return dir_scan_continue;
    if( 0 == strcmp( (const char*)farg, de->name ) )
        return dir_scan_error;
    return dir_scan_continue;
}
########################rank 6#############################
void FS_Dir_f( void ) {
	char    *path;
	char    *extension;
	char    **dirnames;
	int ndirs;
	int i;
	if ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {
		Com_Printf( "usage: dir <directory> [extension]\n" );
		return;
	}
	if ( Cmd_Argc() == 2 ) {
		path = Cmd_Argv( 1 );
		extension = "";
	} else {
		path = Cmd_Argv( 1 );
		extension = Cmd_Argv( 2 );
	}
	Com_Printf( "Directory of %s %s\n", path, extension );
	Com_Printf( "---------------\n" );
	dirnames = FS_ListFiles( path, extension, &ndirs );
	for ( i = 0; i < ndirs; i++ ) {
		Com_Printf( "%s\n", dirnames[i] );
	}
	FS_FreeFileList( dirnames );
}
########################rank 7#############################
void FS_Dir_f( void ) {
	char    *path;
	char    *extension;
	char    **dirnames;
	int ndirs;
	int i;
	if ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {
		Com_Printf( "usage: dir <directory> [extension]\n" );
		return;
	}
	if ( Cmd_Argc() == 2 ) {
		path = Cmd_Argv( 1 );
		extension = "";
	} else {
		path = Cmd_Argv( 1 );
		extension = Cmd_Argv( 2 );
	}
	Com_Printf( "Directory of %s %s\n", path, extension );
	Com_Printf( "---------------\n" );
	dirnames = FS_ListFiles( path, extension, &ndirs );
	for ( i = 0; i < ndirs; i++ ) {
		Com_Printf( "%s\n", dirnames[i] );
	}
	FS_FreeFileList( dirnames );
}
########################rank 8#############################
static void UnixDir_Rewind(void *pUserData)
{
	rewinddir((DIR *)pUserData);
}
########################rank 9#############################
static void UnixDir_Rewind(void *pUserData)
{
	rewinddir((DIR *)pUserData);
}
########################rank 10#############################
static void UnixDir_Rewind(void *pUserData)
{
	rewinddir((DIR *)pUserData);
}
----------------------------QUERY-------------------------------
create a new tree node
########################rank 1#############################
static Node* create_splaytree_node(Type key, Node *left, Node* right)
{
	Node* p;
	if ((p = (Node *)malloc(sizeof(Node))) == NULL)
		return NULL;
	p->key = key;
	p->left = left;
	p->right = right;
	return p;
}
########################rank 2#############################
static rb_node rb_new_node(rb_tree tree, int data) {
	rb_node ret;
	if (rb_mem_pool != NULL) {
		ret = rb_mem_pool;
		rb_mem_pool = ret->parent;
	} else {
		if ((ret = malloc(sizeof(*ret))) == NULL) {
			fprintf(stderr, "Error: out of memory.\n");
			return NULL;
		}
	}
	ret->key = data;
	ret->parent = tree->nil;
	ret->lchild = tree->nil;
	ret->rchild = tree->nil;
	ret->color = 'r';
	return ret;
}
########################rank 3#############################
static SHPTreeNode *SHPTreeNodeCreate( double * padfBoundsMin,
                                       double * padfBoundsMax )
{
    SHPTreeNode	*psTreeNode;
    psTreeNode = (SHPTreeNode *) malloc(sizeof(SHPTreeNode));
    if( NULL == psTreeNode )
        return NULL;
    psTreeNode->nShapeCount = 0;
    psTreeNode->panShapeIds = NULL;
    psTreeNode->papsShapeObj = NULL;
    psTreeNode->nSubNodes = 0;
    if( padfBoundsMin != NULL )
        memcpy( psTreeNode->adfBoundsMin, padfBoundsMin, sizeof(double) * 4 );
    if( padfBoundsMax != NULL )
        memcpy( psTreeNode->adfBoundsMax, padfBoundsMax, sizeof(double) * 4 );
    return psTreeNode;
}
########################rank 4#############################
HuffmanNode* huffman_create_node(Type key, HuffmanNode *left, HuffmanNode* right, HuffmanNode* parent)
{
    HuffmanNode* p;
    if ((p = (HuffmanNode *)malloc(sizeof(HuffmanNode))) == NULL)
        return NULL;
    p->key = key;
    p->left = left;
    p->right = right;
    p->parent = parent;
    return p;
}
########################rank 5#############################
static Node* avltree_create_node(Type key, Node *left, Node* right)
{
    Node* p;
    if ((p = (Node *)malloc(sizeof(Node))) == NULL)
        return NULL;
    p->key = key;
    p->height = 0;
    p->left = left;
    p->right = right;
    return p;
}
########################rank 6#############################
static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)
{
	 * the node has a parent, as it is not the root node. */
	if (node->parent->color != RB_TREE_NODE_BLACK) {
		rb_tree_insert_case3(tree, node);
	}
}
########################rank 7#############################
static Node* create_bstree_node(Type key, Node *parent, Node *left, Node* right)
{
	Node* p;
	if ((p = (Node *)malloc(sizeof(Node))) == NULL)
		return NULL;
	p->key = key;
	p->left = left;
	p->right = right;
	p->parent = parent;
	return p;
}
########################rank 8#############################
static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1,
                                  AVLTreeNode *node2)
{
	int side;
	if (node2 != NULL) {
		node2->parent = node1->parent;
	}
	if (node1->parent == NULL) {
		tree->root_node = node2;
	} else {
		side = avl_tree_node_parent_side(node1);
		node1->parent->children[side] = node2;
		avl_tree_update_height(node1->parent);
	}
}
########################rank 9#############################
Node* splaytree_maximum(SplayTree tree)
{
	if (tree == NULL)
		return NULL;
	while(tree->right != NULL)
		tree = tree->right;
	return tree;
}
########################rank 10#############################
Node* splaytree_splay(SplayTree tree, Type key)
{
    Node N, *l, *r, *c;
    if (tree == NULL) 
        return tree;
    N.left = N.right = NULL;
    l = r = &N;
    for (;;)
    {
        if (key < tree->key)
        {
            if (tree->left == NULL)
                break;
            if (key < tree->left->key)
            {
                c = tree->left;                           
                tree->left = c->right;
                c->right = tree;
                tree = c;
                if (tree->left == NULL) 
                    break;
            }
            r->left = tree;                               /* 02, link right */
            r = tree;
            tree = tree->left;
        }
		else if (key > tree->key)
        {
            if (tree->right == NULL) 
                break;
            if (key > tree->right->key) 
            {
                c = tree->right;                          /* 03, rotate left */
                tree->right = c->left;
                c->left = tree;
                tree = c;
                if (tree->right == NULL) 
                    break;
            }
            l->right = tree;                              /* 04, link left */
            l = tree;
            tree = tree->right;
        }
		else
		{
            break;
        }
    }
    l->right = tree->left;                                /* 05, assemble */
    r->left = tree->right;
    tree->left = N.right;
    tree->right = N.left;
    return tree;
}
----------------------------QUERY-------------------------------
free a dirty page
########################rank 1#############################
static void fsPageBufferFree(Page *pPg){
  pPg->pFS->nCacheAlloc--;
  lsmFree(pPg->pFS->pEnv, pPg->aData);
  lsmFree(pPg->pFS->pEnv, pPg);
}
########################rank 2#############################
static void pcache1FreePage(PgHdr1 *p){
  PCache1 *pCache;
  assert( p!=0 );
  pCache = p->pCache;
  assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );
  if( p->isBulkLocal ){
    p->pNext = pCache->pFree;
    pCache->pFree = p;
  }else{
    pcache1Free(p->page.pBuf);
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
    sqlite3_free(p);
#endif
  }
  (*pCache->pnPurgeable)--;
}
########################rank 3#############################
static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){
  Pgno nFreeList;           /* Number of pages still on the free-list */
  int rc;
  assert( sqlite3_mutex_held(pBt->mutex) );
  assert( iLastPg>nFin );
  if( !PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg!=PENDING_BYTE_PAGE(pBt) ){
    u8 eType;
    Pgno iPtrPage;
    nFreeList = get4byte(&pBt->pPage1->aData[36]);
    if( nFreeList==0 ){
      return SQLITE_DONE;
    }
    rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( eType==PTRMAP_ROOTPAGE ){
      return SQLITE_CORRUPT_BKPT;
    }
    if( eType==PTRMAP_FREEPAGE ){
      if( bCommit==0 ){
        ** if bCommit is non-zero. In that case, the free-list will be
        ** truncated to zero after this function returns, so it doesn't 
        ** matter if it still contains some garbage entries.
        */
        Pgno iFreePg;
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, BTALLOC_EXACT);
        if( rc!=SQLITE_OK ){
          return rc;
        }
        assert( iFreePg==iLastPg );
        releasePage(pFreePg);
      }
    } else {
      Pgno iFreePg;             /* Index of free page to move pLastPg to */
      MemPage *pLastPg;
      u8 eMode = BTALLOC_ANY;   /* Mode parameter for allocateBtreePage() */
      Pgno iNear = 0;           /* nearby parameter for allocateBtreePage() */
      rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);
      if( rc!=SQLITE_OK ){
        return rc;
      }
      ** is swapped with the first free page pulled off the free list.
      **
      ** On the other hand, if bCommit is greater than zero, then keep
      ** looping until a free-page located within the first nFin pages
      ** of the file is found.
      */
      if( bCommit==0 ){
        eMode = BTALLOC_LE;
        iNear = nFin;
      }
      do {
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);
        if( rc!=SQLITE_OK ){
          releasePage(pLastPg);
          return rc;
        }
        releasePage(pFreePg);
      }while( bCommit && iFreePg>nFin );
      assert( iFreePg<iLastPg );
      rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);
      releasePage(pLastPg);
      if( rc!=SQLITE_OK ){
        return rc;
      }
    }
  }
  if( bCommit==0 ){
    do {
      iLastPg--;
    }while( iLastPg==PENDING_BYTE_PAGE(pBt) || PTRMAP_ISPAGE(pBt, iLastPg) );
    pBt->bDoTruncate = 1;
    pBt->nPage = iLastPg;
  }
  return SQLITE_OK;
}
########################rank 4#############################
static int pager_write_hot_dirty_pages(Pager *pPager,Page *pDirty)
{
	int rc = VEDIS_OK;
	Page *pNext;
	for(;;){
		if( pDirty == 0 ){
			break;
		}
		pNext = pDirty->pPrevHot; /* Not a bug: Reverse link */
		if( (pDirty->flags & PAGE_DONT_WRITE) == 0 ){
			rc = vedisOsWrite(pPager->pfd,pDirty->zData,pPager->iPageSize,pDirty->pgno * pPager->iPageSize);
			if( rc != VEDIS_OK ){
				break;
			}
		}
		pDirty->flags &= ~(PAGE_DIRTY|PAGE_DONT_WRITE|PAGE_NEED_SYNC|PAGE_IN_JOURNAL|PAGE_HOT_DIRTY);
		if( pDirty->pDirtyPrev ){
			pDirty->pDirtyPrev->pDirtyNext = pDirty->pDirtyNext;
		}else{
			pPager->pDirty = pDirty->pDirtyNext;
		}
		if( pDirty->pDirtyNext ){
			pDirty->pDirtyNext->pDirtyPrev = pDirty->pDirtyPrev;
		}else{
			pPager->pFirstDirty = pDirty->pDirtyPrev;
		}
		pager_unlink_page(pPager,pDirty);
		pager_release_page(pPager,pDirty);
		pDirty = pNext;
	}
	return rc;
}
########################rank 5#############################
static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){
  assert( pPage!=0 );
  assert( PAGE_IS_UNPINNED(pPage) );
  assert( pPage->pLruNext );
  assert( pPage->pLruPrev );
  assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );
  pPage->pLruPrev->pLruNext = pPage->pLruNext;
  pPage->pLruNext->pLruPrev = pPage->pLruPrev;
  pPage->pLruNext = 0;
  pPage->pLruPrev = 0;
  assert( pPage->isAnchor==0 );
  assert( pPage->pCache->pGroup->lru.isAnchor==1 );
  pPage->pCache->nRecyclable--;
  return pPage;
}
########################rank 6#############################
SQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){
  assert( p->nRef>0 );
  p->pCache->nRefSum--;
  if( (--p->nRef)==0 ){
    if( p->flags&PGHDR_CLEAN ){
      pcacheUnpin(p);
    }else{
      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);
    }
  }
}
########################rank 7#############################
static int pageFreeArray(
  MemPage *pPg,                   /* Page to edit */
  int iFirst,                     /* First cell to delete */
  int nCell,                      /* Cells to delete */
  CellArray *pCArray              /* Array of cells */
){
  u8 * const aData = pPg->aData;
  u8 * const pEnd = &aData[pPg->pBt->usableSize];
  u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];
  int nRet = 0;
  int i;
  int iEnd = iFirst + nCell;
  u8 *pFree = 0;
  int szFree = 0;
  for(i=iFirst; i<iEnd; i++){
    u8 *pCell = pCArray->apCell[i];
    if( SQLITE_WITHIN(pCell, pStart, pEnd) ){
      int sz;
      ** are to be freed have already been computing while deciding which
      ** cells need freeing */
      sz = pCArray->szCell[i];  assert( sz>0 );
      if( pFree!=(pCell + sz) ){
        if( pFree ){
          assert( pFree>aData && (pFree - aData)<65536 );
          freeSpace(pPg, (u16)(pFree - aData), szFree);
        }
        pFree = pCell;
        szFree = sz;
        if( pFree+sz>pEnd ) return 0;
      }else{
        pFree = pCell;
        szFree += sz;
      }
      nRet++;
    }
  }
  if( pFree ){
    assert( pFree>aData && (pFree - aData)<65536 );
    freeSpace(pPg, (u16)(pFree - aData), szFree);
  }
  return nRet;
}
########################rank 8#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( wx_sqlite3_mutex_held(pBt->mutex) );
  rc = wx_sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 9#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( sqlite3_mutex_held(pBt->mutex) );
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 10#############################
static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){
  unsigned int h;
  PCache1 *pCache = pPage->pCache;
  PgHdr1 **pp;
  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );
  h = pPage->iKey % pCache->nHash;
  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);
  *pp = (*pp)->pNext;
  pCache->nPage--;
  if( freeFlag ) pcache1FreePage(pPage);
}
----------------------------QUERY-------------------------------
create message with given type
########################rank 1#############################
struct message_helper *message_helper_create(char *data, unsigned short data_len, unsigned short message_data_size){
	struct message_helper *new_mh;
	new_mh = (struct message_helper *) calloc(1, sizeof(struct message_helper));
	if(!new_mh){
		report_error("message_helper_create(): calloc(1, %d): %s", (int) sizeof(struct message_helper), strerror(errno));
		return(NULL);
	}
	new_mh->data = (char *) calloc(message_data_size, sizeof(char));
	if(!new_mh->data){
		report_error("message_helper_create(): calloc(1, %d): %s", (int) sizeof(struct message_helper), strerror(errno));
		free(new_mh);
		return(NULL);
	}
	memcpy(new_mh->data, data, data_len);
	new_mh->data_len = data_len;
	return(new_mh);
}
########################rank 2#############################
IoError *IoError_newWithMessageFormat_(void *state, const char *format, ...)
{
	IoSymbol *message;
	va_list ap;
	va_start(ap, format);
	message = IoState_symbolWithUArray_copy_(state, UArray_newWithVargs_(format, ap), 0);
	va_end(ap);
	{
		IoError *error = IoError_new(state);
		IoObject_setSlot_to_(error, IoState_symbolWithCString_((IoState*)state, (char *)("message")), message);
		return error;
	}
}
########################rank 3#############################
void start_msg(char **msg, int type)
{
	put_integer(type, msg);
	(*msg) += 4;
}
########################rank 4#############################
static void CL_WriteBinaryMessage( msg_t *msg ) {
	if ( !clc.binaryMessageLength ) {
		return;
	}
	MSG_Uncompressed( msg );
	if ( ( msg->cursize + clc.binaryMessageLength ) >= msg->maxsize ) {
		clc.binaryMessageOverflowed = qtrue;
		return;
	}
	MSG_WriteData( msg, clc.binaryMessage, clc.binaryMessageLength );
	clc.binaryMessageLength = 0;
	clc.binaryMessageOverflowed = qfalse;
}
########################rank 5#############################
static message_t *message_get(u16b age)
{
	message_t *m = messages->head;
	while (m && age) {
		age--;
		m = m->older;
	}
	return m;
}
########################rank 6#############################
static size_t
store_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,
   size_t pos, const char *msg)
{
   if (pp != NULL && pp == ps->pread)
   {
      pos = safecat(buffer, bufsize, pos, "read: ");
      if (ps->current != NULL)
      {
         pos = safecat(buffer, bufsize, pos, ps->current->name);
         pos = safecat(buffer, bufsize, pos, sep);
      }
   }
   else if (pp != NULL && pp == ps->pwrite)
   {
      pos = safecat(buffer, bufsize, pos, "write: ");
      pos = safecat(buffer, bufsize, pos, ps->wname);
      pos = safecat(buffer, bufsize, pos, sep);
   }
   else
   {
      pos = safecat(buffer, bufsize, pos, "pngvalid: ");
   }
   if (ps->test[0] != 0)
   {
      pos = safecat(buffer, bufsize, pos, ps->test);
      pos = safecat(buffer, bufsize, pos, sep);
   }
   pos = safecat(buffer, bufsize, pos, msg);
   return pos;
}
########################rank 7#############################
static void *atan_new(void)
{
    t_object *x = (t_object *)pd_new(atan_class);
    outlet_new(x, &s_float);
    return (x);
}
########################rank 8#############################
static void *atan_new(void)
{
    t_object *x = (t_object *)pd_new(atan_class);
    outlet_new(x, &s_float);
    return (x);
}
########################rank 9#############################
static void *atan_new(void)
{
    t_object *x = (t_object *)pd_new(atan_class);
    outlet_new(x, &s_float);
    return (x);
}
########################rank 10#############################
ir_unit_t *
vmir_create(void *membase, uint32_t memsize,
            uint32_t rsize, uint32_t asize,
            void *opaque)
{
  ir_unit_t *iu = calloc(1, sizeof(ir_unit_t));
  iu->iu_log_level = VMIR_LOG_INFO;
  iu->iu_external_function_resolver = vmir_default_external_function_resolver;
  iu->iu_opaque = opaque;
  iu->iu_mem = membase;
  iu->iu_memsize = memsize;
  iu->iu_rsize = rsize;
  iu->iu_asize = asize;
  iu->iu_text_alloc_memsize = 1024 * 1024;
  iu->iu_text_alloc = malloc(iu->iu_text_alloc_memsize);
  iu->iu_mem_low = iu->iu_mem;
  iu->iu_mem_high = iu->iu_mem + memsize;
  return iu;
}
----------------------------QUERY-------------------------------
encrypt byte sequence
########################rank 1#############################
void AES_cbc_encrypt(AES_CTX *ctx, const uint8_t *msg, uint8_t *out, int length)
{
    int i;
    uint32_t tin[4], tout[4], iv[4];
    memcpy(iv, ctx->iv, AES_IV_SIZE);
    for (i = 0; i < 4; i++)
        tout[i] = ntohl(iv[i]);
    for (length -= AES_BLOCKSIZE; length >= 0; length -= AES_BLOCKSIZE)
    {
        uint32_t msg_32[4];
        uint32_t out_32[4];
        memcpy(msg_32, msg, AES_BLOCKSIZE);
        msg += AES_BLOCKSIZE;
        for (i = 0; i < 4; i++)
            tin[i] = ntohl(msg_32[i])^tout[i];
        AES_encrypt(ctx, tin);
        for (i = 0; i < 4; i++)
        {
            tout[i] = tin[i]; 
            out_32[i] = htonl(tout[i]);
        }
        memcpy(out, out_32, AES_BLOCKSIZE);
        out += AES_BLOCKSIZE;
    }
    for (i = 0; i < 4; i++)
        iv[i] = htonl(tout[i]);
    memcpy(ctx->iv, iv, AES_IV_SIZE);
}
########################rank 2#############################
void AES_ECB_encrypt(AES_ctx* ctx, uint8_t* buf)
{
  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher(ctx, (state_t*)buf);
}
########################rank 3#############################
static void xexEncryptInternal(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key)
{
	xexEnDecrypt(out, in, n, seq, tweak_key, encrypt_key, false);
}
########################rank 4#############################
void SMBOWFencrypt(uchar passwd[16], uchar *c8, uchar p24[24]) {
  uchar p21[21];
  memset(p21, '\0', 21);
  memcpy(p21, passwd, 16);
  E_P24(p21, c8, p24);
}
########################rank 5#############################
static void xexDecryptInternal(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key)
{
	xexEnDecrypt(out, in, n, seq, tweak_key, encrypt_key, true);
}
########################rank 6#############################
void SMBNTencrypt(uchar *passwd, uchar *c8, uchar *p24) {
  uchar p21[21];
  memset(p21, '\0', 21);
  E_md4hash(passwd, p21);
  SMBOWFencrypt(p21, c8, p24);
#ifdef DEBUG_PASSWORD
  DEBUG(100, ("SMBNTencrypt: nt#, challenge, response\n"));
  dump_data(100, (char *)p21, 16);
  dump_data(100, (char *)c8, 8);
  dump_data(100, (char *)p24, 24);
#endif
}
########################rank 7#############################
void AES_cbc256_decrypt(uint8_t *key, uint8_t *iv_in, uint8_t *in, uint64_t len, uint8_t *out)
{
    AES_KEY  k;
    uint32_t i;
    uint8_t  tmp[AES_BLOCK_SIZE];
    uint8_t  iv[AES_BLOCK_SIZE];
    memcpy(iv, iv_in, AES_BLOCK_SIZE);
    memset(&k, 0, sizeof k);
    AES_set_decrypt_key(key, 256, &k);
    while (len > 0)
    {
        memcpy(tmp, in, AES_BLOCK_SIZE);
        AES_decrypt(in, out, &k);
        for (i = 0; i < AES_BLOCK_SIZE; i++)
            out[i] ^= iv[i];
        memcpy(iv, tmp, AES_BLOCK_SIZE);
        out += AES_BLOCK_SIZE;
        in  += AES_BLOCK_SIZE;
        len -= AES_BLOCK_SIZE;
    }
}
########################rank 8#############################
int
encrypt(char *block, int flag)
{
	return __crypt_encrypt(block, flag);
}
########################rank 9#############################
int mbedtls_des3_set3key_enc( mbedtls_des3_context *ctx,
                      const unsigned char key[MBEDTLS_DES_KEY_SIZE * 3] )
{
    uint32_t sk[96];
    des3_set3key( ctx->sk, sk, key );
    mbedtls_zeroize( sk,  sizeof( sk ) );
    return( 0 );
}
########################rank 10#############################
static const unsigned short
    C1 = 52845,
    C2 = 22719,
    key_eexec = 55665,
    key_charstring = 4330;
static uchar decrypt(uchar cipher, unsigned short *keyp) {
    if (g_lenIV < 0) {
        return cipher;
    } else {
        unsigned short key = *keyp;
        uchar plain = cipher ^ (key >> 8);
        *keyp = (cipher + key) * C1 + C2;
        return plain;
    }
}
----------------------------QUERY-------------------------------
parse checksum file
########################rank 1#############################
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;
    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 
    return (unsigned short)(~cksum); 
}
########################rank 2#############################
uint32_t checksum(struct rmessage *msg) {
  int32_t blen;
  uint8_t *stream;
  uint32_t sum;
  blen = msg->length; // Get the real length.
  blen += (4 - (blen % 4));
  // Allocate a worksapce.
  stream = calloc(blen, sizeof(uint8_t));
  memcpy(stream, &msg->type, sizeof(uint8_t));
  memcpy(stream + 1, msg->data, blen - 1);
  sum = 0;
  for (blen -= sizeof(uint32_t); blen > 0; blen -= sizeof(uint32_t)) {
    sum += *(uint32_t *)(stream + blen);
  }
  sum += *(uint32_t *)stream;
  // Free the workspace.
  free(stream);
  return sum;
}
########################rank 3#############################
static uint32_t do_checksum(void)
{
	uint32_t c = 0;
	size_t i = 0x400/4;
	while(i<(0x400+firmware_sz)/4)
		c += ((uint32_t*)buf)[i++];
	return c;
}
########################rank 4#############################
int
libnet_do_checksum(libnet_t *l, uint8_t *iphdr, int protocol, int h_len)
{
    uint16_t ip_len = 0;
    struct libnet_ipv4_hdr* ip4 = (struct libnet_ipv4_hdr *)iphdr;
    struct libnet_ipv6_hdr* ip6 = (struct libnet_ipv6_hdr *)iphdr;
    if(ip4->ip_v == 6) {
        ip_len = ntohs(ip6->ip_len);
    } else {
        ip_len = ntohs(ip4->ip_len);
    }
    return libnet_inet_checksum(l, iphdr, protocol, h_len,
            iphdr, iphdr + ip_len
            );
}
########################rank 5#############################
uint16_t cksum( char *b, int len ){
    uint16_t sum = 0;
    uint16_t t;
    char *e = b + len;
    b[len] = 0;
    while(b < e){
	t = (b[0] << 8) + b[1];
	sum += t;
	if(sum < t) sum++;
	b += 2;
    }
    return ~sum;
}
########################rank 6#############################
static void checksum(int i, dcomplex u1[NZ][NY][NX], int d[3]) {
    int j, q,r,s, ierr;
    dcomplex chk,allchk;
    chk.real = 0.0;
    chk.imag = 0.0;
#pragma omp for nowait
    for (j = 1; j <= 1024; j++) {
	q = j%NX+1;
	if (q >= xstart[0] && q <= xend[0]) {
            r = (3*j)%NY+1;
            if (r >= ystart[0] && r <= yend[0]) {
		s = (5*j)%NZ+1;
		if (s >= zstart[0] && s <= zend[0]) {
		  cadd(chk,chk,u1[s-zstart[0]][r-ystart[0]][q-xstart[0]]);
		}
	    }
	}
    }
#pragma omp critical
    {
	sums[i].real += chk.real;
	sums[i].imag += chk.imag;
    }
#pragma omp barrier
#pragma omp single
  {    
    sums[i].real = sums[i].real/(double)(NTOTAL);
    sums[i].imag = sums[i].imag/(double)(NTOTAL);
  }
}
########################rank 7#############################
static uint8_t
rtc_checksum(uint8_t *ptr)
{
    uint8_t sum;
    int i;
    sum = 0x00;
    for (i=MRTC_CONF_A; i<=MRTC_CONF_E; i++)
	sum += ptr[i];
    return(sum);
}
########################rank 8#############################
int cksum(char *buf, unsigned long count)
{
        unsigned len;
        unsigned char tot;
        unsigned char cksum;
        unsigned x;
        tot = 0;
        len = hextobin(buf + 2);
        for (x = 0; x != len; ++x) {
                tot += hextobin(buf + 2 + x * 2);
        }
        cksum = hextobin(buf + 2 + x * 2);
        tot = (255 & ~tot);
        if (tot != cksum) {
                fprintf(stderr, "Checksum mismatch on line %ld (got %x but calculated %x)\n", count, cksum, tot);
                return 1;
        } else {
                return 0;
        }
}
########################rank 9#############################
static unsigned
icmp_checksum2(const unsigned char *px,
              unsigned offset_icmp, size_t icmp_length)
{
    uint64_t xsum = 0;
    unsigned i;
    for (i=0; i<icmp_length; i += 2) {
        xsum += px[offset_icmp + i]<<8 | px[offset_icmp + i + 1];
    }
    xsum -= (icmp_length & 1) * px[offset_icmp + i - 1]; 
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    return (unsigned)xsum;
}
########################rank 10#############################
static unsigned
icmp_checksum2(const unsigned char *px,
              unsigned offset_icmp, size_t icmp_length)
{
    uint64_t xsum = 0;
    unsigned i;
    for (i=0; i<icmp_length; i += 2) {
        xsum += px[offset_icmp + i]<<8 | px[offset_icmp + i + 1];
    }
    xsum -= (icmp_length & 1) * px[offset_icmp + i - 1]; 
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    return (unsigned)xsum;
}
----------------------------QUERY-------------------------------
remove trailing blanks, tabs and newlines
########################rank 1#############################
void 
pixie_delete_critical_section(void *cs)
{
#if defined(WIN32)
    if (cs) {
        DeleteCriticalSection(cs);
        free(cs);
    }
#elif defined(__GNUC__)
	if (cs) {
		pthread_mutex_destroy(cs);
		free(cs);
	}
#else
#error pixie_delete_critical_section undefined
#endif
}
########################rank 2#############################
void FS_SV_Rename( const char *from, const char *to ) {
	char            *from_ospath, *to_ospath;
	if ( !fs_searchpaths ) {
		Com_Error( ERR_FATAL, "Filesystem call made without initialization\n" );
	}
	// don't let sound stutter
	S_ClearSoundBuffer();
	from_ospath = FS_BuildOSPath( fs_homepath->string, from, "" );
	to_ospath = FS_BuildOSPath( fs_homepath->string, to, "" );
	from_ospath[strlen( from_ospath ) - 1] = '\0';
	to_ospath[strlen( to_ospath ) - 1] = '\0';
	if ( fs_debug->integer ) {
		Com_Printf( "FS_SV_Rename: %s --> %s\n", from_ospath, to_ospath );
	}
	if ( rename( from_ospath, to_ospath ) ) {
		// Failed, try copying it and deleting the original
		FS_CopyFile( from_ospath, to_ospath );
		FS_Remove( from_ospath );
	}
}
########################rank 3#############################
void FS_SV_Rename( const char *from, const char *to ) {
	char            *from_ospath, *to_ospath;
	if ( !fs_searchpaths ) {
		Com_Error( ERR_FATAL, "Filesystem call made without initialization\n" );
	}
	// don't let sound stutter
	//S_ClearSoundBuffer();
	from_ospath = FS_BuildOSPath( fs_homepath->string, from, "" );
	to_ospath = FS_BuildOSPath( fs_homepath->string, to, "" );
	from_ospath[strlen( from_ospath ) - 1] = '\0';
	to_ospath[strlen( to_ospath ) - 1] = '\0';
	if ( fs_debug->integer ) {
		Com_Printf( "FS_SV_Rename: %s --> %s\n", from_ospath, to_ospath );
	}
	if ( rename( from_ospath, to_ospath ) ) {
		// Failed, try copying it and deleting the original
		FS_CopyFile( from_ospath, to_ospath );
		FS_Remove( from_ospath );
	}
}
########################rank 4#############################
void set_graphemebreaks_utf16(const utf16_t *s, size_t len,
                              const char *lang, char *brks)
{
    (void)lang;
    set_graphemebreaks(s, len, brks,
                       (get_next_char_t)ub_get_next_char_utf16);
}
########################rank 5#############################
void set_graphemebreaks_utf32(const utf32_t *s, size_t len,
                              const char *lang, char *brks)
{
    (void)lang;
    set_graphemebreaks(s, len, brks,
                       (get_next_char_t)ub_get_next_char_utf32);
}
########################rank 6#############################
void set_graphemebreaks_utf8(const utf8_t *s, size_t len, const char *lang,
                             char *brks)
{
    (void)lang;
    set_graphemebreaks(s, len, brks,
                       (get_next_char_t)ub_get_next_char_utf8);
}
########################rank 7#############################
static void set_graphemebreaks(const void *s, size_t len, char *brks,
                               get_next_char_t get_next_char)
{
    size_t posNext = 0;
    int rule11Detector = 0;
    bool evenRegionalIndicators = true;  // is the number of preceeding
                                         // GBP_RegionalIndicator characters
                                         // even
    utf32_t ch = get_next_char(s, len, &posNext);
    enum GraphemeBreakClass current_class = get_char_gb_class(ch);
    // initialize whole output to inside char
    memset(brks, GRAPHEMEBREAK_INSIDEACHAR, len);
    while (true)
    {
        // this state-machine recognizes the following pattern:
        // extended_pictograph Extended* ZWJ
        // when that pattern has been detected rule11Detector will be
        // 3 and rule 11 can be applied below
        switch (current_class)
        {
            case GBP_ZWJ:
                if (rule11Detector == 1 || rule11Detector == 2)
                {
                    rule11Detector = 3;
                }
                else
                {
                    rule11Detector = 0;
                }
                break;
            case GBP_Extend:
                if (rule11Detector == 1 || rule11Detector == 2)
                {
                    rule11Detector = 2;
                }
                else
                {
                    rule11Detector = 0;
                }
                break;
            default:
                if (ub_is_extended_pictographic(ch))
                {
                    rule11Detector = 1;
                }
                else
                {
                    rule11Detector = 0;
                }
                break;
        }
        enum GraphemeBreakClass prev_class = current_class;
        // safe position if current character so that we can store the
        // result there later on
        size_t brksPos = posNext - 1;
        // get nect character
        ch = get_next_char(s, len, &posNext);
        if (ch == EOS)
        {
            // done, place one final break after the last character as per
            // algorithm rule GB1
            brks[brksPos] = GRAPHEMEBREAK_BREAK;
            break;
        }
        // get class of current character
        current_class = get_char_gb_class(ch);
        if (prev_class == GBP_Regional_Indicator)
        {
            evenRegionalIndicators = !evenRegionalIndicators;
        }
        else
        {
            evenRegionalIndicators = true;
        }
        // check all rules
        if (prev_class == GBP_CR && current_class == GBP_LF)
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB3
        }
        else if ((prev_class == GBP_CR) || (prev_class == GBP_LF) ||
                 (prev_class == GBP_Control) || (current_class == GBP_CR) ||
                 (current_class == GBP_LF) ||
                 (current_class == GBP_Control))
        {
            brks[brksPos] = GRAPHEMEBREAK_BREAK;  // Rule: GB4 + GB5
        }
        else if ((prev_class == GBP_L) &&
                 ((current_class == GBP_L) || (current_class == GBP_V) ||
                  (current_class == GBP_LV) || (current_class == GBP_LVT)))
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB6
        }
        else if (((prev_class == GBP_LV) || (prev_class == GBP_V)) &&
                 ((current_class == GBP_V) || (current_class == GBP_T)))
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB7
        }
        else if (((prev_class == GBP_LVT) || (prev_class == GBP_T)) &&
                 (current_class == GBP_T))
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB8
        }
        else if ((current_class == GBP_Extend) ||
                 (current_class == GBP_ZWJ) ||
                 (current_class == GBP_Virama))
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB9
        }
        else if (current_class == GBP_SpacingMark)
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB9a
        }
        else if (prev_class == GBP_Prepend)
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB9b
        }
        else if ((rule11Detector == 3) && ub_is_extended_pictographic(ch))
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB11
        }
        else if (!evenRegionalIndicators &&
                 (current_class == GBP_Regional_Indicator))
        {
            brks[brksPos] = GRAPHEMEBREAK_NOBREAK;  // Rule: GB12 + GB13
        }
        else
        {
            brks[brksPos] = GRAPHEMEBREAK_BREAK;  // Rule: GB999
        }
    }
}
########################rank 8#############################
static void
md_char(unsigned char c)
{
	if (c != '\0') {
		putchar(c);
		if (c == '*')
			escflags |= ESC_FON;
		else
			escflags &= ~ESC_FON;
		outcount++;
	}
	if (c != ']')
		escflags &= ~ESC_HYP;
	if (c == ' ' || c == '\t' || c == '>')
		return;
	if (isdigit(c) == 0)
		escflags &= ~ESC_NUM;
	else if (escflags & ESC_BOL)
		escflags |= ESC_NUM;
	escflags &= ~ESC_BOL;
}
########################rank 9#############################
static void replace_char(char *string, char from, char to, int maxlen)
{
	char *lastchar = string + maxlen;
	while (string) {
		string = strchr(string, from);
		if (string) {
			*string = to;
			if (string >= lastchar)
				return;
		}
	}
}
########################rank 10#############################
VOID
copyact(inp,outp,actno) FILE *inp,*outp; int actno; {
    int c,bcnt;
    fprintf(outp,"case %d:\n",actno);
    while (c = getc(inp), (isspace(c) || c == C_L))
      if (c == '\n') lines++;
    if (c == '{') {
	bcnt = 1;
	fputs("    {",outp);
	while (bcnt > 0 && (c = getc(inp)) != EOF) {
	    if (c == '{') bcnt++;
	    else if (c == '}') bcnt--;
	    else if (c == '\n') lines++;
	    putc(c,outp);
	}
	if (bcnt > 0) fatal("action doesn't end");
    } else {
	while (c != '\n' && c != EOF) {
	    putc(c,outp);
	    c = getc(inp);
	}
	lines++;
    }
    fprintf(outp,"\n    break;\n");
}
----------------------------QUERY-------------------------------
search last occurrence of char in string
########################rank 1#############################
size_t
cstrcspn(const char *s1, const char *s2)
{
	const char *p, *spanp;
	char c, sc;
	 * Stop as soon as we find any character from s2.  Note that there
	 * must be a NUL in s2; it suffices to stop when we find that, too.
	 */
	for (p = s1;;) {
		c = *p++;
		spanp = s2;
		do {
			if ((sc = *spanp++) == c)
				return (p - 1 - s1);
		} while (sc != 0);
	}
}
########################rank 2#############################
char *strupr( char *s )
{
  int i;
  for(i=0; i<strlen(s); i++ ) {
    s[i] = toupper(s[i]);
  }
  return s;
}
########################rank 3#############################
int zstrnicmp(s1, s2, n)
    register ZCONST char *s1, *s2;
    register unsigned n;
{
    for (; n > 0;  --n, ++s1, ++s2) {
        if (ToLower(*s1) != ToLower(*s2))
            return ((uch)ToLower(*s1) < (uch)ToLower(*s2))? -1 : 1;
        if (*s1 == '\0')   /* both strings terminate early */
            return 0;
    }
    return 0;
}
########################rank 4#############################
int isexactlcmd(const char *p, const char *s)
{
  while(*p == *s && *s != '\t' && *s != '\0' ) { ++p; ++s; }
  if (*s == '\t' && isLaTeXcmdletter(*p) == 0) return 0;
  return 1;
}
########################rank 5#############################
extern int strneq(const char *s1, const char *s2, size_t len)
{
	size_t i = 0;
	if (!len) return 0;
	while (*s1 != '\0' && *s2 != '\0') {
		if (*s1 != *s2) return 1;
		s1++; s2++; i++;
		if (i == len) return 0;
	}
	if (*s1 != *s2) return 1;
	return 0;
}
########################rank 6#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 7#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 8#############################
uint8_t *
libnet_hex_aton(const char *s, int *len)
{
    uint8_t *buf;
    int i;
    int32_t l;
    char *pp;
    while (isspace(*s))
    {
        s++;
    }
    for (i = 0, *len = 0; s[i]; i++)
    {
        if (s[i] == ':')
        {
            (*len)++;
        }
    }
    buf = malloc(*len + 1);
    if (buf == NULL)
    {
        return (NULL);
    }
    for (i = 0; i < *len + 1; i++)
    {
        l = strtol(s, &pp, 16);
        if (pp == s || l > 0xff || l < 0)
        {
            *len = 0;
            free(buf);
            return (NULL);
        }
        if (!(*pp == ':' || (i == *len && (isspace(*pp) || *pp == '\0'))))
        {
            *len = 0;
            free(buf);
            return (NULL);
        }
        buf[i] = (uint8_t)l;
        s = pp + 1;
    }
    (*len)++;
    return (buf);
}
########################rank 9#############################
extern int strncaseeq(const char *s1, const char *s2, size_t len)
{
	size_t i = 0;
	while (i < len) {
		if (*s1 != *s2) {
			unsigned char c1, c2;
			c1 = *(const unsigned char *)s1;
			c2 = *(const unsigned char *)s2;
			if (c1 == 0 || c2 == 0) return 1;
			if (c1 >= 'A' && c1 <= 'Z') c1 |= 0x20;
			if (c2 >= 'A' && c2 <= 'Z') c2 |= 0x20;
			if (c1 != c2) return 1;
		} else {
			if (*s1 == 0) return 0;
		}
		s1++; s2++;
		i++;
	}
	return 0;
}
########################rank 10#############################
static const char *
startswith(const char *string, const char *pattern)
{
	int l = strlen(pattern);
	if (strlen(string) <= l) return NULL;
	if (strncmp(string, pattern, l) != 0) return NULL;
	string += l;
	if (!isspace(*string)) return NULL;
	while (isspace(*string))
		string++;
	return string;
}
----------------------------QUERY-------------------------------
binary search in sorted array of size
########################rank 1#############################
static unsigned int binarySearch(uint64_t* array, uint64_t z, int n)
{
  unsigned int 
    first = 0,
    last = n-3,
    middle = (first + last) / 2, 
    lastSmallerOrEqual = 0;
  while(first <= last)
    {
      if(array[middle] < z)
	{
	  first = middle + 1;
	  lastSmallerOrEqual = middle;
	}
      else 
	{
	  if (array[middle] > z)	  
	    last = middle-1;	 
	  else 
	    { 
	      // array[middle] == z
	      lastSmallerOrEqual = middle;
	      break;
	    }
	}
      middle = (first + last)/2;
    }
  return lastSmallerOrEqual;
}
########################rank 2#############################
BINN_PRIVATE unsigned char * SearchForID(unsigned char *p, int header_size, int size, int numitems, int id) {
  unsigned char *plimit, *base;
  int  i, int32;
  base = p;
  plimit = p + size - 1;
  p += header_size;
  // search for the ID in all the arguments.
  for (i = 0; i < numitems; i++) {
    copy_be32((u32*)&int32, (u32*)p);
    p += 4;
    if (p > plimit) break;
    // Compare if the IDs are equal.
    if (int32 == id) return p;
    // xxx
    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) break;
  }
  return NULL;
}
########################rank 3#############################
static int binary_search(mrbc_kv_handle *kvh, mrbc_sym sym_id)
{
  int left = 0;
  int right = kvh->n_stored - 1;
  if( right < 0 ) return -1;
  while( left < right ) {
    int mid = (left + right) / 2;
    if( kvh->data[mid].sym_id < sym_id ) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  return left;
}
########################rank 4#############################
unsigned
smack_search(    struct SMACK * smack,
                const void *v_px,
                unsigned length,
                FOUND_CALLBACK cb_found,
                void *callback_data,
                unsigned *current_state)
{
    const unsigned char *px = (const unsigned char*)v_px;
    unsigned row;
    unsigned i;
    const unsigned char *char_to_symbol = smack->char_to_symbol;
    transition_t *table = smack->table;
    unsigned row_shift = smack->row_shift;
    unsigned found_count = 0;
    const struct SmackMatches *match = smack->m_match;
    row = *current_state & 0xFFFFFF;
    for (i=0; i<length; i++) {
        unsigned char column;
        unsigned char c;
        c = px[i];
         * Even though there are 256 possible combinations for a byte, we
         * are probably using fewer than 32 individual characters in the
         * patterns we are looking for. This step allows us to create tables
         * that are only 32 elements wide, instead of 256 elements wide */
        column = char_to_symbol[c];
         * If debugging, and the variable is set, then print out the
         * transition to the command line. This is a good way of visualizing
         * how they work.
         */
#ifdef DEBUG
        if (print_transitions) {
            printf("%s+%c = %s%s\n",
                    smack->m_match[row].DEBUG_name,
                    c,
                    smack->m_match[*(table + (row<<row_shift) + column)].DEBUG_name,
                    smack->m_match[*(table + (row<<row_shift) + column)].m_count?"$$":"");
            print_transitions--;
        }
#endif
         * STATE TRANSITION
         * Given the current row, lookup the symbol, and find the next row.
         * Logically, this is the following  calculation:
         *    row = table[row][column]
         * However, since row can have a variable width (depending on the
         * number of characters in a pattern), we have to do the calculation
         * manually.
         */
        row = *(table + (row<<row_shift) + column);
         * the callback function */
        if (match[row].m_count)
            found_count = handle_match(smack, i, cb_found, callback_data, row);
    }
    *current_state = row;
    return found_count;
}
########################rank 5#############################
unsigned
smack_search(    struct SMACK * smack,
                const void *v_px,
                unsigned length,
                FOUND_CALLBACK cb_found,
                void *callback_data,
                unsigned *current_state)
{
    const unsigned char *px = (const unsigned char*)v_px;
    unsigned row;
    unsigned i;
    const unsigned char *char_to_symbol = smack->char_to_symbol;
    transition_t *table = smack->table;
    unsigned row_shift = smack->row_shift;
    unsigned found_count = 0;
    const struct SmackMatches *match = smack->m_match;
    row = *current_state & 0xFFFFFF;
    for (i=0; i<length; i++) {
        unsigned char column;
        unsigned char c;
        c = px[i];
         * Even though there are 256 possible combinations for a byte, we
         * are probably using fewer than 32 individual characters in the
         * patterns we are looking for. This step allows us to create tables
         * that are only 32 elements wide, instead of 256 elements wide */
        column = char_to_symbol[c];
         * If debugging, and the variable is set, then print out the
         * transition to the command line. This is a good way of visualizing
         * how they work.
         */
#ifdef DEBUG
        if (print_transitions) {
            printf("%s+%c = %s%s\n",
                    smack->m_match[row].DEBUG_name,
                    c,
                    smack->m_match[*(table + (row<<row_shift) + column)].DEBUG_name,
                    smack->m_match[*(table + (row<<row_shift) + column)].m_count?"$$":"");
            print_transitions--;
        }
#endif
         * STATE TRANSITION
         * Given the current row, lookup the symbol, and find the next row.
         * Logically, this is the following  calculation:
         *    row = table[row][column]
         * However, since row can have a variable width (depending on the
         * number of characters in a pattern), we have to do the calculation
         * manually.
         */
        row = *(table + (row<<row_shift) + column);
         * the callback function */
        if (match[row].m_count)
            found_count = handle_match(smack, i, cb_found, callback_data, row);
    }
    *current_state = row;
    return found_count;
}
########################rank 6#############################
unsigned
smack_search(    struct SMACK * smack,
                const void *v_px,
                unsigned length,
                FOUND_CALLBACK cb_found,
                void *callback_data,
                unsigned *current_state)
{
    const unsigned char *px = (const unsigned char*)v_px;
    unsigned row;
    unsigned i;
    const unsigned char *char_to_symbol = smack->char_to_symbol;
    transition_t *table = smack->table;
    unsigned row_shift = smack->row_shift;
    unsigned found_count = 0;
    const struct SmackMatches *match = smack->m_match;
    row = *current_state & 0xFFFFFF;
    for (i=0; i<length; i++) {
        unsigned char column;
        unsigned char c;
        c = px[i];
         * Even though there are 256 possible combinations for a byte, we
         * are probably using fewer than 32 individual characters in the
         * patterns we are looking for. This step allows us to create tables
         * that are only 32 elements wide, instead of 256 elements wide */
        column = char_to_symbol[c];
         * If debugging, and the variable is set, then print out the
         * transition to the command line. This is a good way of visualizing
         * how they work.
         */
#ifdef DEBUG
        if (print_transitions) {
            printf("%s+%c = %s%s\n",
                    smack->m_match[row].DEBUG_name,
                    c,
                    smack->m_match[*(table + (row<<row_shift) + column)].DEBUG_name,
                    smack->m_match[*(table + (row<<row_shift) + column)].m_count?"$$":"");
            print_transitions--;
        }
#endif
         * STATE TRANSITION
         * Given the current row, lookup the symbol, and find the next row.
         * Logically, this is the following  calculation:
         *    row = table[row][column]
         * However, since row can have a variable width (depending on the
         * number of characters in a pattern), we have to do the calculation
         * manually.
         */
        row = *(table + (row<<row_shift) + column);
         * the callback function */
        if (match[row].m_count)
            found_count = handle_match(smack, i, cb_found, callback_data, row);
    }
    *current_state = row;
    return found_count;
}
########################rank 7#############################
void sortColors0(int* nums, int numsSize) {
    int i, zero_count, one_count;
    zero_count = 0;
    one_count = 0;
    for (i = 0; i < numsSize; i++) {
        if (nums[i] == 0) {
            zero_count++;
        }
        if (nums[i] == 1) {
            one_count++;
        }
    }
    for (i = 0; i < zero_count; i++) {
        nums[i] = 0;
    }
    for (i = zero_count; i < zero_count + one_count; i++) {
        nums[i] = 1;
    }
    for ( ; i < numsSize; i++) {
        nums[i] = 2;
    }
}
########################rank 8#############################
int is_sorted(int *a, int n)
{
  for (int i = 0; i < n - 1; i++)
    if (a[i] > a[i + 1])
      return 0;
  return 1;
}
########################rank 9#############################
int is_sorted(int *a, int n)
{
  for (int i = 0; i < n - 1; i++)
    if (a[i] > a[i + 1])
      return 0;
  return 1;
}
########################rank 10#############################
int
permcycles(int *p, int n, int *len, boolean sort)
{
    int m,i,j,k,h,nc,leni;
    m = (n + WORDSIZE - 1) / WORDSIZE;
    DYNALLOC1(set,workset,workset_sz,m,"malloc");
    EMPTYSET(workset,m);
    nc = 0;
    for (i = 0; i < n; ++i)
        if (!ISELEMENT(workset,i))
	{
	    k = 1;
	    for (j = p[i]; j != i; j = p[j]) 
	    {
		ADDELEMENT(workset,j);
		++k;
	    }
	    len[nc++] = k;
	}
    if (sort && nc > 1)
    {
	j = nc / 3;
        h = 1;
        do
            h = 3 * h + 1;
        while (h < j);
	do
        {
            for (i = h; i < nc; ++i)
            {
                leni = len[i];
                for (j = i; len[j-h] > leni; )
                {
                    len[j] = len[j-h];
                    if ((j -= h) < h) break;
                }
                len[j] = leni;
            }
            h /= 3;
        }
        while (h > 0);
    }
    return nc;
}
----------------------------QUERY-------------------------------
calculate checksum of checkpoint
########################rank 1#############################
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;
    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 
    return (unsigned short)(~cksum); 
}
########################rank 2#############################
uint32_t checksum(struct rmessage *msg) {
  int32_t blen;
  uint8_t *stream;
  uint32_t sum;
  blen = msg->length; // Get the real length.
  blen += (4 - (blen % 4));
  // Allocate a worksapce.
  stream = calloc(blen, sizeof(uint8_t));
  memcpy(stream, &msg->type, sizeof(uint8_t));
  memcpy(stream + 1, msg->data, blen - 1);
  sum = 0;
  for (blen -= sizeof(uint32_t); blen > 0; blen -= sizeof(uint32_t)) {
    sum += *(uint32_t *)(stream + blen);
  }
  sum += *(uint32_t *)stream;
  // Free the workspace.
  free(stream);
  return sum;
}
########################rank 3#############################
uint16_t cksum( char *b, int len ){
    uint16_t sum = 0;
    uint16_t t;
    char *e = b + len;
    b[len] = 0;
    while(b < e){
	t = (b[0] << 8) + b[1];
	sum += t;
	if(sum < t) sum++;
	b += 2;
    }
    return ~sum;
}
########################rank 4#############################
static uint32_t do_checksum(void)
{
	uint32_t c = 0;
	size_t i = 0x400/4;
	while(i<(0x400+firmware_sz)/4)
		c += ((uint32_t*)buf)[i++];
	return c;
}
########################rank 5#############################
static uint8_t
rtc_checksum(uint8_t *ptr)
{
    uint8_t sum;
    int i;
    sum = 0x00;
    for (i=MRTC_CONF_A; i<=MRTC_CONF_E; i++)
	sum += ptr[i];
    return(sum);
}
########################rank 6#############################
int cksum(char *buf, unsigned long count)
{
        unsigned len;
        unsigned char tot;
        unsigned char cksum;
        unsigned x;
        tot = 0;
        len = hextobin(buf + 2);
        for (x = 0; x != len; ++x) {
                tot += hextobin(buf + 2 + x * 2);
        }
        cksum = hextobin(buf + 2 + x * 2);
        tot = (255 & ~tot);
        if (tot != cksum) {
                fprintf(stderr, "Checksum mismatch on line %ld (got %x but calculated %x)\n", count, cksum, tot);
                return 1;
        } else {
                return 0;
        }
}
########################rank 7#############################
static void checksum(int i, dcomplex u1[NZ][NY][NX], int d[3]) {
    int j, q,r,s, ierr;
    dcomplex chk,allchk;
    chk.real = 0.0;
    chk.imag = 0.0;
#pragma omp for nowait
    for (j = 1; j <= 1024; j++) {
	q = j%NX+1;
	if (q >= xstart[0] && q <= xend[0]) {
            r = (3*j)%NY+1;
            if (r >= ystart[0] && r <= yend[0]) {
		s = (5*j)%NZ+1;
		if (s >= zstart[0] && s <= zend[0]) {
		  cadd(chk,chk,u1[s-zstart[0]][r-ystart[0]][q-xstart[0]]);
		}
	    }
	}
    }
#pragma omp critical
    {
	sums[i].real += chk.real;
	sums[i].imag += chk.imag;
    }
#pragma omp barrier
#pragma omp single
  {    
    sums[i].real = sums[i].real/(double)(NTOTAL);
    sums[i].imag = sums[i].imag/(double)(NTOTAL);
  }
}
########################rank 8#############################
int
libnet_do_checksum(libnet_t *l, uint8_t *iphdr, int protocol, int h_len)
{
    uint16_t ip_len = 0;
    struct libnet_ipv4_hdr* ip4 = (struct libnet_ipv4_hdr *)iphdr;
    struct libnet_ipv6_hdr* ip6 = (struct libnet_ipv6_hdr *)iphdr;
    if(ip4->ip_v == 6) {
        ip_len = ntohs(ip6->ip_len);
    } else {
        ip_len = ntohs(ip4->ip_len);
    }
    return libnet_inet_checksum(l, iphdr, protocol, h_len,
            iphdr, iphdr + ip_len
            );
}
########################rank 9#############################
static void ckptChecksum(u32 *aCkpt, u32 nCkpt, u32 *piCksum1, u32 *piCksum2){
  u32 i;
  u32 cksum1 = 1;
  u32 cksum2 = 2;
  if( nCkpt % 2 ){
    cksum1 += aCkpt[nCkpt-3] & 0x0000FFFF;
    cksum2 += aCkpt[nCkpt-3] & 0xFFFF0000;
  }
  for(i=0; (i+3)<nCkpt; i+=2){
    cksum1 += cksum2 + aCkpt[i];
    cksum2 += cksum1 + aCkpt[i+1];
  }
  *piCksum1 = cksum1;
  *piCksum2 = cksum2;
}
########################rank 10#############################
static void p_checksum_nop(int tic){} 
void (*P_Checksum)(int) = p_checksum_nop;
 * P_RecordChecksum
 * sets up the file and function pointers to write out checksum data
 */
static FILE *outfile = NULL;
static struct MD5Context md5global;
void P_RecordChecksum(const char *file) {
    size_t fnsize;
    fnsize = strlen(file);
    if(0 == strncmp("-",file,MIN(1,fnsize)))
        outfile = stdout;
    else {
        outfile = fopen(file,"wb");
        if(NULL == outfile) {
            I_Error("cannot open %s for writing checksum:\n%s\n",
                    file, strerror(errno));
        }
        atexit(p_checksum_cleanup);
    }
    MD5Init(&md5global);
    P_Checksum = checksum_gamestate;
}
----------------------------QUERY-------------------------------
judge whether two strings are equal
########################rank 1#############################
char *strupr( char *s )
{
  int i;
  for(i=0; i<strlen(s); i++ ) {
    s[i] = toupper(s[i]);
  }
  return s;
}
########################rank 2#############################
static char *my_string(char *s)
{  int length; char *str;
   while (isspace((unsigned char)*s)) s++;
   str = s; length = 0;
   while (isalnum((unsigned char)*s) || *s == '.' || *s == '_') { length++; s++; }
   if (length == 0) return NULL;
   else {
      if (length + 1 > POOLSIZE - poolsize)
         fatal("Out of memory %s\n", s);
      strncpy(stringpool+poolsize, str, length);
      str = stringpool + poolsize;
      s = stringpool + poolsize + length;
      *s = '\0';
      lastpoolsize = poolsize;
      poolsize += length+1;
      return str; 
   }
}
########################rank 3#############################
static const char *unused_string(
  const char *z,                    /* Result must not appear anywhere in z */
  const char *zA, const char *zB,   /* Try these first */
  char *zBuf                        /* Space to store a generated string */
){
  unsigned i = 0;
  if( strstr(z, zA)==0 ) return zA;
  if( strstr(z, zB)==0 ) return zB;
  do{
    sqlite3_snprintf(20,zBuf,"(%s%u)", zA, i++);
  }while( strstr(z,zBuf)!=0 );
  return zBuf;
}
########################rank 4#############################
int zstrnicmp(s1, s2, n)
    register ZCONST char *s1, *s2;
    register unsigned n;
{
    for (; n > 0;  --n, ++s1, ++s2) {
        if (ToLower(*s1) != ToLower(*s2))
            return ((uch)ToLower(*s1) < (uch)ToLower(*s2))? -1 : 1;
        if (*s1 == '\0')   /* both strings terminate early */
            return 0;
    }
    return 0;
}
########################rank 5#############################
char *Com_StringContains( char *str1, char *str2, int casesensitive ) {
	int len, i, j;
	len = strlen( str1 ) - strlen( str2 );
	for ( i = 0; i <= len; i++, str1++ ) {
		for ( j = 0; str2[j]; j++ ) {
			if ( casesensitive ) {
				if ( str1[j] != str2[j] ) {
					break;
				}
			} else {
				if ( toupper( str1[j] ) != toupper( str2[j] ) ) {
					break;
				}
			}
		}
		if ( !str2[j] ) {
			return str1;
		}
	}
	return NULL;
}
########################rank 6#############################
char *Com_StringContains( char *str1, char *str2, int casesensitive ) {
	int len, i, j;
	len = strlen( str1 ) - strlen( str2 );
	for ( i = 0; i <= len; i++, str1++ ) {
		for ( j = 0; str2[j]; j++ ) {
			if ( casesensitive ) {
				if ( str1[j] != str2[j] ) {
					break;
				}
			} else {
				if ( toupper( str1[j] ) != toupper( str2[j] ) ) {
					break;
				}
			}
		}
		if ( !str2[j] ) {
			return str1;
		}
	}
	return NULL;
}
########################rank 7#############################
const char *Com_StringContains( const char *str1, const char *str2, int casesensitive ) {
	int len, i, j;
	len = strlen( str1 ) - strlen( str2 );
	for ( i = 0; i <= len; i++, str1++ ) {
		for ( j = 0; str2[j]; j++ ) {
			if ( casesensitive ) {
				if ( str1[j] != str2[j] ) {
					break;
				}
			} else {
				if ( toupper( str1[j] ) != toupper( str2[j] ) ) {
					break;
				}
			}
		}
		if ( !str2[j] ) {
			return str1;
		}
	}
	return NULL;
}
########################rank 8#############################
int isexactlcmd(const char *p, const char *s)
{
  while(*p == *s && *s != '\t' && *s != '\0' ) { ++p; ++s; }
  if (*s == '\t' && isLaTeXcmdletter(*p) == 0) return 0;
  return 1;
}
########################rank 9#############################
char *Q_strupr( char *s ) {
	char *p;
	if( s ) {
		for( p = s; *s; s++ )
			*s = toupper( *s );
		return p;
	}
	return NULL;
}
########################rank 10#############################
static int
streqn(const char *s1, const char *s2)
{
	if (s1 == NULL)
		s1 = "";
	if (s2 == NULL)
		s2 = "";
	if (s1 == s2)
		return (1);
	return (strcmp(s1, s2) == 0);
}
----------------------------QUERY-------------------------------
return random integer value between min and max
########################rank 1#############################
static int random_val(int min, int max)
{
    double weight = rand()/(double) RAND_MAX;
    int result = min * (1-weight) + max * weight;
    return result;
}
########################rank 2#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%intrev32ifbe(is->length));
}
########################rank 3#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%intrev32ifbe(is->length));
}
########################rank 4#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%intrev32ifbe(is->length));
}
########################rank 5#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%intrev32ifbe(is->length));
}
########################rank 6#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%is->length);
}
########################rank 7#############################
int P_Random(void)
{
    prndindex = (prndindex + 1) & 0xff;
    return rndtable[prndindex];
}
########################rank 8#############################
int Random(void)
{
  int Return;
  Return = Table[Cur];
  Cur--;
  if(Cur < 0)
	Cur = Size;
  return Return;
}
########################rank 9#############################
int rand(void)
{
    unsigned long y;
    if (--left <= 0)
        next_state();
    y = *next++;
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);
    return ((unsigned int)y) >> 1;
}
########################rank 10#############################
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);
    if (!g_rng_function) {
        return 0;
    }
    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
        if (!uECC_vli_isZero(random, num_words) &&
		        uECC_vli_cmp(top, random, num_words) == 1) {
            return 1;
        }
    }
    return 0;
}
