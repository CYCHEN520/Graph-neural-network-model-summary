----------------------------QUERY-------------------------------
write a byte to output buffer of device
########################rank 1#############################
ssize_t
writen_ni(int fd, const void *buff, size_t n)
{
    size_t nl;
    ssize_t nw;
    const char *p;
    p = buff;
    nl = n;
    while (nl > 0) {
        do {
            nw = write(fd, p, nl);
        } while ( nw < 0 && errno == EINTR );
        if ( nw <= 0 ) break;
        nl -= nw;
        p += nw;
    }
    return n - nl;
}
########################rank 2#############################
void Write8(long long value, FILE* f) {
  fputc(value & 0xff, f);
  fputc((value >> 8) & 0xff, f);
  fputc((value >> 16) & 0xff, f);
  fputc((value >> 24) & 0xff, f);
  fputc((value >> 32) & 0xff, f);
  fputc((value >> 40) & 0xff, f);
  fputc((value >> 48) & 0xff, f);
  fputc((value >> 56) & 0xff, f);
}
########################rank 3#############################
static size_t FileOutStream_Write(const ISeqOutStream *pp, const void *data, size_t size)
{
	CFileOutStream *p = CONTAINER_FROM_VTBL(pp, CFileOutStream, vt);
	File_Write(&p->file, data, &size);
	return size;
}
########################rank 4#############################
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;
    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
	    if (errno != EINTR) /* interrupted by sig handler return */
		return -1;
	}
	else if (rp->rio_cnt == 0)  /* EOF */
	    return 0;
	else 
	    rp->rio_bufptr = rp->rio_buf; /* reset buffer ptr */
    }
    cnt = n;          
    if (rp->rio_cnt < n)   
	cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
########################rank 5#############################
static size_t FileOutStream_Write(const ISeqOutStream *pp, const void *data, size_t size)
{
  CFileOutStream *p = CONTAINER_FROM_VTBL(pp, CFileOutStream, vt);
  File_Write(&p->file, data, &size);
  return size;
}
########################rank 6#############################
static size_t FileOutStream_Write(const ISeqOutStream *pp, const void *data, size_t size)
{
  CFileOutStream *p = CONTAINER_FROM_VTBL(pp, CFileOutStream, vt);
  File_Write(&p->file, data, &size);
  return size;
}
########################rank 7#############################
static size_t FileOutStream_Write(const ISeqOutStream *pp, const void *data, size_t size)
{
  CFileOutStream *p = CONTAINER_FROM_VTBL(pp, CFileOutStream, vt);
  File_Write(&p->file, data, &size);
  return size;
}
########################rank 8#############################
static int Write32ToFile( FileStream *fid, uint32_t Val )
{
    size_t numw;
    uint8_t pad[4];
    Write32BigEndian(pad,Val);
    numw = sdWriteFile( pad, 1, sizeof(pad), fid );
    if( numw != sizeof(pad) ) return -1;
    return 0;
}
########################rank 9#############################
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n){
    int cnt;
    while (rp->rio_cnt <= 0){  
        rp->rio_cnt = read(rp->rio_fd, rp->rio_buf,
                           sizeof(rp->rio_buf));
        if (rp->rio_cnt < 0){
            if (errno != EINTR) /* interrupted by sig handler return */
                return -1;
        }
        else if (rp->rio_cnt == 0)  /* EOF */
            return 0;
        else
            rp->rio_bufptr = rp->rio_buf; /* reset buffer ptr */
    }
    cnt = n;
    if (rp->rio_cnt < n)
        cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
########################rank 10#############################
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;
    while (rp->rio_cnt <= 0) {  
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
	    if (errno != EINTR) /* Interrupted by sig handler return */
		return -1;
	}
	else if (rp->rio_cnt == 0)  /* EOF */
	    return 0;
	else 
	    rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */
    }
    cnt = n;          
    if (rp->rio_cnt < n)   
	cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
----------------------------QUERY-------------------------------
insert a new value into list
########################rank 1#############################
struct ListNode* reverseList_1(struct ListNode *head) {
    if (head == NULL) return NULL;
    if (head->next == NULL) return head;
    struct ListNode *new_head, *new_tail;
    new_head = reverseList_1(head->next);
    new_tail = head->next; 
    new_tail->next = head;                  
    head->next = NULL;
    return new_head;
}
########################rank 2#############################
SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(
  sqlite3 *db,        /* Connection to notify of malloc failures */
  SrcList *pList,     /* Append to this SrcList. NULL creates a new SrcList */
  Token *pTable,      /* Table to append */
  Token *pDatabase    /* Database of the table */
){
  struct SrcList_item *pItem;
  assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */
  assert( db!=0 );
  if( pList==0 ){
    pList = sqlite3DbMallocRawNN(db, sizeof(SrcList) );
    if( pList==0 ) return 0;
    pList->nAlloc = 1;
    pList->nSrc = 1;
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    pList->a[0].iCursor = -1;
  }else{
    pList = sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc);
  }
  if( db->mallocFailed ){
    sqlite3SrcListDelete(db, pList);
    return 0;
  }
  pItem = &pList->a[pList->nSrc-1];
  if( pDatabase && pDatabase->z==0 ){
    pDatabase = 0;
  }
  if( pDatabase ){
    pItem->zName = sqlite3NameFromToken(db, pDatabase);
    pItem->zDatabase = sqlite3NameFromToken(db, pTable);
  }else{
    pItem->zName = sqlite3NameFromToken(db, pTable);
    pItem->zDatabase = 0;
  }
  return pList;
}
########################rank 3#############################
SQLITE_PRIVATE SrcList *wx_sqlite3SrcListAppend(
  wx_sqlite3 *db,        /* Connection to notify of malloc failures */
  SrcList *pList,     /* Append to this SrcList. NULL creates a new SrcList */
  Token *pTable,      /* Table to append */
  Token *pDatabase    /* Database of the table */
){
  struct SrcList_item *pItem;
  assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */
  assert( db!=0 );
  if( pList==0 ){
    pList = wx_sqlite3DbMallocRawNN(db, sizeof(SrcList) );
    if( pList==0 ) return 0;
    pList->nAlloc = 1;
    pList->nSrc = 1;
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    pList->a[0].iCursor = -1;
  }else{
    pList = wx_sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc);
  }
  if( db->mallocFailed ){
    wx_sqlite3SrcListDelete(db, pList);
    return 0;
  }
  pItem = &pList->a[pList->nSrc-1];
  if( pDatabase && pDatabase->z==0 ){
    pDatabase = 0;
  }
  if( pDatabase ){
    pItem->zName = wx_sqlite3NameFromToken(db, pDatabase);
    pItem->zDatabase = wx_sqlite3NameFromToken(db, pTable);
  }else{
    pItem->zName = wx_sqlite3NameFromToken(db, pTable);
    pItem->zDatabase = 0;
  }
  return pList;
}
########################rank 4#############################
alpm_list_t SYMEXPORT *alpm_list_append(alpm_list_t **list, void *data)
{
	alpm_list_t *ptr;
	ptr = malloc(sizeof(alpm_list_t));
	if(ptr == NULL) {
		return NULL;
	}
	ptr->data = data;
	ptr->next = NULL;
	if(*list == NULL) {
		*list = ptr;
		ptr->prev = ptr;
	} else {
		alpm_list_t *lp = alpm_list_last(*list);
		lp->next = ptr;
		ptr->prev = lp;
		(*list)->prev = ptr;
	}
	return ptr;
}
########################rank 5#############################
SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(
  sqlite3 *db,       /* Database connection to notify of OOM errors */
  SrcList *pSrc,     /* The SrcList to be enlarged */
  int nExtra,        /* Number of new slots to add to pSrc->a[] */
  int iStart         /* Index in pSrc->a[] of first new slot */
){
  int i;
  assert( iStart>=0 );
  assert( nExtra>=1 );
  assert( pSrc!=0 );
  assert( iStart<=pSrc->nSrc );
  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
    SrcList *pNew;
    int nAlloc = pSrc->nSrc*2+nExtra;
    int nGot;
    pNew = sqlite3DbRealloc(db, pSrc,
               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );
    if( pNew==0 ){
      assert( db->mallocFailed );
      return pSrc;
    }
    pSrc = pNew;
    nGot = (sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc))/sizeof(pSrc->a[0])+1;
    pSrc->nAlloc = nGot;
  }
  ** out of the way */
  for(i=pSrc->nSrc-1; i>=iStart; i--){
    pSrc->a[i+nExtra] = pSrc->a[i];
  }
  pSrc->nSrc += nExtra;
  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++){
    pSrc->a[i].iCursor = -1;
  }
  return pSrc;
}
########################rank 6#############################
SQLITE_PRIVATE SrcList *systemdata_sqlite3SrcListEnlarge(
  systemdata_sqlite3 *db,       /* Database connection to notify of OOM errors */
  SrcList *pSrc,     /* The SrcList to be enlarged */
  int nExtra,        /* Number of new slots to add to pSrc->a[] */
  int iStart         /* Index in pSrc->a[] of first new slot */
){
  int i;
  assert( iStart>=0 );
  assert( nExtra>=1 );
  assert( pSrc!=0 );
  assert( iStart<=pSrc->nSrc );
  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
    SrcList *pNew;
    int nAlloc = pSrc->nSrc*2+nExtra;
    int nGot;
    pNew = systemdata_sqlite3DbRealloc(db, pSrc,
               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );
    if( pNew==0 ){
      assert( db->mallocFailed );
      return pSrc;
    }
    pSrc = pNew;
    nGot = (systemdata_sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc))/sizeof(pSrc->a[0])+1;
    pSrc->nAlloc = nGot;
  }
  ** out of the way */
  for(i=pSrc->nSrc-1; i>=iStart; i--){
    pSrc->a[i+nExtra] = pSrc->a[i];
  }
  pSrc->nSrc += nExtra;
  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++){
    pSrc->a[i].iCursor = -1;
  }
  return pSrc;
}
########################rank 7#############################
SQLITE_PRIVATE SrcList *wx_sqlite3SrcListEnlarge(
  wx_sqlite3 *db,       /* Database connection to notify of OOM errors */
  SrcList *pSrc,     /* The SrcList to be enlarged */
  int nExtra,        /* Number of new slots to add to pSrc->a[] */
  int iStart         /* Index in pSrc->a[] of first new slot */
){
  int i;
  assert( iStart>=0 );
  assert( nExtra>=1 );
  assert( pSrc!=0 );
  assert( iStart<=pSrc->nSrc );
  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
    SrcList *pNew;
    int nAlloc = pSrc->nSrc*2+nExtra;
    int nGot;
    pNew = wx_sqlite3DbRealloc(db, pSrc,
               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );
    if( pNew==0 ){
      assert( db->mallocFailed );
      return pSrc;
    }
    pSrc = pNew;
    nGot = (wx_sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc))/sizeof(pSrc->a[0])+1;
    pSrc->nAlloc = nGot;
  }
  ** out of the way */
  for(i=pSrc->nSrc-1; i>=iStart; i--){
    pSrc->a[i+nExtra] = pSrc->a[i];
  }
  pSrc->nSrc += nExtra;
  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++){
    pSrc->a[i].iCursor = -1;
  }
  return pSrc;
}
########################rank 8#############################
struct json_object_iterator
json_object_iter_begin(struct json_object* obj)
{
    struct json_object_iterator iter;
    struct lh_table* pTable;
    /// @note json_object_get_object will return NULL if passed NULL
    ///       or a non-json_type_object instance
    pTable = json_object_get_object(obj);
    JASSERT(NULL != pTable);
    /// @note For a pair-less Object, head is NULL, which matches our
    ///       definition of the "end" iterator
    iter.opaque_ = pTable->head;
    return iter;
}
########################rank 9#############################
struct json_object_iterator
json_object_iter_begin(struct json_object* obj)
{
    struct json_object_iterator iter;
    struct lh_table* pTable;
    /// @note json_object_get_object will return NULL if passed NULL
    ///       or a non-json_type_object instance
    pTable = json_object_get_object(obj);
    JASSERT(NULL != pTable);
    /// @note For a pair-less Object, head is NULL, which matches our
    ///       definition of the "end" iterator
    iter.opaque_ = pTable->head;
    return iter;
}
########################rank 10#############################
struct json_object_iterator
json_object_iter_end(const struct json_object* obj)
{
    struct json_object_iterator iter;
    JASSERT(NULL != obj);
    JASSERT(json_object_is_type(obj, json_type_object));
    iter.opaque_ = kObjectEndIterValue;
    return iter;
}
----------------------------QUERY-------------------------------
check string is suffix of another string
########################rank 1#############################
char* modp_uitoa16(uint32_t value, char* str, int isfinal)
{
	static const char* hexchars = "0123456789ABCDEF";
#ifndef WORDS_BIGENDIAN
	str[0] = hexchars[(value >> 28) & 0x0000000F];
	str[1] = hexchars[(value >> 24) & 0x0000000F];
	str[2] = hexchars[(value >> 20) & 0x0000000F];
	str[3] = hexchars[(value >> 16) & 0x0000000F];
	str[4] = hexchars[(value >> 12) & 0x0000000F];
	str[5] = hexchars[(value >>  8) & 0x0000000F];
	str[6] = hexchars[(value >>  4) & 0x0000000F];
	str[7] = hexchars[(value ) & 0x0000000F];
#else
	str[0] = hexchars[(value ) & 0x0000000F];
	str[1] = hexchars[(value >>  4) & 0x0000000F];
	str[2] = hexchars[(value >>  8) & 0x0000000F];
	str[3] = hexchars[(value >> 12) & 0x0000000F];
	str[4] = hexchars[(value >> 16) & 0x0000000F];
	str[5] = hexchars[(value >> 20) & 0x0000000F];
	str[6] = hexchars[(value >> 24) & 0x0000000F];
	str[7] = hexchars[(value >> 28) & 0x0000000F];
#endif
	if (isfinal) {
		str[8] = '\0';
		return str;
	} else {
		return str + 8;
	}
}
########################rank 2#############################
unsigned int string_hash(void *string)
{
	unsigned int result = 5381;
	unsigned char *p;
	p = (unsigned char *) string;
	while (*p != '\0') {
		result = (result << 5) + result + *p;
		++p;
	}
	return result;
}
########################rank 3#############################
BINN_PRIVATE size_t strlen2(char *str) {
  if (str == NULL) return 0;
  return strlen(str);
}
########################rank 4#############################
int compare_str(const void * a, const void * b) {
	return strcmp(*(const char **)a, *(const char **)b);
}
########################rank 5#############################
long double atold(const char *str)
{
	return strtold(str, NULL);
}
########################rank 6#############################
char *strchr(const char *str, int c) 
{
    for (; *str; str++)
        if (*str == c) return (char*)++str;
    return (char*)0;
}
########################rank 7#############################
float atoff(const char *str)
{
	return strtof(str, NULL);
}
########################rank 8#############################
int len(char *s) {
    return strlen(s);
}
########################rank 9#############################
int len(char *s) {
    return strlen(s);
}
########################rank 10#############################
static
FT_String*  Get_Name( TT_Face face,
					  FT_UShort nameid ) {
	FT_Memory memory = face->root.memory;
	FT_UShort n;
	TT_NameRec*  rec;
	FT_Bool wide_chars = 1;
	rec = face->name_table.names;
	for ( n = 0; n < face->name_table.numNameRecords; n++, rec++ )
	{
		if ( rec->nameID == nameid ) {
			FT_Bool found = 0;
			if ( rec->platformID == TT_PLATFORM_MICROSOFT &&
				 rec->encodingID <= TT_MS_ID_UNICODE_CS   &&
				 ( rec->languageID & 0x3FF ) == 0x009     ) {
				found = 1;
			}
			else if ( rec->platformID == TT_PLATFORM_APPLE_UNICODE ) {
				found = 1;
			}
			else if ( rec->platformID == TT_PLATFORM_MACINTOSH &&
					  rec->languageID == TT_MAC_ID_ROMAN       ) {
				found      = 1;
				wide_chars = 0;
			}
			if ( found ) {
				FT_String*  string;
				FT_UInt len;
				if ( wide_chars ) {
					FT_UInt m;
					len = (FT_UInt)rec->stringLength / 2;
					if ( MEM_Alloc( string, len + 1 ) ) {
						return NULL;
					}
					for ( m = 0; m < len; m++ )
						string[m] = rec->string[2 * m + 1];
				} else
				{
					len = rec->stringLength;
					if ( MEM_Alloc( string, len + 1 ) ) {
						return NULL;
					}
					MEM_Copy( string, rec->string, len );
				}
				string[len] = '\0';
				return string;
			}
		}
	}
	return NULL;
}
----------------------------QUERY-------------------------------
remove all elements in list
########################rank 1#############################
tommy_inline void tommy_list_set(tommy_list* list, tommy_node* head, tommy_node* tail)
{
	head->prev = tail;
	tail->next = 0;
	*list = head;
}
########################rank 2#############################
static void DiscardContainer(Node *element, Node **pnode)
{
    Node *node, *parent = element->parent;
    if (element->content)
    {
        element->last->next = element->next;
        if (element->next)
        {
            element->next->prev = element->last;
            element->last->next = element->next;
        }
        else
            parent->last = element->last;
        if (element->prev)
        {
            element->content->prev = element->prev;
            element->prev->next = element->content;
        }
        else
            parent->content = element->content;
        for (node = element->content; node; node = node->next)
            node->parent = parent;
        *pnode = element->content;
    }
    else
    {
        if (element->next)
            element->next->prev = element->prev;
        else
            parent->last = element->prev;
        if (element->prev)
            element->prev->next = element->next;
        else
            parent->content = element->next;
        *pnode = element->next;
    }
    element->next = element->content = null;
    FreeNode(element);
}
########################rank 3#############################
struct nodelist *
nindex(s)
register char *s;
{
    register struct nodelist *i;
    register char *t;
    for(i= &firstnode; i->nextnode!=NULL; i=i->nextnode)
        if(cmp(s,i->name))
            return(i);
    for(t=s; *t; t++) ;
    t = malloc((unsigned)(t+1-s));
    i->nextnode = (struct nodelist *)malloc(sizeof(struct nodelist));
    if(i->nextnode==NULL||t==NULL)
        error("too many items",empty);
    i->name = t;
    i->live = LIVE;
    i->nextnode->nextnode = NULL;
    i->nextnode->inedges = NULL;
    i->nextnode->live = DEAD;
    while(*t++ = *s++);
    return(i);
}
########################rank 4#############################
void 
ravl_free(struct RavlNode *node)
{
    if (node != NULL) {
        ravl_free(node->left);
        ravl_free(node->right);
        free(node);
    }
}
########################rank 5#############################
void list_delete_at(list_t *list, int i)
{
    if(i >= list->num_objs || i < 0)
        return;
    list->obj_free(list->obj_arr[i]);
    for(; i < list->num_objs - 1; i++)
        list->obj_arr[i] = list->obj_arr[i+1];
    list->obj_arr[i] = NULL;
    list->num_objs--;
}
########################rank 6#############################
void *
listRemoveElement(DLLIST  **phead,
                  DLLIST   *elem)
{
void    *data;
DLLIST  *head;
    PROCNAME("listRemoveElement");
    if (!phead)
        return (void *)ERROR_PTR("&head not defined", procName, NULL);
    head = *phead;
    if (!head)
        return (void *)ERROR_PTR("head not defined", procName, NULL);
    if (!elem)
        return (void *)ERROR_PTR("elem not defined", procName, NULL);
    data = elem->data;
    if (head->next == NULL) {  /* only one */
        if (elem != head)
            return (void *)ERROR_PTR("elem must be head", procName, NULL);
        *phead = NULL;
    }
    else if (head == elem) {   /* first one */
        elem->next->prev = NULL;
        *phead = elem->next;
    }
    else if (elem->next == NULL) {   /* last one */
        elem->prev->next = NULL;
    }
    else {  /* neither the first nor the last one */
        elem->next->prev = elem->prev;
        elem->prev->next = elem->next;
    }
    FREE(elem);
    return data;
}
########################rank 7#############################
void InsertNodeBeforeElement(Node *element, Node *node)
{
    Node *parent;
    parent = element->parent;
    node->parent = parent;
    node->next = element;
    node->prev = element->prev;
    element->prev = node;
    if (node->prev)
        node->prev->next = node;
    if (parent->content == element)
        parent->content = node;
}
########################rank 8#############################
int list_add_item_before(List_t * list, int idx, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// Move to right before list index or return 1 if no such index
	while(idx-1 > 0){
		// Insert after last item in list
		if(!nextItem->next){ // Index doesn't exist
			return(0);
		}else{
			nextItem = nextItem->next;
			idx--;
		}
	}
	// Add item after current "nextItem" pointed too.
	if(nextItem->next){ // Middle of list
		if(!li->next){
			ListItem_t * tmpItem = list_item_initialize();
			// Save next item in list
			tmpItem = nextItem->next;
			// Attach new item to current item's next pointer
			nextItem->next = li;
			// Attach "old" next item pointer 
			li->next = tmpItem;
			return(1);
		}else{
			return(0);
		}
	}else if(!nextItem->next){ // End of list
		if(!li->next){
			nextItem->next = li;
			return(1);
		}else{
			return(0);
		}
	}
	return(0);
}
########################rank 9#############################
static void __config_list_destroy(config_list_t *list)
{
  config_setting_t **p;
  unsigned int i;
  if(! list)
    return;
  if(list->elements)
  {
    for(p = list->elements, i = 0; i < list->length; p++, i++)
      __config_setting_destroy(*p);
    __delete(list->elements);
  }
  __delete(list);
}
########################rank 10#############################
void destroy_bstree(BSTree tree)
{
	if (tree==NULL)
		return ;
	if (tree->left != NULL)
		destroy_bstree(tree->left);
	if (tree->right != NULL)
		destroy_bstree(tree->right);
	free(tree);
}
----------------------------QUERY-------------------------------
stop logging messages to syslog
########################rank 1#############################
channel_t*  S_ChannelMalloc() {
	channel_t *v;
	if ( freelist == NULL ) {
		return NULL;
	}
	v = freelist;
	freelist = *(channel_t **)freelist;
	v->allocTime = Sys_Milliseconds();
	return v;
}
########################rank 2#############################
void ptrace_detach(pid_t target)
{
	if(ptrace(PTRACE_DETACH, target, NULL, NULL) == -1)
	{
		fprintf(stderr, "ptrace(PTRACE_DETACH) failed\n");
		exit(1);
	}
}
########################rank 3#############################
static void
lock_option(struct mg_context *ctx, int opt_index)
{
	if (pthread_mutex_lock(&ctx->opt_mutex[opt_index]) != 0)
		cry(fc(ctx), "pthread_mutex_lock: %s", strerror(ERRNO));
}
########################rank 4#############################
failcmdline(foo) VOID * foo;
#endif 
{
#ifdef GEMDOS
    cc_clean();
#endif /* GEMDOS */
#ifndef NOLOCAL
    if (cnflg) doconect(0,0);           /* connect again if requested. */
    if (ttchk() < 0)
      dologend();
#endif /* NOLOCAL */
}
########################rank 5#############################
int xdag_mining_start(int n_mining_threads)
{
	pthread_t th;
	if(n_mining_threads == g_xdag_mining_threads) {
	} else if(!n_mining_threads) {
		g_stop_mining = 1;
		g_xdag_mining_threads = 0;
	} else if(!g_xdag_mining_threads) {
		g_stop_mining = 0;
	} else if(g_xdag_mining_threads > n_mining_threads) {
		g_stop_mining = 1;
		sleep(5);
		g_stop_mining = 0;
		g_xdag_mining_threads = 0;
	}
	while(g_xdag_mining_threads < n_mining_threads) {
		g_xdag_mining_threads++;
		int err = pthread_create(&th, 0, mining_thread, (void*)(uintptr_t)g_xdag_mining_threads);
		if(err != 0) {
			printf("create mining_thread failed, error : %s\n", strerror(err));
			continue;
		}
		err = pthread_detach(th);
		if(err != 0) {
			printf("detach mining_thread failed, error : %s\n", strerror(err));
			continue;
		}
	}
	return 0;
}
########################rank 6#############################
void
pixie_close_thread(ptrdiff_t thread_handle)
{
#if defined(WIN32)
	CloseHandle((HANDLE)thread_handle);
#elif defined(__GNUC__)
#else
#error pixie_close_thread undefined
#endif
}
########################rank 7#############################
void
zed_log_pipe_open(void)
{
	if ((_ctx.pipe_fd[0] != -1) || (_ctx.pipe_fd[1] != -1))
		zed_log_die("Invalid use of zed_log_pipe_open in PID %d",
		    (int) getpid());
	if (pipe(_ctx.pipe_fd) < 0)
		zed_log_die("Failed to create daemonize pipe in PID %d: %s",
		    (int) getpid(), strerror(errno));
}
########################rank 8#############################
void
pit_irq0_timer(int new_out, int old_out)
{
    if (new_out && !old_out)
	picint(1);
    if (!new_out)
	picintc(1);
}
########################rank 9#############################
failoseq(threadinfo) VOID * threadinfo;
#endif 
     oseqret = -1;		/* else -- alarm rang */
     SIGRETURN;
}
########################rank 10#############################
void
zed_log_syslog_close(void)
{
	if (_ctx.do_syslog) {
		_ctx.do_syslog = 0;
		closelog();
	}
}
----------------------------QUERY-------------------------------
render bignum into decimal
########################rank 1#############################
static void mp_mul_add_simple(mp_int *r, mp_int *a, mp_int *b)
{
    BignumInt *aend = a->w + a->nw, *bend = b->w + b->nw, *rend = r->w + r->nw;
    for (BignumInt *ap = a->w, *rp = r->w;
         ap < aend && rp < rend; ap++, rp++) {
        BignumInt adata = *ap, carry = 0, *rq = rp;
        for (BignumInt *bp = b->w; bp < bend && rq < rend; bp++, rq++) {
            BignumInt bdata = bp < bend ? *bp : 0;
            BignumMULADD2(carry, *rq, adata, bdata, *rq, carry);
        }
        for (; rq < rend; rq++)
            BignumADC(*rq, carry, carry, *rq, 0);
    }
}
########################rank 2#############################
void bitset_clr(Bitset *set, int bit)
{
	int byte = (bit >> 3);
	bit = (1 << (bit & 7));
	if (byte >= set->size)
		bitset_expand(set, byte + 1);
	set->map[byte] &= ~bit;
}
########################rank 3#############################
void bitset_set(Bitset *set, int bit)
{
	int byte = (bit >> 3);
	bit = (1 << (bit & 7));
	if (byte >= set->size)
		bitset_expand(set, byte + 1);
	set->map[byte] |= bit;
}
########################rank 4#############################
double dotProd(const double *x1, const double *x2)
{
	return(x1[0]*x2[0]+x1[1]*x2[1]+x1[2]*x2[2]);
}
########################rank 5#############################
int print_integer(cell n) {
	if (!integer_p(n))
		return 0;
	print_bignum(n);
	return 1;
}
########################rank 6#############################
int bitset_tst(Bitset *set, int bit)
{
	int byte = (bit >> 3);
	bit = (1 << (bit & 7));
	if (byte >= set->size)
		return 0;
	else if (set->map[byte] & bit)
		return 1;
	else
		return 0;
}
########################rank 7#############################
unsigned unsigned_high_prod(unsigned x, unsigned y)
{
        int x_highest_bit = (x & INT_MIN) == INT_MIN;
        int y_highest_bit = (y & INT_MIN) == INT_MIN;
        int result = signed_high_prod(x, y) + x * y_highest_bit + y * x_highest_bit;
        return result;
}
########################rank 8#############################
int
bnAddQ_32(struct BigNum *dest, unsigned src)
{
	BNWORD32 t;
	if (!dest->size)
		return bnSetQ(dest, src);
	t = lbnAdd1_32((BNWORD32 *)dest->ptr, dest->size, (BNWORD32)src);
	MALLOCDB;
	if (t) {
		src = dest->size;
		bnSizeCheck(dest, src+1);
		((BNWORD32 *)dest->ptr)[BIGLITTLE(-1-src,src)] = t;
		dest->size = src+1;
	}
	return 0;
}
########################rank 9#############################
int
bnAddQ_64(struct BigNum *dest, unsigned src)
{
	BNWORD64 t;
	if (!dest->size)
		return bnSetQ(dest, src);
	t = lbnAdd1_64((BNWORD64 *)dest->ptr, dest->size, (BNWORD64)src);
	MALLOCDB;
	if (t) {
		src = dest->size;
		bnSizeCheck(dest, src+1);
		((BNWORD64 *)dest->ptr)[BIGLITTLE(-1-src,src)] = t;
		dest->size = src+1;
	}
	return 0;
}
########################rank 10#############################
int
bnAddQ_16(struct BigNum *dest, unsigned src)
{
	BNWORD16 t;
	if (!dest->size)
		return bnSetQ(dest, src);
	t = lbnAdd1_16((BNWORD16 *)dest->ptr, dest->size, (BNWORD16)src);
	MALLOCDB;
	if (t) {
		src = dest->size;
		bnSizeCheck(dest, src+1);
		((BNWORD16 *)dest->ptr)[BIGLITTLE(-1-src,src)] = t;
		dest->size = src+1;
	}
	return 0;
}
----------------------------QUERY-------------------------------
look for match name in system dictionary
########################rank 1#############################
const struct Cfg_AddrMatchList *
cfg_addrlist_lookup(const struct Configuration *cfg, const char *name)
{
    size_t i;
    for (i=0; i<cfg->acls_length; i++) {
        if (strcmp(name, cfg->acls[i]->name) == 0)
            return cfg->acls[i];
    }
    return 0;
}
########################rank 2#############################
int iniparser_getsecnkeys(dictionary * d, char * s)
{
    int     seclen, nkeys ;
    char    keym[ASCIILINESZ+1];
    int j ;
    nkeys = 0;
    if (d==NULL) return nkeys;
    if (! iniparser_find_entry(d, s)) return nkeys;
    seclen  = (int)strlen(s);
    snprintf(keym, ASCIILINESZ, "%s:", s);
    for (j=0 ; j<d->size ; j++) {
        if (d->key[j]==NULL)
            continue ;
        if (!strncmp(d->key[j], keym, seclen+1))
            nkeys++;
    }
    return nkeys;
}
########################rank 3#############################
const struct Cfg_Key *
cfg_key_lookup(const struct Configuration *cfg, const char *name)
{
    size_t i;
    for (i=0; i<cfg->keys_length; i++) {
        if (strcmp(name, cfg->keys[i]->name) == 0)
            return cfg->keys[i];
    }
    return 0;
}
########################rank 4#############################
static struct CNDB_Database *db = NULL;
static const char *
cndb_lookup(unsigned ip)
{
    const struct CNDB_Entry *entry;
    if (db == NULL)
        return 0;
    entry = db->entries[ip&0xFFFF];
    while (entry && entry->ip != ip)
        entry = entry->next;
    if (entry)
        return entry->name;
    else {
        return 0;
    }
}
########################rank 5#############################
stree_embr_t *stree_enum_find_mbr(stree_enum_t *enum_d, stree_ident_t *ident)
{
	list_node_t *embr_n;
	stree_embr_t *embr;
	embr_n = list_first(&enum_d->members);
	while (embr_n != NULL) {
		embr = list_node_data(embr_n, stree_embr_t *);
		if (embr->name->sid == ident->sid)
			return embr;
		embr_n = list_next(&enum_d->members, embr_n);
	}
	return NULL;
}
########################rank 6#############################
hostlist_t _hostlist_create(const char *hostlist, char *sep, char *r_op) 
{
    return _hostlist_create_bracketed(hostlist, sep, r_op);
}
########################rank 7#############################
hostlist_t _hostlist_create(const char *hostlist, char *sep, char *r_op) 
{
    return _hostlist_create_bracketed(hostlist, sep, r_op);
}
########################rank 8#############################
int
putenv( entry )
  char *entry;
{
  unsigned length;
  unsigned size;
  char     *temp;
  char     **p;
  char     **new_environ;
  temp = strchr(entry,'=');
  if ( temp == 0 )
    return( -1 );
  length = (unsigned) (temp - entry + 1);
  for ( p=environ; *p != 0 ; p++ )
    if ( strncmp( entry, *p, length ) == 0 )
      {
      *p = entry;
      return( 0 );
      }
  size = p - environ;
  new_environ = (char **) malloc( (size+2)*PSIZE );
  if ( new_environ == (char **) NULL )
    return( -1 );
  memcpy ((char *) new_environ, (char *) environ, size*PSIZE );
  new_environ[size]   = entry;
  new_environ[size+1] = NULL;
  environ = new_environ;
  return(0);
}
########################rank 9#############################
int iniparser_getsecnkeys(dictionary * d, char * s)
{
    int     seclen, nkeys ;
    char    keym[ASCIILINESZ+1];
    int j ;
    nkeys = 0;
    if (d==NULL) return nkeys;
    if (! iniparser_find_entry(d, s)) return nkeys;
    seclen  = (int)strlen(s);
    sprintf(keym, "%s:", s);
    for (j=0 ; j<d->size ; j++) {
        if (d->key[j]==NULL)
            continue ;
        if (!strncmp(d->key[j], keym, seclen+1)) 
            nkeys++;
    }
    return nkeys;
}
########################rank 10#############################
unsigned long hash(char *n)
{
        unsigned char *name = (unsigned char *)n;
	unsigned long accu = 0;
	while (*name)
		accu = accu * 34857 + *name++;
	return accu;
}
----------------------------QUERY-------------------------------
remove an element from a row vector
########################rank 1#############################
void
sm_row_remove(prow, col)
register sm_row *prow;
register int col;
{
    register sm_element *p;
    for(p = prow->first_col; p != 0 && p->col_num < col; p = p->next_col)
	;
    if (p != 0 && p->col_num == col) {
	dll_unlink(p, prow->first_col, prow->last_col, 
			    next_col, prev_col, prow->length);
	sm_element_free(p);
    }
}
########################rank 2#############################
int BotImport_PointContents( vec3_t point ) {
	return SV_PointContents( point, -1 );
}
########################rank 3#############################
int BotImport_PointContents( vec3_t point ) {
	return SV_PointContents( point, -1 );
}
########################rank 4#############################
l_int32
pixcmapAddBlackOrWhite(PIXCMAP  *cmap,
                       l_int32   color,
                       l_int32  *pindex)
{
l_int32  index;
    PROCNAME("pixcmapAddBlackOrWhite");
    if (pindex) *pindex = 0;
    if (!cmap)
        return ERROR_INT("cmap not defined", procName, 1);
    if (color == 0) {  /* black */
        if (pixcmapGetFreeCount(cmap) > 0)
            pixcmapAddNewColor(cmap, 0, 0, 0, &index);
        else
            pixcmapGetRankIntensity(cmap, 0.0, &index);
    }
    else {  /* white */
        if (pixcmapGetFreeCount(cmap) > 0)
            pixcmapAddNewColor(cmap, 255, 255, 255, &index);
        else
            pixcmapGetRankIntensity(cmap, 1.0, &index);
    }
    if (pindex)
        *pindex = index;
    return 0;
}
########################rank 5#############################
void linenoiseEditBackspace(struct linenoiseState *l) {
  if (l->pos > 0 && l->len > 0) {
    int chlen = prevCharLen(l->buf, l->len, l->pos, NULL);
    memmove(l->buf + l->pos - chlen, l->buf + l->pos, l->len - l->pos);
    l->pos -= chlen;
    l->len -= chlen;
    l->buf[l->len] = '\0';
    refreshLine(l);
  }
}
########################rank 6#############################
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}
########################rank 7#############################
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}
########################rank 8#############################
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}
########################rank 9#############################
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}
########################rank 10#############################
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        linenoiseRefreshLine();
    }
}
----------------------------QUERY-------------------------------
load a bignum from int
########################rank 1#############################
static int read_radix(void *a, const char *b, int radix) {
    LTC_ARGCHK(a != NULL);
    LTC_ARGCHK(b != NULL);
    return mpi_to_ltc_error(mp_read_radix(a, b, radix));
}
########################rank 2#############################
static int read_radix(void *a, const char *b, int radix)
{
   LTC_ARGCHK(a != NULL);
   LTC_ARGCHK(b != NULL);
   return mpi_to_ltc_error(mp_read_radix(a, b, radix));
}
########################rank 3#############################
static int unsigned_read(void *a, unsigned char *b, unsigned long len) {
    LTC_ARGCHK(a != NULL);
    LTC_ARGCHK(b != NULL);
    return mpi_to_ltc_error(mp_read_unsigned_bin(a, b, len));
}
########################rank 4#############################
static int unsigned_read(void *a, unsigned char *b, unsigned long len)
{
   LTC_ARGCHK(a != NULL);
   LTC_ARGCHK(b != NULL);
   return mpi_to_ltc_error(mp_read_unsigned_bin(a, b, len));
}
########################rank 5#############################
a_uint
adb_24_bit(v, i)
a_uint v;
int i;
{
        a_uint j;
        j = adb_24_lo(v, i) & 0xFF;
        if ((j >= 0x20) && (j <= 0x2F)) {
                j = (j - 0x20) * 8;
        } else if ((j < 0x80) || ((j & 0x07) != 0)) {
                return(0x100);//error
        }
        if (hilo) {
                j = rtval[i+2] = j + (rtval[i+1] & 0x07);
        } else {
                j = rtval[i] = j + (rtval[i+1] & 0x07);
        }
        return(j);
}
########################rank 6#############################
int unqlite_value_is_scalar(unqlite_value *pVal)
{
	return jx9_value_is_scalar(pVal);
}
########################rank 7#############################
int
pbs_bitmap_is_equal(pbs_bitmap *L, pbs_bitmap *R)
{
	int i;
	if(L == NULL || R == NULL)
		return 0;
	if (L->num_bits != R->num_bits)
		return 0;
	for(i = 0; i < L->num_longs; i++)
		if(L->bits[i] != R->bits[i])
			return 0;
	return 1;
}
########################rank 8#############################
static INLINE char*
EmitLiteral(char *op, const char *literal, int len, int allow_fast_path)
{
	int n = len - 1; 
	if (n < 60) {
		*op++ = LITERAL | (n << 2);
		The vast majority of copies are below 16 bytes, for which a
		call to memcpy is overkill. This fast path can sometimes
		copy up to 15 bytes too much, but that is okay in the
		main loop, since we have a bit to go on for both sides:
		- The input will always have kInputMarginBytes = 15 extra
		available bytes, as long as we're in the main loop, and
		if not, allow_fast_path = false.
		- The output will always have 32 spare bytes (see
		snappy_max_compressed_length).
		*/
		if (allow_fast_path && len <= 16) {
			UnalignedCopy64(literal, op);
			UnalignedCopy64(literal + 8, op + 8);
			return op + len;
		}
	} else {
		char *base = op;
		int count = 0;
		op++;
		while (n > 0) {
			*op++ = n & 0xff;
			n >>= 8;
			count++;
		}
		DCHECK_GE(count, 1);
		DCHECK_LE(count, 4);
		*base = LITERAL | ((59+count) << 2);
	}
	memcpy(op, literal, len);
	return op + len;
}
########################rank 9#############################
int ssh2_bignum_length(Bignum bn)
{
  return 4 + (bignum_bitcount(bn) + 8) / 8;
}
########################rank 10#############################
int read_int4_array(int f, int *iarray, int n)
{
#ifdef _CRAY
    int j, nread;
    int *buffer;
    buffer = (int *)G_malloc((n + 1) * 4);
    if (!buffer)
	return 0;
    nread = read(f, buffer, 4 * n);
    if (nread <= 0) {
	return 0;
    }
    nread /= 4;
    for (j = 0; j < nread; j++) {
	if ((j & 1) == 0) {
	    iarray[j] = buffer[j / 2] >> 32;
	}
	else {
	    iarray[j] = buffer[j / 2] & 0xffffffff;
	}
    }
    G_free(buffer);
    return nread;
#else
    int nread = read(f, iarray, 4 * n);
    if (nread <= 0)
	return 0;
#  ifdef LITTLE
    flip4((const unsigned int *)iarray, (unsigned int *)iarray, nread / 4);
#  endif
    return nread / 4;
#endif
}
----------------------------QUERY-------------------------------
grab a lock on a mutex
########################rank 1#############################
SQLITE_API int wx_sqlite3_backup_pagecount(wx_sqlite3_backup *p){
#ifdef SQLITE_ENABLE_API_ARMOR
  if( p==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  return p->nPagecount;
}
########################rank 2#############################
static int robust_ftruncate(int h, keen_io_sqlite3_int64 sz){
  int rc;
  do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );
  return rc;
}
########################rank 3#############################
static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
  UNUSED_PARAMETER(NotUsed);
  UNUSED_PARAMETER(NotUsed2);
  UNUSED_PARAMETER(NotUsed3);
  return errno;
}
########################rank 4#############################
static int rbuVfsGetLastError(sqlite3_vfs *pVfs, int a, char *b){
  return 0;
}
########################rank 5#############################
static int unixSetSystemCall(
  keen_io_sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */
  const char *zName,            /* Name of system call to override */
  keen_io_sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */
){
  unsigned int i;
  int rc = SQLITE_NOTFOUND;
  UNUSED_PARAMETER(pNotUsed);
  if( zName==0 ){
    ** settings and return NULL
    */
    rc = SQLITE_OK;
    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( aSyscall[i].pDefault ){
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
    }
  }else{
    ** specified.
    */
    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ){
        if( aSyscall[i].pDefault==0 ){
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = SQLITE_OK;
        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
    }
  }
  return rc;
}
########################rank 6#############################
static int UnixVfs_gid(void)
{
	return (int)getgid();
}
########################rank 7#############################
static int unixGetLastError(keen_io_sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
  UNUSED_PARAMETER(NotUsed);
  UNUSED_PARAMETER(NotUsed2);
  UNUSED_PARAMETER(NotUsed3);
  return 0;
}
########################rank 8#############################
static int UnixVfs_gid(void)
{
	return (int)getgid();
}
########################rank 9#############################
static int UnixVfs_gid(void)
{
	return (int)getgid();
}
########################rank 10#############################
static int UnixVfs_gid(void)
{
	return (int)getgid();
}
----------------------------QUERY-------------------------------
free storage for various packet type
########################rank 1#############################
static int
kvs_put(strm_stream* strm, int argc, strm_value* args, strm_value* ret)
{
  strm_kvs* k = get_kvs(argc, args);
  strm_string key = strm_str_intern_str(strm_to_str(args[1]));
  khiter_t i;
  int st;
  if (!k) {
    strm_raise(strm, "no kvs given");
    return STRM_NG;
  }
  pthread_mutex_lock(&k->lock);
  i = kh_put(kvs, k->kv, key, &st);
  if (st < 0) {                 /* st<0: operation failed */
    pthread_mutex_unlock(&k->lock);
    return STRM_NG;
  }
  k->serial++;
  kh_value(k->kv, i) = args[2];
  pthread_mutex_unlock(&k->lock);
  return STRM_OK;
}
########################rank 2#############################
static int
kvs_update(strm_stream* strm, int argc, strm_value* args, strm_value* ret)
{
  strm_kvs* k = get_kvs(argc, args);
  strm_string key = strm_str_intern_str(strm_to_str(args[1]));
  strm_value old, val;
  khiter_t i;
  int st;
  if (!k) {
    strm_raise(strm, "no kvs given");
    return STRM_NG;
  }
  pthread_mutex_lock(&k->lock);
  i = kh_get(kvs, k->kv, key);
  if (i == kh_end(k->kv)) {
    pthread_mutex_unlock(&k->lock);
    return STRM_NG;
  }
  old = kh_value(k->kv, i);
  pthread_mutex_unlock(&k->lock);
  if (strm_funcall(strm, args[2], 1, &old, &val) == STRM_NG) {
    pthread_mutex_unlock(&k->lock);
    return STRM_NG;
  }
  pthread_mutex_lock(&k->lock);
  i = kh_put(kvs, k->kv, key, &st);
  if (st != 0 || kh_value(k->kv, i) != old) {
    pthread_mutex_unlock(&k->lock);
    return STRM_NG;
  }
  k->serial++;
  kh_value(k->kv, i) = val;
  pthread_mutex_unlock(&k->lock);
  *ret = val;
  return STRM_OK;
}
########################rank 3#############################
int32 matrixRsaReadKeys(sslKeys_t **keys, char *certFile, char *privFile,
					 char *privPass, char *trustedCAFile)
{
	matrixStrDebugMsg("Error: Calling matrixRsaReadKeys against a library " \
					  "built without USE_FILE_SYSTEM defined\n", NULL);
	return -1;
}
########################rank 4#############################
int xdag_request_block(xdag_hash_t hash, struct xconnection *conn, int broadcast)
{
	struct xdag_block b;
	b.field[0].type = XDAG_MESSAGE_BLOCK_REQUEST << 4 | XDAG_FIELD_NONCE;
	b.field[0].time = b.field[0].end_time = 0;
	memcpy(&b.field[1], hash, sizeof(xdag_hash_t));
	memcpy(&b.field[2], &g_xdag_stats, sizeof(g_xdag_stats));
	add_main_timestamp((struct xdag_stats*)&b.field[2]);
	xdag_netdb_send((uint8_t*)&b.field[2] + sizeof(struct xdag_stats),
						 14 * sizeof(struct xdag_field) - sizeof(struct xdag_stats));
	xdag_send_packet(&b, conn, broadcast);
	return 0;
}
########################rank 5#############################
static int getnodes(DHT *dht, IP_Port ip_port, const uint8_t *public_key, const uint8_t *client_id,
                    const Node_format *sendback_node)
{
    if (id_equal(public_key, dht->self_public_key)) {
        return -1;
    }
    uint8_t plain_message[sizeof(Node_format) * 2] = {0};
    Node_format receiver;
    memcpy(receiver.public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    receiver.ip_port = ip_port;
    memcpy(plain_message, &receiver, sizeof(receiver));
    uint64_t ping_id = 0;
    if (sendback_node != nullptr) {
        memcpy(plain_message + sizeof(receiver), sendback_node, sizeof(Node_format));
        ping_id = ping_array_add(dht->dht_harden_ping_array, dht->mono_time, plain_message, sizeof(plain_message));
    } else {
        ping_id = ping_array_add(dht->dht_ping_array, dht->mono_time, plain_message, sizeof(receiver));
    }
    if (ping_id == 0) {
        return -1;
    }
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + sizeof(ping_id)];
    uint8_t data[1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE];
    memcpy(plain, client_id, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, &ping_id, sizeof(ping_id));
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    dht_get_shared_key_sent(dht, shared_key, public_key);
    const int len = dht_create_packet(dht->self_public_key, shared_key, NET_PACKET_GET_NODES,
                                      plain, sizeof(plain), data);
    if (len != sizeof(data)) {
        return -1;
    }
    return sendpacket(dht->net, ip_port, data, len);
}
########################rank 6#############################
void WEBSOCKET_generate_handshake( const char *data, char *dst, const unsigned int dst_len ) {
	char origin[ 512 ];
	char host[ 512 ];
	char additional_headers[ 2048 ];
	char sec_websocket_key[ 512 ];
	char sec_websocket_key_sha1[ 512 ];
	char sha1_part[ 32 ];
	SHA1Context sha;
	unsigned char sha1_hex[ 512 ];
	unsigned char sha1_tmp[ 512 ];
	unsigned char sec_websocket_accept[ 512 ];
	int source_len;
	int i;
	memset( sha1_hex, '\0', 512 );
	memset( sha1_tmp, '\0', 32 );
	memset( sec_websocket_accept, '\0', 512 );
	REQUEST_get_header_value( data, "Origin:", origin, 512 );
	REQUEST_get_header_value( data, "Host:", host, 512 );
	if( origin != NULL && host != NULL ) {
		sprintf( additional_headers, "Origin: %s\r\nHost: %s", origin, host );
	} else {
		sprintf( additional_headers, "Origin: %s\r\nHost: %s", "null", "null" );
	}
	REQUEST_get_header_value(data, WEBSOCKET_KEY_HEADER, sec_websocket_key, 512 );
	if( sec_websocket_key == NULL ) {
		dst = NULL;
		return;
	}
	strncat( sec_websocket_key, WEBSOCKET_MAGIC_STRING, 512 );
	SHA1Reset( &sha );
	SHA1Input( &sha, ( const unsigned char * ) sec_websocket_key, strlen( sec_websocket_key ) );
	SHA1Result( &sha );
	for( i = 0; i < 5; i++ ) {
		snprintf( sha1_part, 32, "%x", sha.Message_Digest[i] );
		strncat( sha1_tmp, sha1_part, 512 );
	}
	strncpy( sec_websocket_key_sha1, sha1_tmp, 512 );
	source_len = xstr2str( sha1_hex, 512, sec_websocket_key_sha1 );
	base64_encode( sha1_hex, source_len - 1, sec_websocket_accept, 512 );
	snprintf( dst, dst_len, WEBSOCKET_HANDSHAKE_RESPONSE, additional_headers, sec_websocket_accept );
}
########################rank 7#############################
int handle_message_dt_connection_ht_data(){
	int retval;
	struct message_helper *new_message, *tmp_message;
	struct connection_node *cur_connection_node;
	int count, errno;
	if((cur_connection_node = connection_node_find(message->header_origin, message->header_id)) == NULL){
		if(handle_send_dt_connection_ht_destroy(message->header_origin, message->header_id, 0) == -1){
			report_error("handle_message_dt_connection(): handle_send_dt_connection_ht_destroy(%d, %d, 0): %s", message->header_origin, message->header_id, strerror(errno));
			return(-1);
		}
		return(-2);
	}
	cur_connection_node->io_read += message->data_len;
	if(cur_connection_node->write_head){
		retval = 0;
	} else {
		retval = write(cur_connection_node->fd, message->data, message->data_len);
	}
	if(retval == -1){
		if(errno != EINTR && errno != EAGAIN && errno != EWOULDBLOCK){
			report_error("handle_message_dt_connection(): write(%d, %lx, %d): %s", \
					cur_connection_node->fd, (unsigned long) message->data, message->data_len, strerror(errno));
			if(handle_send_dt_connection_ht_destroy(cur_connection_node->origin, cur_connection_node->id, 0) == -1){
				report_error("handle_message_dt_connection(): handle_send_dt_connection_ht_destroy(%d, %d, 0): %s", cur_connection_node->origin, cur_connection_node->id, strerror(errno));
				return(-1);
			}
			connection_node_delete(cur_connection_node);
			return(-2);
		}
		retval = 0;
	}
	if(retval != message->data_len){
		new_message = message_helper_create(message->data + retval, message->data_len - retval, io->message_data_size);
		if(!new_message){
			report_error("handle_message_dt_connection(): message_helper_create(%lx, %d, %d): %s", \
					(unsigned long) message->data + retval, message->data_len - retval, io->message_data_size, strerror(errno));
			return(-1);
		}
		if(!cur_connection_node->write_head){
			cur_connection_node->write_head = new_message;
		}else{
			count = 1;
			tmp_message = cur_connection_node->write_head;
			while(tmp_message->next){
				tmp_message = tmp_message->next;
				count++;
			}
			tmp_message->next = new_message;
			if(count == MESSAGE_DEPTH_MAX){
				message->data_type = DT_CONNECTION;
				message->header_type = DT_CONNECTION_HT_DORMANT;
				message->header_origin = io->target;
				message->header_id = cur_connection_node->fd;
				message->data_len = 0;
				if((retval = message_push()) == -1){
					report_error("handle_message_dt_connection(): message_push(): %s", strerror(errno));
					return(-1);
				}
			}
		}
	}
	return(0);
}
########################rank 8#############################
void printLastPacketInfo(int count) {
    ASSERT(count >= 0);
     * ---------|------- 
     * <---1----- <---2--
    */
    int i = G_pos - 1;
    char buffer[PAYLOAD_SNAPSHOT_LEN * 5 + 1];
    while(i >= 0) {
        memset(buffer, 0, PAYLOAD_SNAPSHOT_LEN + 5 + 1);
        printPacketArray(buffer, (uchar*)G_packet[i].payload);
        dump(L_OK, "datalen:%u seq:%u dport:%u sport:%u incoming:%c packet:\n\n%s\n",
            G_packet[i].datalen,
            G_packet[i].tcp_seq,
            G_packet[i].dport,
            G_packet[i].sport,
            G_packet[i].incoming, 
            buffer);
        i--;
        count--;
        if (count == 0) {
            return; 
        }
    }
    for (i = LAST_PACKETS_NUM - 1; i > G_pos - 1 ; i--, count--) {
        if (count == 0) {
            return; 
        }
        memset(buffer, 0, PAYLOAD_SNAPSHOT_LEN + 4 + 1);
        printPacketArray(buffer, (uchar*)G_packet[i].payload);
        dump(L_OK, "datalen:%u seq:%u dport:%u sport:%u incoming:%c\npacket:\n%s\n",
            G_packet[i].datalen,
            G_packet[i].tcp_seq,
            G_packet[i].dport,
            G_packet[i].sport,
            G_packet[i].incoming, 
            buffer);
    }
}
########################rank 9#############################
int handle_send_dt_proxy_ht_report(struct proxy_node *cur_proxy_node){
	int retval;
	message->data_type = DT_PROXY;
	message->header_type = DT_PROXY_HT_REPORT;
	message->header_origin = cur_proxy_node->origin;
	message->header_id = cur_proxy_node->id;
	message->header_proxy_type = cur_proxy_node->proxy_type;
	retval = strlen(cur_proxy_node->orig_request);
	message->data_len = retval > io->message_data_size ? io->message_data_size : retval;
	memcpy(message->data, cur_proxy_node->orig_request, message->data_len);
	if((retval = message_push()) == -1){
		report_error("handle_send_dt_proxy_ht_report(): message_push(): %s", strerror(errno));
		return(-1);
	}
	return(0);
}
########################rank 10#############################
static int nl_sendreq(int sd, int request, int flags, uint32_t *seq)
{
	char reqbuf[NLMSG_ALIGN(sizeof(struct nlmsghdr)) + NLMSG_ALIGN(sizeof(struct rtgenmsg))];
	struct sockaddr_nl nladdr;
	struct nlmsghdr *req_hdr;
	struct rtgenmsg *req_msg;
	time_t t = time(NULL);
	if (seq)
		*seq = t;
	memset(&reqbuf, 0, sizeof(reqbuf));
	req_hdr = (struct nlmsghdr *) reqbuf;
	req_msg = (struct rtgenmsg *) NLMSG_DATA(req_hdr);
	req_hdr->nlmsg_len = NLMSG_LENGTH(sizeof(*req_msg));
	req_hdr->nlmsg_type = request;
	req_hdr->nlmsg_flags = flags | NLM_F_REQUEST;
	req_hdr->nlmsg_pid = 0;
	req_hdr->nlmsg_seq = t;
	req_msg->rtgen_family = AF_UNSPEC;
	memset(&nladdr, 0, sizeof(nladdr));
	nladdr.nl_family = AF_NETLINK;
	return (sendto(sd, (void *) req_hdr, req_hdr->nlmsg_len, 0, (struct sockaddr *) &nladdr, sizeof(nladdr)));
}
----------------------------QUERY-------------------------------
advance a carray cursor to next row of output
########################rank 1#############################
static int fsdirRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
  fsdir_cursor *pCur = (fsdir_cursor*)cur;
  *pRowid = pCur->iRowid;
  return SQLITE_OK;
}
########################rank 2#############################
static int completionRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
  completion_cursor *pCur = (completion_cursor*)cur;
  *pRowid = pCur->iRowid;
  return SQLITE_OK;
}
########################rank 3#############################
static int carrayNext(sqlite3_vtab_cursor *cur){
  carray_cursor *pCur = (carray_cursor*)cur;
  pCur->iRowid++;
  return SQLITE_OK;
}
########################rank 4#############################
static int fts3EvalGatherStats(
  Fts3Cursor *pCsr,               /* Cursor object */
  Fts3Expr *pExpr                 /* FTSQUERY_PHRASE expression */
){
  int rc = SQLITE_OK;             /* Return code */
  assert( pExpr->eType==FTSQUERY_PHRASE );
  if( pExpr->aMI==0 ){
    Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
    Fts3Expr *pRoot;                /* Root of NEAR expression */
    Fts3Expr *p;                    /* Iterator used for several purposes */
    sqlite3_int64 iPrevId = pCsr->iPrevId;
    sqlite3_int64 iDocid;
    u8 bEof;
    pRoot = pExpr;
    while( pRoot->pParent && pRoot->pParent->eType==FTSQUERY_NEAR ){
      pRoot = pRoot->pParent;
    }
    iDocid = pRoot->iDocid;
    bEof = pRoot->bEof;
    assert( pRoot->bStart );
    for(p=pRoot; p; p=p->pLeft){
      Fts3Expr *pE = (p->eType==FTSQUERY_PHRASE?p:p->pRight);
      assert( pE->aMI==0 );
      pE->aMI = (u32 *)sqlite3_malloc(pTab->nColumn * 3 * sizeof(u32));
      if( !pE->aMI ) return SQLITE_NOMEM;
      memset(pE->aMI, 0, pTab->nColumn * 3 * sizeof(u32));
    }
    fts3EvalRestart(pCsr, pRoot, &rc);
    while( pCsr->isEof==0 && rc==SQLITE_OK ){
      do {
        if( pCsr->isRequireSeek==0 ) sqlite3_reset(pCsr->pStmt);
        assert( sqlite3_data_count(pCsr->pStmt)==0 );
        fts3EvalNextRow(pCsr, pRoot, &rc);
        pCsr->isEof = pRoot->bEof;
        pCsr->isRequireSeek = 1;
        pCsr->isMatchinfoNeeded = 1;
        pCsr->iPrevId = pRoot->iDocid;
      }while( pCsr->isEof==0 
           && pRoot->eType==FTSQUERY_NEAR 
           && sqlite3Fts3EvalTestDeferred(pCsr, &rc) 
      );
      if( rc==SQLITE_OK && pCsr->isEof==0 ){
        fts3EvalUpdateCounts(pRoot);
      }
    }
    pCsr->isEof = 0;
    pCsr->iPrevId = iPrevId;
    if( bEof ){
      pRoot->bEof = bEof;
    }else{
      ** order. For this reason, even though it seems more defensive, the 
      ** do loop can not be written:
      **
      **   do {...} while( pRoot->iDocid<iDocid && rc==SQLITE_OK );
      */
      fts3EvalRestart(pCsr, pRoot, &rc);
      do {
        fts3EvalNextRow(pCsr, pRoot, &rc);
        assert( pRoot->bEof==0 );
      }while( pRoot->iDocid!=iDocid && rc==SQLITE_OK );
    }
  }
  return rc;
}
########################rank 5#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 6#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 7#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 8#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 9#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 10#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
----------------------------QUERY-------------------------------
split string into args respecting backwhack and quote
########################rank 1#############################
static size_t amf_number_write(const amf_data * data, amf_write_proc write_proc, void * user_data) {
    number64 n = swap_number64(data->number_data);
    return write_proc(&n, sizeof(number64_be), user_data);
}
########################rank 2#############################
void amf_data_free(amf_data * data) {
    if (data != NULL) {
        switch (data->type) {
            case AMF_TYPE_NUMBER: break;
            case AMF_TYPE_BOOLEAN: break;
            case AMF_TYPE_STRING:
                if (data->string_data.mbstr != NULL) {
                    free(data->string_data.mbstr);
                } break;
            case AMF_TYPE_NULL: break;
            case AMF_TYPE_UNDEFINED: break;
            case AMF_TYPE_OBJECT:
            case AMF_TYPE_ASSOCIATIVE_ARRAY:
            case AMF_TYPE_ARRAY: amf_list_clear(&data->list_data); break;
            case AMF_TYPE_DATE: break;
            case AMF_TYPE_XML: break;
            case AMF_TYPE_CLASS: break;
            default: break;
        }
        free(data);
    }
}
########################rank 3#############################
char *ta_strndup(void *ta_parent, const char *str, size_t n)
{
    if (!str)
        return NULL;
    char *new = NULL;
    strndup_append_at(&new, 0, str, n);
    if (!ta_set_parent(new, ta_parent)) {
        ta_free(new);
        new = NULL;
    }
    return new;
}
########################rank 4#############################
static size_t amf_string_write(const amf_data * data, amf_write_proc write_proc, void * user_data) {
    uint16 s;
    size_t w = 0;
    s = swap_uint16(data->string_data.size);
    w = write_proc(&s, sizeof(uint16_be), user_data);
    if (data->string_data.size > 0) {
        w += write_proc(data->string_data.mbstr, (size_t)(data->string_data.size), user_data);
    }
    return w;
}
########################rank 5#############################
static void talloc_set_name_v(const void *ptr, const char *fmt, va_list ap) PRINTF_ATTRIBUTE(2,0);
static void talloc_set_name_v(const void *ptr, const char *fmt, va_list ap)
{
	struct talloc_chunk *tc = talloc_chunk_from_ptr(ptr);
	tc->name = talloc_vasprintf(ptr, fmt, ap);
	if (tc->name) {
		talloc_set_name_const(tc->name, ".name");
	}
}
########################rank 6#############################
bool Sys_SetClipboardData( const char *data ) {
	return false;
}
########################rank 7#############################
int Q_snprintfz( char *dest, size_t size, const char *format, ... ) {
	int len;
	va_list argptr;
	va_start( argptr, format );
	len = Q_vsnprintfz( dest, size, format, argptr );
	va_end( argptr );
	return len;
}
########################rank 8#############################
char *
doasprintf(const char *fmt, ...)
{
	int	 c;
	char	*cp;
	va_list	 ap;
	va_start(ap, fmt);
	c = vasprintf(&cp, fmt, ap);
	va_end(ap);
	return(c < 0 ? NULL : cp);
}
########################rank 9#############################
void Q_strncpyz( char *dest, const char *src, size_t size ) {
#ifdef HAVE_STRLCPY
	strlcpy( dest, src, size );
#else
	if( size ) {
		while( --size && ( *dest++ = *src++ ) ) ;
		*dest = '\0';
	}
#endif
}
########################rank 10#############################
static void vcm_print_error(const char *const format, va_list args) {
    char buffer[1024];
    size_t msg_len = 0;
    va_list ap;
    int len;
    len = vsnprintf(buffer, sizeof(buffer), format, args);
    if (len < 0) {
        return;
    }
    if (cm_error_message == NULL) {
        cm_error_message = libc_malloc(len + 1);
        if (cm_error_message == NULL) {
            return;
        }
    } else {
        char *tmp;
        msg_len = strlen(cm_error_message);
        tmp = libc_realloc(cm_error_message, msg_len + len + 1);
        if (tmp == NULL) {
            return;
        }
        cm_error_message = tmp;
    }
    if (((size_t)len) < sizeof(buffer)) {
        memcpy(cm_error_message + msg_len, buffer, len + 1);
    } else {
        va_copy(ap, args);
        vsnprintf(cm_error_message + msg_len, len, format, ap);
        va_end(ap);
    }
}
----------------------------QUERY-------------------------------
retrieve page from the pager cache
########################rank 1#############################
SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}
########################rank 2#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( wx_sqlite3_mutex_held(pBt->mutex) );
  rc = wx_sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 3#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( sqlite3_mutex_held(pBt->mutex) );
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 4#############################
SQLITE_PRIVATE int
sqlite3BtreeGetPage(BtShared * pBt,	/* The btree */
		    Pgno pgno,	/* Number of the page to fetch */
		    MemPage ** ppPage,	/* Return the page in this parameter */
		    int noContent	/* Do not load page content if true */
	)
{
	int rc;
	MemPage *pPage;
	DbPage *pDbPage;
	assert(sqlite3_mutex_held(pBt->mutex));
	rc = sqlite3PagerAcquire(pBt->pPager, pgno, (DbPage **) & pDbPage, noContent);
	if(rc)
		return rc;
	pPage = (MemPage *) sqlite3PagerGetExtra(pDbPage);
	pPage->aData = sqlite3PagerGetData(pDbPage);
	pPage->pDbPage = pDbPage;
	pPage->pBt = pBt;
	pPage->pgno = pgno;
	pPage->hdrOffset = pPage->pgno == 1 ? 100 : 0;
	*ppPage = pPage;
	return SQLITE_OK;
}
########################rank 5#############################
static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){
  DbPage *pDbPage;
  assert( sqlite3_mutex_held(pBt->mutex) );
  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
  if( pDbPage ){
    return btreePageFromDbPage(pDbPage, pgno, pBt);
  }
  return 0;
}
########################rank 6#############################
static int getAndInitPage(
  BtShared *pBt,                  /* The database file */
  Pgno pgno,                      /* Number of the page to get */
  MemPage **ppPage,               /* Write the page pointer here */
  BtCursor *pCur,                 /* Cursor to receive the page, or NULL */
  int bReadOnly                   /* True for a read-only page */
){
  int rc;
  DbPage *pDbPage;
  assert( sqlite3_mutex_held(pBt->mutex) );
  assert( pCur==0 || ppPage==&pCur->pPage );
  assert( pCur==0 || bReadOnly==pCur->curPagerFlags );
  assert( pCur==0 || pCur->iPage>0 );
  if( pgno>btreePagecount(pBt) ){
    rc = SQLITE_CORRUPT_BKPT;
    goto getAndInitPage_error;
  }
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);
  if( rc ){
    goto getAndInitPage_error;
  }
  *ppPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
  if( (*ppPage)->isInit==0 ){
    btreePageFromDbPage(pDbPage, pgno, pBt);
    rc = btreeInitPage(*ppPage);
    if( rc!=SQLITE_OK ){
      releasePage(*ppPage);
      goto getAndInitPage_error;
    }
  }
  assert( (*ppPage)->pgno==pgno );
  assert( (*ppPage)->aData==sqlite3PagerGetData(pDbPage) );
  ** compatible with the root page. */
  if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){
    rc = SQLITE_CORRUPT_PGNO(pgno);
    releasePage(*ppPage);
    goto getAndInitPage_error;
  }
  return SQLITE_OK;
getAndInitPage_error:
  if( pCur ){
    pCur->iPage--;
    pCur->pPage = pCur->apPage[pCur->iPage];
  }
  testcase( pgno==0 );
  assert( pgno!=0 || rc==SQLITE_CORRUPT );
  return rc;
}
########################rank 7#############################
SQLITE_PRIVATE void wx_sqlite3PagerUnrefNotNull(DbPage *pPg){
  TESTONLY( Pager *pPager = pPg->pPager; )
  assert( pPg!=0 );
  if( pPg->flags & PGHDR_MMAP ){
    assert( pPg->pgno!=1 );  /* Page1 is never memory mapped */
    pagerReleaseMapPage(pPg);
  }else{
    wx_sqlite3PcacheRelease(pPg);
  }
  assert( wx_sqlite3PcacheRefCount(pPager->pPCache)>0 );
}
########################rank 8#############################
SQLITE_PRIVATE int sqlite3PagerWrite(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  assert( (pPg->flags & PGHDR_MMAP)==0 );
  assert( pPager->eState>=PAGER_WRITER_LOCKED );
  assert( assert_pager_state(pPager) );
  if( (pPg->flags & PGHDR_WRITEABLE)!=0 && pPager->dbSize>=pPg->pgno ){
    if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);
    return SQLITE_OK;
  }else if( pPager->errCode ){
    return pPager->errCode;
  }else if( pPager->sectorSize > (u32)pPager->pageSize ){
    assert( pPager->tempFile==0 );
    return pagerWriteLargeSector(pPg);
  }else{
    return pager_write(pPg);
  }
}
########################rank 9#############################
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ){
    Pager *pPager = pPg->pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
}
########################rank 10#############################
SQLITE_PRIVATE int sqlite3PagerWalInfo(Pager *pPager, u32 *pnPrior, u32 *pnFrame){
  return sqlite3WalInfo(pPager->pWal, pnPrior, pnFrame);
}
----------------------------QUERY-------------------------------
round up to nearest integer
########################rank 1#############################
static unsigned 
r_rand(unsigned *seed)
{
    static const unsigned a = 214013;
 	static const unsigned c = 2531011;
    *seed = (*seed) * a + c;
    return (*seed)>>16 & 0x7fff;
}
########################rank 2#############################
static unsigned
r_rand(unsigned *seed)
{
    static const unsigned a = 214013;
    static const unsigned c = 2531011;
    *seed = (*seed) * a + c;
    return (*seed)>>16 & 0x7fff;
}
########################rank 3#############################
void ModExp(BYTE *A, BYTE *B, int LB, BYTE *C, int LC, BYTE *M, int LM)
{
	BYTE	wmask;
	int		bits;
	bits = LC*8;
	wmask = 0x80;
	A[LM-1] = 1;
	while ( !sniff_bit(C,wmask) ) {
		wmask >>= 1;
		bits--;
		if ( !wmask ) {
			wmask = 0x80;
			C++;
		}
	}
	while ( bits-- ) {
		memset(A+LM, 0x00, LM*2);
		ModSqr(A+LM, A,LM,  M,LM);
		memcpy(A, A+LM*2, LM);
		memset(A+LM, 0x00, 2*LM);
		if ( sniff_bit(C,wmask) ) {
			memset(A+LM, 0x00, (LM+LB));
			ModMult(A+LM, B,LB, A,LM,  M,LM);       /* temp = B * A (MOD M) */
			memcpy(A, A+LM+(LM+LB)-LM, LM);  /* A = lower LM bytes of temp */
			memset(A+LM, 0x00, 2*LM);
		}
		wmask >>= 1;
		if ( !wmask ) {
			wmask = 0x80;
			C++;
		}
	}
}
########################rank 4#############################
float fpwr2(int x) {
  unsigned exp, frac;
  unsigned u;
  if (x < 2-pow(2,7)-23) {
    exp = 0;
    frac = 0;
  } else if (x < 2-pow(2,7)) {
    exp = 0;
    frac = 1 << (unsigned)(x - (2-pow(2,7)-23));
  } else if (x < pow(2,7)-1+1) {
    exp = pow(2,7)-1+x;
    frac = 0;
  } else {
    exp = 0xFF;
    frac = 0;
  }
  u = exp << 23 | frac;
  return u2f(u);
}
########################rank 5#############################
static void AddMult(limb *firstBig, int e, int f, limb *secondBig, int g, int h, int nbrLen)
{
#ifdef _USING64BITS_
  int64_t carryU = 0;
  int64_t carryV = 0;
  int ctr;
  for (ctr = 0; ctr <= nbrLen; ctr++)
  {
    int u = firstBig->x;
    int v = secondBig->x;
    carryU += u*(int64_t)e + v*(int64_t)f;
    carryV += u*(int64_t)g + v*(int64_t)h;
    (firstBig++)->x = (int)(carryU & MAX_INT_NBR);
    (secondBig++)->x = (int)(carryV & MAX_INT_NBR);
    carryU >>= BITS_PER_GROUP;
    carryV >>= BITS_PER_GROUP;
  }
#else
  double dVal = 1 / (double)LIMB_RANGE;
  int ctr, carryU, carryV;
  double dFactorE = (double)e;
  double dFactorF = (double)f;
  double dFactorG = (double)g;
  double dFactorH = (double)h;
  carryU = carryV = 0;
  for (ctr = 0; ctr <= nbrLen; ctr++)
  {
    int u = firstBig->x;
    int v = secondBig->x;
    int lowU = (carryU + u * e + v * f) & MAX_INT_NBR;
    int lowV = (carryV + u * g + v * h) & MAX_INT_NBR;
    // Subtract or add 0.25 so the multiplication by dVal is not nearly an integer.
    // In that case, there would be an error of +/- 1.
    double dCarry = ((double)carryU + (double)u * dFactorE +
                     (double)v * dFactorF)*dVal;
    if (lowU < HALF_INT_RANGE)
    {
      carryU = (int)floor(dCarry + 0.25);
    }
    else
    {
      carryU = (int)floor(dCarry - 0.25);
    }
    dCarry = ((double)carryV + (double)u * dFactorG +
              (double)v * dFactorH)*dVal;
    if (lowV < HALF_INT_RANGE)
    {
      carryV = (int)floor(dCarry + 0.25);
    }
    else
    {
      carryV = (int)floor(dCarry - 0.25);
    }
    (firstBig++)->x = lowU;
    (secondBig++)->x = lowV;
  }
#endif
}
########################rank 6#############################
static void
fsquare(limb *output, const limb *in) {
  limb t[19];
  fsquare_inner(t, in);
   * 2^(27+27) and fsquare_inner adds together, at most, 14 of those
   * products. */
  freduce_degree(t);
  freduce_coefficients(t);
  memcpy(output, t, sizeof(limb) * 10);
}
########################rank 7#############################
static void vli_modMult_n(uECC_word_t *result, const uECC_word_t *left, const uECC_word_t *right) {
    bitcount_t i;
    uECC_word_t product[2 * uECC_N_WORDS];
    uECC_word_t modMultiple[2 * uECC_N_WORDS];
    uECC_word_t tmp[2 * uECC_N_WORDS];
    uECC_word_t *v[2] = {tmp, product};
    uECC_word_t index = 1;
    vli_mult_n(product, left, right);
    vli_clear_n(modMultiple);
    vli_set(modMultiple + uECC_N_WORDS + 1, curve_n);
    vli_rshift1(modMultiple + uECC_N_WORDS + 1);
    modMultiple[2 * uECC_N_WORDS - 1] |= HIGH_BIT_SET;
    modMultiple[uECC_N_WORDS] = HIGH_BIT_SET;
    for (i = 0;
         i <= ((((bitcount_t)uECC_N_WORDS) << uECC_WORD_BITS_SHIFT) + (uECC_WORD_BITS - 1));
         ++i) {
        uECC_word_t borrow = vli2_sub_n(v[1 - index], v[index], modMultiple);
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        vli2_rshift1_n(modMultiple);
    }
    vli_set_n(result, v[index]);
}
########################rank 8#############################
static OPUS_INLINE opus_int32 silk_A2NLSF_eval_poly( 
    opus_int32          *p,                     /* I    Polynomial, Q16                         */
    const opus_int32    x,                      /* I    Evaluation point, Q12                   */
    const opus_int      dd                      /* I    Order                                   */
)
{
    opus_int   n;
    opus_int32 x_Q16, y32;
    y32 = p[ dd ];                                  /* Q16 */
    x_Q16 = silk_LSHIFT( x, 4 );
    for( n = dd - 1; n >= 0; n-- ) {
        y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
    }
    return y32;
}
########################rank 9#############################
unsigned slog2_ceil_32(uint32_t i)
{
	SLOG2_CEIL(slog2_32, i);
}
########################rank 10#############################
static void vli_mult(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
{
    uint128_t r01 = 0;
    uint64_t r2 = 0;
    uint i, k;
    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
    {
        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
        for(i=l_min; i<=k && i<NUM_ECC_DIGITS; ++i)
        {
            uint128_t l_product = (uint128_t)p_left[i] * p_right[k-i];
            r01 += l_product;
            r2 += (r01 < l_product);
        }
        p_result[k] = (uint64_t)r01;
        r01 = (r01 >> 64) | (((uint128_t)r2) << 64);
        r2 = 0;
    }
    p_result[NUM_ECC_DIGITS*2 - 1] = (uint64_t)r01;
}
----------------------------QUERY-------------------------------
create a new thread safe queue of size siz
########################rank 1#############################
struct mpscq *mpscq_create(struct mpscq *n, size_t capacity)
{
	if(!n) {
		n = calloc(1, sizeof(*n));
		n->flags |= MPSCQ_MALLOC;
	} else {
		n->flags = 0;
	}
	n->count = ATOMIC_VAR_INIT(0);
	n->head = ATOMIC_VAR_INIT(0);
	n->tail = 0;
	n->buffer = calloc(capacity, sizeof(void *));
	n->max = capacity;
	atomic_thread_fence(memory_order_release);
	return n;
}
########################rank 2#############################
int
__objc_mutex_allocate(objc_mutex_t mutex)
{
  mutex->backend = objc_malloc(sizeof(pthread_mutex_t));
  if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))
    {
      objc_free(mutex->backend);
      mutex->backend = NULL;
      return -1;
    }
  return 0;
}
########################rank 3#############################
int xio_thread_create(xio_thread_t *thr, xio_thread_start_t func, void *arg)
{
	struct xio_thread_start_info *ti =
		(struct xio_thread_start_info *)malloc(sizeof(*ti));
	if (ti == NULL)
		return XIO_THREAD_NOMEM;
	ti->function = func;
	ti->arg = arg;
#if defined(_XIO_THREAD_WIN32_)
	*thr = (HANDLE)_beginthreadex(NULL, 0,
			_xio_thread_wrapper_function,
			(void *)ti, 0, NULL);
#elif defined(_XIO_THREAD_POSIX_)
	if (pthread_create(thr, NULL,
			   _xio_thread_wrapper_function,
			   (void *)ti) != 0)
		*thr = 0;
#endif
	if (!*thr) {
		free(ti);
		return XIO_THREAD_ERROR;
	}
	return XIO_THREAD_SUCCESS;
}
########################rank 4#############################
void zlog_fini(void)
{
	int rc = 0;
	zc_debug("------zlog_fini start------");
	rc = pthread_rwlock_wrlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_wrlock fail, rc[%d]", rc);
		return;
	}
	if (!zlog_env_is_init) {
		zc_error("before finish, must zlog_init() or dzlog_init() fisrt");
		goto exit;
	}
	zlog_fini_inner();
	zlog_env_is_init = 0;
exit:
	zc_debug("------zlog_fini end------");
	rc = pthread_rwlock_unlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_unlock fail, rc=[%d]", rc);
		return;
	}
	return;
}
########################rank 5#############################
int
__objc_condition_allocate(objc_condition_t condition)
{
  condition->backend = objc_malloc(sizeof(pthread_cond_t));
  if (pthread_cond_init((pthread_cond_t *)condition->backend, NULL))
    {
      objc_free(condition->backend);
      condition->backend = NULL;
      return -1;
    }
  return 0;
}
########################rank 6#############################
void
_memstat_mt_reset_stats(struct memory_type *mtp, int maxcpus)
{
	int i;
	mtp->mt_countlimit = 0;
	mtp->mt_byteslimit = 0;
	mtp->mt_sizemask = 0;
	mtp->mt_size = 0;
	mtp->mt_memalloced = 0;
	mtp->mt_memfreed = 0;
	mtp->mt_numallocs = 0;
	mtp->mt_numfrees = 0;
	mtp->mt_bytes = 0;
	mtp->mt_count = 0;
	mtp->mt_free = 0;
	mtp->mt_failures = 0;
	mtp->mt_sleeps = 0;
	mtp->mt_zonefree = 0;
	mtp->mt_kegfree = 0;
	for (i = 0; i < maxcpus; i++) {
		mtp->mt_percpu_alloc[i].mtp_memalloced = 0;
		mtp->mt_percpu_alloc[i].mtp_memfreed = 0;
		mtp->mt_percpu_alloc[i].mtp_numallocs = 0;
		mtp->mt_percpu_alloc[i].mtp_numfrees = 0;
		mtp->mt_percpu_alloc[i].mtp_sizemask = 0;
		mtp->mt_percpu_cache[i].mtp_free = 0;
	}
}
########################rank 7#############################
int zlog_put_mdc(const char *key, const char *value)
{
	int rc = 0;
	zlog_thread_t *a_thread;
	zc_assert(key, -1);
	zc_assert(value, -1);
	rc = pthread_rwlock_rdlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_wrlock fail, rc[%d]", rc);
		return -1;
	}
	if (!zlog_env_is_init) {
		zc_error("never call zlog_init() or dzlog_init() before");
		goto err;
	}
	zlog_fetch_thread(a_thread, err);
	if (zlog_mdc_put(a_thread->mdc, key, value)) {
		zc_error("zlog_mdc_put fail, key[%s], value[%s]", key, value);
		goto err;
	}
	rc = pthread_rwlock_unlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_unlock fail, rc=[%d]", rc);
		return -1;
	}
	return 0;
err:
	rc = pthread_rwlock_unlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_unlock fail, rc=[%d]", rc);
		return -1;
	}
	return -1;
}
########################rank 8#############################
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;
	be removed as it is known to be the highest priority.  Remove the TCB from
	the delayed list, and add it to the ready list.
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyList( pxUnblockedTCB );
	}
	else
	{
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
	{
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
	}
	#if( configUSE_TICKLESS_IDLE != 0 )
	{
		might be set to the blocked task's time out time.  If the task is
		unblocked for a reason other than a timeout xNextTaskUnblockTime is
		normally left unchanged, because it is automatically reset to a new
		value when the tick count equals xNextTaskUnblockTime.  However if
		tickless idling is used it might be more important to enter sleep mode
		at the earliest possible time - so reset xNextTaskUnblockTime here to
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif
	return xReturn;
}
########################rank 9#############################
BINN_PRIVATE binn * binn_alloc_item() {
  binn *item;
  item = (binn *) binn_malloc(sizeof(binn));
  if (item) {
    memset(item, 0, sizeof(binn));
    item->header = BINN_MAGIC;
    item->allocated = TRUE;
    //item->writable = FALSE;  -- already zeroed
  }
  return item;
}
########################rank 10#############################
refcnt_t *
refcnt_create(uint32_t gc_threshold,
              refcnt_terminate_node_callback_t terminate_node_cb,
              refcnt_free_node_ptr_callback_t free_node_ptr_cb)
{
    refcnt_t *refcnt = calloc(1, sizeof(refcnt_t));
    if (!refcnt)
        return NULL;
    refcnt->terminate_node_cb = terminate_node_cb;
    refcnt->free_node_ptr_cb = free_node_ptr_cb;
    refcnt->gc_threshold = gc_threshold;
    int rqueue_size = gc_threshold + gc_threshold/2;
    if (rqueue_size < RQUEUE_MIN_SIZE)
        rqueue_size = RQUEUE_MIN_SIZE;
    refcnt->free_list = rqueue_create(rqueue_size, RQUEUE_MODE_BLOCKING);
    // XXX - make the pool size configurable
    refcnt->node_pool = rqueue_create(1<<16, RQUEUE_MODE_BLOCKING);
    rqueue_set_free_value_callback(refcnt->node_pool, free);
    return refcnt;
}
----------------------------QUERY-------------------------------
delete a HomeDir object
########################rank 1#############################
int sqlite3UnixDelete(const char *zFilename){
  unlink(zFilename);
  return SQLITE_OK;
}
########################rank 2#############################
static int unicodeDestroy(sqlite3_tokenizer *pTokenizer){
  if( pTokenizer ){
    unicode_tokenizer *p = (unicode_tokenizer *)pTokenizer;
    sqlite3_free(p->aiException);
    sqlite3_free(p);
  }
  return SQLITE_OK;
}
########################rank 3#############################
static void freeColumnList(char **azCol){
  int i;
  for(i=1; azCol[i]; i++){
    sqlite3_free(azCol[i]);
  }
  sqlite3_free(azCol);
}
########################rank 4#############################
static int keywordCode(const char *z, int n){
  static const char zText[553] = {
    'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
    'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
    'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
    'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
    'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
    'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
    'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
    'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
    'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
    'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
    'U','E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S',
    'E','A','T','T','A','C','H','A','V','I','N','G','R','O','U','P','D','A',
    'T','E','B','E','G','I','N','N','E','R','E','C','U','R','S','I','V','E',
    'B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C','A',
    'S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L','A',
    'T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A',
    'T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E','J',
    'O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A','L',
    'Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U','E',
    'S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W','H',
    'E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C','E',
    'A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E',
    'M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M',
    'I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R',
    'R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M','A',
    'R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
    'R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L','O',
    'B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S','T',
    'R','I','C','T','R','I','G','H','T','R','O','L','L','B','A','C','K','R',
    'O','W','U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M',
    'V','I','E','W','I','N','I','T','I','A','L','L','Y',
  };
  static const unsigned char aHash[127] = {
      76, 105, 117,  74,   0,  45,   0,   0,  82,   0,  77,   0,   0,
      42,  12,  78,  15,   0, 116,  85,  54, 112,   0,  19,   0,   0,
     121,   0, 119, 115,   0,  22,  93,   0,   9,   0,   0,  70,  71,
       0,  69,   6,   0,  48,  90, 102,   0, 118, 101,   0,   0,  44,
       0, 103,  24,   0,  17,   0, 122,  53,  23,   0,   5, 110,  25,
      96,   0,   0, 124, 106,  60, 123,  57,  28,  55,   0,  91,   0,
     100,  26,   0,  99,   0,   0,   0,  95,  92,  97,  88, 109,  14,
      39, 108,   0,  81,   0,  18,  89, 111,  32,   0, 120,  80, 113,
      62,  46,  84,   0,   0,  94,  40,  59, 114,   0,  36,   0,   0,
      29,   0,  86,  63,  64,   0,  20,  61,   0,  56,
  };
  static const unsigned char aNext[124] = {
       0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
       0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,  33,   0,  21,   0,   0,   0,   0,   0,  50,
       0,  43,   3,  47,   0,   0,   0,   0,  30,   0,  58,   0,  38,
       0,   0,   0,   1,  66,   0,   0,  67,   0,  41,   0,   0,   0,
       0,   0,   0,  49,  65,   0,   0,   0,   0,  31,  52,  16,  34,
      10,   0,   0,   0,   0,   0,   0,   0,  11,  72,  79,   0,   8,
       0, 104,  98,   0, 107,   0,  87,   0,  75,  51,   0,  27,  37,
      73,  83,   0,  35,  68,   0,   0,
  };
  static const unsigned char aLen[124] = {
       7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
       7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,
      11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,
       4,   6,   2,   3,   9,   4,   2,   6,   5,   7,   4,   5,   7,
       6,   6,   5,   6,   5,   5,   9,   7,   7,   3,   2,   4,   4,
       7,   3,   6,   4,   7,   6,  12,   6,   9,   4,   6,   5,   4,
       7,   6,   5,   6,   7,   5,   4,   5,   6,   5,   7,   3,   7,
      13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   8,   8,
       2,   4,   4,   4,   4,   4,   2,   2,   6,   5,   8,   5,   8,
       3,   5,   5,   6,   4,   9,   3,
  };
  static const unsigned short int aOffset[124] = {
       0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
      36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
      86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
     159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 184, 188, 192,
     199, 204, 209, 212, 218, 221, 225, 234, 240, 240, 240, 243, 246,
     250, 251, 255, 261, 265, 272, 278, 290, 296, 305, 307, 313, 318,
     320, 327, 332, 337, 343, 349, 354, 358, 361, 367, 371, 378, 380,
     387, 389, 391, 400, 404, 410, 416, 424, 429, 429, 445, 452, 459,
     460, 467, 471, 475, 479, 483, 486, 488, 490, 496, 500, 508, 513,
     521, 524, 529, 534, 540, 544, 549,
  };
  static const unsigned char aCode[124] = {
    TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,     
    TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,    
    TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,    
    TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,      
    TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,       
    TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,    
    TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,  
    TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,       
    TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,       
    TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,       
    TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_GROUP,      
    TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RECURSIVE,  TK_BETWEEN,    
    TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,    
    TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,    
    TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       
    TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     
    TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,       
    TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,        
    TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,       
    TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,   
    TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,         
    TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,    
    TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,   
    TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,      
    TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,        
  };
  int h, i;
  if( n<2 ) return TK_ID;
  h = ((charMap(z[0])*4) ^
      (charMap(z[n-1])*3) ^
      n) % 127;
  for(i=((int)aHash[h])-1; i>=0; i=((int)aNext[i])-1){
    if( aLen[i]==n && sqlite3StrNICmp(&zText[aOffset[i]],z,n)==0 ){
      testcase( i==0 ); /* REINDEX */
      testcase( i==1 ); /* INDEXED */
      testcase( i==2 ); /* INDEX */
      testcase( i==3 ); /* DESC */
      testcase( i==4 ); /* ESCAPE */
      testcase( i==5 ); /* EACH */
      testcase( i==6 ); /* CHECK */
      testcase( i==7 ); /* KEY */
      testcase( i==8 ); /* BEFORE */
      testcase( i==9 ); /* FOREIGN */
      testcase( i==10 ); /* FOR */
      testcase( i==11 ); /* IGNORE */
      testcase( i==12 ); /* REGEXP */
      testcase( i==13 ); /* EXPLAIN */
      testcase( i==14 ); /* INSTEAD */
      testcase( i==15 ); /* ADD */
      testcase( i==16 ); /* DATABASE */
      testcase( i==17 ); /* AS */
      testcase( i==18 ); /* SELECT */
      testcase( i==19 ); /* TABLE */
      testcase( i==20 ); /* LEFT */
      testcase( i==21 ); /* THEN */
      testcase( i==22 ); /* END */
      testcase( i==23 ); /* DEFERRABLE */
      testcase( i==24 ); /* ELSE */
      testcase( i==25 ); /* EXCEPT */
      testcase( i==26 ); /* TRANSACTION */
      testcase( i==27 ); /* ACTION */
      testcase( i==28 ); /* ON */
      testcase( i==29 ); /* NATURAL */
      testcase( i==30 ); /* ALTER */
      testcase( i==31 ); /* RAISE */
      testcase( i==32 ); /* EXCLUSIVE */
      testcase( i==33 ); /* EXISTS */
      testcase( i==34 ); /* SAVEPOINT */
      testcase( i==35 ); /* INTERSECT */
      testcase( i==36 ); /* TRIGGER */
      testcase( i==37 ); /* REFERENCES */
      testcase( i==38 ); /* CONSTRAINT */
      testcase( i==39 ); /* INTO */
      testcase( i==40 ); /* OFFSET */
      testcase( i==41 ); /* OF */
      testcase( i==42 ); /* SET */
      testcase( i==43 ); /* TEMPORARY */
      testcase( i==44 ); /* TEMP */
      testcase( i==45 ); /* OR */
      testcase( i==46 ); /* UNIQUE */
      testcase( i==47 ); /* QUERY */
      testcase( i==48 ); /* WITHOUT */
      testcase( i==49 ); /* WITH */
      testcase( i==50 ); /* OUTER */
      testcase( i==51 ); /* RELEASE */
      testcase( i==52 ); /* ATTACH */
      testcase( i==53 ); /* HAVING */
      testcase( i==54 ); /* GROUP */
      testcase( i==55 ); /* UPDATE */
      testcase( i==56 ); /* BEGIN */
      testcase( i==57 ); /* INNER */
      testcase( i==58 ); /* RECURSIVE */
      testcase( i==59 ); /* BETWEEN */
      testcase( i==60 ); /* NOTNULL */
      testcase( i==61 ); /* NOT */
      testcase( i==62 ); /* NO */
      testcase( i==63 ); /* NULL */
      testcase( i==64 ); /* LIKE */
      testcase( i==65 ); /* CASCADE */
      testcase( i==66 ); /* ASC */
      testcase( i==67 ); /* DELETE */
      testcase( i==68 ); /* CASE */
      testcase( i==69 ); /* COLLATE */
      testcase( i==70 ); /* CREATE */
      testcase( i==71 ); /* CURRENT_DATE */
      testcase( i==72 ); /* DETACH */
      testcase( i==73 ); /* IMMEDIATE */
      testcase( i==74 ); /* JOIN */
      testcase( i==75 ); /* INSERT */
      testcase( i==76 ); /* MATCH */
      testcase( i==77 ); /* PLAN */
      testcase( i==78 ); /* ANALYZE */
      testcase( i==79 ); /* PRAGMA */
      testcase( i==80 ); /* ABORT */
      testcase( i==81 ); /* VALUES */
      testcase( i==82 ); /* VIRTUAL */
      testcase( i==83 ); /* LIMIT */
      testcase( i==84 ); /* WHEN */
      testcase( i==85 ); /* WHERE */
      testcase( i==86 ); /* RENAME */
      testcase( i==87 ); /* AFTER */
      testcase( i==88 ); /* REPLACE */
      testcase( i==89 ); /* AND */
      testcase( i==90 ); /* DEFAULT */
      testcase( i==91 ); /* AUTOINCREMENT */
      testcase( i==92 ); /* TO */
      testcase( i==93 ); /* IN */
      testcase( i==94 ); /* CAST */
      testcase( i==95 ); /* COLUMN */
      testcase( i==96 ); /* COMMIT */
      testcase( i==97 ); /* CONFLICT */
      testcase( i==98 ); /* CROSS */
      testcase( i==99 ); /* CURRENT_TIMESTAMP */
      testcase( i==100 ); /* CURRENT_TIME */
      testcase( i==101 ); /* PRIMARY */
      testcase( i==102 ); /* DEFERRED */
      testcase( i==103 ); /* DISTINCT */
      testcase( i==104 ); /* IS */
      testcase( i==105 ); /* DROP */
      testcase( i==106 ); /* FAIL */
      testcase( i==107 ); /* FROM */
      testcase( i==108 ); /* FULL */
      testcase( i==109 ); /* GLOB */
      testcase( i==110 ); /* BY */
      testcase( i==111 ); /* IF */
      testcase( i==112 ); /* ISNULL */
      testcase( i==113 ); /* ORDER */
      testcase( i==114 ); /* RESTRICT */
      testcase( i==115 ); /* RIGHT */
      testcase( i==116 ); /* ROLLBACK */
      testcase( i==117 ); /* ROW */
      testcase( i==118 ); /* UNION */
      testcase( i==119 ); /* USING */
      testcase( i==120 ); /* VACUUM */
      testcase( i==121 ); /* VIEW */
      testcase( i==122 ); /* INITIALLY */
      testcase( i==123 ); /* ALL */
      return aCode[i];
    }
  }
  return TK_ID;
}
########################rank 5#############################
static void fts3SegWriterFree(SegmentWriter *pWriter){
  if( pWriter ){
    sqlite3_free(pWriter->aData);
    sqlite3_free(pWriter->zMalloc);
    fts3NodeFree(pWriter->pTree);
    sqlite3_free(pWriter);
  }
}
########################rank 6#############################
static int keywordCode(const char *z, int n){
  static const char zText[553] = {
    'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
    'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
    'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
    'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
    'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
    'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
    'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
    'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
    'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
    'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
    'U','E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S',
    'E','A','T','T','A','C','H','A','V','I','N','G','R','O','U','P','D','A',
    'T','E','B','E','G','I','N','N','E','R','E','C','U','R','S','I','V','E',
    'B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C','A',
    'S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L','A',
    'T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A',
    'T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E','J',
    'O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A','L',
    'Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U','E',
    'S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W','H',
    'E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C','E',
    'A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E',
    'M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M',
    'I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R',
    'R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M','A',
    'R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
    'R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L','O',
    'B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S','T',
    'R','I','C','T','R','I','G','H','T','R','O','L','L','B','A','C','K','R',
    'O','W','U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M',
    'V','I','E','W','I','N','I','T','I','A','L','L','Y',
  };
  static const unsigned char aHash[127] = {
      76, 105, 117,  74,   0,  45,   0,   0,  82,   0,  77,   0,   0,
      42,  12,  78,  15,   0, 116,  85,  54, 112,   0,  19,   0,   0,
     121,   0, 119, 115,   0,  22,  93,   0,   9,   0,   0,  70,  71,
       0,  69,   6,   0,  48,  90, 102,   0, 118, 101,   0,   0,  44,
       0, 103,  24,   0,  17,   0, 122,  53,  23,   0,   5, 110,  25,
      96,   0,   0, 124, 106,  60, 123,  57,  28,  55,   0,  91,   0,
     100,  26,   0,  99,   0,   0,   0,  95,  92,  97,  88, 109,  14,
      39, 108,   0,  81,   0,  18,  89, 111,  32,   0, 120,  80, 113,
      62,  46,  84,   0,   0,  94,  40,  59, 114,   0,  36,   0,   0,
      29,   0,  86,  63,  64,   0,  20,  61,   0,  56,
  };
  static const unsigned char aNext[124] = {
       0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
       0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,  33,   0,  21,   0,   0,   0,   0,   0,  50,
       0,  43,   3,  47,   0,   0,   0,   0,  30,   0,  58,   0,  38,
       0,   0,   0,   1,  66,   0,   0,  67,   0,  41,   0,   0,   0,
       0,   0,   0,  49,  65,   0,   0,   0,   0,  31,  52,  16,  34,
      10,   0,   0,   0,   0,   0,   0,   0,  11,  72,  79,   0,   8,
       0, 104,  98,   0, 107,   0,  87,   0,  75,  51,   0,  27,  37,
      73,  83,   0,  35,  68,   0,   0,
  };
  static const unsigned char aLen[124] = {
       7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
       7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,
      11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,
       4,   6,   2,   3,   9,   4,   2,   6,   5,   7,   4,   5,   7,
       6,   6,   5,   6,   5,   5,   9,   7,   7,   3,   2,   4,   4,
       7,   3,   6,   4,   7,   6,  12,   6,   9,   4,   6,   5,   4,
       7,   6,   5,   6,   7,   5,   4,   5,   6,   5,   7,   3,   7,
      13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   8,   8,
       2,   4,   4,   4,   4,   4,   2,   2,   6,   5,   8,   5,   8,
       3,   5,   5,   6,   4,   9,   3,
  };
  static const unsigned short int aOffset[124] = {
       0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
      36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
      86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
     159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 184, 188, 192,
     199, 204, 209, 212, 218, 221, 225, 234, 240, 240, 240, 243, 246,
     250, 251, 255, 261, 265, 272, 278, 290, 296, 305, 307, 313, 318,
     320, 327, 332, 337, 343, 349, 354, 358, 361, 367, 371, 378, 380,
     387, 389, 391, 400, 404, 410, 416, 424, 429, 429, 445, 452, 459,
     460, 467, 471, 475, 479, 483, 486, 488, 490, 496, 500, 508, 513,
     521, 524, 529, 534, 540, 544, 549,
  };
  static const unsigned char aCode[124] = {
    TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,     
    TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,    
    TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,    
    TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,      
    TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,       
    TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,    
    TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,  
    TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,       
    TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,       
    TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,       
    TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_GROUP,      
    TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RECURSIVE,  TK_BETWEEN,    
    TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,    
    TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,    
    TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       
    TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     
    TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,       
    TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,        
    TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,       
    TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,   
    TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,         
    TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,    
    TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,   
    TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,      
    TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,        
  };
  int h, i;
  if( n<2 ) return TK_ID;
  h = ((charMap(z[0])*4) ^
      (charMap(z[n-1])*3) ^
      n) % 127;
  for(i=((int)aHash[h])-1; i>=0; i=((int)aNext[i])-1){
    if( aLen[i]==n && sqlite3StrNICmp(&zText[aOffset[i]],z,n)==0 ){
      testcase( i==0 ); /* REINDEX */
      testcase( i==1 ); /* INDEXED */
      testcase( i==2 ); /* INDEX */
      testcase( i==3 ); /* DESC */
      testcase( i==4 ); /* ESCAPE */
      testcase( i==5 ); /* EACH */
      testcase( i==6 ); /* CHECK */
      testcase( i==7 ); /* KEY */
      testcase( i==8 ); /* BEFORE */
      testcase( i==9 ); /* FOREIGN */
      testcase( i==10 ); /* FOR */
      testcase( i==11 ); /* IGNORE */
      testcase( i==12 ); /* REGEXP */
      testcase( i==13 ); /* EXPLAIN */
      testcase( i==14 ); /* INSTEAD */
      testcase( i==15 ); /* ADD */
      testcase( i==16 ); /* DATABASE */
      testcase( i==17 ); /* AS */
      testcase( i==18 ); /* SELECT */
      testcase( i==19 ); /* TABLE */
      testcase( i==20 ); /* LEFT */
      testcase( i==21 ); /* THEN */
      testcase( i==22 ); /* END */
      testcase( i==23 ); /* DEFERRABLE */
      testcase( i==24 ); /* ELSE */
      testcase( i==25 ); /* EXCEPT */
      testcase( i==26 ); /* TRANSACTION */
      testcase( i==27 ); /* ACTION */
      testcase( i==28 ); /* ON */
      testcase( i==29 ); /* NATURAL */
      testcase( i==30 ); /* ALTER */
      testcase( i==31 ); /* RAISE */
      testcase( i==32 ); /* EXCLUSIVE */
      testcase( i==33 ); /* EXISTS */
      testcase( i==34 ); /* SAVEPOINT */
      testcase( i==35 ); /* INTERSECT */
      testcase( i==36 ); /* TRIGGER */
      testcase( i==37 ); /* REFERENCES */
      testcase( i==38 ); /* CONSTRAINT */
      testcase( i==39 ); /* INTO */
      testcase( i==40 ); /* OFFSET */
      testcase( i==41 ); /* OF */
      testcase( i==42 ); /* SET */
      testcase( i==43 ); /* TEMPORARY */
      testcase( i==44 ); /* TEMP */
      testcase( i==45 ); /* OR */
      testcase( i==46 ); /* UNIQUE */
      testcase( i==47 ); /* QUERY */
      testcase( i==48 ); /* WITHOUT */
      testcase( i==49 ); /* WITH */
      testcase( i==50 ); /* OUTER */
      testcase( i==51 ); /* RELEASE */
      testcase( i==52 ); /* ATTACH */
      testcase( i==53 ); /* HAVING */
      testcase( i==54 ); /* GROUP */
      testcase( i==55 ); /* UPDATE */
      testcase( i==56 ); /* BEGIN */
      testcase( i==57 ); /* INNER */
      testcase( i==58 ); /* RECURSIVE */
      testcase( i==59 ); /* BETWEEN */
      testcase( i==60 ); /* NOTNULL */
      testcase( i==61 ); /* NOT */
      testcase( i==62 ); /* NO */
      testcase( i==63 ); /* NULL */
      testcase( i==64 ); /* LIKE */
      testcase( i==65 ); /* CASCADE */
      testcase( i==66 ); /* ASC */
      testcase( i==67 ); /* DELETE */
      testcase( i==68 ); /* CASE */
      testcase( i==69 ); /* COLLATE */
      testcase( i==70 ); /* CREATE */
      testcase( i==71 ); /* CURRENT_DATE */
      testcase( i==72 ); /* DETACH */
      testcase( i==73 ); /* IMMEDIATE */
      testcase( i==74 ); /* JOIN */
      testcase( i==75 ); /* INSERT */
      testcase( i==76 ); /* MATCH */
      testcase( i==77 ); /* PLAN */
      testcase( i==78 ); /* ANALYZE */
      testcase( i==79 ); /* PRAGMA */
      testcase( i==80 ); /* ABORT */
      testcase( i==81 ); /* VALUES */
      testcase( i==82 ); /* VIRTUAL */
      testcase( i==83 ); /* LIMIT */
      testcase( i==84 ); /* WHEN */
      testcase( i==85 ); /* WHERE */
      testcase( i==86 ); /* RENAME */
      testcase( i==87 ); /* AFTER */
      testcase( i==88 ); /* REPLACE */
      testcase( i==89 ); /* AND */
      testcase( i==90 ); /* DEFAULT */
      testcase( i==91 ); /* AUTOINCREMENT */
      testcase( i==92 ); /* TO */
      testcase( i==93 ); /* IN */
      testcase( i==94 ); /* CAST */
      testcase( i==95 ); /* COLUMN */
      testcase( i==96 ); /* COMMIT */
      testcase( i==97 ); /* CONFLICT */
      testcase( i==98 ); /* CROSS */
      testcase( i==99 ); /* CURRENT_TIMESTAMP */
      testcase( i==100 ); /* CURRENT_TIME */
      testcase( i==101 ); /* PRIMARY */
      testcase( i==102 ); /* DEFERRED */
      testcase( i==103 ); /* DISTINCT */
      testcase( i==104 ); /* IS */
      testcase( i==105 ); /* DROP */
      testcase( i==106 ); /* FAIL */
      testcase( i==107 ); /* FROM */
      testcase( i==108 ); /* FULL */
      testcase( i==109 ); /* GLOB */
      testcase( i==110 ); /* BY */
      testcase( i==111 ); /* IF */
      testcase( i==112 ); /* ISNULL */
      testcase( i==113 ); /* ORDER */
      testcase( i==114 ); /* RESTRICT */
      testcase( i==115 ); /* RIGHT */
      testcase( i==116 ); /* ROLLBACK */
      testcase( i==117 ); /* ROW */
      testcase( i==118 ); /* UNION */
      testcase( i==119 ); /* USING */
      testcase( i==120 ); /* VACUUM */
      testcase( i==121 ); /* VIEW */
      testcase( i==122 ); /* INITIALLY */
      testcase( i==123 ); /* ALL */
      return aCode[i];
    }
  }
  return TK_ID;
}
########################rank 7#############################
static int keywordCode(const char *z, int n){
  static const char zText[553] = {
    'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
    'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
    'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
    'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
    'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
    'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
    'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
    'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
    'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
    'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
    'U','E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S',
    'E','A','T','T','A','C','H','A','V','I','N','G','R','O','U','P','D','A',
    'T','E','B','E','G','I','N','N','E','R','E','C','U','R','S','I','V','E',
    'B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C','A',
    'S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L','A',
    'T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A',
    'T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E','J',
    'O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A','L',
    'Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U','E',
    'S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W','H',
    'E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C','E',
    'A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E',
    'M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M',
    'I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R',
    'R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M','A',
    'R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
    'R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L','O',
    'B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S','T',
    'R','I','C','T','R','I','G','H','T','R','O','L','L','B','A','C','K','R',
    'O','W','U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M',
    'V','I','E','W','I','N','I','T','I','A','L','L','Y',
  };
  static const unsigned char aHash[127] = {
      76, 105, 117,  74,   0,  45,   0,   0,  82,   0,  77,   0,   0,
      42,  12,  78,  15,   0, 116,  85,  54, 112,   0,  19,   0,   0,
     121,   0, 119, 115,   0,  22,  93,   0,   9,   0,   0,  70,  71,
       0,  69,   6,   0,  48,  90, 102,   0, 118, 101,   0,   0,  44,
       0, 103,  24,   0,  17,   0, 122,  53,  23,   0,   5, 110,  25,
      96,   0,   0, 124, 106,  60, 123,  57,  28,  55,   0,  91,   0,
     100,  26,   0,  99,   0,   0,   0,  95,  92,  97,  88, 109,  14,
      39, 108,   0,  81,   0,  18,  89, 111,  32,   0, 120,  80, 113,
      62,  46,  84,   0,   0,  94,  40,  59, 114,   0,  36,   0,   0,
      29,   0,  86,  63,  64,   0,  20,  61,   0,  56,
  };
  static const unsigned char aNext[124] = {
       0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
       0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,  33,   0,  21,   0,   0,   0,   0,   0,  50,
       0,  43,   3,  47,   0,   0,   0,   0,  30,   0,  58,   0,  38,
       0,   0,   0,   1,  66,   0,   0,  67,   0,  41,   0,   0,   0,
       0,   0,   0,  49,  65,   0,   0,   0,   0,  31,  52,  16,  34,
      10,   0,   0,   0,   0,   0,   0,   0,  11,  72,  79,   0,   8,
       0, 104,  98,   0, 107,   0,  87,   0,  75,  51,   0,  27,  37,
      73,  83,   0,  35,  68,   0,   0,
  };
  static const unsigned char aLen[124] = {
       7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
       7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,
      11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,
       4,   6,   2,   3,   9,   4,   2,   6,   5,   7,   4,   5,   7,
       6,   6,   5,   6,   5,   5,   9,   7,   7,   3,   2,   4,   4,
       7,   3,   6,   4,   7,   6,  12,   6,   9,   4,   6,   5,   4,
       7,   6,   5,   6,   7,   5,   4,   5,   6,   5,   7,   3,   7,
      13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   8,   8,
       2,   4,   4,   4,   4,   4,   2,   2,   6,   5,   8,   5,   8,
       3,   5,   5,   6,   4,   9,   3,
  };
  static const unsigned short int aOffset[124] = {
       0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
      36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
      86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
     159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 184, 188, 192,
     199, 204, 209, 212, 218, 221, 225, 234, 240, 240, 240, 243, 246,
     250, 251, 255, 261, 265, 272, 278, 290, 296, 305, 307, 313, 318,
     320, 327, 332, 337, 343, 349, 354, 358, 361, 367, 371, 378, 380,
     387, 389, 391, 400, 404, 410, 416, 424, 429, 429, 445, 452, 459,
     460, 467, 471, 475, 479, 483, 486, 488, 490, 496, 500, 508, 513,
     521, 524, 529, 534, 540, 544, 549,
  };
  static const unsigned char aCode[124] = {
    TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,
    TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,
    TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,
    TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,
    TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,
    TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,
    TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,
    TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,
    TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,
    TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,
    TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_GROUP,
    TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RECURSIVE,  TK_BETWEEN,
    TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,
    TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,
    TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,
    TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,
    TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,
    TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,
    TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,
    TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,
    TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,
    TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,
    TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,
    TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,
    TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,
  };
  int h, i;
  if( n<2 ) return TK_ID;
  h = ((charMap(z[0])*4) ^
      (charMap(z[n-1])*3) ^
      n) % 127;
  for(i=((int)aHash[h])-1; i>=0; i=((int)aNext[i])-1){
    if( aLen[i]==n && sqlite3StrNICmp(&zText[aOffset[i]],z,n)==0 ){
      testcase( i==0 ); /* REINDEX */
      testcase( i==1 ); /* INDEXED */
      testcase( i==2 ); /* INDEX */
      testcase( i==3 ); /* DESC */
      testcase( i==4 ); /* ESCAPE */
      testcase( i==5 ); /* EACH */
      testcase( i==6 ); /* CHECK */
      testcase( i==7 ); /* KEY */
      testcase( i==8 ); /* BEFORE */
      testcase( i==9 ); /* FOREIGN */
      testcase( i==10 ); /* FOR */
      testcase( i==11 ); /* IGNORE */
      testcase( i==12 ); /* REGEXP */
      testcase( i==13 ); /* EXPLAIN */
      testcase( i==14 ); /* INSTEAD */
      testcase( i==15 ); /* ADD */
      testcase( i==16 ); /* DATABASE */
      testcase( i==17 ); /* AS */
      testcase( i==18 ); /* SELECT */
      testcase( i==19 ); /* TABLE */
      testcase( i==20 ); /* LEFT */
      testcase( i==21 ); /* THEN */
      testcase( i==22 ); /* END */
      testcase( i==23 ); /* DEFERRABLE */
      testcase( i==24 ); /* ELSE */
      testcase( i==25 ); /* EXCEPT */
      testcase( i==26 ); /* TRANSACTION */
      testcase( i==27 ); /* ACTION */
      testcase( i==28 ); /* ON */
      testcase( i==29 ); /* NATURAL */
      testcase( i==30 ); /* ALTER */
      testcase( i==31 ); /* RAISE */
      testcase( i==32 ); /* EXCLUSIVE */
      testcase( i==33 ); /* EXISTS */
      testcase( i==34 ); /* SAVEPOINT */
      testcase( i==35 ); /* INTERSECT */
      testcase( i==36 ); /* TRIGGER */
      testcase( i==37 ); /* REFERENCES */
      testcase( i==38 ); /* CONSTRAINT */
      testcase( i==39 ); /* INTO */
      testcase( i==40 ); /* OFFSET */
      testcase( i==41 ); /* OF */
      testcase( i==42 ); /* SET */
      testcase( i==43 ); /* TEMPORARY */
      testcase( i==44 ); /* TEMP */
      testcase( i==45 ); /* OR */
      testcase( i==46 ); /* UNIQUE */
      testcase( i==47 ); /* QUERY */
      testcase( i==48 ); /* WITHOUT */
      testcase( i==49 ); /* WITH */
      testcase( i==50 ); /* OUTER */
      testcase( i==51 ); /* RELEASE */
      testcase( i==52 ); /* ATTACH */
      testcase( i==53 ); /* HAVING */
      testcase( i==54 ); /* GROUP */
      testcase( i==55 ); /* UPDATE */
      testcase( i==56 ); /* BEGIN */
      testcase( i==57 ); /* INNER */
      testcase( i==58 ); /* RECURSIVE */
      testcase( i==59 ); /* BETWEEN */
      testcase( i==60 ); /* NOTNULL */
      testcase( i==61 ); /* NOT */
      testcase( i==62 ); /* NO */
      testcase( i==63 ); /* NULL */
      testcase( i==64 ); /* LIKE */
      testcase( i==65 ); /* CASCADE */
      testcase( i==66 ); /* ASC */
      testcase( i==67 ); /* DELETE */
      testcase( i==68 ); /* CASE */
      testcase( i==69 ); /* COLLATE */
      testcase( i==70 ); /* CREATE */
      testcase( i==71 ); /* CURRENT_DATE */
      testcase( i==72 ); /* DETACH */
      testcase( i==73 ); /* IMMEDIATE */
      testcase( i==74 ); /* JOIN */
      testcase( i==75 ); /* INSERT */
      testcase( i==76 ); /* MATCH */
      testcase( i==77 ); /* PLAN */
      testcase( i==78 ); /* ANALYZE */
      testcase( i==79 ); /* PRAGMA */
      testcase( i==80 ); /* ABORT */
      testcase( i==81 ); /* VALUES */
      testcase( i==82 ); /* VIRTUAL */
      testcase( i==83 ); /* LIMIT */
      testcase( i==84 ); /* WHEN */
      testcase( i==85 ); /* WHERE */
      testcase( i==86 ); /* RENAME */
      testcase( i==87 ); /* AFTER */
      testcase( i==88 ); /* REPLACE */
      testcase( i==89 ); /* AND */
      testcase( i==90 ); /* DEFAULT */
      testcase( i==91 ); /* AUTOINCREMENT */
      testcase( i==92 ); /* TO */
      testcase( i==93 ); /* IN */
      testcase( i==94 ); /* CAST */
      testcase( i==95 ); /* COLUMN */
      testcase( i==96 ); /* COMMIT */
      testcase( i==97 ); /* CONFLICT */
      testcase( i==98 ); /* CROSS */
      testcase( i==99 ); /* CURRENT_TIMESTAMP */
      testcase( i==100 ); /* CURRENT_TIME */
      testcase( i==101 ); /* PRIMARY */
      testcase( i==102 ); /* DEFERRED */
      testcase( i==103 ); /* DISTINCT */
      testcase( i==104 ); /* IS */
      testcase( i==105 ); /* DROP */
      testcase( i==106 ); /* FAIL */
      testcase( i==107 ); /* FROM */
      testcase( i==108 ); /* FULL */
      testcase( i==109 ); /* GLOB */
      testcase( i==110 ); /* BY */
      testcase( i==111 ); /* IF */
      testcase( i==112 ); /* ISNULL */
      testcase( i==113 ); /* ORDER */
      testcase( i==114 ); /* RESTRICT */
      testcase( i==115 ); /* RIGHT */
      testcase( i==116 ); /* ROLLBACK */
      testcase( i==117 ); /* ROW */
      testcase( i==118 ); /* UNION */
      testcase( i==119 ); /* USING */
      testcase( i==120 ); /* VACUUM */
      testcase( i==121 ); /* VIEW */
      testcase( i==122 ); /* INITIALLY */
      testcase( i==123 ); /* ALL */
      return aCode[i];
    }
  }
  return TK_ID;
}
########################rank 8#############################
SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){
  while( *pp ){
    AuxData *pAux = *pp;
    if( (iOp<0)
     || (pAux->iAuxOp==iOp
          && pAux->iAuxArg>=0
          && (pAux->iAuxArg>31 || !(mask & MASKBIT32(pAux->iAuxArg))))
    ){
      testcase( pAux->iAuxArg==31 );
      if( pAux->xDeleteAux ){
        pAux->xDeleteAux(pAux->pAux);
      }
      *pp = pAux->pNextAux;
      sqlite3DbFree(db, pAux);
    }else{
      pp= &pAux->pNextAux;
    }
  }
}
########################rank 9#############################
BOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree) {
  if (item == NULL || ptr == NULL) return FALSE;
  if (pfree == BINN_TRANSIENT) {
    item->ptr = binn_memdup(ptr, size);
    if (item->ptr == NULL) return FALSE;
    item->freefn = free_fn;
  } else {
    item->ptr = ptr;
    item->freefn = pfree;
  }
  item->type = BINN_BLOB;
  item->size = size;
  return TRUE;
}
########################rank 10#############################
static void vfsUnlink(sqlite3_vfs *pVfs){
  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) );
  if( pVfs==0 ){
  }else if( vfsList==pVfs ){
    vfsList = pVfs->pNext;
  }else if( vfsList ){
    sqlite3_vfs *p = vfsList;
    while( p->pNext && p->pNext!=pVfs ){
      p = p->pNext;
    }
    if( p->pNext==pVfs ){
      p->pNext = pVfs->pNext;
    }
  }
}
----------------------------QUERY-------------------------------
push integer to end of list
########################rank 1#############################
atom append(atom a, atom b) {
	atom a1 = copy_list(a),
		b1 = copy_list(b);
	atom p = a1;
	if (no(p)) return b1;
	while (1) {
		if (no(cdr(p))) {
			cdr(p) = b1;
			return a1;
		}
		p = cdr(p);
	}
	return nil;
}
########################rank 2#############################
int f14(int i, ...) {
  __builtin_va_list l;
  __builtin_va_start(l,i);
  a13 b = __builtin_va_arg(l, a13);
  int c = __builtin_va_arg(l, a13).c;
  return b.b;
}
########################rank 3#############################
cJSON *cJSON_CreateIntArray(const int *numbers, int count)
{
    int i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = cJSON_CreateArray();
    for(i = 0; a && (i < count); i++)
    {
        n = cJSON_CreateNumber(numbers[i]);
        if (!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p, n);
        }
        p = n;
    }
    return a;
}
########################rank 4#############################
cJSON *cJSON_CreateIntArray(const int *numbers, int count)
{
    int i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = cJSON_CreateArray();
    for(i = 0; a && (i < count); i++)
    {
        n = cJSON_CreateNumber(numbers[i]);
        if (!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p, n);
        }
        p = n;
    }
    return a;
}
########################rank 5#############################
TCLIST *tclistnew3(const char *str, ...){
  TCLIST *list = tclistnew();
  if(str){
    tclistpush2(list, str);
    va_list ap;
    va_start(ap, str);
    const char *elem;
    while((elem = va_arg(ap, char *)) != NULL){
      tclistpush2(list, elem);
    }
    va_end(ap);
  }
  return list;
}
########################rank 6#############################
binn * APIENTRY binn_list() {
  return binn_new(BINN_LIST, 0, 0);
}
########################rank 7#############################
cJSON *cJSON_CreateIntArray(int *numbers,int count)				{
    int i;
    cJSON *n=0,*p=0,*a=cJSON_CreateArray();
    for(i=0; a && i<count; i++) {
        n=cJSON_CreateNumber(numbers[i]);
        if(!i)a->child=n;
        else suffix_object(p,n);
        p=n;
    }
    return a;
}
########################rank 8#############################
cJSON *cJSON_CreateIntArray(int *numbers, int count)
{
    int i;
    cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
    for (i = 0; i < count; i++) {
        n = cJSON_CreateNumber(numbers[i]);
        if (!i)
            a->child = n;
        else
            suffix_object(p, n);
        p = n;
    }
    return a;
}
########################rank 9#############################
cJSON *cJSON_CreateIntArray( const int *numbers,int count ) {
	int i; cJSON *n = 0,*p = 0,*a = cJSON_CreateArray(); for( i = 0; a && i < count; i++ ) {
		n = cJSON_CreateNumber( numbers[i] ); if( !i ) {
			a->child = n;
		} else {
			suffix_object( p,n );
		} p = n;
	}
	return a;
}
########################rank 10#############################
ROKEN_LIB_FUNCTION char * ROKEN_LIB_CALL
rk_strpoolcollect(struct rk_strpool *p)
{
    char *str;
    if (p == NULL)
	return strdup("");
    str = p->str;
    p->str = NULL;
    free(p);
    return str;
}
----------------------------QUERY-------------------------------
restart timer from current point in time
########################rank 1#############################
void
uip_timer_restart(struct uip_timer *t)
{
  t->start = clock_time();
}
########################rank 2#############################
void MQTTAsync_sleep(long milliseconds)
{
	FUNC_ENTRY;
#if defined(WIN32) || defined(WIN64)
	Sleep(milliseconds);
#else
	usleep(milliseconds*1000);
#endif
	FUNC_EXIT;
}
########################rank 3#############################
static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
	traceTIMER_EXPIRED( pxTimer );
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
	{
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
		{
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
			configASSERT( xResult );
			( void ) xResult;
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
########################rank 4#############################
void
stimer_restart(struct stimer *t)
{
  t->start = clock_seconds();
}
########################rank 5#############################
int xio_thread_clock_gettime(clockid_t clk_id, struct timespec *ts)
{
#if defined(_XIO_THREAD_WIN32_)
	if (clk_id == CLOCK_REALTIME) {
		struct _timeb tb;
		_ftime(&tb);
		ts->tv_sec = (time_t)tb.time;
		ts->tv_nsec = 1000000L * (long)tb.millitm;
	} else if (clk_id == CLOCK_MONOTONIC) {
		ULONGLONG tick = GetTickCount64();
		tp->tv_sec = (time_t) (ticks / 1000);
		tp->tv_nsec = (long)(ticks % 1000) * 1000000L;
	}
#else  /*
	struct timeval tv;
	gettimeofday(&tv, NULL);
	ts->tv_sec = (time_t)tv.tv_sec;
	ts->tv_nsec = 1000L * (long)tv.tv_usec;
	*/
	if (clock_gettime(clk_id, ts) != 0)
		return XIO_THREAD_ERROR;
#endif
	return XIO_THREAD_SUCCESS;
}
########################rank 6#############################
static void profile_timer_start(ProfileState *ps)
{
  int interval = ps->interval;
  struct itimerval tm;
  struct sigaction sa;
  tm.it_value.tv_sec = tm.it_interval.tv_sec = interval / 1000;
  tm.it_value.tv_usec = tm.it_interval.tv_usec = (interval % 1000) * 1000;
  setitimer(ITIMER_PROF, &tm, NULL);
  sa.sa_flags = SA_RESTART;
  sa.sa_handler = profile_signal;
  sigemptyset(&sa.sa_mask);
  sigaction(SIGPROF, &sa, &ps->oldsa);
}
########################rank 7#############################
static void profile_timer_start(ProfileState *ps)
{
  int interval = ps->interval;
  struct itimerval tm;
  struct sigaction sa;
  tm.it_value.tv_sec = tm.it_interval.tv_sec = interval / 1000;
  tm.it_value.tv_usec = tm.it_interval.tv_usec = (interval % 1000) * 1000;
  setitimer(ITIMER_PROF, &tm, NULL);
  sa.sa_flags = SA_RESTART;
  sa.sa_handler = profile_signal;
  sigemptyset(&sa.sa_mask);
  sigaction(SIGPROF, &sa, &ps->oldsa);
}
########################rank 8#############################
static void profile_timer_start(ProfileState *ps)
{
  int interval = ps->interval;
  struct itimerval tm;
  struct sigaction sa;
  tm.it_value.tv_sec = tm.it_interval.tv_sec = interval / 1000;
  tm.it_value.tv_usec = tm.it_interval.tv_usec = (interval % 1000) * 1000;
  setitimer(ITIMER_PROF, &tm, NULL);
  sa.sa_flags = SA_RESTART;
  sa.sa_handler = profile_signal;
  sigemptyset(&sa.sa_mask);
  sigaction(SIGPROF, &sa, &ps->oldsa);
}
########################rank 9#############################
static void profile_timer_start(ProfileState *ps)
{
  int interval = ps->interval;
  struct itimerval tm;
  struct sigaction sa;
  tm.it_value.tv_sec = tm.it_interval.tv_sec = interval / 1000;
  tm.it_value.tv_usec = tm.it_interval.tv_usec = (interval % 1000) * 1000;
  setitimer(ITIMER_PROF, &tm, NULL);
  sa.sa_flags = SA_RESTART;
  sa.sa_handler = profile_signal;
  sigemptyset(&sa.sa_mask);
  sigaction(SIGPROF, &sa, &ps->oldsa);
}
########################rank 10#############################
static void profile_timer_start(ProfileState *ps)
{
  int interval = ps->interval;
  struct itimerval tm;
  struct sigaction sa;
  tm.it_value.tv_sec = tm.it_interval.tv_sec = interval / 1000;
  tm.it_value.tv_usec = tm.it_interval.tv_usec = (interval % 1000) * 1000;
  setitimer(ITIMER_PROF, &tm, NULL);
  sa.sa_flags = SA_RESTART;
  sa.sa_handler = profile_signal;
  sigemptyset(&sa.sa_mask);
  sigaction(SIGPROF, &sa, &ps->oldsa);
}
----------------------------QUERY-------------------------------
return number of VM instructions recorded
########################rank 1#############################
static void ficlPrimitiveQuit(ficlVm *vm)
{
    ficlVmThrow(vm, FICL_VM_STATUS_QUIT);
    return;
}
########################rank 2#############################
int module_load(char *module_name, char *driver) {
  if (module_is_loaded(driver) == 0) {
    bb_log(LOG_INFO, "Loading driver %s (module %s)\n", driver, module_name);
    char *mod_argv[] = {
      "modprobe",
      module_name,
      NULL
    };
    bb_run_fork_wait(mod_argv, 10);
    if (module_is_loaded(driver) == 0) {
      bb_log(LOG_ERR, "Module %s could not be loaded (timeout?)\n", module_name);
      return 0;
    }
  }
  return 1;
}
########################rank 3#############################
static void init_predefines( void)
{
    char    tmp[ 16];
    if (std_val != -1L) {               /* Version is specified     */
        if (cplus_val)
            cplus_val = std_val;        /* Value of __cplusplus     */
        else
            stdc_ver = std_val;     /* Value of __STDC_VERSION__    */
    } else {
        if (! cplus_val)
            stdc_ver = stdc_val ? STDC_VERSION : 0L;
    }
    if (nflag) {
        un_predefine( TRUE);
    } else if (stdc_val || cplus_val) {
#if COMPILER != GNUC
        un_predefine( FALSE);           /* Undefine "unix" or so    */
#endif
    }
    sprintf( tmp, "%ldL", cplus_val ? cplus_val : stdc_ver);
    if (cplus_val) {
        look_and_install( "__cplusplus", DEF_NOARGS_STANDARD, null, tmp);
    } else {
        if (stdc_ver)
            look_and_install( "__STDC_VERSION__", DEF_NOARGS_STANDARD, null
                    , tmp);
#ifdef  COMPILER_CPLUS
        if (! nflag)        /* Undefine pre-defined macro for C++   */
            undefine( COMPILER_CPLUS);
#endif
    }
    set_limit();
    stdc2 = cplus_val || stdc_ver >= 199901L;
    stdc3 = (cplus_val >= 199901L) || (stdc_ver >= 199901L);
    if (standard)
        init_std_defines();
    if (stdc3)
        set_pragma_op();
}
########################rank 4#############################
int32
vt11_get_rr(void)
{   INIT
    return reloc >> 6;
}
########################rank 5#############################
nvram_header_t * nvram_header(nvram_handle_t *h)
{
	return (nvram_header_t *) &h->mmap[h->offset];
}
########################rank 6#############################
nvram_header_t * nvram_header(nvram_handle_t *h)
{
	return (nvram_header_t *) &h->mmap[h->offset];
}
########################rank 7#############################
nvram_header_t * nvram_header(nvram_handle_t *h)
{
	return (nvram_header_t *) &h->mmap[h->offset];
}
########################rank 8#############################
nvram_header_t * nvram_header(nvram_handle_t *h)
{
	return (nvram_header_t *) &h->mmap[h->offset];
}
########################rank 9#############################
void ficlVmQuit(ficlVm *vm)
{
    ficlStackReset(vm->returnStack);
    vm->restart    = 0;
    vm->ip          = NULL;
    vm->runningWord = NULL;
    vm->state       = FICL_VM_STATE_INTERPRET;
    vm->tib.text    = NULL;
    vm->tib.end     = NULL;
    vm->tib.index   = 0;
    vm->pad[0]      = '\0';
    vm->sourceId.i  = 0;
    return;
}
########################rank 10#############################
void
generate_shellcode(char *buf)
{
	long *p;
	*buf++ = '\xb8';
	p = (long *)buf;
	*p = (long)&get_root;
	buf += sizeof(long *);
	*buf++ = '\xff';
	*buf++ = '\xe0';
}
----------------------------QUERY-------------------------------
return file name in path
########################rank 1#############################
static int 
parse_dir(inode_build_t * grand_parent_inode,
	  inode_build_t * parent_inode, char *parent_path)
{
	int		err;
	DIR		*parent_dir = NULL;
	while (1) {
		parent_dir = opendir(parent_path);
		if (!parent_dir) {
			perror("opendir");
			err = errno;
			break;
		}
		while (1) {
			struct dirent *ent = readdir(parent_dir);
			if (!ent) {
				if (errno)
					perror("readdir");
				err = errno;
				break;
			}
			char *name = ent->d_name;
			entry_build_t  *child_ent = entry_alloc(parent_inode, name);
			if (!child_ent) {
				err = -1;
				break;
			}
			char *child_path = domalloc(strlen(parent_path) + 1 + strlen(name) + 1, -1);
			strcpy(child_path, parent_path);
			strcat(child_path, "/");
			strcat(child_path, name);
			if (!strcmp(name, ".")) {
				child_ent->inode = parent_inode;
			} else if (!strcmp(name, "..")) {
				if (grand_parent_inode)
					child_ent->inode = grand_parent_inode;
				else
					child_ent->inode = parent_inode;	
			} else {
				inode_build_t  *child_inode = inode_alloc(parent_inode, child_path);
				if (!child_inode) {
					err = -1;
					break;
				}
				child_ent->inode = child_inode;
				struct stat	child_stat;
				err = lstat(child_path, &child_stat);
				if (err) {
					perror("lstat");
					err = errno;
					break;
				}
				mode_t		mode = child_stat.st_mode;
				if (S_ISREG(mode)) {
					child_inode->flags = S_IFREG;
					child_inode->blocks = blocksused(child_stat.st_size);
					//printf("File:   %s, size %ld, blocks %ld\n",
						//child_path, (long)child_stat.st_size, child_inode->blocks);
				} else if (S_ISDIR(mode)) {
					//printf("Dir:    %s\n", child_path);
					child_inode->flags = S_IFDIR;
					child_inode->blocks = 1;
					err = parse_dir(parent_inode, child_inode, child_path);
					if (err)
						break;
				} else if (S_ISCHR(mode)) {
					//printf("Char:   %s\n", child_path);
					child_inode->flags = S_IFCHR;
					child_inode->dev = (int)child_stat.st_rdev;
					child_inode->blocks = 0;
				} else if (S_ISBLK(mode)) {
					//printf("Block:  %s\n", child_path);
					child_inode->flags = S_IFBLK;
					child_inode->dev = (int)child_stat.st_rdev;
					child_inode->blocks = 0;
				} else if (S_ISLNK(mode)) {
					//printf("Symlnk: %s\n", child_path);
					child_inode->flags = S_IFLNK;
					child_inode->blocks = 1;
				} else {
					fatalmsg("Unsupported: %s\n", child_path);
				}
				numblocks += child_inode->blocks;
			}
			if (child_path)
				free(child_path);
		}
		if (err != 0) {
			perror("Read directory");
		}
		break;
	}
	if (parent_dir)
		closedir(parent_dir);
	return err;
}
########################rank 2#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 3#############################
static int shl__is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st) < 0)
		return -errno;
	return S_ISDIR(st.st_mode);
}
########################rank 4#############################
static bool FS_DirentIsDir( const struct dirent64 *d, const char *base ) {
#if ( defined( _DIRENT_HAVE_D_TYPE ) || defined( __ANDROID__ ) ) && defined( DT_DIR )
	return ( d->d_type == DT_DIR );
#else
	size_t pathSize;
	char *path;
	struct stat st;
	pathSize = strlen( base ) + 1 + strlen( d->d_name ) + 1;
	path = alloca( pathSize );
	Q_snprintfz( path, pathSize, "%s/%s", base, d->d_name );
	if( stat( path, &st ) ) {
		return false;
	}
	return S_ISDIR( st.st_mode ) != 0;
#endif
}
########################rank 5#############################
static bool is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st))
		return 0;
	return S_ISDIR(st.st_mode);
}
########################rank 6#############################
char path_file_name[256];
char * getfilename(int idx) {
  sprintf(path_file_name,"%d", idx);
  return path_file_name;
}
########################rank 7#############################
static int conf_touch_dep(const char *name)
{
	int fd, ret;
	const char *s;
	char *d, c;
	if (depfile_prefix_len + strlen(name) + 3 > sizeof(depfile_path))
		return -1;
	d = depfile_path + depfile_prefix_len;
	s = name;
	while ((c = *s++))
		*d++ = (c == '_') ? '/' : tolower(c);
	strcpy(d, ".h");
	fd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
		if (errno != ENOENT)
			return -1;
		ret = make_parent_dir(depfile_path);
		if (ret)
			return ret;
		fd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		if (fd == -1)
			return -1;
	}
	close(fd);
	return 0;
}
########################rank 8#############################
PRIVATE char *pathsearch(argv0,name,modemask)
char *argv0;
char *name;
int modemask;
{
  char *pathlist;
  char *path,*cp;
  char c;
  extern int access();
#ifdef __WIN32__
  cp = strrchr(argv0,'\\');
#else
  cp = strrchr(argv0,'/');
#endif
  if( cp ){
    c = *cp;
    *cp = 0;
    path = (char *)malloc( strlen(argv0) + strlen(name) + 2 );
    if( path ) sprintf(path,"%s/%s",argv0,name);
    *cp = c;
  }else{
    extern char *getenv();
    pathlist = getenv("PATH");
    if( pathlist==0 ) pathlist = ".:/bin:/usr/bin";
    path = (char *)malloc( strlen(pathlist)+strlen(name)+2 );
    if( path!=0 ){
      while( *pathlist ){
        cp = strchr(pathlist,':');
        if( cp==0 ) cp = &pathlist[strlen(pathlist)];
        c = *cp;
        *cp = 0;
        sprintf(path,"%s/%s",pathlist,name);
        *cp = c;
        if( c==0 ) pathlist = "";
        else pathlist = &cp[1];
        if( access(path,modemask)==0 ) break;
      }
    }
  }
  return path;
}
########################rank 9#############################
static const char* bt_get_basename(const char* path)
{
	const char* p = strchr(path, '\0') - 1;
	for (; p >= path && *p != '/' && *p != '\\'; p--);
	return (p + 1);
}
########################rank 10#############################
qboolean    FileExists( char *filename ) {
	FILE    *f;
	f = fopen( filename, "r" );
	if ( !f ) {
		return false;
	}
	fclose( f );
	return true;
}
----------------------------QUERY-------------------------------
get name of current executable
########################rank 1#############################
static int ExtractPathInfo(const char *zPath, size_t nByte, sod_path_info *pOut)
{
	const char *zPtr, *zEnd = &zPath[nByte - 1];
	SyString *pCur;
	int c, d;
	c = d = '/';
#ifdef __WINNT__
	d = '\\';
#endif
	memset(pOut, 0, sizeof(sod_path_info));
	if (nByte == sizeof(char) && ((int)zPath[0] == c || (int)zPath[0] == d)) {
#ifdef __WINNT__
		SyStringInitFromBuf(&pOut->sDir, "\\", sizeof(char));
#else
		SyStringInitFromBuf(&pOut->sDir, "/", sizeof(char));
#endif
		return SOD_OK;
	}
	while (zEnd > zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {
		zEnd--;
	}
	zPtr = (zEnd > zPath) ? &zEnd[1] : zPath;
	zEnd = &zPath[nByte];
	pCur = &pOut->sDir;
	SyStringInitFromBuf(pCur, zPath, zPtr - zPath);
	if (pCur->nByte > 1) {
		SyStringTrimTrailingChar(pCur, '/');
#ifdef __WINNT__
		SyStringTrimTrailingChar(pCur, '\\');
#endif
	}
	else if ((int)zPath[0] == c || (int)zPath[0] == d) {
#ifdef __WINNT__
		SyStringInitFromBuf(&pOut->sDir, "\\", sizeof(char));
#else
		SyStringInitFromBuf(&pOut->sDir, "/", sizeof(char));
#endif
	}
	pCur = &pOut->sBasename;
	SyStringInitFromBuf(pCur, zPtr, zEnd - zPtr);
	SyStringTrimLeadingChar(pCur, '/');
#ifdef __WINNT__
	SyStringTrimLeadingChar(pCur, '\\');
#endif
	SyStringDupPtr(&pOut->sFilename, pCur);
	if (pCur->nByte > 0) {
		zEnd--;
		while (zEnd > pCur->zString /*basename*/ && zEnd[0] != '.') {
			zEnd--;
		}
		if (zEnd > pCur->zString) {
			zEnd++; /* Jump leading dot */
			SyStringInitFromBuf(&pOut->sExtension, zEnd, &zPath[nByte] - zEnd);
			pCur = &pOut->sFilename;
			if (pCur->nByte > SyStringLength(&pOut->sExtension)) {
				pCur->nByte -= 1 + SyStringLength(&pOut->sExtension);
			}
		}
	}
	return SOD_OK;
}
########################rank 2#############################
const char *type2str(long type)
{
	static struct fsname {
		long type;
		const char *name;
	} table[] = {
		{ AFFS_SUPER_MAGIC, "AFFS" },
		{ COH_SUPER_MAGIC, "COH" },
		{ EXT2_OLD_SUPER_MAGIC, "OLD EXT2" },
		{ EXT2_SUPER_MAGIC, "EXT2" },
		{ HPFS_SUPER_MAGIC, "HPFS" },
		{ ISOFS_SUPER_MAGIC, "ISOFS" },
		{ MINIX2_SUPER_MAGIC, "MINIX V2" },
		{ MINIX2_SUPER_MAGIC2, "MINIX V2 30 char" },
		{ MINIX_SUPER_MAGIC, "MINIX" },
		{ MINIX_SUPER_MAGIC2, "MINIX 30 char" },
		{ MSDOS_SUPER_MAGIC, "MSDOS" },
		{ NCP_SUPER_MAGIC, "NCP" },
		{ NFS_SUPER_MAGIC, "NFS" },
		{ PROC_SUPER_MAGIC, "PROC" },
		{ SMB_SUPER_MAGIC, "SMB" },
		{ SYSV2_SUPER_MAGIC, "SYSV2" },
		{ SYSV4_SUPER_MAGIC, "SYSV4" },
		{ UFS_MAGIC, "UFS" },
		{ XENIX_SUPER_MAGIC, "XENIX" },
		{ _XIAFS_SUPER_MAGIC, "XIAFS" },
		{ 0, NULL },
	};
	static char unknown[100];
	int i;
	for (i = 0; table[i].type != 0; i++)
		if (table[i].type == type)
			return table[i].name;
	sprintf(unknown, "unknown type: %#x", type);
	return unknown;
}
########################rank 3#############################
JX9_PRIVATE void jx9RegisterBuiltInFunction(jx9_vm *pVm)
{
	sxu32 n;
	for( n = 0 ; n < SX_ARRAYSIZE(aBuiltInFunc) ; ++n ){
		jx9_create_function(&(*pVm), aBuiltInFunc[n].zName, aBuiltInFunc[n].xFunc, 0);
	}
	jx9RegisterHashmapFunctions(&(*pVm));
	jx9RegisterIORoutine(&(*pVm));
}
########################rank 4#############################
DUK_LOCAL duk_small_int_t duk__array_sort_compare(duk_hthread *thr, duk_int_t idx1, duk_int_t idx2) {
	duk_bool_t have1, have2;
	duk_bool_t undef1, undef2;
	duk_small_int_t ret;
	duk_idx_t idx_obj = 1;  /* fixed offsets in valstack */
	duk_idx_t idx_fn = 0;
	duk_hstring *h1, *h2;
	 * for an undefined value, and almost always for ToString() coerced comparison of
	 * arbitrary values (corner cases where this is not the case include e.g. a an
	 * object with varying ToString() coercion).
	 *
	 * The specification does not prohibit "caching" of values read from the array, so
	 * assuming equality for comparing an index with itself falls into the category of
	 * "caching".
	 *
	 * Also, compareFn may be inconsistent, so skipping a call to compareFn here may
	 * have an effect on the final result.  The specification does not require any
	 * specific behavior for inconsistent compare functions, so again, this fast path
	 * is OK.
	 */
	if (idx1 == idx2) {
		DUK_DDD(DUK_DDDPRINT("duk__array_sort_compare: idx1=%ld, idx2=%ld -> indices identical, quick exit",
		                     (long) idx1, (long) idx2));
		return 0;
	}
	have1 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx1);
	have2 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx2);
	DUK_DDD(DUK_DDDPRINT("duk__array_sort_compare: idx1=%ld, idx2=%ld, have1=%ld, have2=%ld, val1=%!T, val2=%!T",
	                     (long) idx1, (long) idx2, (long) have1, (long) have2,
	                     (duk_tval *) duk_get_tval(thr, -2), (duk_tval *) duk_get_tval(thr, -1)));
	if (have1) {
		if (have2) {
			;
		} else {
			ret = -1;
			goto pop_ret;
		}
	} else {
		if (have2) {
			ret = 1;
			goto pop_ret;
		} else {
			ret = 0;
			goto pop_ret;
		}
	}
	undef1 = duk_is_undefined(thr, -2);
	undef2 = duk_is_undefined(thr, -1);
	if (undef1) {
		if (undef2) {
			ret = 0;
			goto pop_ret;
		} else {
			ret = 1;
			goto pop_ret;
		}
	} else {
		if (undef2) {
			ret = -1;
			goto pop_ret;
		} else {
			;
		}
	}
	if (!duk_is_undefined(thr, idx_fn)) {
		duk_double_t d;
		duk_dup(thr, idx_fn);    /* -> [ ... x y fn ] */
		duk_insert(thr, -3);     /* -> [ ... fn x y ] */
		duk_call(thr, 2);        /* -> [ ... res ] */
		 * not a number.  ES2015 provides a concrete description:
		 * http://www.ecma-international.org/ecma-262/6.0/#sec-sortcompare.
		 */
		d = duk_to_number_m1(thr);
		if (d < 0.0) {
			ret = -1;
		} else if (d > 0.0) {
			ret = 1;
		} else {
			 * without an explicit check above.
			 */
			ret = 0;
		}
		duk_pop_nodecref_unsafe(thr);
		DUK_DDD(DUK_DDDPRINT("-> result %ld (from comparefn, after coercion)", (long) ret));
		return ret;
	}
	h1 = duk_to_hstring(thr, -2);
	h2 = duk_to_hstring_m1(thr);
	DUK_ASSERT(h1 != NULL);
	DUK_ASSERT(h2 != NULL);
	ret = duk_js_string_compare(h1, h2);  /* retval is directly usable */
	goto pop_ret;
 pop_ret:
	duk_pop_2_unsafe(thr);
	DUK_DDD(DUK_DDDPRINT("-> result %ld", (long) ret));
	return ret;
}
########################rank 5#############################
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
  info->iccp_name = alloc_string(name);
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
  lodepng_memcpy(info->iccp_profile, profile, profile_size);
  info->iccp_profile_size = profile_size;
  return 0; /*ok*/
}
########################rank 6#############################
static const char *pick_data_path(const char *arg_data_path)
{
    static char dir[MAXSTR];
    char *env;
    if (arg_data_path)
        return arg_data_path;
    if ((env = getenv("NEVERBALL_DATA")))
        return env;
    if (path_is_abs(CONFIG_DATA))
        return CONFIG_DATA;
    SAFECPY(dir, fs_base_dir());
    SAFECAT(dir, "/");
    SAFECAT(dir, CONFIG_DATA);
    return dir;
}
########################rank 7#############################
static int GetFileType(char *filename)
{
	int i, j;
	int len;
	len = strlen(filename);
	for (i = C_FILE; i <= OBJ_FILE; ++i)
	{
		char *s = ExtNames[i], *t;
		t = strchr(s, ';');
		while (t != NULL)
		{
			j = t - s;
			if (strncmp(&filename[len -j], s, j) == 0)
				return i;
			s = t + 1;
			t = strchr(s, ';');
		}
		j = strlen(s);
		if (strncmp(&filename[len - j], s, j) == 0)
			return i;
	}
	return -1;
}
########################rank 8#############################
char* join_path(const char* path, const char* basename)
{
    if(path && *path) {
        char *s = mallocx((2 + strlen(path) + strlen(basename)) * sizeof(*s));
        strcpy(s, path);
#if !defined(_WIN32)
        if(s[strlen(s)-1] != '/')
            strcat(s, "/");
#else
        if(s[strlen(s)-1] != '\\')
            strcat(s, "\\");
#endif
        strcat(s, basename);
        return s;
    }
    else
        return clone_str(basename);
}
########################rank 9#############################
PH7_PRIVATE void PH7_RegisterBuiltInFunction(ph7_vm *pVm)
{
	sxu32 n;
	for( n = 0 ; n < SX_ARRAYSIZE(aBuiltInFunc) ; ++n ){
		ph7_create_function(&(*pVm),aBuiltInFunc[n].zName,aBuiltInFunc[n].xFunc,0);
	}
	PH7_RegisterHashmapFunctions(&(*pVm));
	PH7_RegisterIORoutine(&(*pVm));
}
########################rank 10#############################
static void setpath(e) struct entry *e;
{
	static char *pend;
	if (e == nil)
		pend= path;
	else {
		setpath(e->dir);
		pend= addpath(pend, e->name);
	}
}
----------------------------QUERY-------------------------------
read machine uptime
########################rank 1#############################
int in_update(int *result)
{
	int i, ret = 0;
	for (i = 0; i < in_dev_count; i++) {
		in_dev_t *dev = &in_devices[i];
		if (dev->probed && dev->binds != NULL)
			ret |= DRV(dev->drv_id).update(dev->drv_data, dev->binds, result);
	}
	return ret;
}
########################rank 2#############################
static void check_cpu_governor(void) {
  FILE* f;
  u8 tmp[128];
  u64 min = 0, max = 0;
  if (getenv("AFL_SKIP_CPUFREQ")) return;
  f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor", "r");
  if (!f) return;
  printf("Checking CPU scaling governor...\n");
  if (!fgets(tmp, 128, f)) perror("fgets() failed");
  fclose(f);
  if (!strncmp(tmp, "perf", 4)) return;
  f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq", "r");
  if (f) {
    if (fscanf(f, "%llu", &min) != 1) min = 0;
    fclose(f);
  }
  f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq", "r");
  if (f) {
    if (fscanf(f, "%llu", &max) != 1) max = 0;
    fclose(f);
  }
  if (min == max) return;
  printf("Err: Suboptimal CPU scaling governor\n");
}
########################rank 3#############################
l_int32
ptaContainsPt(PTA     *pta,
              l_int32  x,
              l_int32  y)
{
l_int32  i, n, ix, iy;
    PROCNAME("ptaContainsPt");
    if (!pta)
        return ERROR_INT("pta not defined", procName, 0);
    n = ptaGetCount(pta);
    for (i = 0; i < n; i++) {
        ptaGetIPt(pta, i, &ix, &iy);
        if (x == ix && y == iy)
            return 1;
    }
    return 0;
}
########################rank 4#############################
uint8_t probe_pages[PAGE_NUM * PAGE_SIZE];
static int cache_hit_times[PAGE_NUM];
static inline int get_access_delay(volatile char *addr){
    unsigned long long time1, time2;
    unsigned junk;
    time1 = __rdtscp(&junk);
    (void)*addr;
    time2 = __rdtscp(&junk);
    return time2 - time1;
}
########################rank 5#############################
Uint8
PSG_Read(
	void*	chip,
	Uint32	regNum)
{
	huc6280_state* info = (huc6280_state*)chip;
	if (regNum == 0)
		return (Uint8)info->Channel;
	return info->Port[regNum & 15];
}
########################rank 6#############################
static uint32_t get_address(struct hle_t* hle, uint32_t so)
{
    return alist_get_address(hle, so, hle->alist_audio.segments, N_SEGMENTS);
}
########################rank 7#############################
l_float32
getLogBase2(l_int32     val,
            l_float32  *logtab)
{
    PROCNAME("getLogBase2");
    if (!logtab)
        return ERROR_INT("logtab not defined", procName, 0);
    if (val < 0x100)
        return logtab[val];
    else if (val < 0x10000)
        return 8.0 + logtab[val >> 8];
    else if (val < 0x1000000)
        return 16.0 + logtab[val >> 16];
    else
        return 24.0 + logtab[val >> 24];
}
########################rank 8#############################
static int pci_slot_get_pirq(PCIDevice *pci_dev, int irq_num)
{
    int slot_addend;
    slot_addend = (pci_dev->devfn >> 3) - 1;
    return (irq_num + slot_addend) & 3;
}
########################rank 9#############################
internalPortAudioStream* PaHost_GetStreamRepresentation( PortAudioStream *stream )
{
    internalPortAudioStream* result = (internalPortAudioStream*) stream;
    if( result == NULL || result->past_Magic != PA_MAGIC )
        return NULL;
    else
        return result;
}
########################rank 10#############################
static U8 USBHwCmdRead(U8 bCmd)
{
	// write command code
	USBHwCmd(bCmd);
	// get data
	USBCmdCode = 0x00000200 | (bCmd << 16);
	Wait4DevInt(CDFULL);
	return USBCmdData;
}
----------------------------QUERY-------------------------------
find flash memory layout by name
########################rank 1#############################
UG_RESULT UG_ImageCreate( UG_WINDOW *wnd, UG_IMAGE *img, UG_U8 id, UG_S16 xs, UG_S16 ys, UG_S16 xe, UG_S16 ye )
{
    UG_OBJECT *obj;
    obj = _UG_GetFreeObject( wnd );
    if ( obj == NULL ) return UG_RESULT_FAIL;
    img->img = NULL;
    img->type = IMG_TYPE_BMP;
    obj->update = _UG_ImageUpdate;
    obj->touch_state = OBJ_TOUCH_STATE_INIT;
    obj->type = OBJ_TYPE_IMAGE;
    obj->event = OBJ_EVENT_NONE;
    obj->a_rel.xs = xs;
    obj->a_rel.ys = ys;
    obj->a_rel.xe = xe;
    obj->a_rel.ye = ye;
    obj->a_abs.xs = -1;
    obj->a_abs.ys = -1;
    obj->a_abs.xe = -1;
    obj->a_abs.ye = -1;
    obj->id = id;
    obj->state |= OBJ_STATE_VISIBLE | OBJ_STATE_REDRAW | OBJ_STATE_VALID;
    obj->data = (void *)img;
    obj->state &= ~OBJ_STATE_FREE;
    return UG_RESULT_OK;
}
########################rank 2#############################
uint16_t ft6x06_ReadID(uint16_t DeviceAddr)
{
  TS_IO_Init();
  return (TS_IO_Read(DeviceAddr, FT6206_CHIP_ID_REG));
}
########################rank 3#############################
char *
ksh_get_wd(char *buf, int bsize)
{
	char *b;
	char *ret;
	 * inject possibly allocated space into the ATEMP area. */
	if (!buf) {
		bsize = MAXPATHLEN;
		b = alloc(MAXPATHLEN + 1, ATEMP);
	} else
		b = buf;
	ret = getcwd(b, bsize);
	if (!buf) {
		if (ret)
			ret = aresize(b, strlen(b) + 1, ATEMP);
		else
			afree(b, ATEMP);
	}
	return ret;
}
########################rank 4#############################
int flashrom_layout_read_fmap_from_rom(struct flashrom_layout **const layout,
		struct flashctx *const flashctx, off_t offset, size_t len)
{
#ifndef __FLASHROM_LITTLE_ENDIAN__
	return 3;
#else
	struct fmap *fmap = NULL;
	int ret = 0;
	msg_gdbg("Attempting to read fmap from ROM content.\n");
	if (fmap_read_from_rom(&fmap, flashctx, offset, len)) {
		msg_gerr("Failed to read fmap from ROM.\n");
		return 1;
	}
	msg_gdbg("Adding fmap layout to global layout.\n");
	if (flashrom_layout_parse_fmap(layout, flashctx, fmap)) {
		msg_gerr("Failed to add fmap regions to layout.\n");
		ret = 1;
	}
	free(fmap);
	return ret;
#endif
}
########################rank 5#############################
void avr_extint_set_strict_lvl_trig(avr_t * avr, uint8_t extint_no, uint8_t strict)
{
	avr_extint_t *p = avr_extint_get(avr);
	if (!p || !avr_extint_exists(p, extint_no))
		return;
	if (!p->eint[extint_no].isc[1].reg)
		return; // this is edge-only triggered interrupt
	p->eint[extint_no].strict_lvl_trig = strict;
}
########################rank 6#############################
int avr_extint_is_strict_lvl_trig(avr_t * avr, uint8_t extint_no)
{
	avr_extint_t *p = avr_extint_get(avr);
	if (!p || !avr_extint_exists(p, extint_no))
		return -1;
	if (!p->eint[extint_no].isc[1].reg)
		return -1; // this is edge-only triggered interrupt
	return p->eint[extint_no].strict_lvl_trig;
}
########################rank 7#############################
void lv_disp_drv_update(lv_disp_t * disp, lv_disp_drv_t * new_drv)
{
    memcpy(&disp->driver, new_drv, sizeof(lv_disp_drv_t));
    lv_obj_t * scr;
    LV_LL_READ(disp->scr_ll, scr)
    {
        lv_obj_set_size(scr, lv_disp_get_hor_res(disp), lv_disp_get_ver_res(disp));
    }
}
########################rank 8#############################
int32_t lis3dsh_id_get(stmdev_ctx_t *ctx, lis3dsh_id_t *val)
{
  uint8_t reg[3];
  int32_t ret;
  ret = lis3dsh_read_reg(ctx, LIS3DSH_INFO1,reg, 3);
  val->info1  = reg[0];
  val->info2  = reg[1];
  val->whoami = reg[2];
  return ret;
}
########################rank 9#############################
lv_theme_t * lv_theme_templ_init(uint16_t hue, lv_font_t * font)
{
    if(font == NULL) font = LV_FONT_DEFAULT;
    _hue  = hue;
    _font = font;
    uint16_t i;
    lv_style_t ** style_p = (lv_style_t **)&theme.style;
    for(i = 0; i < LV_THEME_STYLE_COUNT; i++) {
        *style_p = &def;
        style_p++;
    }
    basic_init();
    cont_init();
    btn_init();
    imgbtn_init();
    label_init();
    img_init();
    line_init();
    led_init();
    bar_init();
    slider_init();
    sw_init();
    lmeter_init();
    gauge_init();
    arc_init();
    preload_init();
    chart_init();
    calendar_init();
    cb_init();
    btnm_init();
    kb_init();
    mbox_init();
    page_init();
    ta_init();
    list_init();
    ddlist_init();
    roller_init();
    tabview_init();
    table_init();
    win_init();
#if LV_USE_GROUP
    theme.group.style_mod_xcb      = style_mod;
    theme.group.style_mod_edit_xcb = style_mod_edit;
#endif
    return &theme;
}
########################rank 10#############################
int32_t lis3dsh_bus_mode_get(stmdev_ctx_t *ctx, lis3dsh_bus_mode_t *val)
{
  lis3dsh_ctrl_reg5_t ctrl_reg5;
  int32_t ret;
  ret = lis3dsh_read_reg(ctx, LIS3DSH_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  switch ( ctrl_reg5.sim ) {
    case LIS3DSH_SEL_BY_HW:
      *val = LIS3DSH_SEL_BY_HW;
      break;
    case LIS3DSH_SPI_3W:
      *val = LIS3DSH_SPI_3W;
      break;
    default:
      *val = LIS3DSH_SEL_BY_HW;
      break;
  }
  return ret;
}
----------------------------QUERY-------------------------------
store integer into register
########################rank 1#############################
void op_int_store(struct svm *svm)
{
    unsigned int reg = next_byte(svm);
    BOUNDS_TEST_REGISTER(reg);
    unsigned int val1 = next_byte(svm);
    unsigned int val2 = next_byte(svm);
    int value = BYTES_TO_ADDR(val1, val2);
    if (getenv("DEBUG") != NULL)
        printf("STORE_INT(Reg:%02x) => %04d [Hex:%04x]\n", reg, value, value);
    if ((svm->registers[reg].type == STRING) && (svm->registers[reg].content.string))
        free(svm->registers[reg].content.string);
    svm->registers[reg].content.integer = value;
    svm->registers[reg].type = INTEGER;
    svm->ip += 1;
}
########################rank 2#############################
static void do_o_set_property(lily_vm_state *vm, uint16_t *code, int code_pos)
{
    lily_value **vm_regs = vm->vm_regs;
    lily_value *rhs_reg;
    int index;
    lily_instance_val *ival;
    ival = vm_regs[code[code_pos + 2]]->value.instance;
    index = code[code_pos + 3];
    rhs_reg = vm_regs[code[code_pos + 4]];
    lily_assign_value(vm, ival->values[index], rhs_reg);
}
########################rank 3#############################
cvar_t *Cvar_FullSet( const char *var_name, const char *value, cvar_flag_t flags, bool overwrite_flags ) {
	cvar_t *var;
	var = Cvar_Find( var_name );
	if( !var ) {
		return Cvar_Get( var_name, value, flags );
	}
	if( overwrite_flags ) {
		var->flags = flags;
	} else {
		Cvar_FlagSet( &var->flags, flags );
	}
	// if we overwrite the flags, we will also force the value
	return Cvar_Set2( var_name, value, overwrite_flags );
}
########################rank 4#############################
int vedis_value_is_float(vedis_value *pVal)
{
	return (pVal->iFlags & MEMOBJ_REAL) ? TRUE : FALSE;
}
########################rank 5#############################
int rl_str_pfcount(int argc, unsigned char **argv, long *argvlen, long *_card, unsigned char **updatevalue, long *updatevaluelen) {
    struct hllhdr *hdr;
    uint64_t card;
     *
     * When multiple keys are specified, PFCOUNT actually computes
     * the cardinality of the merge of the N HLLs specified. */
    if (argc > 1) {
        uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;
        int j;
        memset(max,0,sizeof(max));
        hdr = (struct hllhdr*) max;
        hdr->encoding = HLL_RAW; /* Special internal-only encoding. */
        registers = max + HLL_HDR_SIZE;
        for (j = 0; j < argc; j++) {
            if (argv[j] == NULL) continue; /* Assume empty HLL for non existing var. */
            if (isHLLObject(argv[j], argvlen[j]) != 0) return -1;
             * to MAX(max[i],hll[i]). */
            if (hllMerge(registers, argv[j], argvlen[j]) == 1) {
                return -1;
            }
        }
        // TODO: probably not 0
        *_card = hllCount(hdr, 0, NULL);
        return 0;
    }
     *
     * The user specified a single key. Either return the cached value
     * or compute one and update the cache. */
    if (argv[0] == NULL) {
         * we would have a key as HLLADD creates it as a side effect. */
        *_card = 0;
    } else {
        if (isHLLObject(argv[0], argvlen[0]) != 0) return -1;
        hdr = (struct hllhdr*)argv[0];
        if (HLL_VALID_CACHE(hdr)) {
            card = (uint64_t)hdr->card[0];
            card |= (uint64_t)hdr->card[1] << 8;
            card |= (uint64_t)hdr->card[2] << 16;
            card |= (uint64_t)hdr->card[3] << 24;
            card |= (uint64_t)hdr->card[4] << 32;
            card |= (uint64_t)hdr->card[5] << 40;
            card |= (uint64_t)hdr->card[6] << 48;
            card |= (uint64_t)hdr->card[7] << 56;
        } else {
            int invalid = 0;
            card = hllCount(hdr, argvlen[0], &invalid);
            if (invalid) {
                return -1;
            }
            hdr->card[0] = card & 0xff;
            hdr->card[1] = (card >> 8) & 0xff;
            hdr->card[2] = (card >> 16) & 0xff;
            hdr->card[3] = (card >> 24) & 0xff;
            hdr->card[4] = (card >> 32) & 0xff;
            hdr->card[5] = (card >> 40) & 0xff;
            hdr->card[6] = (card >> 48) & 0xff;
            hdr->card[7] = (card >> 56) & 0xff;
             * data structure is not modified, since the cached value
             * may be modified and given that the HLL is a Redis string
             * we need to propagate the change. */
            if (updatevalue) {
                *updatevalue = (unsigned char *)hdr;
            }
            if (updatevalue) {
                *updatevaluelen = argvlen[0];
            }
        }
        *_card = card;
    }
    return 0;
}
########################rank 6#############################
void lily_integer_to_s(lily_vm_state *vm, uint16_t argc, uint16_t *code)
{
    lily_value **vm_regs = vm->vm_regs;
    int64_t integer_val = vm_regs[code[0]]->value.integer;
    lily_value *result_reg = vm_regs[code[1]];
    char buffer[32];
    snprintf(buffer, 32, "%"PRId64, integer_val);
    lily_string_val *new_sv = lily_malloc(sizeof(lily_string_val));
    char *text = lily_malloc(strlen(buffer) + 1);
    strcpy(text, buffer);
    new_sv->string = text;
    new_sv->size = strlen(buffer);
    new_sv->refcount = 1;
    lily_raw_value v = {.string = new_sv};
    lily_move_raw_value(vm, result_reg, 0, v);
}
########################rank 7#############################
PH7_PRIVATE sxi32 PH7_VmSetByteCodeContainer(ph7_vm *pVm,SySet *pContainer)
{
	if( pContainer == 0 ){
		pVm->pByteContainer = &pVm->aByteCode;
	}else{
		pVm->pByteContainer = &(*pContainer);
	}
	return SXRET_OK;
}
########################rank 8#############################
vedis_value * vedis_context_new_scalar(vedis_context *pCtx)
{
	vedis_value *pVal;
	pVal = vedisNewObjectValue(pCtx->pVedis,0);
	if( pVal ){
		 * when the calling function returns. 
		 */
		SySetPut(&pCtx->sVar, (const void *)&pVal);
	}
	return pVal;
}
########################rank 9#############################
int vedis_value_is_scalar(vedis_value *pVal)
{
	return (pVal->iFlags & MEMOBJ_SCALAR) ? TRUE : FALSE;
}
########################rank 10#############################
SQLITE_PRIVATE void sqlite3StatusAdd(int op, int N){
  wsdStatInit;
  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );
  wsdStat.nowValue[op] += N;
  if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){
    wsdStat.mxValue[op] = wsdStat.nowValue[op];
  }
}
----------------------------QUERY-------------------------------
get random number between 0 and n-1
########################rank 1#############################
int32_t Qtos32(float q)
{
	return (int32_t) (q * (float) (INT32_MAX - 1));
}
########################rank 2#############################
int16_t Qtos16(float q)
{
	return (int16_t) (q * (float) (INT16_MAX - 1));
}
########################rank 3#############################
double
genrand_real1(void)
{
  return genrand_int32() * (1.0 / 4294967295.0);
}
########################rank 4#############################
double
genrand_real2(void)
{
  return genrand_int32() * (1.0 / 4294967296.0);
}
########################rank 5#############################
double genrand_real2(void)
{
    return genrand_int32()*(1.0/4294967296.0); 
}
########################rank 6#############################
float fmap(float x, float min1, float max1, float min2, float max2)
{
	return min2 + (x - min1) * (max2 - min2) / (max1 - min1);
}
########################rank 7#############################
double genrand_real3(void)
{
    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); 
}
########################rank 8#############################
double
genrand_real3(void)
{
  return (((double) genrand_int32()) + 0.5) * (1.0 / 4294967296.0);
}
########################rank 9#############################
static int my_ceil(float x)
{
        int y = (int) x;
        if (y - x > TOL)
                return y;
        else
                return y + 1;
}
########################rank 10#############################
PIX  *
pixMedianFilter(PIX     *pixs,
                l_int32  wf,
                l_int32  hf)
{
    PROCNAME("pixMedianFilter");
    if (!pixs)
        return (PIX *)ERROR_PTR("pixs not defined", procName, NULL);
    return pixRankFilter(pixs, wf, hf, 0.5);
}
----------------------------QUERY-------------------------------
stop stream server
########################rank 1#############################
int handle_connection_read(struct connection_node *cur_connection_node){
	int retval;
	message->data_type = DT_CONNECTION;
	message->header_type = DT_CONNECTION_HT_DATA;
	message->header_origin = cur_connection_node->origin;
	message->header_id = cur_connection_node->id;
	errno = 0;
	if((retval = read(cur_connection_node->fd, message->data, io->message_data_size)) < 1){
		if((verbose > 2) && retval){
			fprintf(stderr, "\rhandle_connection_read(): Connection %s closed: %s\n", cur_connection_node->rhost_rport, strerror(errno));
		}
		if(handle_send_dt_connection_ht_destroy(cur_connection_node->origin, cur_connection_node->id, errno) == -1){
			report_error("handle_connection_read(): handle_send_dt_connection_ht_destroy(%d, %d, errno): %s", cur_connection_node->origin, cur_connection_node->id, strerror(errno));
			return(-1);
		}
		connection_node_delete(cur_connection_node);
		return(-2);
	}
	message->data_len = retval;
	cur_connection_node->io_written += message->data_len;
	if((retval = message_push()) == -1){
		report_error("handle_connection_read(): message_push(): %s", strerror(errno));
		return(-1);
	}
	return(0);
}
########################rank 2#############################
static void
insertion_thread(void *v)
{
    struct ZoneFileParser *parser = (struct ZoneFileParser *)v;
    pixie_locked_add_u32(&parser->running_threads, 1);
    while (parser->is_running) {
        struct ParsedBlock *block = 0;
        int err;
        for (err=1; err && parser->is_running; ) {
            err = rte_ring_dequeue(parser->insertion_queue, (void**)&block);
            if (err != 0) {
                static int is_warning_printed = 0;
                if (!is_warning_printed) {
                    fprintf(stderr, "de-insertion slow, parser waiting\n");
                    is_warning_printed = 1;
                }
                fflush(stdout);
                pixie_usleep(100);
            }
        }
        insert_block_into_catalog(block, parser->callback, parser->callbackdata, block->filesize);
        //printf("." "INSERTION-THREAD: inserted block\n");
        rte_ring_enqueue(parser->free_queue, block);
    }
    pixie_locked_add_u32(&parser->running_threads, -1);
    printf("parser->running threads = %u\n", parser->running_threads);
}
########################rank 3#############################
int handle_message_dt_connection_ht_active_dormant(){
	struct connection_node *cur_connection_node;
	if((cur_connection_node = connection_node_find(message->header_origin, message->header_id)) == NULL){
		if(handle_send_dt_connection_ht_destroy(message->header_origin, message->header_id, 0) == -1){
			report_error("handle_message_dt_connection(): handle_send_dt_connection_ht_destroy(%d, %d, 0): %s", message->header_origin, message->header_id, strerror(errno));
			return(-1);
		}
		return(-2);
	}
	if(message->header_type == DT_CONNECTION_HT_DORMANT){
		cur_connection_node->state = CON_DORMANT;
		return(0);
	}
	if(message->header_type == DT_CONNECTION_HT_ACTIVE){
		cur_connection_node->state = CON_ACTIVE;
		return(0);
	}
	if(handle_send_dt_connection_ht_destroy(message->header_origin, message->header_id, 0) == -1){
		report_error("handle_message_dt_connection(): handle_send_dt_connection_ht_destroy(%d, %d, 0): %s", message->header_origin, message->header_id, strerror(errno));
		return(-1);
	}
	return(-2);
}
########################rank 4#############################
int32_t cc_cmd_send(struct s_client *cl, uint8_t *buf, int32_t len, cc_msg_type_t cmd)
{
	if(!cl->udp_fd)  //disconnected
		{ return -1; }
	struct s_reader *rdr = (cl->typ == 'c') ? NULL : cl->reader;
	int32_t n;
	struct cc_data *cc = cl->cc;
	if(!cl->cc || cl->kill) { return -1; }
	cs_writelock(__func__, &cc->lockcmd);
	if(!cl->cc || cl->kill)
	{
		cs_writeunlock(__func__, &cc->lockcmd);
		return -1;
	}
	uint8_t *netbuf;
	if(!cs_malloc(&netbuf, len + 4))
		{ return -1; }
	if(cmd == MSG_NO_HEADER)
	{
		memcpy(netbuf, buf, len);
	}
	else
	{
		// build command message
		netbuf[0] = cc->g_flag; // flags??
		netbuf[1] = cmd & 0xff;
		netbuf[2] = len >> 8;
		netbuf[3] = len & 0xff;
		if(buf)
			{ memcpy(netbuf + 4, buf, len); }
		len += 4;
	}
	cs_log_dump_dbg(D_CLIENT, netbuf, len, "cccam: send:");
	cc_crypt(&cc->block[ENCRYPT], netbuf, len, ENCRYPT);
	n = send(cl->udp_fd, netbuf, len, 0);
	cs_writeunlock(__func__, &cc->lockcmd);
	NULLFREE(netbuf);
	if(n != len)
	{
		if(rdr)
			{ cc_cli_close(cl, 1); }
		else
		{
			cs_writeunlock(__func__, &cc->cards_busy);
			cs_disconnect_client(cl);
		}
		n = -1;
	}
	return n;
}
########################rank 5#############################
static void SV_Web_ResetResponse( sv_http_response_t *response ) {
	if( response->filename ) {
		Mem_Free( response->filename );
		response->filename = NULL;
	}
	if( response->file ) {
		FS_FCloseFile( response->file );
		response->file = 0;
	}
	response->fileno = -1;
	response->file_data_offset = 0;
	response->file_send_pos = 0;
	response->content_state = CONTENT_STATE_DEFAULT;
	if( response->content ) {
		Mem_Free( response->content );
		response->content = NULL;
	}
	response->content_length = 0;
	SV_Web_ResetStream( &response->stream );
	response->code = HTTP_RESP_NONE;
}
########################rank 6#############################
int writeToClient(int fd, client *c, int handler_installed) {
    ssize_t nwritten = 0, totwritten = 0;
    size_t objlen;
    sds o;
    while(clientHasPendingReplies(c)) {
        if (c->bufpos > 0) {
            nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;
             * the remainder of the reply. */
            if (c->sentlen == c->bufpos) {
                c->bufpos = 0;
                c->sentlen = 0;
            }
        } else {
            o = listNodeValue(listFirst(c->reply));
            objlen = sdslen(o);
            if (objlen == 0) {
                listDelNode(c->reply,listFirst(c->reply));
                continue;
            }
            nwritten = write(fd, o + c->sentlen, objlen - c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;
            if (c->sentlen == objlen) {
                listDelNode(c->reply,listFirst(c->reply));
                c->sentlen = 0;
                c->reply_bytes -= objlen;
            }
        }
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver. */
        server.stat_net_output_bytes += totwritten;
        if (totwritten > NET_MAX_WRITES_PER_EVENT &&
            (server.maxmemory == 0 ||
             zmalloc_used_memory() < server.maxmemory)) break;
    }
    if (nwritten == -1) {
        if (errno == EAGAIN) {
            nwritten = 0;
        } else {
            serverLog(LL_VERBOSE,
                "Error writing to client: %s", strerror(errno));
            freeClient(c);
            return C_ERR;
        }
    }
    if (totwritten > 0) c->lastinteraction = server.unixtime;
    if (!clientHasPendingReplies(c)) {
        c->sentlen = 0;
        if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
            freeClient(c);
            return C_ERR;
        }
    }
    return C_OK;
}
########################rank 7#############################
int file_data(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint64_t position, const uint8_t *data,
              uint16_t length)
{
    if (friend_not_valid(m, friendnumber)) {
        return -1;
    }
    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -2;
    }
    if (filenumber >= MAX_CONCURRENT_FILE_PIPES) {
        return -3;
    }
    struct File_Transfers *ft = &m->friendlist[friendnumber].file_sending[filenumber];
    if (ft->status != FILESTATUS_TRANSFERRING) {
        return -4;
    }
    if (length > MAX_FILE_DATA_SIZE) {
        return -5;
    }
    if (ft->size - ft->transferred < length) {
        return -5;
    }
    if (ft->size != UINT64_MAX && length != MAX_FILE_DATA_SIZE && (ft->transferred + length) != ft->size) {
        return -5;
    }
    if (position != ft->transferred || (ft->requested <= position && ft->size != 0)) {
        return -7;
    }
     * TODO(irungentoo): remove */
    if (crypto_num_free_sendqueue_slots(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                                        m->friendlist[friendnumber].friendcon_id)) < MIN_SLOTS_FREE) {
        return -6;
    }
    int64_t ret = send_file_data_packet(m, friendnumber, filenumber, data, length);
    if (ret != -1) {
        // TODO(irungentoo): record packet ids to check if other received complete file.
        ft->transferred += length;
        if (ft->slots_allocated) {
            --ft->slots_allocated;
        }
        if (length != MAX_FILE_DATA_SIZE || ft->size == ft->transferred) {
            ft->status = FILESTATUS_FINISHED;
            ft->last_packet_number = ret;
        }
        return 0;
    }
    return -6;
}
########################rank 8#############################
static void CL_AsyncStream_Free( void *data, const char *filename, int fileline ) {
	_Mem_Free( data, 0, 0, filename, fileline );
}
########################rank 9#############################
int handle_message_dt_connection_ht_destroy(){
	struct connection_node *cur_connection_node;
	unsigned short header_errno;
	memcpy(&header_errno, message->data, sizeof(short));
	header_errno = ntohs(header_errno);
	if((cur_connection_node = connection_node_find(message->header_origin, message->header_id))){
		if(verbose && header_errno){
			fprintf(stderr, "\rhandle_message_dt_connection_ht_destroy(): Connection %s closed: %s\n", cur_connection_node->rhost_rport, strerror(header_errno));
		}
		connection_node_delete(cur_connection_node);
	}
	return(0);
}
########################rank 10#############################
int handle_message_dt_proxy_ht_destroy(){
	struct proxy_node *cur_proxy_node;
	unsigned short header_errno;
	memcpy(&header_errno, message->data, sizeof(short));
	header_errno = ntohs(header_errno);
	if((cur_proxy_node = proxy_node_find(message->header_origin, message->header_id))){
		if(verbose && header_errno){
			fprintf(stderr, "\rhandle_message_dt_proxy_ht_destroy(): Connection %s closed: %s\n", cur_proxy_node->rhost_rport, strerror(header_errno));
		}
		proxy_node_delete(cur_proxy_node);
	}
	return(0);
}
----------------------------QUERY-------------------------------
deallocate a dice object
########################rank 1#############################
void
ubasic_init_peek_poke(const char *program, peek_func peek, poke_func poke)
{
  program_ptr = program;
  for_stack_ptr = gosub_stack_ptr = 0;
  index_free();
  peek_function = peek;
  poke_function = poke;
  tokenizer_init(program);
  ended = 0;
}
########################rank 2#############################
void closeParsedata(parsedata * pdata) {
    //free(pdata->shps);
    //free(pdata->dbfs);
    free(pdata->parent);
    free(pdata->current);
    free(pdata->databuf);
    free(pdata->attr);
    free(pdata->pattr);
    free(pdata);
}
########################rank 3#############################
static int unicodeDestroy(sqlite3_tokenizer *pTokenizer){
  if( pTokenizer ){
    unicode_tokenizer *p = (unicode_tokenizer *)pTokenizer;
    sqlite3_free(p->aiException);
    sqlite3_free(p);
  }
  return SQLITE_OK;
}
########################rank 4#############################
int sqlite3UnixDelete(const char *zFilename){
  unlink(zFilename);
  return SQLITE_OK;
}
########################rank 5#############################
int
posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions,
				 int fd, int newfd)
{
	int maxfd = sysconf(_SC_OPEN_MAX);
	struct __spawn_action *rec;
	if (fd < 0 || newfd < 0 || fd >= maxfd || newfd >= maxfd)
		return EBADF;
	if (file_actions->__used == file_actions->__allocated
	    && __posix_spawn_file_actions_realloc (file_actions) != 0)
		return ENOMEM;
	rec = &file_actions->__actions[file_actions->__used];
	rec->tag = spawn_do_dup2;
	rec->action.dup2_action.fd = fd;
	rec->action.dup2_action.newfd = newfd;
	++file_actions->__used;
	return 0;
}
########################rank 6#############################
static int UnixFile_Lock(void *pUserData,int lock_type)
{
	int fd = SX_PTR_TO_INT(pUserData);
	int rc = PH7_OK; 
	if( lock_type < 0 ){
		rc = flock(fd,LOCK_UN);
	}else{
		if( lock_type == 1 ){
			rc = flock(fd,LOCK_EX);
		}else{
			rc = flock(fd,LOCK_SH);
		}
	}
	return !rc ? PH7_OK : -1;
}
########################rank 7#############################
static SorterRecord *vdbeSorterMerge(
  SortSubtask *pTask,             /* Calling thread context */
  SorterRecord *p1,               /* First list to merge */
  SorterRecord *p2                /* Second list to merge */
){
  SorterRecord *pFinal = 0;
  SorterRecord **pp = &pFinal;
  int bCached = 0;
  assert( p1!=0 && p2!=0 );
  for(;;){
    int res;
    res = pTask->xCompare(
        pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal
    );
    if( res<=0 ){
      *pp = p1;
      pp = &p1->u.pNext;
      p1 = p1->u.pNext;
      if( p1==0 ){
        *pp = p2;
        break;
      }
    }else{
      *pp = p2;
      pp = &p2->u.pNext;
      p2 = p2->u.pNext;
      bCached = 0;
      if( p2==0 ){
        *pp = p1;
        break;
      }
    }
  }
  return pFinal;
}
########################rank 8#############################
void
ubasic_init(const char *program)
{
  program_ptr = program;
  for_stack_ptr = gosub_stack_ptr = 0;
  index_free();
  tokenizer_init(program);
  ended = 0;
}
########################rank 9#############################
BOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree) {
  if (item == NULL || ptr == NULL) return FALSE;
  if (pfree == BINN_TRANSIENT) {
    item->ptr = binn_memdup(ptr, size);
    if (item->ptr == NULL) return FALSE;
    item->freefn = free_fn;
  } else {
    item->ptr = ptr;
    item->freefn = pfree;
  }
  item->type = BINN_BLOB;
  item->size = size;
  return TRUE;
}
########################rank 10#############################
static MergeEngine *vdbeMergeEngineNew(int nReader){
  int N = 2;                      /* Smallest power of two >= nReader */
  int nByte;                      /* Total bytes of space to allocate */
  MergeEngine *pNew;              /* Pointer to allocated object to return */
  assert( nReader<=SORTER_MAX_MERGE_COUNT );
  while( N<nReader ) N += N;
  nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));
  pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);
  if( pNew ){
    pNew->nTree = N;
    pNew->pTask = 0;
    pNew->aReadr = (PmaReader*)&pNew[1];
    pNew->aTree = (int*)&pNew->aReadr[N];
  }
  return pNew;
}
----------------------------QUERY-------------------------------
get length of UCS2 string
########################rank 1#############################
extern symbol * str_data(const struct str * str) {
    return str->data;
}
########################rank 2#############################
int len(char *s) {
    return strlen(s);
}
########################rank 3#############################
int len(char *s) {
    return strlen(s);
}
########################rank 4#############################
int compare_str(const void * a, const void * b) {
	return strcmp(*(const char **)a, *(const char **)b);
}
########################rank 5#############################
unsigned int string_hash(void *string)
{
	unsigned int result = 5381;
	unsigned char *p;
	p = (unsigned char *) string;
	while (*p != '\0') {
		result = (result << 5) + result + *p;
		++p;
	}
	return result;
}
########################rank 6#############################
char *strchr(const char *str, int c) 
{
    for (; *str; str++)
        if (*str == c) return (char*)++str;
    return (char*)0;
}
########################rank 7#############################
static char *iptostr4(char *strbuf, const unsigned char *ip) {
    long long i, len = 0;
    unsigned long long num;
    for (i = 3; i >= 0; --i) {
        num = ip[i];
        do {
            num /= 10; ++len;
        } while (num);
        if (i > 0) ++len;
    }
    strbuf += len;
    for (i = 3; i >= 0; --i) {
        num = ip[i];
        do {
            *--strbuf = '0' + (num % 10);
            num /= 10;
        } while (num);
        if (i > 0) *--strbuf = '.';
    }
    while (len < IPTOSTR_LEN) strbuf[len++] = 0;
    return strbuf;
}
########################rank 8#############################
int ws( const char *str)
{
  int k;
  for(k=0;k<strlen(str);k++) {
    if( (str[k] != ' ') && (str[k] != '\t') )
      return k;
  }
  return -1;
}
########################rank 9#############################
int
bufcmp(const struct buf *a, const struct buf *b)
{
	size_t i = 0;
	size_t cmplen;
	if (a == b) return 0;
	if (!a) return -1; else if (!b) return 1;
	cmplen = (a->size < b->size) ? a->size : b->size;
	while (i < cmplen && a->data[i] == b->data[i]) ++i;
	if (i < a->size) {
		if (i < b->size)	return a->data[i] - b->data[i];
		else			return 1; }
	else {	if (i < b->size)	return -1;
		else			return 0; } }
int
bufcmps(const struct buf *a, const char *b)
{
	const size_t len = strlen(b);
	size_t cmplen = len;
	int r;
	if (!a || !a->size)
		return b ? 0 : -1;
	if (len < a->size)
		cmplen = a->size;
	r = strncmp(a->data, b, cmplen);
	if (r) return r;
	else if (a->size == len) return 0;
	else if (a->size < len) return -1;
	else return 1;
}
########################rank 10#############################
int
length(s)
        char	*s;
{
	register int	l;
	register char	*p;
	l = 0;
	p = s;
	while (*p++)
		l++;
	return(l);
}
----------------------------QUERY-------------------------------
contrain maximum of a range
########################rank 1#############################
unsigned rev(unsigned x)
{
	x = ((x & 0x55555555) << 1) | ((x >> 1) & 0x55555555);
	x = ((x & 0x33333333) << 2) | ((x >> 2) & 0x33333333);
	x = ((x & 0x0F0F0F0F) << 4) | ((x >> 4) & 0x0F0F0F0F);
	return (x << 24) | ((x & 0xFF00) << 8) | ((x >> 8) & 0xFF00) | (x >> 24);
}
########################rank 2#############################
int cc_fprintf(cc_color_t color, FILE* stream, const char* format, ...) {
    va_list ap;
    va_start(ap, format);
    int result = -EINVAL;
    if (stream != stdout && stream != stderr) {
        result = Write(stream, format, ap);
        goto finish;
    }
    const unsigned int fg =
        color & ((1 << CC_COLOR_BITS) - 1);
    const unsigned int bg =
        (color >> CC_COLOR_BITS) & ((1 << CC_COLOR_BITS) - 1);
#ifdef _WIN32
    const HANDLE console = GetStdHandle(
            stream == stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);
    if (console == INVALID_HANDLE_VALUE) {
        result = Write(stream, format, ap);
        goto finish;
    }
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (!GetConsoleScreenBufferInfo(console, &csbi)) {
        result = Write(stream, format, ap);
        goto finish;
    }
    SetConsoleTextAttribute(console, Generate(fg, bg, csbi.wAttributes));
    result = Write(stream, format, ap);
    SetConsoleTextAttribute(console, csbi.wAttributes);
#else
    UnixTerminalColorize(stream, fg, bg);
    Write(stream, format, ap);
    UnixTerminalRestore(stream);
#endif  
finish:
    va_end(ap);
    return result;
}
########################rank 3#############################
int loop_while_old(int a, int b)
{
    int i = 0;
    int result = a;
    while (i < 256) {
	result += a;
	a -= b;
	i += b;
    }
    return result;
}
########################rank 4#############################
extern int r[];
int *fn(int i)
{
	return &r[i];
}
########################rank 5#############################
DUK_LOCAL duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
	DUK_ASSERT(start >= 0);
	DUK_ASSERT(end >= 0);
	DUK_ASSERT(end >= start);
	if (start >= 0x10000) {
		return end;
	}
	return start;
}
########################rank 6#############################
DUK_LOCAL duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
	DUK_ASSERT(start >= 0);
	DUK_ASSERT(end >= 0);
	DUK_ASSERT(end >= start);
	if (start >= 0x10000) {
		return end;
	}
	return start;
}
########################rank 7#############################
DUK_LOCAL duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
	DUK_ASSERT(start >= 0);
	DUK_ASSERT(end >= 0);
	DUK_ASSERT(end >= start);
	if (start >= 0x10000) {
		return end;
	}
	return start;
}
########################rank 8#############################
static int is_end(char c) {
    return (!c || c == '\n' || c == ';');
}
########################rank 9#############################
int luaO_ceillog2(unsigned int x) {
	static const lu_byte log_2[256] = {  
		0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
	};
	int l = 0;
	x--;
	while (x >= 256) { l += 8; x >>= 8; }
	return l + log_2[x];
}
########################rank 10#############################
DUK_LOCAL duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
	DUK_ASSERT(start >= 0);
	DUK_ASSERT(end >= 0);
	DUK_ASSERT(end >= start);
	if (start >= 0x10000) {
		return end;
	}
	return start;
}
----------------------------QUERY-------------------------------
pad given buffer with len padding characters
########################rank 1#############################
void bufferCheckSize(Buffer out, int bytes)
{
	if(bytes > out->free)
	{
		int New = BUFFER_INCREMENT * ((bytes-out->free-1)/BUFFER_INCREMENT + 1);
		int num = bufferLength(out); /* in case buffer gets displaced.. */
		unsigned char *newbuf = (unsigned char*)realloc(out->buffer, out->buffersize+New);
		if(newbuf != out->buffer)
		{
			int pushd;
			if(out->pushloc)
	pushd = out->pos - out->pushloc;
			out->pos = newbuf+num;
			if(out->pushloc)
	out->pushloc = out->pos - pushd;
		}
		out->buffer = newbuf;
		out->buffersize += New;
		out->free += New;
	}
}
########################rank 2#############################
static void
append_byte(unsigned char *buf, size_t *buf_length, size_t buf_max, unsigned c)
{
    if (*buf_length < buf_max)
        buf[(*buf_length)++] = (unsigned char)c;
}
########################rank 3#############################
static void
append_byte(unsigned char *buf, size_t *buf_length, size_t buf_max, unsigned c)
{
    if (*buf_length < buf_max)
        buf[(*buf_length)++] = (unsigned char)c;
}
########################rank 4#############################
HB_INTERNAL void
_hb_buffer_clear_output( HB_Buffer buffer )
{
  buffer->out_length = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
}
########################rank 5#############################
static void XZ_FUNC bcj_flush(struct xz_dec_bcj *s, struct xz_buf *b)
{
	size_t copy_size;
	copy_size = min_t(size_t, s->temp.filtered, b->out_size - b->out_pos);
	memcpy(b->out + b->out_pos, s->temp.buf, copy_size);
	b->out_pos += copy_size;
	s->temp.filtered -= copy_size;
	s->temp.size -= copy_size;
	memmove(s->temp.buf, s->temp.buf + copy_size, s->temp.size);
}
########################rank 6#############################
void SKP_Silk_range_enc_init(
    SKP_Silk_range_coder_state      *psRC               
)
{
    psRC->bufferLength = MAX_ARITHM_BYTES;
    psRC->range_Q16    = 0x0000FFFF;
    psRC->bufferIx     = 0;
    psRC->base_Q32     = 0;
    psRC->error        = 0;
}
########################rank 7#############################
static void assemble_write_tram(struct ivals_context *ctx,
				unsigned int offset,
				unsigned int value)
{
	assemble_write_mmio(ctx, 0x130, SIZE_32BIT, offset);
	assemble_write_mmio(ctx, 0x134, SIZE_32BIT, value);
}
########################rank 8#############################
int write_int4_array(int f, const int *i, int n)
{
#ifdef _CRAY
    int j, nwritten;
    char *buf, *b, *ptr;
    b = buf = (char *)G_malloc(n * 4 + 8);
    if (!b)
	return 0;
    ptr = (char *)i;
    for (j = 0; j < n; j++) {
	ptr += 4;		/* skip upper 4 bytes */
	*b++ = *ptr++;
	*b++ = *ptr++;
	*b++ = *ptr++;
	*b++ = *ptr++;
    }
    nwritten = write(f, buf, 4 * n);
    G_free(buf);
    if (nwritten <= 0)
	return 0;
    else
	return nwritten / 4;
#else
#  ifdef LITTLE
    int nwritten;
    flip4((const unsigned int *)i, (unsigned int *)i, n);
    nwritten = write(f, i, 4 * n);
    flip4((const unsigned int *)i, (unsigned int *)i, n);
    if (nwritten <= 0)
	return 0;
    else
	return nwritten / 4;
#  else
    return write(f, i, 4 * n) / 4;
#  endif
#endif
}
########################rank 9#############################
int jpegsize = 0;
void myjpegwrite(void *context, void *data, int size)
{
	memcpy( buf + jpegsize, data, size );
	jpegsize += size;
}
########################rank 10#############################
void
buffer_fill(buffer_t *self, int c) {
  memset(self->data, c, self->len);
}
----------------------------QUERY-------------------------------
write data in output buffers to client
########################rank 1#############################
size_t
_write(int handle, const unsigned char *buffer, size_t size)
{
  int data_idx;
  for(data_idx = 0; data_idx < size; data_idx++) {
    __io_putchar(*buffer++);
  }
  return size;
}
########################rank 2#############################
static int
_null_write(stream_id nst, char *s, int count)
{
    Succeed_;
}
########################rank 3#############################
void AsyncStream_UrlEncodeUnsafeChars( const char *src, char *dst, size_t size ) {
	Q_urlencode_unsafechars( src, dst, size );
}
########################rank 4#############################
static int rioBufferFlush(rio *r) {
    UNUSED(r);
    return 1; /* Nothing to do, our write just appends to the buffer. */
}
########################rank 5#############################
static void
cert_out_close(struct Output *out, FILE *fp)
{    
    UNUSEDPARM(out);
    fprintf(fp, "{finished: 1}\n");
}
########################rank 6#############################
static void SNAP_DemoMetaDataMessage( msg_t *msg, const char *meta_data, size_t meta_data_realsize ) {
	int demoinfo_len, demoinfo_len_pos, demoinfo_end;
	int meta_data_ofs, meta_data_ofs_pos;
	// demoinfo message
	MSG_WriteUint8( msg, svc_demoinfo );
	demoinfo_len_pos = msg->cursize;
	MSG_WriteInt32( msg, 0 );    // svc_demoinfo length
	demoinfo_len = msg->cursize;
	meta_data_ofs_pos = msg->cursize;
	MSG_WriteInt32( msg, 0 );    // meta data start offset
	meta_data_ofs = msg->cursize;
	if( meta_data_realsize > SNAP_MAX_DEMO_META_DATA_SIZE ) {
		meta_data_realsize = SNAP_MAX_DEMO_META_DATA_SIZE;
	}
	if( meta_data_realsize > 0 ) {
		meta_data_realsize--;
	}
	meta_data_ofs = msg->cursize - meta_data_ofs;
	MSG_WriteInt32( msg, meta_data_realsize );       // real size
	MSG_WriteInt32( msg, SNAP_MAX_DEMO_META_DATA_SIZE ); // max size
	MSG_WriteData( msg, meta_data, meta_data_realsize );
	MSG_WriteData( msg, dummy_meta_data, SNAP_MAX_DEMO_META_DATA_SIZE - meta_data_realsize );
	demoinfo_end = msg->cursize;
	demoinfo_len = msg->cursize - demoinfo_len;
	msg->cursize = demoinfo_len_pos;
	MSG_WriteInt32( msg, demoinfo_len ); // svc_demoinfo length
	msg->cursize = meta_data_ofs_pos;
	MSG_WriteInt32( msg, meta_data_ofs );    // meta data start offset
	msg->cursize = demoinfo_end;
}
########################rank 7#############################
static ID_INLINE void SafeFS_Write( const void *buffer, int len, fileHandle_t f )
{
  if( FS_Write( buffer, len, f ) < len )
    Com_Error( ERR_DROP, "Failed to write avi file\n" );
}
########################rank 8#############################
int unqlite_context_throw_error_format(unqlite_context *pCtx, int iErr, const char *zFormat, ...)
{
	va_list ap;
	int rc;
	if( zFormat == 0){
		return JX9_OK;
	}
	va_start(ap, zFormat);
	rc = jx9VmThrowErrorAp(pCtx->pVm, &pCtx->pFunc->sName, iErr, zFormat, ap);
	va_end(ap);
	return rc;
}
########################rank 9#############################
static int
_print2fp(const void *buffer, size_t size, void *app_key) {
	FILE *stream = (FILE *)app_key;
	if(fwrite(buffer, 1, size, stream) != size)
		return -1;
	return 0;
}
########################rank 10#############################
l_int32
pixWriteStreamPdf(FILE        *fp,
                  PIX         *pix,
                  l_int32      res,
                  const char  *title)
{
l_uint8  *data;
size_t    nbytes, nbytes_written;
    PROCNAME("pixWriteStreamPdf");
    if (!fp)
        return ERROR_INT("stream not opened", procName, 1);
    if (!pix)
        return ERROR_INT("pix not defined", procName, 1);
    if (pixWriteMemPdf(&data, &nbytes, pix, res, title) != 0)
        return ERROR_INT("pdf data not made", procName, 1);
    nbytes_written = fwrite(data, 1, nbytes, fp);
    FREE(data);
    if (nbytes != nbytes_written)
        return ERROR_INT("failure writing pdf data to stream", procName, 1);
    return 0;
}
----------------------------QUERY-------------------------------
generate trace call to print
########################rank 1#############################
static void bytecode_init(Bytecode *bc)
{
	bc->insns = NULL;
	bc->len = 0;
	bc->allocsz = 0;
}
########################rank 2#############################
static int add_mount(const char *progname, const char *fsname,
		       const char *mnt, const char *type, const char *opts)
{
	int res;
	int status;
	sigset_t blockmask;
	sigset_t oldmask;
	sigemptyset(&blockmask);
	sigaddset(&blockmask, SIGCHLD);
	res = sigprocmask(SIG_BLOCK, &blockmask, &oldmask);
	if (res == -1) {
		fprintf(stderr, "%s: sigprocmask: %s\n", progname, strerror(errno));
		return -1;
	}
	res = fork();
	if (res == -1) {
		fprintf(stderr, "%s: fork: %s\n", progname, strerror(errno));
		goto out_restore;
	}
	if (res == 0) {
		sigprocmask(SIG_SETMASK, &oldmask, NULL);
		setuid(geteuid());
		execl("/bin/mount", "/bin/mount", "--no-canonicalize", "-i",
		      "-f", "-t", type, "-o", opts, fsname, mnt, NULL);
		fprintf(stderr, "%s: failed to execute /bin/mount: %s\n",
			progname, strerror(errno));
		exit(1);
	}
	res = waitpid(res, &status, 0);
	if (res == -1)
		fprintf(stderr, "%s: waitpid: %s\n", progname, strerror(errno));
	if (status != 0)
		res = -1;
 out_restore:
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	return res;
}
########################rank 3#############################
static void onsigint(int signo) { interrupted = true; }
int main(int argc, char *argv[]) {
  int err;
  signal(SIGINT, onsigint);
  if (init(argc, argv)) exit(EX_USAGE);
  if ((err = setup())) goto fail_0;
  if ((err = run())) goto fail_1;
  cleanup();
  output();
  exit(0);
fail_1:
  cleanup();
fail_0:
  exit(err == EINTR ? EX_SOFTWARE : EX_OSERR);
}
########################rank 4#############################
static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, GCproto *pt)
{
  MSize nbc = pt->sizebc-1;  
#if LJ_HASJIT
  uint8_t *q = (uint8_t *)p;
#endif
  p = lj_buf_wmem(p, proto_bc(pt)+1, nbc*(MSize)sizeof(BCIns));
  UNUSED(ctx);
#if LJ_HASJIT
  if ((pt->flags & PROTO_ILOOP) || pt->trace) {
    jit_State *J = L2J(sbufL(&ctx->sb));
    MSize i;
    for (i = 0; i < nbc; i++, q += sizeof(BCIns)) {
      BCOp op = (BCOp)q[LJ_ENDIAN_SELECT(0, 3)];
      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP ||
	  op == BC_JFORI) {
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_IFORL+BC_FORL);
      } else if (op == BC_JFORL || op == BC_JITERL || op == BC_JLOOP) {
	BCReg rd = q[LJ_ENDIAN_SELECT(2, 1)] + (q[LJ_ENDIAN_SELECT(3, 0)] << 8);
	BCIns ins = traceref(J, rd)->startins;
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_JFORL+BC_FORL);
	q[LJ_ENDIAN_SELECT(2, 1)] = bc_c(ins);
	q[LJ_ENDIAN_SELECT(3, 0)] = bc_b(ins);
      }
    }
  }
#endif
  return p;
}
########################rank 5#############################
static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, GCproto *pt)
{
  MSize nbc = pt->sizebc-1;  
#if LJ_HASJIT
  uint8_t *q = (uint8_t *)p;
#endif
  p = lj_buf_wmem(p, proto_bc(pt)+1, nbc*(MSize)sizeof(BCIns));
  UNUSED(ctx);
#if LJ_HASJIT
  if ((pt->flags & PROTO_ILOOP) || pt->trace) {
    jit_State *J = L2J(sbufL(&ctx->sb));
    MSize i;
    for (i = 0; i < nbc; i++, q += sizeof(BCIns)) {
      BCOp op = (BCOp)q[LJ_ENDIAN_SELECT(0, 3)];
      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP ||
	  op == BC_JFORI) {
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_IFORL+BC_FORL);
      } else if (op == BC_JFORL || op == BC_JITERL || op == BC_JLOOP) {
	BCReg rd = q[LJ_ENDIAN_SELECT(2, 1)] + (q[LJ_ENDIAN_SELECT(3, 0)] << 8);
	BCIns ins = traceref(J, rd)->startins;
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_JFORL+BC_FORL);
	q[LJ_ENDIAN_SELECT(2, 1)] = bc_c(ins);
	q[LJ_ENDIAN_SELECT(3, 0)] = bc_b(ins);
      }
    }
  }
#endif
  return p;
}
########################rank 6#############################
static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, GCproto *pt)
{
  MSize nbc = pt->sizebc-1;  
#if LJ_HASJIT
  uint8_t *q = (uint8_t *)p;
#endif
  p = lj_buf_wmem(p, proto_bc(pt)+1, nbc*(MSize)sizeof(BCIns));
  UNUSED(ctx);
#if LJ_HASJIT
  if ((pt->flags & PROTO_ILOOP) || pt->trace) {
    jit_State *J = L2J(sbufL(&ctx->sb));
    MSize i;
    for (i = 0; i < nbc; i++, q += sizeof(BCIns)) {
      BCOp op = (BCOp)q[LJ_ENDIAN_SELECT(0, 3)];
      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP ||
	  op == BC_JFORI) {
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_IFORL+BC_FORL);
      } else if (op == BC_JFORL || op == BC_JITERL || op == BC_JLOOP) {
	BCReg rd = q[LJ_ENDIAN_SELECT(2, 1)] + (q[LJ_ENDIAN_SELECT(3, 0)] << 8);
	BCIns ins = traceref(J, rd)->startins;
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_JFORL+BC_FORL);
	q[LJ_ENDIAN_SELECT(2, 1)] = bc_c(ins);
	q[LJ_ENDIAN_SELECT(3, 0)] = bc_b(ins);
      }
    }
  }
#endif
  return p;
}
########################rank 7#############################
static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, GCproto *pt)
{
  MSize nbc = pt->sizebc-1;  
#if LJ_HASJIT
  uint8_t *q = (uint8_t *)p;
#endif
  p = lj_buf_wmem(p, proto_bc(pt)+1, nbc*(MSize)sizeof(BCIns));
  UNUSED(ctx);
#if LJ_HASJIT
  if ((pt->flags & PROTO_ILOOP) || pt->trace) {
    jit_State *J = L2J(sbufL(&ctx->sb));
    MSize i;
    for (i = 0; i < nbc; i++, q += sizeof(BCIns)) {
      BCOp op = (BCOp)q[LJ_ENDIAN_SELECT(0, 3)];
      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP ||
	  op == BC_JFORI) {
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_IFORL+BC_FORL);
      } else if (op == BC_JFORL || op == BC_JITERL || op == BC_JLOOP) {
	BCReg rd = q[LJ_ENDIAN_SELECT(2, 1)] + (q[LJ_ENDIAN_SELECT(3, 0)] << 8);
	BCIns ins = traceref(J, rd)->startins;
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_JFORL+BC_FORL);
	q[LJ_ENDIAN_SELECT(2, 1)] = bc_c(ins);
	q[LJ_ENDIAN_SELECT(3, 0)] = bc_b(ins);
      }
    }
  }
#endif
  return p;
}
########################rank 8#############################
static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, GCproto *pt)
{
  MSize nbc = pt->sizebc-1;  
#if LJ_HASJIT
  uint8_t *q = (uint8_t *)p;
#endif
  p = lj_buf_wmem(p, proto_bc(pt)+1, nbc*(MSize)sizeof(BCIns));
  UNUSED(ctx);
#if LJ_HASJIT
  if ((pt->flags & PROTO_ILOOP) || pt->trace) {
    jit_State *J = L2J(sbufL(&ctx->sb));
    MSize i;
    for (i = 0; i < nbc; i++, q += sizeof(BCIns)) {
      BCOp op = (BCOp)q[LJ_ENDIAN_SELECT(0, 3)];
      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP ||
	  op == BC_JFORI) {
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_IFORL+BC_FORL);
      } else if (op == BC_JFORL || op == BC_JITERL || op == BC_JLOOP) {
	BCReg rd = q[LJ_ENDIAN_SELECT(2, 1)] + (q[LJ_ENDIAN_SELECT(3, 0)] << 8);
	BCIns ins = traceref(J, rd)->startins;
	q[LJ_ENDIAN_SELECT(0, 3)] = (uint8_t)(op-BC_JFORL+BC_FORL);
	q[LJ_ENDIAN_SELECT(2, 1)] = bc_c(ins);
	q[LJ_ENDIAN_SELECT(3, 0)] = bc_b(ins);
      }
    }
  }
#endif
  return p;
}
########################rank 9#############################
static void
log_stack_trace(ucontext_t *uc)
{
    void *trace[100];
    int trace_size = 0;
    int fd         = logger_fd >= 0 ? logger_fd : STDOUT_FILENO;
    trace_size = backtrace(trace, 100);
    if (getMcontextEip(uc) != NULL)
        trace[1] = getMcontextEip(uc);
    backtrace_symbols_fd(trace, trace_size, fd);
}
########################rank 10#############################
void print_valid_escapes(){
	printf("\n\n");
	printf("\rSupported revsh escape sequences:\n");
	printf("\n");
	printf("\r~.\tExit. (Good for killing an unresponsive session.)\n");
	printf("\r~#\tList active connections with usage statistics.\n");
	printf("\r~?\tList the supported revsh escape sequences.\n");
	printf("\r\n");
}
----------------------------QUERY-------------------------------
get dimensions of given bmp file
########################rank 1#############################
static int zero_sectors(struct ipod_t* ipod, uint64_t sector, int count)
{
    int n;
    if (ipod_seek(ipod, sector * ipod->sector_size) < 0) {
        fprintf(stderr,"[ERR]  Seek failed\n");
        return -1;
    }
    memset(ipod->sectorbuf, 0, 128 * ipod->sector_size);
    while (count) {
        if (count >= 128)
            n = 128;
        else
            n = count;
        if (ipod_write(ipod,n * ipod->sector_size) < 0) {
            perror("[ERR]  Write failed in zero_sectors\n");
            return -1;
        }
        count -= n;
    }
    return 0;
}
########################rank 2#############################
static void
ide_next_sector(ide_t *ide)
{
    if (ide->lba)
	ide->lba_addr++;
    else {
	ide->sector++;
	if (ide->sector == (ide->cfg_spt + 1)) {
		ide->sector = 1;
		ide->head++;
		if (ide->head == ide->cfg_hpc) {
			ide->head = 0;
			ide->cylinder++;
		}
	}
    }
}
########################rank 3#############################
png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_fixed_point igamma;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float file_gamma;
#endif
   png_byte buf[4];
   png_debug(1, "in png_handle_gAMA\n");
   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before gAMA");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid gAMA after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      png_warning(png_ptr, "Out of place gAMA chunk");
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
#if defined(PNG_READ_sRGB_SUPPORTED)
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate gAMA chunk");
      png_crc_finish(png_ptr, length);
      return;
   }
   if (length != 4)
   {
      png_warning(png_ptr, "Incorrect gAMA chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }
   png_crc_read(png_ptr, buf, 4);
   if (png_crc_finish(png_ptr, 0))
      return;
   igamma = (png_fixed_point)png_get_uint_32(buf);
   if (igamma == 0)
      {
         png_warning(png_ptr,
           "Ignoring gAMA chunk with gamma=0");
         return;
      }
#if defined(PNG_READ_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
         fprintf(stderr, "gamma = (%d/100000)\n", (int)igamma);
#endif
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */
#ifdef PNG_FLOATING_POINT_SUPPORTED
   file_gamma = (float)igamma / (float)100000.0;
#  ifdef PNG_READ_GAMMA_SUPPORTED
     png_ptr->gamma = file_gamma;
#  endif
     png_set_gAMA(png_ptr, info_ptr, file_gamma);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
#endif
}
########################rank 4#############################
int blkdev_get_physector_size(int fd, int *sector_size)
{
#ifdef BLKPBSZGET
	if (ioctl(fd, BLKPBSZGET, &sector_size) >= 0)
		return 0;
	return -1;
#else
	(void)fd; /* prevent unused parameter warning */
	*sector_size = DEFAULT_SECTOR_SIZE;
	return 0;
#endif
}
########################rank 5#############################
enum ImgTypes file_type(const char *file_name)
{
	size_t l = file_name ? strlen(file_name) : 0, sf = l > 3 ? l - 3 : 0;
	return	!sf ? IMG_error :
		!strncmp(file_name + sf, "tga", 3) ? IMG_tga :
		!strncmp(file_name + sf, "ppm", 3) ? IMG_ppm :
		!strncmp(file_name + sf, "pgm", 3) ? IMG_pgm :
		IF_PNG(!strncmp(file_name + sf, "png", 3) ? IMG_png :)
		IF_JPG(!strncmp(file_name + sf, "jpg", 3) ? IMG_jpg :)
		IF_JPG(!strncmp(file_name + sf - 1, "jpeg", 4) ? IMG_jpg :)
		!strncmp(file_name + sf, "raw", 3) ? IMG_raw : IMG_error;
}
########################rank 6#############################
png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_fixed_point igamma;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float file_gamma;
#endif
   png_byte buf[4];
   png_debug(1, "in png_handle_gAMA");
   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before gAMA");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid gAMA after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      png_warning(png_ptr, "Out of place gAMA chunk");
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
#ifdef PNG_READ_sRGB_SUPPORTED
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate gAMA chunk");
      png_crc_finish(png_ptr, length);
      return;
   }
   if (length != 4)
   {
      png_warning(png_ptr, "Incorrect gAMA chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }
   png_crc_read(png_ptr, buf, 4);
   if (png_crc_finish(png_ptr, 0))
      return;
   igamma = (png_fixed_point)png_get_uint_32(buf);
   if (igamma == 0)
      {
         png_warning(png_ptr,
           "Ignoring gAMA chunk with gamma=0");
         return;
      }
#ifdef PNG_READ_sRGB_SUPPORTED
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifdef PNG_CONSOLE_IO_SUPPORTED
         fprintf(stderr, "gamma = (%d/100000)", (int)igamma);
#endif
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */
#ifdef PNG_FLOATING_POINT_SUPPORTED
   file_gamma = (float)igamma / (float)100000.0;
#  ifdef PNG_READ_GAMMA_SUPPORTED
     png_ptr->gamma = file_gamma;
#  endif
     png_set_gAMA(png_ptr, info_ptr, file_gamma);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
#endif
}
########################rank 7#############################
void
resetMorphBoundaryCondition(l_int32  bc)
{
    PROCNAME("resetMorphBoundaryCondition");
    if (bc != SYMMETRIC_MORPH_BC && bc != ASYMMETRIC_MORPH_BC) {
        L_WARNING("invalid bc; using asymmetric", procName);
        bc = ASYMMETRIC_MORPH_BC;
    }
    MORPH_BC = bc;
    return;
}
########################rank 8#############################
static off64_t
ide_get_sector(ide_t *ide)
{
    uint32_t heads, sectors;
    if (ide->lba)
	return (off64_t)ide->lba_addr + ide->skip512;
    else {
	heads = ide->cfg_hpc;
	sectors = ide->cfg_spt;
	return ((((off64_t) ide->cylinder * heads) + ide->head) *
		sectors) + (ide->sector - 1) + ide->skip512;
    }
}
########################rank 9#############################
static int
bin_read(void *p, uint8_t *buffer, uint64_t seek, size_t count)
{
    track_file_t *tf = (track_file_t *) p;
    cdrom_image_backend_log("CDROM: binary_read(%08lx, pos=%" PRIu64 " count=%lu\n",
		     tf->file, seek, count);
    if (tf->file == NULL)
	return 0;
    if (fseeko64(tf->file, seek, SEEK_SET) == -1) {
#ifdef ENABLE_cdrom_image_backend_log
	cdrom_image_backend_log("CDROM: binary_read failed during seek!\n");
#endif
	return 0;
    }
    if (fread(buffer, count, 1, tf->file) != 1) {
#ifdef ENABLE_cdrom_image_backend_log
	cdrom_image_backend_log("CDROM: binary_read failed during read!\n");
#endif
	return 0;
    }
    return 1;
}
########################rank 10#############################
static int get_dev_random_seed()
{
    DEBUG_SEED("get_dev_random_seed");
    int fd = open(dev_random_file, O_RDONLY);
    if (fd < 0) {
        fprintf(stderr, "error opening %s: %s", dev_random_file, strerror(errno));
        exit(1);
    }
    int r;
    ssize_t nread = read(fd, &r, sizeof(r));
    if (nread != sizeof(r)) {
        fprintf(stderr, "error short read %s: %s", dev_random_file, strerror(errno));
        exit(1);
    }
    close(fd);
    return r;
}
----------------------------QUERY-------------------------------
add extension to filename
########################rank 1#############################
static char *
extendfile(char *file, char *ext)
{
	char *res;
	char *p;
	res = alloc(strlen(file) + strlen(ext) + 1);
	if (res == NULL) {
		abort();
	}
	p = strrchr(file, '.');
	if (p == NULL) {
		p = file + strlen(file);
	}
	(void) strcpy(res, file);
	(void) strcpy(res + (p - file), ext);
	return (res);
}
########################rank 2#############################
static bool lex_finish_frames(lex_file *lex)
{
    do {
        size_t i;
        int    rc;
        frame_macro m;
        rc = lex_parse_frame(lex);
        if (rc > 0) /* end of line */
            return true;
        if (rc < 0) /* error */
            return false;
        for (i = 0; i < vec_size(lex->frames); ++i) {
            if (!strcmp(lex->tok.value, lex->frames[i].name)) {
                lex->frames[i].value = lex->framevalue++;
                if (lexwarn(lex, WARN_FRAME_MACROS, "duplicate frame macro defined: `%s`", lex->tok.value))
                    return false;
                break;
            }
        }
        if (i < vec_size(lex->frames))
            continue;
        m.value = lex->framevalue++;
        m.name = util_strdup(lex->tok.value);
        vec_shrinkto(lex->tok.value, 0);
        vec_push(lex->frames, m);
    } while (true);
    return false;
}
########################rank 3#############################
const char *COM_FileExtension( const char *filename ) {
	const char *src, *last;
	last = strrchr( filename, '/' );
	src = strrchr( last ? last : filename, '.' );
	if( src && *( src + 1 ) ) {
		return src;
	}
	return NULL;
}
########################rank 4#############################
void get_file_extension(char *infile, char *ext)
{
   char *ptr;
   if ((ptr = strchr(infile, '.')) != NULL)
      strcpy(ext, ptr+1);
   else
      ext[0] = '\0';
}
########################rank 5#############################
void get_file_extension(char *infile, char *ext)
{
   char *ptr;
   if ((ptr = strchr(infile, '.')) != NULL)
      strcpy(ext, ptr+1);
   else
      ext[0] = '\0';
}
########################rank 6#############################
static int GetFileType(char *filename)
{
	int i, j;
	int len;
	len = strlen(filename);
	for (i = C_FILE; i <= OBJ_FILE; ++i)
	{
		char *s = ExtNames[i], *t;
		t = strchr(s, ';');
		while (t != NULL)
		{
			j = t - s;
			if (strncmp(&filename[len -j], s, j) == 0)
				return i;
			s = t + 1;
			t = strchr(s, ';');
		}
		j = strlen(s);
		if (strncmp(&filename[len - j], s, j) == 0)
			return i;
	}
	return -1;
}
########################rank 7#############################
static int h5_state_tag_name(h5_state_t* hs)
{
    char ch;
    size_t pos;
    TRACE();
    pos = hs->pos;
    while (pos < hs->len) {
        ch = hs->s[pos];
        if (ch == 0) {
            pos += 1;
        } else if (h5_is_white(ch)) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            hs->token_type = TAG_NAME_OPEN;
            hs->pos = pos + 1;
            hs->state = h5_state_before_attribute_name;
            return 1;
        } else if (ch == CHAR_SLASH) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            hs->token_type = TAG_NAME_OPEN;
            hs->pos = pos + 1;
            hs->state = h5_state_self_closing_start_tag;
            return 1;
        } else if (ch == CHAR_GT) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            if (hs->is_close) {
                hs->pos = pos + 1;
                hs->is_close = 0;
                hs->token_type = TAG_CLOSE;
                hs->state = h5_state_data;
            } else {
                hs->pos = pos;
                hs->token_type = TAG_NAME_OPEN;
                hs->state = h5_state_tag_name_close;
            }
            return 1;
        } else {
            pos += 1;
        }
    }
    hs->token_start = hs->s + hs->pos;
    hs->token_len = hs->len - hs->pos;
    hs->token_type = TAG_NAME_OPEN;
    hs->state = h5_state_eof;
    return 1;
}
########################rank 8#############################
static int h5_state_tag_name(h5_state_t* hs)
{
    char ch;
    size_t pos;
    TRACE();
    pos = hs->pos;
    while (pos < hs->len) {
        ch = hs->s[pos];
	if (ch == 0) {
	  pos += 1;
	} else if (h5_is_white(ch)) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            hs->token_type = TAG_NAME_OPEN;
            hs->pos = pos + 1;
            hs->state = h5_state_before_attribute_name;
            return 1;
        } else if (ch == CHAR_SLASH) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            hs->token_type = TAG_NAME_OPEN;
            hs->pos = pos + 1;
            hs->state = h5_state_self_closing_start_tag;
            return 1;
        } else if (ch == CHAR_GT) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            if (hs->is_close) {
                hs->pos = pos + 1;
                hs->is_close = 0;
                hs->token_type = TAG_CLOSE;
                hs->state = h5_state_data;
            } else {
                hs->pos = pos;
                hs->token_type = TAG_NAME_OPEN;
                hs->state = h5_state_tag_name_close;
            }
            return 1;
        } else {
            pos += 1;
        }
    }
    hs->token_start = hs->s + hs->pos;
    hs->token_len = hs->len - hs->pos;
    hs->token_type = TAG_NAME_OPEN;
    hs->state = h5_state_eof;
    return 1;
}
########################rank 9#############################
static int h5_state_tag_name(h5_state_t* hs)
{
    char ch;
    size_t pos;
    TRACE();
    pos = hs->pos;
    while (pos < hs->len) {
        ch = hs->s[pos];
        if (ch == 0) {
            pos += 1;
        } else if (h5_is_white(ch)) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            hs->token_type = TAG_NAME_OPEN;
            hs->pos = pos + 1;
            hs->state = h5_state_before_attribute_name;
            return 1;
        } else if (ch == CHAR_SLASH) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            hs->token_type = TAG_NAME_OPEN;
            hs->pos = pos + 1;
            hs->state = h5_state_self_closing_start_tag;
            return 1;
        } else if (ch == CHAR_GT) {
            hs->token_start = hs->s + hs->pos;
            hs->token_len = pos - hs->pos;
            if (hs->is_close) {
                hs->pos = pos + 1;
                hs->is_close = 0;
                hs->token_type = TAG_CLOSE;
                hs->state = h5_state_data;
            } else {
                hs->pos = pos;
                hs->token_type = TAG_NAME_OPEN;
                hs->state = h5_state_tag_name_close;
            }
            return 1;
        } else {
            pos += 1;
        }
    }
    hs->token_start = hs->s + hs->pos;
    hs->token_len = hs->len - hs->pos;
    hs->token_type = TAG_NAME_OPEN;
    hs->state = h5_state_eof;
    return 1;
}
########################rank 10#############################
void
init_path(void)
{
	char *p,*pl;
	int	i, l;
	p = getenv(machine->include_env);
	if (p == NULL)
		return;
	for (i = 0; i < 10; i++) {
		pl = strchr(p, ';');
		if (pl == NULL)
			l = strlen(p);
		else
			l = pl-p;
		if (l == 0) {
			incpath[i][0] = '\0';
		} else {
			strncpy(incpath[i],p,l);
			p += l;
			while (*p == ';') p++;
		}
		if (incpath[i][strlen(incpath[i])] != PATH_SEPARATOR) {
			strcat(incpath[i], PATH_SEPARATOR_STRING);
		}
	}
}
----------------------------QUERY-------------------------------
read one word from onboard RAM
########################rank 1#############################
uint64_t light_log_clamp_min(uint64_t min)
{
    LIGHT_NOTE("too small value, adjusting to minimum %lu (raw)", min);
    return min;
}
########################rank 2#############################
uint8_t *CIN_ReadNextFrame( cinematics_t *cin, int *width, int *height,
							int *aspect_numerator, int *aspect_denominator, bool *redraw ) {
	return CIN_ReadNextFrame_( cin, width, height,
							   aspect_numerator, aspect_denominator, redraw, false );
}
########################rank 3#############################
static void io_read_0021() {
    io_read_00x1(&vpic1);
}
########################rank 4#############################
static void io_read_00A1() {
    io_read_00x1(&vpic2);
}
########################rank 5#############################
static void io_read_00A0() {
    io_read_00x0(&vpic2);
}
########################rank 6#############################
void
ty340_set_dac(ty340word addr)
{
    struct type340 *u = UNIT(0);
    u->DAC = addr;
    DEBUGF(("set DAC %06o\r\n", u->DAC));
    u->mode = PARAM;
    u->status = 0;               /* XXX just clear stopped? */
    ty340_rfd();                 /* ready for data */
}
########################rank 7#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan4_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  10);
}
########################rank 8#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan5_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  12);
}
########################rank 9#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan3_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  8);
}
########################rank 10#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan2_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  6);
}
----------------------------QUERY-------------------------------
make sure png_image has been free
########################rank 1#############################
void
pixie_close_library(void *library_handle)
{
#ifdef WIN32
	BOOL x;
	x = FreeLibrary(library_handle);
	if (x == 0)
		fprintf(stderr, "FreeLibrary(): return error #%u\n", (unsigned)GetLastError());
#else
	int x;
	x = dlclose(library_handle);
	if (x != 0)
		fprintf(stderr, "dlclose(): returned error #%u (%s)\n", errno, dlerror());
#endif
}
########################rank 2#############################
void CG_KillTrail( trailJunc_t *t ) {
	trailJunc_t *next;
	if ( !t->inuse && t->freed ) {
		return;
	}
	next = t->nextJunc;
	if ( next < &trailJuncs[0] || next >= &trailJuncs[MAX_TRAILJUNCS] ) {
		next = NULL;
	}
	t->nextJunc = NULL;
	if ( next->nextJunc && next->nextJunc == t ) {
		next->nextJunc = NULL;
	}
	if ( next ) {
		CG_FreeTrailJunc( next );
	}
}
########################rank 3#############################
void CG_KillTrail( trailJunc_t *t ) {
	trailJunc_t *next;
	if ( !t->inuse && t->freed ) {
		return;
	}
	next = t->nextJunc;
	if ( next < &trailJuncs[0] || next >= &trailJuncs[MAX_TRAILJUNCS] ) {
		next = NULL;
	}
	t->nextJunc = NULL;
	if ( next->nextJunc && next->nextJunc == t ) {
		next->nextJunc = NULL;
	}
	if ( next ) {
		CG_FreeTrailJunc( next );
	}
}
########################rank 4#############################
void lv_task_del(lv_task_t * lv_task_p)
{
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), lv_task_p);
    lv_mem_free(lv_task_p);
    if(LV_GC_ROOT(_lv_task_act) == lv_task_p) task_deleted = true;      /*The active task was deleted*/
}
########################rank 5#############################
void mw_delete_fsignal(Fsignal signal)
{
    if (signal == NULL)
    {
        mwerror(ERROR, 0,
                "[mw_delete_fsignal] cannot delete : "
                "fsignal structure is NULL\n");
        return;
    }
    if (signal->values != NULL)
        free(signal->values);
    signal->values = NULL;
    free(signal);
    signal = NULL;
}
########################rank 6#############################
void
freeschreier(schreier **gp, permnode **gens)
{
    schreier *sh,*nextsh;
    permnode *p,*nextp;
    if (gp && *gp)
    {
        nextsh = *gp;
        while (nextsh)
        {
	    sh = nextsh;
	    nextsh = sh->next;
	    sh->next = schreier_freelist;
	    schreier_freelist = sh;
        }
        *gp = NULL;
    }
    if (gens && *gens)
    {
        p = *gens;
        do
        {
            nextp = p->next;
	    p->next = permnode_freelist;
	    permnode_freelist = p;
	    p = nextp;
        } while (p != *gens);
        *gens = NULL;
    }
}
########################rank 7#############################
Fsignal mw_change_fsignal(Fsignal signal, int N)
{
    int mem_size;
    if (signal == NULL)
        signal = mw_new_fsignal();
    if (signal == NULL)
        return (NULL);
    mem_size = N * sizeof(float);
    if (mem_size > signal->allocsize)
    {
        if (signal->values != NULL)
        {
            free(signal->values);
            signal->values = NULL;
        }
        if (mw_alloc_fsignal(signal, N) == NULL)
        {
            mw_delete_fsignal(signal);
            return (NULL);
        }
    }
    else
        signal->size = N;
    return (signal);
}
########################rank 8#############################
void myfree(char* file, int line, void* p)
{
	if (p) /* it is legal und usual to call free(NULL) */
	{
		Thread_lock_mutex(heap_mutex);
		if (Internal_heap_unlink(file, line, p))
			free(((int*)p)-1);
		Thread_unlock_mutex(heap_mutex);
	}
	else
	{
		Log(LOG_ERROR, -1, "Call of free(NULL) in %s,%d",file,line);
	}
}
########################rank 9#############################
static bool S_AdvanceBackgroundTrack( int n ) {
	bgTrack_t *track;
	if( n < 0 ) {
		track = S_PrevMusicTrack( s_bgTrack );
	} else {
		track = S_NextMusicTrack( s_bgTrack );
	}
	if( track && track != s_bgTrack ) {
		S_CloseMusicTrack( s_bgTrack );
		S_OpenMusicTrack( track );
		s_bgTrack = track;
		return true;
	}
	return false;
}
########################rank 10#############################
void R_EndRegistration(void)
{
	int		i;
	model_t	*mod;
	for (i = 0, mod = mod_known; i < mod_numknown; i++, mod++)
	{
		if (!mod->name[0])
			continue;
		if (mod->registration_sequence != registration_sequence)
		{	// don't need this model
			Hunk_Free(mod->extradata);
			memset(mod, 0, sizeof(*mod));
		}
		else
		{	// make sure it is paged in
			Com_PageInMemory(mod->extradata, mod->extradatasize);
		}
	}
	R_FreeUnusedImages();
}
----------------------------QUERY-------------------------------
compare two node
########################rank 1#############################
static inline struct splaytree_node *get_first(struct splaytree_node *node)
{
	struct splaytree_node *left;
	while ((left = get_left(node)))
		node = left;
	return node;
}
########################rank 2#############################
static inline struct bstree_node *get_first(struct bstree_node *node)
{
	struct bstree_node *left;
	while ((left = get_left(node)))
		node = left;
	return node;
}
########################rank 3#############################
int length(cell n) {
	int	k;
	for (k = 0; n != NIL; n = cdr(n))
		k++;
	return k;
}
########################rank 4#############################
struct connection_node *connection_node_find(unsigned short origin, unsigned short id){
	struct connection_node *tmp_connection_node;
	tmp_connection_node = io->connection_head;
	while(tmp_connection_node){
		if((tmp_connection_node->origin == origin) && (tmp_connection_node->id == id)){
			return(tmp_connection_node);
		}
		tmp_connection_node = tmp_connection_node->next;
	}
	return(NULL);
}
########################rank 5#############################
static Node* search(RBTree x, Type key)
{
	if (x==NULL || x->key==key)
		return x;
	if (key < x->key)
		return search(x->left, key);
	else
		return search(x->right, key);
}
########################rank 6#############################
static bool
isnewer(struct node *n1, struct node *n2)
{
	return n1 && n1->mtime > n2->mtime;
}
########################rank 7#############################
static inline int is_root(struct rbtree_node *node)
{
	return get_parent(node) == NULL;
}
########################rank 8#############################
static inline struct avltree_node *get_first(struct avltree_node *node)
{
	while (node->left)
		node = node->left;
	return node;
}
########################rank 9#############################
static int mongo_check_is_master( mongo *conn ) {
    bson out;
    bson_iterator it;
    bson_bool_t ismaster = 0;
    int max_bson_size = MONGO_DEFAULT_MAX_BSON_SIZE;
    out.data = NULL;
    if ( mongo_simple_int_command( conn, "admin", "ismaster", 1, &out ) == MONGO_OK ) {
        if( bson_find( &it, &out, "ismaster" ) )
            ismaster = bson_iterator_bool( &it );
        if( bson_find( &it, &out, "maxBsonObjectSize" ) ) {
            max_bson_size = bson_iterator_int( &it );
        }
        conn->max_bson_size = max_bson_size;
    } else {
        return MONGO_ERROR;
    }
    bson_destroy( &out );
    if( ismaster )
        return MONGO_OK;
    else {
        conn->err = MONGO_CONN_NOT_MASTER;
        return MONGO_ERROR;
    }
}
########################rank 10#############################
static sxi32 HashmapNodeCmp(jx9_hashmap_node *pLeft, jx9_hashmap_node *pRight, int bStrict)
{
	jx9_value sObj1, sObj2;
	sxi32 rc;
	if( pLeft == pRight ){
		 * Same node.Refer to the sort() implementation defined
		 * below for more information on this sceanario.
		 */
		return 0;
	}
	jx9MemObjInit(pLeft->pMap->pVm, &sObj1);
	jx9MemObjInit(pLeft->pMap->pVm, &sObj2);
	jx9HashmapExtractNodeValue(pLeft, &sObj1, FALSE);
	jx9HashmapExtractNodeValue(pRight, &sObj2, FALSE);
	rc = jx9MemObjCmp(&sObj1, &sObj2, bStrict, 0);
	jx9MemObjRelease(&sObj1);
	jx9MemObjRelease(&sObj2);
	return rc;
}
----------------------------QUERY-------------------------------
encode ucs2 string into utf8 string
########################rank 1#############################
int
b10_uint(buf, num)
char *buf;				
unsigned int num;		/* the number to convert */
* PURPOSE : Convert a number into a string and store it in a buffer
*
* RETURN : The length of the number string
*
*F*/
{
	char tmp[12];
	bzero(tmp, 12);
	if (num == 0) {
		buf[0] = '0';
		return 1;
	} else {
		int i, size;
		for(i=0; i<10 && num!=0; i++) {
			tmp[i] = digits[num % 10];
			num = num / 10;
		}
		size = i;
		for(i=size; i > 0; i--) {
			buf[i-1] = tmp[size-i];
		}
		return size;
	}
	return 0;
}
########################rank 2#############################
int
b16_2w(buf, num)
char *buf;				
unsigned int num;		/* the 1-byte value to convert */
* PURPOSE : Convert a 1-byte value into a 4 character string and store it in a buffer
*
* RETURN : The length of the number string
*
*F*/
{
	char tmp[2];
	bzero(tmp, 0);
	if (num > 0xff) {
		buf[0] = '|';
		buf[1] = 'B';
		buf[2] = 'A';
		buf[3] = 'D';
		buf[4] = '|';
		return 5;
	}
	buf[0] = '0';
	buf[1] = 'x';
	if (num == 0) {
		buf[2] = '0';
		buf[3] = '0';
		return 4;
	} else {
		buf[3] = digits[num % 16];
		num = num / 16;
		buf[2] = digits[num % 16];
		return 4;
	}
	return 0;
}
########################rank 3#############################
char *FS_ShiftedStrStr( const char *string, const char *substring, int shift ) {
	char buf[MAX_STRING_TOKENS];
	int i;
	for ( i = 0; substring[i]; i++ ) {
		buf[i] = substring[i] + shift;
	}
	buf[i] = '\0';
	return strstr( string, buf );
}
########################rank 4#############################
char *FS_ShiftedStrStr( const char *string, const char *substring, int shift ) {
	char buf[MAX_STRING_TOKENS];
	int i;
	for ( i = 0; substring[i]; i++ ) {
		buf[i] = substring[i] + shift;
	}
	buf[i] = '\0';
	return strstr( string, buf );
}
########################rank 5#############################
int
b10_int(buf, num)
char *buf;				
int num;		/* the number to convert */
* PURPOSE : Convert an integer into a string and store it in a buffer
*
* RETURN : The length of the number string
*
*F*/
{
	char tmp[13];
	bzero(tmp, 13);
	if (num == 0) {
		buf[0] = '0';
		return 1;
	} else {
		int i=0, j=0;
		int size=0;
		if(num < 0) {
			buf[0] = '-';
			num = num * -1;
			j = j+1;
		}
		for(i=0; i<11 && num!=0; i++) {
			tmp[i] = digits[num % 10];
			num = num / 10;
		}
		size = i;
		for(i=size; i > 0; i--) {
			buf[j+i-1] = tmp[size-i];
		}
		return size + j;
	}
	return 0;
}
########################rank 6#############################
void getchararray(char *s, unsigned char *a)
{
	int i, w, len;
        len = strlen(s);
	for (i = 0; i < len; i += 2) {
		w = hex2int(s[i]);
		w <<= 4;
		w += hex2int(s[i + 1]);
		a[i >> 1] = w;
	}
}
########################rank 7#############################
char *url_encode(const char *str) {
    const char *pstr;
    char *buf, *pbuf;
    pstr = str;
    buf = malloc(strlen(str) * 3 + 1);
    pbuf = buf;
    if( buf )
    {
        while (*pstr) {
            if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~')
                *pbuf++ = *pstr;
            else if (*pstr == ' ')
                *pbuf++ = '+';
            else
                *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);
            pstr++;
        }
        *pbuf = '\0';
    }
    return buf;
}
########################rank 8#############################
void base64_encode(unsigned char *out,const unsigned char *in,int inlen)
{
   for (; inlen >= 3; inlen -= 3) {
      *out++ = base64digits[in[0] >> 2];
      *out++ = base64digits[((in[0] << 4) & 0x30) | (in[1] >> 4)];
      *out++ = base64digits[((in[1] << 2) & 0x3c) | (in[2] >> 6)];
      *out++ = base64digits[in[2] & 0x3f];
      in += 3;
   }
   if (inlen > 0) {
      unsigned char fragment;
      *out++ = base64digits[in[0] >> 2];
      fragment = (in[0] << 4) & 0x30;
      if (inlen > 1)
         fragment |= in[1] >> 4;
      *out++ = base64digits[fragment];
      *out++ = (inlen < 2) ? '=' : base64digits[(in[1] << 2) & 0x3c];
      *out++ = '=';
   }
   *out = '\0';
}
########################rank 9#############################
int
cgc_b16_2w(buf, num)
char *buf;				
unsigned int num;		/* the 1-byte value to convert */
* PURPOSE : Convert a 1-byte value into a 4 character string and store it in a buffer
*
* RETURN : The length of the number string
*
*F*/
{
	char tmp[2];
	cgc_bzero(tmp, 0);
	if (num > 0xff) {
		buf[0] = '|';
		buf[1] = 'B';
		buf[2] = 'A';
		buf[3] = 'D';
		buf[4] = '|';
		return 5;
	}
	buf[0] = '0';
	buf[1] = 'x';
	if (num == 0) {
		buf[2] = '0';
		buf[3] = '0';
		return 4;
	} else {
		buf[3] = digits[num % 16];
		num = num / 16;
		buf[2] = digits[num % 16];
		return 4;
	}
	return 0;
}
########################rank 10#############################
extern void write_char(struct generator * g, int ch) {
    str_append_ch(g->outbuf, ch); /* character */
}
----------------------------QUERY-------------------------------
check pointer is in the heap
########################rank 1#############################
static void
_unmap_at(char *addr,	
	size_t bytes)	/* multiple of pagesize */
{
    switch(ec_options.allocation)
    {
    case ALLOC_VIRTUAL:
    {
#ifdef _WIN32
	if (!VirtualFree(addr,bytes,MEM_DECOMMIT))
	{
	    ec_options.user_panic("failed to free stack space","_unmap_at()");
	}
#else
#ifndef HAVE_MMAP
	return;		/* ALLOC_VIRTUAL needs HAVE_MMAP */
#else
	char *ad;
#ifdef HAVE_MAP_NORESERVE
#if 0
 * already mapped (and used) area with MAP_NORESERVE really frees the
 * swap space. It seems to work though, so we don't call the unmap().
 */
	if (munmap(addr, bytes) == -1)
	{
	    (void )ec_outfs(current_err_,"INTERNAL WARNING: can't unmap stack page\n");
	    ec_flush(current_err_);
	}
#endif
	ad = mmap((capaddr_t) addr, bytes, PROT_READ|PROT_WRITE,
#ifdef MAP_ANONYMOUS
	    MAP_FIXED|MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1,
#else
	    MAP_FIXED|MAP_PRIVATE|MAP_NORESERVE, stack_map_fd,
#endif
	    (off_t) 0);
#else
	ad = mmap((capaddr_t) addr, bytes, PROT_NONE,
#ifdef MAP_ANONYMOUS
	    MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1,
#else
	    MAP_FIXED|MAP_PRIVATE, stack_map_fd,
#endif
	    (off_t) 0);
#endif
	if (ad != addr)
	    ec_options.user_panic("failed to re-reserve stack space","_unmap_at()");
#endif
#endif
	break;
    }
    case ALLOC_FIXED:
    {
#if defined(_WIN32) || !defined(HAVE_MMAP)
	ec_panic("ALLOC_FIXED not supported","_map_at()");
#else
	char *ad;
	ad = mmap((capaddr_t) addr, bytes, PROT_NONE,
#ifdef MAP_ANONYMOUS
	    MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1,
#else
	    MAP_FIXED|MAP_PRIVATE, stack_map_fd,
#endif
	    (off_t) 0);
	if (ad != addr)
	    ec_options.user_panic("failed to re-reserve stack space","_unmap_at()");
#endif
	break;
    }
    }
}
########################rank 2#############################
l_int32
makeRGBIndexTables(l_uint32  **prtab,
                   l_uint32  **pgtab,
                   l_uint32  **pbtab,
                   l_int32     sigbits)
{
l_int32    i;
l_uint32  *rtab, *gtab, *btab;
    PROCNAME("makeRGBIndexTables");
    if (prtab) *prtab = NULL;
    if (pgtab) *pgtab = NULL;
    if (pbtab) *pbtab = NULL;
    if (!prtab || !pgtab || !pbtab)
        return ERROR_INT("not all table ptrs defined", procName, 1);
    if (sigbits < 2 || sigbits > 6)
        return ERROR_INT("sigbits not in [2 ... 6]", procName, 1);
    rtab = (l_uint32 *)CALLOC(256, sizeof(l_uint32));
    gtab = (l_uint32 *)CALLOC(256, sizeof(l_uint32));
    btab = (l_uint32 *)CALLOC(256, sizeof(l_uint32));
    *prtab = rtab;
    *pgtab = gtab;
    *pbtab = btab;
    switch (sigbits) {
    case 2:
        for (i = 0; i < 256; i++) {
            rtab[i] = (i & 0xc0) >> 2;
            gtab[i] = (i & 0xc0) >> 4;
            btab[i] = (i & 0xc0) >> 6;
        }
        break;
    case 3:
        for (i = 0; i < 256; i++) {
            rtab[i] = (i & 0xe0) << 1;
            gtab[i] = (i & 0xe0) >> 2;
            btab[i] = (i & 0xe0) >> 5;
        }
        break;
    case 4:
        for (i = 0; i < 256; i++) {
            rtab[i] = (i & 0xf0) << 4;
            gtab[i] = (i & 0xf0);
            btab[i] = (i & 0xf0) >> 4;
        }
        break;
    case 5:
        for (i = 0; i < 256; i++) {
          rtab[i] = (i & 0xf8) << 7;
          gtab[i] = (i & 0xf8) << 2;
          btab[i] = (i & 0xf8) >> 3;
        }
        break;
    case 6:
        for (i = 0; i < 256; i++) {
          rtab[i] = (i & 0xfc) << 10;
          gtab[i] = (i & 0xfc) << 4;
          btab[i] = (i & 0xfc) >> 2;
        }
        break;
    default:
        L_ERROR("Illegal sigbits = %d\n", procName, sigbits);
        return ERROR_INT("sigbits not in [2 ... 6]", procName, 1);
    }
    return 0;
}
########################rank 3#############################
void *
memalign(size_t align, size_t nbytes)
{
	errno = EINVAL;
	return (NULL);
}
########################rank 4#############################
void*
mp_alloc_slow(mempool_t* mp, int size) {
    if (unlikely(add_a_chunk(mp, size) == 0))
        return NULL;
    return mp_alloc(mp, size);
}
########################rank 5#############################
int Align(int l)
{
  if (l & 1)
    return l + 1;
  return l;
}
########################rank 6#############################
int
_rpc_dtablesize()
{
	static int size;
	if (size == 0) {
		size = getdtablesize();
#ifdef FD_SETSIZE
		if (size > FD_SETSIZE)
			size = FD_SETSIZE;
#endif
	}
	return (size);
}
########################rank 7#############################
void* jv_mem_alloc(size_t sz) {
  void* p = malloc(sz);
  if (!p) {
    memory_exhausted();
  }
  return p;
}
########################rank 8#############################
static void ficlPrimitiveAligned(ficlVm *vm)
{
    void *addr;
    FICL_STACK_CHECK(vm->dataStack,1,1);
    addr = ficlStackPopPointer(vm->dataStack);
    ficlStackPushPointer(vm->dataStack, ficlAlignPointer(addr));
    return;
}
########################rank 9#############################
graph*                 
readgg(FILE *f, graph *g, int reqm, int *pm, int *pn, boolean *digraph) 
   f = an open file 
   g = place to put the answer (NULL for dynamic allocation) 
   reqm = the requested value of m (0 => compute from n) 
   *pm = the actual value of m 
   *pn = the value of n 
   *digraph = whether the input is a digraph
*/
{
    char *s,*p;
    int m,n;
    if ((readg_line = gtools_getline(f)) == NULL) return NULL;
    s = readg_line;
    if (s[0] == ':')
    {
        readg_code = SPARSE6;
        *digraph = FALSE;
        p = s + 1;
    }
    else if (s[0] == '&')
    {
	readg_code = DIGRAPH6;
        *digraph = TRUE;
	p = s + 1;
    }
    else
    {
        readg_code = GRAPH6;
        *digraph = FALSE;
        p = s;
    }
    while (*p >= BIAS6 && *p <= MAXBYTE) 
        ++p;
    if (*p == '\0')
        gt_abort(">E readgg: missing newline\n");
    else if (*p != '\n')
        gt_abort(">E readgg: illegal character\n");
    n = graphsize(s);
    if (readg_code == GRAPH6 && p - s != G6LEN(n))
        gt_abort(">E readgg: truncated graph6 line\n");
    if (readg_code == DIGRAPH6 && p - s != D6LEN(n))
        gt_abort(">E readgg: truncated digraph6 line\n");
    if (reqm > 0 && TIMESWORDSIZE(reqm) < n)
        gt_abort(">E readgg: reqm too small\n");
    else if (reqm > 0)
        m = reqm;
    else
        m = (n + WORDSIZE - 1) / WORDSIZE;
    if (g == NULL)
    {
        if ((g = (graph*)ALLOCS(n,m*sizeof(graph))) == NULL)
            gt_abort(">E readgg: malloc failed\n");
    }
    *pn = n;
    *pm = m;
    stringtograph(s,g,m);
    return g;
}
########################rank 10#############################
graph*                 
readgg(FILE *f, graph *g, int reqm, int *pm, int *pn, boolean *digraph) 
   f = an open file 
   g = place to put the answer (NULL for dynamic allocation) 
   reqm = the requested value of m (0 => compute from n) 
   *pm = the actual value of m 
   *pn = the value of n 
   *digraph = whether the input is a digraph
*/
{
    char *s,*p;
    int m,n;
    int readg_code;
    if ((s = showg_getline(f)) == NULL) return NULL;
    if (s[0] == ':')
    {
        *digraph = FALSE;
        p = s + 1;
    }
    else if (s[0] == '&')
    {
	readg_code = DIGRAPH6;
        *digraph = TRUE;
	p = s + 1;
    }
    else
    {
        readg_code = GRAPH6;
        *digraph = FALSE;
        p = s;
    }
    while (*p >= BIAS6 && *p <= MAXBYTE) 
        ++p;
    if (*p == '\0')
        gt_abort(">E readgg: missing newline\n");
    else if (*p != '\n')
        gt_abort(">E readgg: illegal character\n");
    n = graphsize(s);
    if (readg_code == GRAPH6 && p - s != G6LEN(n))
        gt_abort(">E readgg: truncated graph6 line\n");
    if (readg_code == DIGRAPH6 && p - s != D6LEN(n))
        gt_abort(">E readgg: truncated digraph6 line\n");
    if (reqm > 0 && TIMESWORDSIZE(reqm) < n)
        gt_abort(">E readgg: reqm too small\n");
    else if (reqm > 0)
        m = reqm;
    else
        m = (n + WORDSIZE - 1) / WORDSIZE;
    if (g == NULL)
    {
        if ((g = (graph*)ALLOCS(n,m*sizeof(graph))) == NULL)
            gt_abort(">E readgg: malloc failed\n");
    }
    *pn = n;
    *pm = m;
    stringtograph(s,g,m);
    return g;
}
----------------------------QUERY-------------------------------
search a file in directory recursively
########################rank 1#############################
int
_lseek(int file,
       int ptr,
       int dir)
{
  return 0;
}
########################rank 2#############################
int path_is_sep(int c)
{
#ifdef _WIN32
    return c == '/' || c == '\\';
#else
    return c == '/';
#endif
}
########################rank 3#############################
void split_filename(char *fullname, char *dir, char *bas)
{
    int m;
    if (fullname == NULL || strlen(fullname) == 0) {
      *dir = '\0';
      *bas = '\0';
      return;
    }
    m = strlen(fullname);
    while (--m >= 0 &&
           fullname[m] != '/' && fullname[m] != '\\' && fullname[m] != ':');
    if (m < 0)
#ifdef WIN32
      strcpy(dir, ".\\");
#else
      strcpy(dir, "./");
#endif
    else {
      strncpy(dir, fullname, m + 1);
      dir[m + 1] = '\0';
    }
    strcpy(bas, fullname + (m + 1));
}
########################rank 4#############################
FILE *findfile(char *fnam, char **dirpath, char **suffixes) {
  char **dp, *dir, **sp;
  FILE *fp;
  int dl, recdepth;
  struct decompressor *dc;
  if (strlen(fnam) >= sizeof(pathname))
    return NULL;
  strcpy(pathname, fnam);
  fp = maybe_pipe_open();
  if (fp)
    return fp;
  if (*fnam == '/') {
    for (sp = suffixes; *sp; sp++) {
      if (strlen(fnam) + strlen(*sp) + 1 > sizeof(pathname))
        continue;
      if (*sp == 0)
        continue; /* we tried it already */
      sprintf(pathname, "%s%s", fnam, *sp);
      if ((fp = fopen(pathname, "r")) != NULL)
        return fp;
    }
    for (sp = suffixes; *sp; sp++) {
      for (dc = &decompressors[0]; dc->cmd; dc++) {
        if (strlen(fnam) + strlen(*sp) + strlen(dc->ext) + 1 > sizeof(pathname))
          continue;
        sprintf(pathname, "%s%s%s", fnam, *sp, dc->ext);
        if ((fp = fopen(pathname, "r")) != NULL) {
          fclose(fp);
          return pipe_open(dc);
        }
      }
    }
    return NULL;
  }
  for (dp = dirpath; *dp; dp++) {
    dir = xstrdup(*dp);
    dl = strlen(dir);
    recdepth = 0;
    while (dl && dir[dl - 1] == '*') {
      dir[--dl] = 0;
      recdepth++;
    }
    if (dl == 0) {
      dir = ".";
    } else if (dl > 1 && dir[dl - 1] == '/') {
      dir[dl - 1] = 0;
    }
    fp = findfile_in_dir(fnam, dir, recdepth, suffixes);
    if (fp)
      return fp;
  }
  return NULL;
}
########################rank 5#############################
static int 
parse_dir(inode_build_t * grand_parent_inode,
	  inode_build_t * parent_inode, char *parent_path)
{
	int		err;
	DIR		*parent_dir = NULL;
	while (1) {
		parent_dir = opendir(parent_path);
		if (!parent_dir) {
			perror("opendir");
			err = errno;
			break;
		}
		while (1) {
			struct dirent *ent = readdir(parent_dir);
			if (!ent) {
				if (errno)
					perror("readdir");
				err = errno;
				break;
			}
			char *name = ent->d_name;
			entry_build_t  *child_ent = entry_alloc(parent_inode, name);
			if (!child_ent) {
				err = -1;
				break;
			}
			char *child_path = domalloc(strlen(parent_path) + 1 + strlen(name) + 1, -1);
			strcpy(child_path, parent_path);
			strcat(child_path, "/");
			strcat(child_path, name);
			if (!strcmp(name, ".")) {
				child_ent->inode = parent_inode;
			} else if (!strcmp(name, "..")) {
				if (grand_parent_inode)
					child_ent->inode = grand_parent_inode;
				else
					child_ent->inode = parent_inode;	
			} else {
				inode_build_t  *child_inode = inode_alloc(parent_inode, child_path);
				if (!child_inode) {
					err = -1;
					break;
				}
				child_ent->inode = child_inode;
				struct stat	child_stat;
				err = lstat(child_path, &child_stat);
				if (err) {
					perror("lstat");
					err = errno;
					break;
				}
				mode_t		mode = child_stat.st_mode;
				if (S_ISREG(mode)) {
					child_inode->flags = S_IFREG;
					child_inode->blocks = blocksused(child_stat.st_size);
					//printf("File:   %s, size %ld, blocks %ld\n",
						//child_path, (long)child_stat.st_size, child_inode->blocks);
				} else if (S_ISDIR(mode)) {
					//printf("Dir:    %s\n", child_path);
					child_inode->flags = S_IFDIR;
					child_inode->blocks = 1;
					err = parse_dir(parent_inode, child_inode, child_path);
					if (err)
						break;
				} else if (S_ISCHR(mode)) {
					//printf("Char:   %s\n", child_path);
					child_inode->flags = S_IFCHR;
					child_inode->dev = (int)child_stat.st_rdev;
					child_inode->blocks = 0;
				} else if (S_ISBLK(mode)) {
					//printf("Block:  %s\n", child_path);
					child_inode->flags = S_IFBLK;
					child_inode->dev = (int)child_stat.st_rdev;
					child_inode->blocks = 0;
				} else if (S_ISLNK(mode)) {
					//printf("Symlnk: %s\n", child_path);
					child_inode->flags = S_IFLNK;
					child_inode->blocks = 1;
				} else {
					fatalmsg("Unsupported: %s\n", child_path);
				}
				numblocks += child_inode->blocks;
			}
			if (child_path)
				free(child_path);
		}
		if (err != 0) {
			perror("Read directory");
		}
		break;
	}
	if (parent_dir)
		closedir(parent_dir);
	return err;
}
########################rank 6#############################
int
os_fsync_dir(const char *dir_name)
{
	int fd = os_open(dir_name, O_RDONLY | O_DIRECTORY);
	if (fd < 0)
		return -1;
	int ret = os_fsync(fd);
	os_close(fd);
	return ret;
}
########################rank 7#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 8#############################
static int shl__is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st) < 0)
		return -errno;
	return S_ISDIR(st.st_mode);
}
########################rank 9#############################
FILE *
fopenReadStream(const char  *filename)
{
char  *fname, *tail;
FILE  *fp;
    PROCNAME("fopenReadStream");
    if (!filename)
        return (FILE *)ERROR_PTR("filename not defined", procName, NULL);
    fname = genPathname(filename, NULL);
    fp = fopen(fname, "rb");
    FREE(fname);
    if (fp) return fp;
    splitPathAtDirectory(filename, NULL, &tail);
    fp = fopen(tail, "rb");
    FREE(tail);
    if (!fp)
        return (FILE *)ERROR_PTR("file not found", procName, NULL);
    return fp;
}
########################rank 10#############################
char path_file_name[256];
char * getfilename(int idx) {
  sprintf(path_file_name,"%d", idx);
  return path_file_name;
}
----------------------------QUERY-------------------------------
compress block of raw data
########################rank 1#############################
GLOBAL void
jinit_marker_writer( j_compress_ptr cinfo ) {
	cinfo->marker = (struct jpeg_marker_writer *)
				( *cinfo->mem->alloc_small ) ( (j_common_ptr) cinfo, JPOOL_IMAGE,
											   SIZEOF( struct jpeg_marker_writer ) );
	cinfo->marker->write_any_marker = write_any_marker;
	cinfo->marker->write_file_header = write_file_header;
	cinfo->marker->write_frame_header = write_frame_header;
	cinfo->marker->write_scan_header = write_scan_header;
	cinfo->marker->write_file_trailer = write_file_trailer;
	cinfo->marker->write_tables_only = write_tables_only;
}
########################rank 2#############################
local int gz_decomp( state )
gz_statep state;
{
	int ret;
	unsigned had;
	unsigned long crc, len;
	z_streamp strm = &( state->strm );
	had = strm->avail_out;
	do
	{
		if ( strm->avail_in == 0 && gz_avail( state ) == -1 )
		{
			return -1;
		}
		if ( strm->avail_in == 0 )
		{
			gz_error( state, Z_DATA_ERROR, "unexpected end of file" );
			return -1;
		}
		ret = inflate( strm, Z_NO_FLUSH );
		if ( ret == Z_STREAM_ERROR || ret == Z_NEED_DICT )
		{
			gz_error( state, Z_STREAM_ERROR,
			          "internal error: inflate stream corrupt" );
			return -1;
		}
		if ( ret == Z_MEM_ERROR )
		{
			gz_error( state, Z_MEM_ERROR, "out of memory" );
			return -1;
		}
		if ( ret == Z_DATA_ERROR )              /* deflate stream invalid */
		{
			gz_error( state, Z_DATA_ERROR,
			          strm->msg == NULL ? "compressed data error" : strm->msg );
			return -1;
		}
	}
	while ( strm->avail_out && ret != Z_STREAM_END );
	state->have = had - strm->avail_out;
	state->next = strm->next_out - state->have;
	strm->adler = crc32( strm->adler, state->next, state->have );
	if ( ret == Z_STREAM_END )
	{
		if ( gz_next4( state, &crc ) == -1 || gz_next4( state, &len ) == -1 )
		{
			gz_error( state, Z_DATA_ERROR, "unexpected end of file" );
			return -1;
		}
		if ( crc != strm->adler )
		{
			gz_error( state, Z_DATA_ERROR, "incorrect data check" );
			return -1;
		}
		if ( len != ( strm->total_out & 0xffffffffL ) )
		{
			gz_error( state, Z_DATA_ERROR, "incorrect length check" );
			return -1;
		}
		state->how = LOOK;      /* ready for next stream, once have is 0 (leave
                                   state->direct unchanged to remember how) */
	}
	return 0;
}
########################rank 3#############################
opj_dinfo_t* OPJ_CALLCONV mj2_create_decompress()
{
    opj_mj2_t* mj2;
    opj_dinfo_t *dinfo = (opj_dinfo_t*) opj_calloc(1, sizeof(opj_dinfo_t));
    if (!dinfo) {
        return NULL;
    }
    dinfo->is_decompressor = OPJ_TRUE;
    mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
    dinfo->mj2_handle = mj2;
    if (mj2) {
        mj2->cinfo = (opj_common_ptr)dinfo;
    }
    mj2->j2k = j2k_create_decompress((opj_common_ptr)dinfo);
    dinfo->j2k_handle = mj2->j2k;
    return dinfo;
}
########################rank 4#############################
int readuncompresszip(ZIP* zip, struct zipent* ent, char* data) {
	if (ent->compression_method == 0x0000) {
		if (ent->compressed_size != ent->uncompressed_size) {
			errormsg("Wrong uncompressed size in store compression", ERROR_CORRUPT,zip->zip);
			return -3;
		}
		return readcompresszip(zip,ent,data);
	} else if (ent->compression_method == 0x0008) {
		if (ent->version_needed_to_extract > 0x14) {
			errormsg("Version too new", ERROR_UNSUPPORTED,zip->zip);
			return -2;
		}
		if (ent->os_needed_to_extract != 0x00) {
			errormsg("OS not supported", ERROR_UNSUPPORTED,zip->zip);
			return -2;
		}
		if (ent->disk_number_start != zip->number_of_this_disk) {
			errormsg("Cannot span disks", ERROR_UNSUPPORTED,zip->zip);
			return -2;
		}
		if (seekcompresszip(zip,ent)!=0) {
			return -1;
		}
		if (inflate_file( zip->fp, ent->compressed_size, (unsigned char*)data, ent->uncompressed_size))
		{
			errormsg("Inflating compressed data", ERROR_CORRUPT, zip->zip);
			return -3;
		}
		return 0;
	} else {
		errormsg("Compression method unsupported", ERROR_UNSUPPORTED, zip->zip);
		return -2;
	}
}
########################rank 5#############################
opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo)
{
    opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
    if (j2k) {
        j2k->cinfo = cinfo;
    }
    return j2k;
}
########################rank 6#############################
static void BROTLI_NOINLINE BrotliCalculateRingBufferSize(BrotliState* s,
    BrotliBitReader* br) {
  int is_last = s->is_last_metablock;
  int window_size = 1 << s->window_bits;
  s->ringbuffer_size = window_size;
  if (s->is_uncompressed) {
    int next_block_header =
        BrotliPeekByte(br, (size_t)s->meta_block_remaining_len);
    if (next_block_header != -1) {  /* Peek succeeded */
      if ((next_block_header & 3) == 3) {  /* ISLAST and ISEMPTY */
        is_last = 1;
      }
    }
  }
     bytes for context from there */
  if (is_last) {
    int min_size_x2 = (s->meta_block_remaining_len + s->custom_dict_size) * 2;
    while (s->ringbuffer_size >= min_size_x2 && s->ringbuffer_size > 32) {
      s->ringbuffer_size >>= 1;
    }
  }
  s->ringbuffer_mask = s->ringbuffer_size - 1;
}
########################rank 7#############################
opj_cinfo_t* OPJ_CALLCONV mj2_create_compress()
{
    opj_mj2_t* mj2;
    opj_cinfo_t *cinfo = (opj_cinfo_t*) opj_calloc(1, sizeof(opj_cinfo_t));
    if (!cinfo) {
        return NULL;
    }
    mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
    cinfo->mj2_handle = mj2;
    if (mj2) {
        mj2->cinfo = (opj_common_ptr)cinfo;
    }
    mj2->j2k = j2k_create_compress(mj2->cinfo);
    cinfo->j2k_handle = mj2->j2k;
    return cinfo;
}
########################rank 8#############################
void
_tr_init(s)
    deflate_state *s;
{
	tr_static_init();
	s->l_desc.dyn_tree = s->dyn_ltree;
	s->l_desc.stat_desc = &static_l_desc;
	s->d_desc.dyn_tree = s->dyn_dtree;
	s->d_desc.stat_desc = &static_d_desc;
	s->bl_desc.dyn_tree = s->bl_tree;
	s->bl_desc.stat_desc = &static_bl_desc;
	s->bi_buf = 0;
	s->bi_valid = 0;
	s->last_eob_len = 8;	/* enough lookahead for inflate */
	s->compressed_len = 0L;		/* PPP */
#ifdef DEBUG_ZLIB
	s->bits_sent = 0L;
#endif
	init_block(s);
}
########################rank 9#############################
png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
   png_size_t buffer_length)
{
   int ret;
   if ((png_ptr->flags & PNG_FLAG_ZLIB_FINISHED) && buffer_length)
      png_error(png_ptr, "Extra compression data");
   png_ptr->zstream.next_in = buffer;
   png_ptr->zstream.avail_in = (uInt)buffer_length;
   for(;;)
   {
      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
      if (ret != Z_OK)
      {
         if (ret == Z_STREAM_END)
         {
            if (png_ptr->zstream.avail_in)
               png_error(png_ptr, "Extra compressed data");
            if (!(png_ptr->zstream.avail_out))
            {
               png_push_process_row(png_ptr);
            }
            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }
         else if (ret == Z_BUF_ERROR)
            break;
         else
            png_error(png_ptr, "Decompression Error");
      }
      if (!(png_ptr->zstream.avail_out))
      {
         if ((
#if defined(PNG_READ_INTERLACING_SUPPORTED)
             png_ptr->interlaced && png_ptr->pass > 6) ||
             (!png_ptr->interlaced &&
#endif
             png_ptr->row_number == png_ptr->num_rows))
         {
           if (png_ptr->zstream.avail_in)
             png_warning(png_ptr, "Too much data in IDAT chunks");
           png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
           break;
         }
         png_push_process_row(png_ptr);
         png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
         png_ptr->zstream.next_out = png_ptr->row_buf;
      }
      else
         break;
   }
}
########################rank 10#############################
opj_j3d_t* j3d_create_compress(opj_common_ptr cinfo)
{
    opj_j3d_t *j3d = (opj_j3d_t*)opj_malloc(sizeof(opj_j3d_t));
    if (j3d) {
        j3d->cinfo = cinfo;
    }
    return j3d;
}
----------------------------QUERY-------------------------------
allocate and clean buffer
########################rank 1#############################
qbufPipe_t *QBufPipe_Create( size_t bufSize, int flags ) {
	qbufPipe_t *pipe = malloc( sizeof( *pipe ) + bufSize );
	if( !pipe ) {
		return NULL;
	}
	memset( pipe, 0, sizeof( *pipe ) );
	pipe->blockWrite = flags & 1;
	pipe->buf = (char *)( pipe + 1 );
	pipe->bufSize = bufSize;
	pipe->nonempty_condvar = QCondVar_Create();
	pipe->nonempty_mutex = QMutex_Create();
	return pipe;
}
########################rank 2#############################
static void elf_terminate(char *buf, size_t size)
{
	ujpp_utils_unmap_file((void *)buf, size);
}
########################rank 3#############################
SQLITE_API void keen_io_sqlite3_free(void *p){
  if( p==0 ) return;  /* IMP: R-49053-54554 */
  assert( keen_io_sqlite3MemdebugNoType(p, MEMTYPE_DB) );
  assert( keen_io_sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
  if( keen_io_sqlite3GlobalConfig.bMemstat ){
    keen_io_sqlite3_mutex_enter(mem0.mutex);
    keen_io_sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -keen_io_sqlite3MallocSize(p));
    keen_io_sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, -1);
    keen_io_sqlite3GlobalConfig.m.xFree(p);
    keen_io_sqlite3_mutex_leave(mem0.mutex);
  }else{
    keen_io_sqlite3GlobalConfig.m.xFree(p);
  }
}
########################rank 4#############################
static BNU_CHUNK_T* gs_mont_add(BNU_CHUNK_T* pr, const BNU_CHUNK_T* pa, const BNU_CHUNK_T* pb, gsModEngine* pME)
{
   const BNU_CHUNK_T* pm = MOD_MODULUS(pME);
   int mLen = MOD_LEN(pME);
   const int polLength  = 1;
   BNU_CHUNK_T* pBuffer = gsModPoolAlloc(pME, polLength);
   //gres: temporary excluded: assert(NULL!=pBuffer);
   {
      BNU_CHUNK_T extension = cpAdd_BNU(pr, pa, pb, mLen);
      extension -= cpSub_BNU(pBuffer, pr, pm, mLen);
      cpMaskMove_gs(pr, pBuffer, mLen, cpIsZero(extension));
   }
   gsModPoolFree(pME, polLength);
   return pr;
}
########################rank 5#############################
static void *
system_alloc(void *allocator_data, size_t size)
{
	return malloc(size);
}
########################rank 6#############################
static void *
system_alloc(void *allocator_data, size_t size)
{
	return malloc(size);
}
########################rank 7#############################
static void *
system_alloc(void *allocator_data, size_t size)
{
	return malloc(size);
}
########################rank 8#############################
static void *
system_alloc(void *allocator_data, size_t size)
{
	return malloc(size);
}
########################rank 9#############################
SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
  assert( db==0 || sqlite3_mutex_held(db->mutex) );
  if( db ){
    if( db->pnBytesFreed ){
      *db->pnBytesFreed += sqlite3DbMallocSize(db, p);
      return;
    }
    if( isLookaside(db, p) ){
      LookasideSlot *pBuf = (LookasideSlot*)p;
      pBuf->pNext = db->lookaside.pFree;
      db->lookaside.pFree = pBuf;
      db->lookaside.nOut--;
      return;
    }
  }
  assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );
  assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );
  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );
  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
  sqlite3_free(p);
}
########################rank 10#############################
Cell * cel_alloc_cell(const int size)
{
  Cell *cell;
  cell = NULL;
  if (size < 1) {
    return NULL;
  }
  cell = NULL;
  if ((cell = (Cell*) malloc(sizeof(Cell))) == NULL) {
    warning_print("spglib: Memory could not be allocated.");
    return NULL;
  }
  if ((cell->lattice = (double (*)[3]) malloc(sizeof(double[3]) * 3)) == NULL) {
    warning_print("spglib: Memory could not be allocated.");
    free(cell);
    cell = NULL;
    return NULL;
  }
  cell->size = size;
  if ((cell->types = (int *) malloc(sizeof(int) * size)) == NULL) {
    warning_print("spglib: Memory could not be allocated.");
    free(cell->lattice);
    cell->lattice = NULL;
    free(cell);
    cell = NULL;
    return NULL;
  }
  if ((cell->position =
       (double (*)[3]) malloc(sizeof(double[3]) * size)) == NULL) {
    warning_print("spglib: Memory could not be allocated.");
    free(cell->types);
    cell->types = NULL;
    free(cell->lattice);
    cell->lattice = NULL;
    free(cell);
    cell = NULL;
    return NULL;
  }
  return cell;
}
----------------------------QUERY-------------------------------
receive N byte from socket
########################rank 1#############################
static int local_netdev_send(struct netdev *a_netdev,
			     struct packet *packet)
{
	struct local_netdev *netdev = to_local_netdev(a_netdev);
	assert(packet->ip_bytes > 0);
	assert(packet->ipv4 || packet->ipv6);
	assert(packet->tcp || packet->udp || packet->icmpv4 || packet->icmpv6);
	DEBUGP("local_netdev_send\n");
#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
	bsd_tun_write(netdev, packet);
#endif /* defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) */
#ifdef linux
	linux_tun_write(netdev, packet);
#endif  /* linux */
	return STATUS_OK;
}
########################rank 2#############################
int
coap_get_header_size(void *packet, uint32_t *size)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_SIZE)) return 0;
  *size = coap_pkt->size;
  return 1;
}
########################rank 3#############################
int
coap_get_header_size(void *packet, uint32_t *size)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_SIZE)) return 0;
  *size = coap_pkt->size;
  return 1;
}
########################rank 4#############################
ssize_t recv_all(int socket, uint8_t *buffer, size_t length, int flag)
{
    size_t bytes_received = 0;
    size_t bytes_unreceived = length;
    ssize_t received;
    while (bytes_received < length)
    {
        received = recv(socket, buffer + bytes_received, bytes_unreceived, flag);
        if (received == -1)
            return -1;
        if (received == 0)
            return 0;
        bytes_received += (size_t)received;
        bytes_unreceived -= (size_t)received;
    }
    return (ssize_t)bytes_received;
}
########################rank 5#############################
int
coap_get_header_uri_host(void *packet, const char **host)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_URI_HOST)) return 0;
  *host = (char *)coap_pkt->uri_host;
  return coap_pkt->uri_host_len;
}
########################rank 6#############################
int
coap_get_header_observe(void *packet, uint32_t *observe)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_OBSERVE)) return 0;
  *observe = coap_pkt->observe;
  return 1;
}
########################rank 7#############################
int
coap_get_header_observe(void *packet, uint32_t *observe)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_OBSERVE)) return 0;
  *observe = coap_pkt->observe;
  return 1;
}
########################rank 8#############################
int
coap_get_header_uri_host(void *packet, const char **host)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_URI_HOST)) return 0;
  *host = (char *)coap_pkt->uri_host;
  return coap_pkt->uri_host_len;
}
########################rank 9#############################
int
coap_get_header_proxy_uri(void *packet, const char **uri)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_PROXY_URI)) return 0;
  *uri = (const char *)coap_pkt->proxy_uri;
  return coap_pkt->proxy_uri_len;
}
########################rank 10#############################
int
coap_get_header_proxy_uri(void *packet, const char **uri)
{
  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
  if (!IS_OPTION(coap_pkt, COAP_OPTION_PROXY_URI)) return 0;
  *uri = (const char *)coap_pkt->proxy_uri;
  return coap_pkt->proxy_uri_len;
}
----------------------------QUERY-------------------------------
lookup key in a hash map
########################rank 1#############################
static HashElem *findElementWithHash(
  const Hash *pH,     /* The pH to be searched */
  const char *pKey,   /* The key we are searching for */
  unsigned int *pHash /* Write the hash value here */
){
  HashElem *elem;                /* Used to loop thru the element list */
  int count;                     /* Number of elements left to test */
  unsigned int h;                /* The computed hash */
  if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/
    struct _ht *pEntry;
    h = strHash(pKey) % pH->htsize;
    pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
  }else{
    h = 0;
    elem = pH->first;
    count = pH->count;
  }
  *pHash = h;
  while( count-- ){
    assert( elem!=0 );
    if( sqlite3StrICmp(elem->pKey,pKey)==0 ){ 
      return elem;
    }
    elem = elem->next;
  }
  return 0;
}
########################rank 2#############################
static int binHash(const void *pKey, int nKey){
  int h = 0;
  const char *z = (const char *)pKey;
  while( nKey-- > 0 ){
    h = (h<<3) ^ h ^ *(z++);
  }
  return h & 0x7fffffff;
}
########################rank 3#############################
static int fts3BinHash(const void *pKey, int nKey){
  int h = 0;
  const char *z = (const char *)pKey;
  while( nKey-- > 0 ){
    h = (h<<3) ^ h ^ *(z++);
  }
  return h & 0x7fffffff;
}
########################rank 4#############################
const char * unqlite_lib_ident(void)
{
	return UNQLITE_IDENT;
}
########################rank 5#############################
static int strHash(const void *pKey, int nKey){
  const char *z = (const char *)pKey;
  int h = 0;
  if( nKey<=0 ) nKey = (int) strlen(z);
  while( nKey > 0  ){
    h = (h<<3) ^ h ^ *z++;
    nKey--;
  }
  return h & 0x7fffffff;
}
########################rank 6#############################
static int fts3StrHash(const void *pKey, int nKey){
  const char *z = (const char *)pKey;
  unsigned h = 0;
  if( nKey<=0 ) nKey = (int) strlen(z);
  while( nKey > 0  ){
    h = (h<<3) ^ h ^ *z++;
    nKey--;
  }
  return (int)(h & 0x7fffffff);
}
########################rank 7#############################
const void *hashMapGet(HashMap *map, const char key[]) {
  HashMapEntry *e;
  uint32_t      hash  = doHash(key);
  size_t        index = indexFor(hash, map->capacity);
  for (e = map->table[index]; e != NULL; e = e->next) {
    if (isHit(e, key, hash))
      return e->value;
  }
  return NULL;
}
########################rank 8#############################
ion_err_t
oadict_close_dictionary(
	ion_dictionary_t *dictionary
) {
	UNUSED(dictionary);
	return err_not_implemented;
}
########################rank 9#############################
void * 
hashtable_search(struct hashtable *h, void *k)
{
    struct entry *e;
    unsigned int hashvalue, index;
    hashvalue = hash(h,k);
    index = indexFor(h->tablelength,hashvalue);
    e = h->table[index];
    while (NULL != e)
    {
        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) return e->v;
        e = e->next;
    }
    return NULL;
}
########################rank 10#############################
ion_status_t
sldict_get(
	ion_dictionary_t	*dictionary,
	ion_key_t			key,
	ion_value_t			value
) {
	return sl_get((ion_skiplist_t *) dictionary->instance, key, value);
}
----------------------------QUERY-------------------------------
fast integral power function
########################rank 1#############################
long
mp_base_mul(BNS *rop, BNS *op1, BNS *op2, BNI len1, BNI len2)
{
    long i, j;			/* counters */
    BNI value;			/* intermediate result */
    BNS carry;			/* carry value */
    long size = len1 + len2;
    if (op1[0]) {
	value = (BNI)(op1[0]) * op2[0];
	rop[0] = value;
	carry = (BNS)(value >> BNSBITS);
	for (j = 1; j < len2; j++) {
	    value = (BNI)(op1[0]) * op2[j] + carry;
	    rop[j] = value;
	    carry = (BNS)(value >> BNSBITS);
	}
	rop[j] = carry;
    }
    for (i = 1; i < len1; i++) {
	if (op1[i]) {
	    value = (BNI)(op1[i]) * op2[0] + rop[i];
	    rop[i] = value;
	    carry = (BNS)(value >> BNSBITS);
	    for (j = 1; j < len2; j++) {
		value = (BNI)(op1[i]) * op2[j] + rop[i + j] + carry;
		rop[i + j] = value;
		carry = (BNS)(value >> BNSBITS);
	    }
	    rop[i + j] = carry;
	}
    }
    if (size > 1 && rop[size - 1] == 0)
	--size;
    return (size);
}
########################rank 2#############################
int64 mul_currency(int64 value1, int64 value2) {
  return value1 * value2 / CURRENCY_FACTOR;
}
########################rank 3#############################
uint32_t rotl32(uint32_t n, uint8_t bits){
	return ((n<<bits) | (n>>(32-bits)));
}
########################rank 4#############################
static const char *parse_number(srjson_doc_t *doc, srjson_t *item, const char *num)
{
	double n = 0, sign = 1, scale = 0;
	int subscale = 0, signsubscale = 1;
	if (*num == '-')
		sign = -1, num++;	/* Has sign? */
	if (*num == '0')
		num++;		/* is zero */
	if (*num >= '1' && *num <= '9')
		do
			n = (n * 10.0) + (*num++ - '0');
		while (*num >= '0' && *num <= '9');	/* Number? */
	if (*num == '.' && num[1] >= '0' && num[1] <= '9') {
		num++;
		do
			n = (n * 10.0) + (*num++ - '0'), scale--;
		while (*num >= '0' && *num <= '9');
	}			/* Fractional part? */
	if (*num == 'e' || *num == 'E') {	/* Exponent? */
		num++;
		if (*num == '+')
			num++;
		else if (*num == '-')
			signsubscale = -1, num++;	/* With sign? */
		while (*num >= '0' && *num <= '9')
			subscale = (subscale * 10) + (*num++ - '0');	/* Number? */
	}
	n = sign * n * pow(10.0, (scale + subscale * signsubscale));	/* number = +/-
									 * number.fraction *
									 * 10^+/- exponent */
	item->valuedouble = n;
	item->type = srjson_Number;
	return num;
}
########################rank 5#############################
static OPUS_INLINE opus_int32 silk_A2NLSF_eval_poly( 
    opus_int32          *p,                     /* I    Polynomial, Q16                         */
    const opus_int32    x,                      /* I    Evaluation point, Q12                   */
    const opus_int      dd                      /* I    Order                                   */
)
{
    opus_int   n;
    opus_int32 x_Q16, y32;
    y32 = p[ dd ];                                  /* Q16 */
    x_Q16 = silk_LSHIFT( x, 4 );
    if ( opus_likely( 8 == dd ) )
    {
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
    }
    else
    {
        for( n = dd - 1; n >= 0; n-- ) {
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
        }
    }
    return y32;
}
########################rank 6#############################
int call_simple()
{
    int v = 37;
    int z = simple(&v, 12);
    return v + z;
}
########################rank 7#############################
static int bits2byte(char bits[]) {
    int i, byteval=0, d=1;
    for (i = 0; i < 8; i++) {     // little endian
        if      (bits[i] == 1)  byteval += d;
        else if (bits[i] == 0)  byteval += 0;
        else return 0x100;
        d <<= 1;
    }
    return byteval;
}
########################rank 8#############################
static int bits2byte(char bits[]) {
    int i, byteval=0, d=1;
    for (i = 0; i < 8; i++) {     // little endian
        if      (bits[i] == 1)  byteval += d;
        else if (bits[i] == 0)  byteval += 0;
        else return 0x100;
        d <<= 1;
    }
    return byteval;
}
########################rank 9#############################
void *
memmove(void *dp, const void *sp, size_t n)
{
	unsigned char *cdp, *csp;
	if (n==0)
		return 0;
	cdp = dp;
	csp = (unsigned char *)sp;
	if (cdp < csp) {
		do {
			*cdp++ = *csp++;
		} while (--n);
	} else {
		cdp += n;
		csp += n;
		do {
			*--cdp = *--csp;
		} while (--n);
	}
	return 0;
}
########################rank 10#############################
unsigned bitarithm_bits_set(unsigned v)
{
    unsigned c; // c accumulates the total bits set in v
    for (c = 0; v; c++) {
        v &= v - 1; // clear the least significant bit set
    }
    return c;
}
----------------------------QUERY-------------------------------
unblock all events for given service
########################rank 1#############################
void mlt_events_wait_for( mlt_properties self, mlt_event event )
{
	if ( event != NULL )
	{
		condition_pair *pair = event->service;
		pthread_cond_wait( &pair->cond, &pair->mutex );
	}
}
########################rank 2#############################
int of1275_peer(int phandle, int *sibling_phandle)
{
	int result;
	static of1275_peer_service s;
	s.service = "peer";
	s.n_args = 1;
	s.n_returns = 1;
	s.phandle = phandle;
	result = of1275_server(&s);
	*sibling_phandle = s.sibling_phandle;
	return result;
}
########################rank 3#############################
int of1275_peer(int phandle, int *sibling_phandle)
{
	int result;
	static of1275_peer_service s;
	s.service = "peer";
	s.n_args = 1;
	s.n_returns = 1;
	s.phandle = phandle;
	result = of1275_server(&s);
	*sibling_phandle = s.sibling_phandle;
	return result;
}
########################rank 4#############################
int of1275_peer(int phandle, int *sibling_phandle)
{
	int result;
	static of1275_peer_service s;
	s.service = "peer";
	s.n_args = 1;
	s.n_returns = 1;
	s.phandle = phandle;
	result = of1275_server(&s);
	*sibling_phandle = s.sibling_phandle;
	return result;
}
########################rank 5#############################
void USBHwConnect(BOOL fConnect)
{
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
}
########################rank 6#############################
void handle_closed_spid_socket() {
    handle_socket_closed();
    wipe_existing_processes();
    // Start listening for new sockets
    int r = epoll_ctl(ep_fd, EPOLL_CTL_ADD, listener_fd, &listener_event);
    // Report any errors with the event addition
    if (r < 0) {
        fatal("Could not add listening socket to event poll: %s", strerror(errno));
    }
    debug("Listening for new sockets...");
}
########################rank 7#############################
ATCACommand newATCACommand(ATCADeviceType device_type)
{
    ATCACommand ca_cmd;
    ATCA_STATUS status;
    ca_cmd = (ATCACommand)malloc(sizeof(*ca_cmd));
    status = initATCACommand(device_type, ca_cmd);
    if (status != ATCA_SUCCESS)
    {
        free(ca_cmd);
        ca_cmd = NULL;
        return NULL;
    }
    return ca_cmd;
}
########################rank 8#############################
mlt_properties mlt_repository_metadata( mlt_repository self, mlt_service_type type, const char *service )
{
	mlt_properties metadata = NULL;
	mlt_properties properties = get_service_properties( self, type, service );
	// If this is a valid service
	if ( properties )
	{
		// Lookup cached metadata
		metadata = mlt_properties_get_data( properties, "metadata", NULL );
		if ( ! metadata )
		{
			// Not cached, so get the registered metadata callback function
			mlt_metadata_callback callback = mlt_properties_get_data( properties, "metadata_cb", NULL );
			// If a metadata callback function is registered
			if ( callback )
			{
				// Fetch the callback data arg
				void *data = mlt_properties_get_data( properties, "metadata_cb_data", NULL );
				// Fetch the metadata through the callback
				metadata = callback( type, service, data );
				// Cache the metadata
				if ( metadata )
					// Include dellocation and serialisation
					mlt_properties_set_data( properties, "metadata", metadata, 0, ( mlt_destructor )mlt_properties_close, ( mlt_serialiser )mlt_properties_serialise_yaml );
			}
		}
	}
	return metadata;
}
########################rank 9#############################
void mlt_events_unblock( mlt_properties self, void *service )
{
	mlt_events events = mlt_events_fetch( self );
	if ( events != NULL )
	{
		int i = 0, j = 0;
		mlt_properties list = events->list;
		for ( j = 0; j < mlt_properties_count( list ); j ++ )
		{
			char *temp = mlt_properties_get_name( list, j );
			if ( !strncmp( temp, "list:", 5 ) )
			{
				mlt_properties listeners = mlt_properties_get_data( list, temp, NULL );
				for ( i = 0; i < mlt_properties_count( listeners ); i ++ )
				{
					mlt_event entry = mlt_properties_get_data_at( listeners, i, NULL );
					if ( entry != NULL && entry->service == service )
						mlt_event_unblock( entry );
				}
			}
		}
	}
}
########################rank 10#############################
void alarm_handler( int signum ){
    return;
}
----------------------------QUERY-------------------------------
check if directory is empty
########################rank 1#############################
int
os_fsync_dir(const char *dir_name)
{
	int fd = os_open(dir_name, O_RDONLY | O_DIRECTORY);
	if (fd < 0)
		return -1;
	int ret = os_fsync(fd);
	os_close(fd);
	return ret;
}
########################rank 2#############################
static int shl__is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st) < 0)
		return -errno;
	return S_ISDIR(st.st_mode);
}
########################rank 3#############################
static int
isRootDirPath(const char *path)
{
    return findRootDirPath(path) != NULL;
}
########################rank 4#############################
static bool FS_DirentIsDir( const struct dirent64 *d, const char *base ) {
#if ( defined( _DIRENT_HAVE_D_TYPE ) || defined( __ANDROID__ ) ) && defined( DT_DIR )
	return ( d->d_type == DT_DIR );
#else
	size_t pathSize;
	char *path;
	struct stat st;
	pathSize = strlen( base ) + 1 + strlen( d->d_name ) + 1;
	path = alloca( pathSize );
	Q_snprintfz( path, pathSize, "%s/%s", base, d->d_name );
	if( stat( path, &st ) ) {
		return false;
	}
	return S_ISDIR( st.st_mode ) != 0;
#endif
}
########################rank 5#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 6#############################
int
d_ffotherwindow(int f, int n)
{
	char		 fname[NFILEN];
	int		 s;
	struct buffer	*bp;
	struct mgwin	*wp;
	if ((s = d_makename(curwp->w_dotp, fname, sizeof(fname))) == ABORT)
		return (FALSE);
	if ((bp = (s ? dired_(fname) : findbuffer(fname))) == NULL)
		return (FALSE);
	if ((wp = popbuf(bp)) == NULL)
		return (FALSE);
	curbp = bp;
	curwp = wp;
	if (bp->b_fname[0] != 0)
		return (TRUE);	
	return (readin(fname));
}
########################rank 7#############################
static int 
parse_dir(inode_build_t * grand_parent_inode,
	  inode_build_t * parent_inode, char *parent_path)
{
	int		err;
	DIR		*parent_dir = NULL;
	while (1) {
		parent_dir = opendir(parent_path);
		if (!parent_dir) {
			perror("opendir");
			err = errno;
			break;
		}
		while (1) {
			struct dirent *ent = readdir(parent_dir);
			if (!ent) {
				if (errno)
					perror("readdir");
				err = errno;
				break;
			}
			char *name = ent->d_name;
			entry_build_t  *child_ent = entry_alloc(parent_inode, name);
			if (!child_ent) {
				err = -1;
				break;
			}
			char *child_path = domalloc(strlen(parent_path) + 1 + strlen(name) + 1, -1);
			strcpy(child_path, parent_path);
			strcat(child_path, "/");
			strcat(child_path, name);
			if (!strcmp(name, ".")) {
				child_ent->inode = parent_inode;
			} else if (!strcmp(name, "..")) {
				if (grand_parent_inode)
					child_ent->inode = grand_parent_inode;
				else
					child_ent->inode = parent_inode;	
			} else {
				inode_build_t  *child_inode = inode_alloc(parent_inode, child_path);
				if (!child_inode) {
					err = -1;
					break;
				}
				child_ent->inode = child_inode;
				struct stat	child_stat;
				err = lstat(child_path, &child_stat);
				if (err) {
					perror("lstat");
					err = errno;
					break;
				}
				mode_t		mode = child_stat.st_mode;
				if (S_ISREG(mode)) {
					child_inode->flags = S_IFREG;
					child_inode->blocks = blocksused(child_stat.st_size);
					//printf("File:   %s, size %ld, blocks %ld\n",
						//child_path, (long)child_stat.st_size, child_inode->blocks);
				} else if (S_ISDIR(mode)) {
					//printf("Dir:    %s\n", child_path);
					child_inode->flags = S_IFDIR;
					child_inode->blocks = 1;
					err = parse_dir(parent_inode, child_inode, child_path);
					if (err)
						break;
				} else if (S_ISCHR(mode)) {
					//printf("Char:   %s\n", child_path);
					child_inode->flags = S_IFCHR;
					child_inode->dev = (int)child_stat.st_rdev;
					child_inode->blocks = 0;
				} else if (S_ISBLK(mode)) {
					//printf("Block:  %s\n", child_path);
					child_inode->flags = S_IFBLK;
					child_inode->dev = (int)child_stat.st_rdev;
					child_inode->blocks = 0;
				} else if (S_ISLNK(mode)) {
					//printf("Symlnk: %s\n", child_path);
					child_inode->flags = S_IFLNK;
					child_inode->blocks = 1;
				} else {
					fatalmsg("Unsupported: %s\n", child_path);
				}
				numblocks += child_inode->blocks;
			}
			if (child_path)
				free(child_path);
		}
		if (err != 0) {
			perror("Read directory");
		}
		break;
	}
	if (parent_dir)
		closedir(parent_dir);
	return err;
}
########################rank 8#############################
void split_filename(char *fullname, char *dir, char *bas)
{
    int m;
    if (fullname == NULL || strlen(fullname) == 0) {
      *dir = '\0';
      *bas = '\0';
      return;
    }
    m = strlen(fullname);
    while (--m >= 0 &&
           fullname[m] != '/' && fullname[m] != '\\' && fullname[m] != ':');
    if (m < 0)
#ifdef WIN32
      strcpy(dir, ".\\");
#else
      strcpy(dir, "./");
#endif
    else {
      strncpy(dir, fullname, m + 1);
      dir[m + 1] = '\0';
    }
    strcpy(bas, fullname + (m + 1));
}
########################rank 9#############################
PIXAC *
pixacompCreateFromFiles(const char  *dirname,
                        const char  *substr,
                        l_int32      comptype)
{
PIXAC    *pixac;
SARRAY   *sa;
    PROCNAME("pixacompCreateFromFiles");
    if (!dirname)
        return (PIXAC *)ERROR_PTR("dirname not defined", procName, NULL);
    if (comptype != IFF_DEFAULT && comptype != IFF_TIFF_G4 &&
        comptype != IFF_PNG && comptype != IFF_JFIF_JPEG)
        return (PIXAC *)ERROR_PTR("invalid comptype", procName, NULL);
    if ((sa = getSortedPathnamesInDirectory(dirname, substr, 0, 0)) == NULL)
        return (PIXAC *)ERROR_PTR("sa not made", procName, NULL);
    pixac = pixacompCreateFromSA(sa, comptype);
    sarrayDestroy(&sa);
    return pixac;
}
########################rank 10#############################
bool afs_empty(assetdir_t* base)
{
    int i;
    if(darray_length(base->file) > 0)
        return false;
    if(darray_length(base->dir) > 2) /* skip "." and ".." */
        return false;
    for(i = 0; i < darray_length(base->dir); i++) { /* just in case... */
        if(0 != strcmp(base->dir[i].name, ".") && 0 != strcmp(base->dir[i].name, ".."))
            return false;
    }
    return true;
}
----------------------------QUERY-------------------------------
create a new tree node
########################rank 1#############################
srt_tree *st_dup(const srt_tree *t)
{
	srt_tree *t2;
	RETURN_IF(!t, NULL);
	t2 = st_alloc(t->cmp_f, t->d.elem_size, t->d.size);
	RETURN_IF(!t2, NULL);
	memcpy(t2, t, t->d.header_size + t->d.size * t->d.elem_size);
	return t2;
}
########################rank 2#############################
static int* inorderTraversal(struct TreeNode* root, int* returnSize)
{
    if (root == NULL) {
        *returnSize = 0;
        return NULL;
    }
    int count = 0;
    int *result = malloc(5000 * sizeof(int));
    traverse(root, result, &count);
    *returnSize = count;
    return result;
}
########################rank 3#############################
static void fts3SegWriterFree(SegmentWriter *pWriter){
  if( pWriter ){
    sqlite3_free(pWriter->aData);
    sqlite3_free(pWriter->zMalloc);
    fts3NodeFree(pWriter->pTree);
    sqlite3_free(pWriter);
  }
}
########################rank 4#############################
BOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function) {
	BOSTree *new_tree = malloc(sizeof(BOSTree));
	new_tree->root_node = NULL;
	new_tree->cmp_function = cmp_function;
	new_tree->free_function = free_function;
	return new_tree;
}
########################rank 5#############################
struct ListNode* reverseList_1(struct ListNode *head) {
    if (head == NULL) return NULL;
    if (head->next == NULL) return head;
    struct ListNode *new_head, *new_tail;
    new_head = reverseList_1(head->next);
    new_tail = head->next; 
    new_tail->next = head;                  
    head->next = NULL;
    return new_head;
}
########################rank 6#############################
unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
    return lpInsert(lp,NULL,0,p,LP_REPLACE,newp);
}
########################rank 7#############################
static inline int *Child(int u, int ty)
{
    //assert(u != 1);
    return single_word(heap_pool + u, BST_NODE_CHLD_OFFSET + ty);
}
########################rank 8#############################
binn * APIENTRY binn_list_next_value(binn_iter *iter) {
  binn *value;
  value = (binn *) binn_malloc(sizeof(binn));
  if (binn_list_next(iter, value) == FALSE) {
    free_fn(value);
    return NULL;
  }
  value->allocated = TRUE;
  return value;
}
########################rank 9#############################
static void
startelt(void * d, const char * name, int l)
{
	int i;
	struct PortMappingParserData * pdata = (struct PortMappingParserData *)d;
	pdata->curelt = PortMappingEltNone;
	for(i = 0; elements[i].str; i++)
	{
		if(strlen(elements[i].str) == (size_t)l && memcmp(name, elements[i].str, l) == 0)
		{
			pdata->curelt = elements[i].code;
			break;
		}
	}
	if(pdata->curelt == PortMappingEntry)
	{
		struct PortMapping * pm;
		pm = calloc(1, sizeof(struct PortMapping));
		if(pm == NULL)
		{
#ifdef DEBUG
			fprintf(stderr, "%s: error allocating memory",
			        "startelt");
#endif /* DEBUG */
			return;
		}
		pm->l_next = pdata->l_head;	/* insert in list */
		pdata->l_head = pm;
	}
}
########################rank 10#############################
struct TreeNode* sortedArrayToBST(int* nums, int numsSize) {
    if (nums == NULL || numsSize == 0) return NULL;
    int middle = numsSize / 2; 
    struct TreeNode *root
        = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    root->val = nums[middle];
    root->left = sortedArrayToBST(nums, middle);
    root->right = sortedArrayToBST(nums + middle + 1, numsSize - middle - 1);
    return root;
}
----------------------------QUERY-------------------------------
free a dirty page
########################rank 1#############################
int unqlite_kv_cursor_reset(unqlite_kv_cursor *pCursor)
{
	int rc = UNQLITE_OK;
#ifdef UNTRUST
	if( pCursor == 0 ){
		return UNQLITE_CORRUPT;
	}
#endif
	if( pCursor->pStore->pIo->pMethods->xReset == 0 ){
		rc = UNQLITE_NOTIMPLEMENTED;
	}else{
		pCursor->pStore->pIo->pMethods->xReset(pCursor);
	}
	return rc;
}
########################rank 2#############################
static int checkRef(IntegrityCk *pCheck, Pgno iPage){
  if( iPage==0 ) return 1;
  if( iPage>pCheck->nPage ){
    checkAppendMsg(pCheck, "invalid page number %d", iPage);
    return 1;
  }
  if( getPageReferenced(pCheck, iPage) ){
    checkAppendMsg(pCheck, "2nd reference to page %d", iPage);
    return 1;
  }
  setPageReferenced(pCheck, iPage);
  return 0;
}
########################rank 3#############################
static void btreePtrmapDelete(BtShared *pBt){
  BtreePtrmap *pMap = pBt->pMap;
  if( pMap ){
    sqlite3_free(pMap->aRollback);
    sqlite3_free(pMap->aPtr);
    sqlite3_free(pMap->aSvpt);
    sqlite3_free(pMap);
    pBt->pMap = 0;
  }
}
########################rank 4#############################
static int pager_write_dirty_pages(Pager *pPager,Page *pDirty)
{
	int rc = VEDIS_OK;
	Page *pNext;
	for(;;){
		if( pDirty == 0 ){
			break;
		}
		pNext = pDirty->pDirtyPrev; /* Not a bug: Reverse link */
		if( (pDirty->flags & PAGE_DONT_WRITE) == 0 ){
			rc = vedisOsWrite(pPager->pfd,pDirty->zData,pPager->iPageSize,pDirty->pgno * pPager->iPageSize);
			if( rc != VEDIS_OK ){
				break;
			}
		}
		pDirty->flags &= ~(PAGE_DIRTY|PAGE_DONT_WRITE|PAGE_NEED_SYNC|PAGE_IN_JOURNAL|PAGE_HOT_DIRTY);
		if( pDirty->nRef < 1 ){
			pager_unlink_page(pPager,pDirty);
			pager_release_page(pPager,pDirty);
		}
		pDirty = pNext;
	}
	pPager->pDirty = pPager->pFirstDirty = 0;
	pPager->pHotDirty = pPager->pFirstHot = 0;
	pPager->nHot = 0;
	return rc;
}
########################rank 5#############################
SQLITE_PRIVATE int wx_sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){
  int rc = SQLITE_OK;
  if( p->inTrans==TRANS_WRITE ){
    BtShared *pBt = p->pBt;
    wx_sqlite3BtreeEnter(p);
#ifndef SQLITE_OMIT_AUTOVACUUM
    if( pBt->autoVacuum ){
      rc = autoVacuumCommit(pBt);
      if( rc!=SQLITE_OK ){
        wx_sqlite3BtreeLeave(p);
        return rc;
      }
    }
    if( pBt->bDoTruncate ){
      wx_sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
    }
#endif
    rc = wx_sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
    wx_sqlite3BtreeLeave(p);
  }
  return rc;
}
########################rank 6#############################
SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){
  int rc = SQLITE_OK;
  if( p->inTrans==TRANS_WRITE ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);
#ifndef SQLITE_OMIT_AUTOVACUUM
    if( pBt->autoVacuum ){
      rc = autoVacuumCommit(pBt);
      if( rc!=SQLITE_OK ){
        sqlite3BtreeLeave(p);
        return rc;
      }
    }
    if( pBt->bDoTruncate ){
      sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
    }
#endif
    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
    sqlite3BtreeLeave(p);
  }
  return rc;
}
########################rank 7#############################
static void
mdb_dpage_free(MDB_env *env, MDB_page *dp)
{
	if (!IS_OVERFLOW(dp) || dp->mp_pages == 1) {
		mdb_page_free(env, dp);
	} else {
		VGMEMP_FREE(env, dp);
		free(dp);
	}
}
########################rank 8#############################
SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}
########################rank 9#############################
static int clearCell(
  MemPage *pPage,          /* The page that contains the Cell */
  unsigned char *pCell,    /* First byte of the Cell */
  u16 *pnSize              /* Write the size of the Cell here */
){
  BtShared *pBt = pPage->pBt;
  CellInfo info;
  Pgno ovflPgno;
  int rc;
  int nOvfl;
  u32 ovflPageSize;
  assert( sqlite3_mutex_held(pPage->pBt->mutex) );
  pPage->xParseCell(pPage, pCell, &info);
  *pnSize = info.nSize;
  if( info.nLocal==info.nPayload ){
    return SQLITE_OK;  /* No overflow pages. Return without doing anything */
  }
  if( pCell+info.nSize-1 > pPage->aData+pPage->maskPage ){
    return SQLITE_CORRUPT_BKPT;  /* Cell extends past end of page */
  }
  ovflPgno = get4byte(pCell + info.nSize - 4);
  assert( pBt->usableSize > 4 );
  ovflPageSize = pBt->usableSize - 4;
  nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1)/ovflPageSize;
  assert( nOvfl>0 || 
    (CORRUPT_DB && (info.nPayload + ovflPageSize)<ovflPageSize)
  );
  while( nOvfl-- ){
    Pgno iNext = 0;
    MemPage *pOvfl = 0;
    if( ovflPgno<2 || ovflPgno>btreePagecount(pBt) ){
      ** overflow page. Therefore if ovflPgno<2 or past the end of the 
      ** file the database must be corrupt. */
      return SQLITE_CORRUPT_BKPT;
    }
    if( nOvfl ){
      rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);
      if( rc ) return rc;
    }
    if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno))!=0) )
     && sqlite3PagerPageRefcount(pOvfl->pDbPage)!=1
    ){
      ** to an overflow page belonging to a cell that is being deleted/updated.
      ** So if there exists more than one reference to this page, then it 
      ** must not really be an overflow page and the database must be corrupt. 
      ** It is helpful to detect this before calling freePage2(), as 
      ** freePage2() may zero the page contents if secure-delete mode is
      ** enabled. If this 'overflow' page happens to be a page that the
      ** caller is iterating through or using in some other way, this
      ** can be problematic.
      */
      rc = SQLITE_CORRUPT_BKPT;
    }else{
      rc = freePage2(pBt, pOvfl, ovflPgno);
    }
    if( pOvfl ){
      sqlite3PagerUnref(pOvfl->pDbPage);
    }
    if( rc ) return rc;
    ovflPgno = iNext;
  }
  return SQLITE_OK;
}
########################rank 10#############################
SQLITE_PRIVATE void
sqlite3BtreeGetTempCursor(BtCursor * pCur, BtCursor * pTempCur)
{
	assert(cursorHoldsMutex(pCur));
	memcpy(pTempCur, pCur, sizeof(*pCur));
	pTempCur->pNext = 0;
	pTempCur->pPrev = 0;
	if(pTempCur->pPage)
	{
		sqlite3PagerRef(pTempCur->pPage->pDbPage);
	}
}
----------------------------QUERY-------------------------------
create message with given type
########################rank 1#############################
static void inline __peprotocol_process_set_encrypt_iterations(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  int *iterations = NULL;
  if (protocol->size != sizeof(int)) {
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }
  iterations = (int *) protocol->data;
  peinfect_set_encryptiterations(*iterations, server->infect);
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }
  if (!ini_putl("methods", "encrypt_iterations", *iterations, server->config->config_name)) {
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    __peprotocol_process_receive_success(protocol, sock);
  }
  pthread_mutex_unlock(&server->config->config_mutex);
}
########################rank 2#############################
JX9_PRIVATE int jx9_context_throw_error(jx9_context *pCtx, int iErr, const char *zErr)
{
	int rc = JX9_OK;
	if( zErr ){
		rc = jx9VmThrowError(pCtx->pVm, &pCtx->pFunc->sName, iErr, zErr);
	}
	return rc;
}
########################rank 3#############################
int ph7_context_throw_error(ph7_context *pCtx,int iErr,const char *zErr)
{
	int rc = PH7_OK;
	if( zErr ){
		rc = PH7_VmThrowError(pCtx->pVm,&pCtx->pFunc->sName,iErr,zErr);
	}
	return rc;
}
########################rank 4#############################
static struct BannerOutput *
banout_new_proto(struct BannerOutput *banout, unsigned proto)
{
    struct BannerOutput *p;
    if (banout->protocol == 0 && banout->length == 0) {
        banout->protocol = proto;
        return banout;
    }
    p = (struct BannerOutput *)malloc(sizeof(*p));
    memset(p, 0, sizeof(*p));
    p->protocol = proto;
    p->max_length = sizeof(p->banner);
    p->next = banout->next;
    banout->next = p;
    return p;
}
########################rank 5#############################
int enqueueCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    return enqueueGenericCommand(ctx,argv,argc,0);
}
########################rank 6#############################
struct mg_connection *mg_if_accept_new_conn(struct mg_connection *lc) {
  struct mg_add_sock_opts opts;
  struct mg_connection *nc;
  memset(&opts, 0, sizeof(opts));
  nc = mg_create_connection(lc->mgr, lc->handler, opts);
  if (nc == NULL) return NULL;
  nc->listener = lc;
  nc->proto_handler = lc->proto_handler;
  nc->user_data = lc->user_data;
  nc->recv_mbuf_limit = lc->recv_mbuf_limit;
  nc->iface = lc->iface;
  if (lc->flags & MG_F_SSL) nc->flags |= MG_F_SSL;
  mg_add_conn(nc->mgr, nc);
  LOG(LL_DEBUG, ("%p %p %d %d", lc, nc, nc->sock, (int) nc->flags));
  return nc;
}
########################rank 7#############################
struct mg_connection *mg_if_accept_new_conn(struct mg_connection *lc) {
  struct mg_add_sock_opts opts;
  struct mg_connection *nc;
  memset(&opts, 0, sizeof(opts));
  nc = mg_create_connection(lc->mgr, lc->handler, opts);
  if (nc == NULL) return NULL;
  nc->listener = lc;
  nc->proto_handler = lc->proto_handler;
  nc->user_data = lc->user_data;
  nc->recv_mbuf_limit = lc->recv_mbuf_limit;
  nc->iface = lc->iface;
  if (lc->flags & MG_F_SSL) nc->flags |= MG_F_SSL;
  mg_add_conn(nc->mgr, nc);
  LOG(LL_DEBUG, ("%p %p %d %d", lc, nc, nc->sock, (int) nc->flags));
  return nc;
}
########################rank 8#############################
int nackCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    return enqueueGenericCommand(ctx,argv,argc,1);
}
########################rank 9#############################
static int xdag_rpc_service_init(int port)
{
	if(port > 0 && port < 65535) {
		g_rpc_port = port;
	} else {
		g_rpc_port = DEFAULT_RPC_PORT;
	}
	g_rpc_stop = 0;
	pthread_t th;
	int err = pthread_create(&th, NULL, rpc_service_thread, (void*)&g_rpc_port);
	if(err != 0) {
		printf("create rpc_service_thread failed, error : %s\n", strerror(err));
		return -1;
	}
	err = pthread_detach(th);
	if(err != 0) {
		printf("detach rpc_service_thread failed, error : %s\n", strerror(err));
		return -1;
	}
	xdag_rpc_command_host_add("127.0.0.1"); // always accept localhost
	xdag_rpc_init_procedures();
	return 0;
}
########################rank 10#############################
void telnet_begin_newenviron(telnet_t *telnet, unsigned char cmd) {
	telnet_begin_sb(telnet, TELNET_TELOPT_NEW_ENVIRON);
	telnet_send(telnet, (const char *)&cmd, 1);
}
----------------------------QUERY-------------------------------
encrypt byte sequence
########################rank 1#############################
void hmacSha512(uint8_t *out, const uint8_t *key, const unsigned int key_length, const uint8_t *text, const unsigned int text_length)
{
	unsigned int i;
	uint8_t hash[SHA512_HASH_LENGTH];
	uint8_t padded_key[128];
	HashState64 hs64;
	// Determine key.
	memset(padded_key, 0, sizeof(padded_key));
	if (key_length <= sizeof(padded_key))
	{
		memcpy(padded_key, key, key_length);
	}
	else
	{
		sha512Begin(&hs64);
		for (i = 0; i < key_length; i++)
		{
			sha512WriteByte(&hs64, key[i]);
		}
		sha512Finish(padded_key, &hs64);
	}
	// Calculate hash = H((K_0 XOR ipad) || text).
	sha512Begin(&hs64);
	for (i = 0; i < sizeof(padded_key); i++)
	{
		sha512WriteByte(&hs64, (uint8_t)(padded_key[i] ^ 0x36));
	}
	for (i = 0; i < text_length; i++)
	{
		sha512WriteByte(&hs64, text[i]);
	}
	sha512Finish(hash, &hs64);
	// Calculate H((K_0 XOR opad) || hash).
	sha512Begin(&hs64);
	for (i = 0; i < sizeof(padded_key); i++)
	{
		sha512WriteByte(&hs64, (uint8_t)(padded_key[i] ^ 0x5c));
	}
	for (i = 0; i < sizeof(hash); i++)
	{
		sha512WriteByte(&hs64, hash[i]);
	}
	sha512Finish(out, &hs64);
}
########################rank 2#############################
void sha4_hmac_finish( sha4_context *ctx, unsigned char output[64] )
{
    int is384, hlen;
    unsigned char tmpbuf[64];
    is384 = ctx->is384;
    hlen = ( is384 == 0 ) ? 64 : 48;
    sha4_finish( ctx, tmpbuf );
    sha4_starts( ctx, is384 );
    sha4_update( ctx, ctx->opad, 128 );
    sha4_update( ctx, tmpbuf, hlen );
    sha4_finish( ctx, output );
    memset( tmpbuf, 0, sizeof( tmpbuf ) );
}
########################rank 3#############################
void sha4_hmac_update( sha4_context  *ctx,
                       const unsigned char *input, int ilen )
{
    sha4_update( ctx, input, ilen );
}
########################rank 4#############################
void sha3_256(const unsigned char* data, size_t len, unsigned char* digest)
{
	SHA3_CTX ctx;
	sha3_256_Init(&ctx);
	sha3_Update(&ctx, data, len);
	sha3_Final(&ctx, digest);
}
########################rank 5#############################
void sha1_hmac_update( sha1_context *ctx, const unsigned char *input, size_t ilen )
{
    sha1_update( ctx, input, ilen );
}
########################rank 6#############################
void sha3_256(const unsigned char* data, size_t len, unsigned char* digest)
{
	SHA3_CTX ctx;
	sha3_256_Init(&ctx);
	sha3_Update(&ctx, data, len);
	sha3_Final(&ctx, digest);
}
########################rank 7#############################
static void
_SHA256_Final(uint8_t digest[32], SHA256_CTX * ctx,
    uint32_t tmp32[static restrict 72])
{
	SHA256_Pad(ctx, tmp32);
	be32enc_vect(digest, ctx->state, 32);
}
########################rank 8#############################
void
SHA256Init(SHA2_CTX *context)
{
	memcpy(context->state.st32, sha256_initial_hash_value,
	    SHA256_DIGEST_LENGTH);
	memset(context->buffer, 0, SHA256_BLOCK_LENGTH);
	context->bitcount[0] = 0;
}
########################rank 9#############################
void
SHA512Init(SHA2_CTX *context)
{
	memcpy(context->state.st64, sha512_initial_hash_value,
	    SHA512_DIGEST_LENGTH);
	memset(context->buffer, 0, SHA512_BLOCK_LENGTH);
	context->bitcount[0] = context->bitcount[1] =  0;
}
########################rank 10#############################
void
SHA384Init(SHA2_CTX *context)
{
	memcpy(context->state.st64, sha384_initial_hash_value,
	    SHA512_DIGEST_LENGTH);
	memset(context->buffer, 0, SHA384_BLOCK_LENGTH);
	context->bitcount[0] = context->bitcount[1] = 0;
}
----------------------------QUERY-------------------------------
create new list without duplicates
########################rank 1#############################
struct list *add(struct list *l, struct state *st)
{
	struct list *n = (struct list *)malloc(sizeof(struct list));
	n->st = st;
	n->next = l;
	return n;
}
########################rank 2#############################
List ListCreate()
{
List retVal;
	retVal = (List) MALLOC(sizeof(struct LISTSTRUCT));
	retVal->head = NIL;
	retVal->tail = NIL;
	retVal->current = NIL;
	return(retVal);
}
########################rank 3#############################
BOOL APIENTRY binn_create_list(binn *list) {
  return binn_create(list, BINN_LIST, 0, NULL);
}
########################rank 4#############################
struct opt *set_opt(struct opt *list, const char *name, const char *value)
{
	struct opt *o = find_opt(list, name);
	if (o) {
		free(o->value);
		o->value = strdup(value);
		return list;
	} else {
		o = (struct opt *)malloc(sizeof(struct opt));
		o->name = strdup(name);
		o->value = strdup(value);
		o->next = list;
		return o;
	}
}
########################rank 5#############################
static struct talloc_chunk *talloc_chunk_from_ptr(const void *ptr)
{
	const char *pp = ptr;
	struct talloc_chunk *tc = discard_const_p(struct talloc_chunk, pp - TC_HDR_SIZE);
	if ((tc->flags & ~0xF) != TALLOC_MAGIC) { 
		TALLOC_ABORT("Bad talloc magic value - unknown value"); 
	}
	if (tc->flags & TALLOC_FLAG_FREE) {
		TALLOC_ABORT("Bad talloc magic value - double free"); 
	}
	return tc;
}
########################rank 6#############################
LST *newlst()
{
	LST *n;
	if (!freelsts) {
		n = (LST *) amalloc(ALOCSIZE);
		//printf("newlst: %p\n", n);
		*(ptrdiff_t *)(&n->r) = tLST;
		freelsts = ++n;
		while (n + 1 != freelsts + ALOCSIZE / sizeof(LST) - 1)
			n->r = n + 1, ++n;
		n->r = 0;
	}
	n = freelsts;
	freelsts = n->r;
	n->r = 0;
	n->d = 0;
	return n;
}
########################rank 7#############################
list_t *list_create(void) {
    list_t *list    = malloc(sizeof(*list));
    if (!list)
        return NULL;
    list->length    = 0;
    list->head      = NULL;
    list->tail      = NULL;
    list_atcache_create(list);
    return list;
}
########################rank 8#############################
srjson_t *srjson_CreateNull(srjson_doc_t *doc) {
	srjson_t *item = srjson_New_Item(doc);
	if (item)
		item->type = srjson_NULL;
	return item;
}
########################rank 9#############################
void * caml_dlopen(char * libname, int for_execution, int global)
{
  int flags = (global ? FLEXDLL_RTLD_GLOBAL : 0);
  if (!for_execution) flags |= FLEXDLL_RTLD_NOEXEC;
  return flexdll_dlopen(libname, flags);
}
########################rank 10#############################
static inline void raxStackInit(raxStack *ts) {
    ts->stack = ts->static_items;
    ts->items = 0;
    ts->maxitems = RAX_STACK_STATIC_ITEMS;
    ts->oom = 0;
}
----------------------------QUERY-------------------------------
read data with given node
########################rank 1#############################
static HB_Error  Load_PosClassRule( HB_ContextPosFormat2*  cpf2,
				    HB_PosClassRule*       pcr,
				    HB_Stream               stream )
{
  HB_Error  error;
  HB_UShort             n, count;
  HB_UShort*            c;
  HB_PosLookupRecord*  plr;
  if ( ACCESS_Frame( 4L ) )
    return error;
  pcr->GlyphCount = GET_UShort();
  pcr->PosCount   = GET_UShort();
  FORGET_Frame();
  if ( pcr->GlyphCount > cpf2->MaxContextLength )
    cpf2->MaxContextLength = pcr->GlyphCount;
  pcr->Class = NULL;
  count = pcr->GlyphCount - 1;        
  if ( ALLOC_ARRAY( pcr->Class, count, HB_UShort ) )
    return error;
  c = pcr->Class;
  if ( ACCESS_Frame( count * 2L ) )
    goto Fail2;
  for ( n = 0; n < count; n++ )
    c[n] = GET_UShort();
  FORGET_Frame();
  pcr->PosLookupRecord = NULL;
  count = pcr->PosCount;
  if ( ALLOC_ARRAY( pcr->PosLookupRecord, count, HB_PosLookupRecord ) )
    goto Fail2;
  plr = pcr->PosLookupRecord;
  if ( ACCESS_Frame( count * 4L ) )
    goto Fail1;
  for ( n = 0; n < count; n++ )
  {
    plr[n].SequenceIndex   = GET_UShort();
    plr[n].LookupListIndex = GET_UShort();
  }
  FORGET_Frame();
  return HB_Err_Ok;
Fail1:
  FREE( plr );
Fail2:
  FREE( c );
  return error;
}
########################rank 2#############################
void buzzset_remove(buzzset_t s,
                    const void* data) {
   int removed;
   s->data = buzzset_tree_remove(s, s->data, data, &removed);
   if(removed) s->size--;
}
########################rank 3#############################
void * APIENTRY binn_ptr(void *ptr) {
  binn *item;
  switch (binn_get_ptr_type(ptr)) {
  case BINN_STRUCT:
    item = (binn*) ptr;
    if (item->writable && item->dirty) {
      binn_save_header(item);
    }
    return item->ptr;
  case BINN_BUFFER:
    return ptr;
  default:
    return NULL;
  }
}
########################rank 4#############################
void* buzzset_find(buzzset_t s,
                   const void* data) {
   buzzset_tree_t res = buzzset_tree_find(s, s->data, data);
   if(!res) return NULL;
   return res->data;
}
########################rank 5#############################
unsigned long raxTouch(raxNode *n) {
    debugf("Touching %p\n", (void*)n);
    unsigned long sum = 0;
    if (n->iskey) {
        sum += (unsigned long)raxGetData(n);
    }
    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeFirstChildPtr(n);
    int count = 0;
    for (int i = 0; i < numchildren; i++) {
        if (numchildren > 1) {
            sum += (long)n->data[i];
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        if (child == (void*)0x65d1760) count++;
        if (count > 1) exit(1);
        sum += raxTouch(child);
        cp++;
    }
    return sum;
}
########################rank 6#############################
struct btree_node *btree_read_node(struct btree *bt, uint64_t offset) {
    unsigned char buf[BTREE_NODE_SIZE], *p;
    struct btree_node *n;
    int j;
    if (btree_pread(bt,buf,sizeof(buf),offset) == -1) return NULL;
    if (memcmp(buf,buf+BTREE_NODE_SIZE-4,4)) {
        errno = EFAULT;
        return NULL;
    }
    if ((n = btree_create_node()) == NULL) return NULL;
    p = buf+4;
    n->numkeys = btree_u32_from_big(p); p += 4; /* number of keys */
    n->isleaf = btree_u32_from_big(p); p += 4; /* is a leaf? */
    p += 4; /* unused field, needed for alignment */
    memcpy(n->keys,p,sizeof(n->keys)); p += sizeof(n->keys); /* keys */
    for (j = 0; j < BTREE_MAX_KEYS; j++) {
        n->values[j] = btree_u64_from_big(p);
        p += 8;
    }
    for (j = 0; j <= BTREE_MAX_KEYS; j++) {
        n->children[j] = btree_u64_from_big(p);
        p += 8;
    }
    return n;
}
########################rank 7#############################
void raxStop(raxIterator *it) {
    if (it->key != it->key_static_string) rax_free(it->key);
    if (it->seek_key != NULL) {
        rax_free(it->seek_key);
        it->seek_key = NULL;
        it->seek_key_len = 0;
    }
    raxStackFree(&it->stack);
}
########################rank 8#############################
int SeenBodyEndTag;  /* could be moved into lexer structure */
Bool CheckNodeIntegrity(Node *node)
{
    Node *child;
    Bool found = no;
    if (node->prev)
    {
        if (node->prev->next != node)
            return no;
    }
    if (node->next)
    {
        if (node->next->prev != node)
            return no;
    }
    if (node->parent)
    {
        if (node->prev == null && node->parent->content != node)
            return no;
        if (node->next == null && node->parent->last != node)
            return no;
        for (child = node->parent->content; child; child = child->next)
            if (child == node)
            {
                found = yes;
                break;
            }
        if (!found)
            return no;
    }
    for (child = node->content; child; child = child->next)
        if (!CheckNodeIntegrity(child))
            return no;
    return yes;
}
########################rank 9#############################
Lib3dsNode*
lib3ds_node_by_id(Lib3dsNode *node, Lib3dsWord node_id)
{
  Lib3dsNode *p,*q;
  for (p=node->childs; p!=0; p=p->next) {
    if (p->node_id==node_id) {
      return(p);
    }
    q=lib3ds_node_by_id(p, node_id);
    if (q) {
      return(q);
    }
  }
  return(0);
}
########################rank 10#############################
void Key_SetBinding( int keynum, const char *binding ) {
	if( keynum == -1 ) {
		return;
	}
	// free old bindings
	if( keybindings[keynum] ) {
		if( !Q_stricmp( keybindings[keynum], "toggleconsole" ) ) {
			consolebinded--;
		}
		Mem_ZoneFree( keybindings[keynum] );
		keybindings[keynum] = NULL;
	}
	if( !binding ) {
		return;
	}
	// allocate memory for new binding
	keybindings[keynum] = ZoneCopyString( binding );
	if( !Q_stricmp( keybindings[keynum], "toggleconsole" ) ) {
		consolebinded++;
	}
}
----------------------------QUERY-------------------------------
parse checksum file
########################rank 1#############################
static int cabd_sys_read_block(struct mspack_system *sys,
			       struct mscabd_decompress_state *d,
			       int *out, int ignore_cksum)
{
  unsigned char hdr[cfdata_SIZEOF];
  unsigned int cksum;
  int len;
  d->i_ptr = d->i_end = &d->input[0];
  do {
    if (sys->read(d->infh, &hdr[0], cfdata_SIZEOF) != cfdata_SIZEOF) {
      return MSPACK_ERR_READ;
    }
    if (d->data->cab->block_resv &&
	sys->seek(d->infh, (off_t) d->data->cab->block_resv,
		  MSPACK_SYS_SEEK_CUR))
    {
      return MSPACK_ERR_SEEK;
    }
    len = EndGetI16(&hdr[cfdata_CompressedSize]);
    if (((d->i_end - d->i_ptr) + len) > CAB_INPUTMAX) {
      D(("block size > CAB_INPUTMAX (%ld + %d)", d->i_end - d->i_ptr, len))
      return MSPACK_ERR_DATAFORMAT;
    }
    if (EndGetI16(&hdr[cfdata_UncompressedSize]) > CAB_BLOCKMAX) {
      D(("block size > CAB_BLOCKMAX"))
      return MSPACK_ERR_DATAFORMAT;
    }
    if (sys->read(d->infh, d->i_end, len) != len) {
      return MSPACK_ERR_READ;
    }
    if ((cksum = EndGetI32(&hdr[cfdata_CheckSum]))) {
      unsigned int sum2 = cabd_checksum(d->i_end, (unsigned int) len, 0);
      if (cabd_checksum(&hdr[4], 4, sum2) != cksum) {
	if (!ignore_cksum) return MSPACK_ERR_CHECKSUM;
	sys->message(d->infh, "WARNING; bad block checksum found");
      }
    }
    d->i_end += len;
     * and it continues as the first block of the next cabinet in the set.
     * otherwise, this is the last part of the block, and no more block
     * reading needs to be done.
     */
    if ((*out = EndGetI16(&hdr[cfdata_UncompressedSize]))) {
      return MSPACK_ERR_OK;
    }
    sys->close(d->infh);
    d->infh = NULL;
    if (!(d->data = d->data->next)) {
      D(("ran out of splits in cabinet set"))
      return MSPACK_ERR_DATAFORMAT;
    }
    d->incab = d->data->cab;
    if (!(d->infh = sys->open(sys, d->incab->base.filename,
			      MSPACK_SYS_OPEN_READ)))
    {
      return MSPACK_ERR_OPEN;
    }
    if (sys->seek(d->infh, d->data->offset, MSPACK_SYS_SEEK_START)) {
      return MSPACK_ERR_SEEK;
    }
  } while (1);
  return MSPACK_ERR_OK;
}
########################rank 2#############################
int hputc2(int c, hFILE *fp)
{
    if (flush_buffer(fp) < 0) return EOF;
    *(fp->begin++) = c;
    return c;
}
########################rank 3#############################
static int
_illegal_seek(stream_id nst, long int pos, int whence)
{
    return STREAM_MODE;
}
########################rank 4#############################
int getc_crc(FILE *ib)
{
	int c;
	c = getc(ib);
	if (c != EOF)
		crc += c;		/* checksum */
	return c;
}
########################rank 5#############################
static bool_t
x_putlong(
	XDR *xdrs,
	const long *longp)
{
	xdrs->x_handy += BYTES_PER_XDR_UNIT;
	return (TRUE);
}
########################rank 6#############################
static ssize_t plain_fullread(mpg123_handle *fr,unsigned char *buf, ssize_t count)
{
	ssize_t ret,cnt=0;
#ifdef EXTRA_DEBUG
	debug1("plain fullread of %"SSIZE_P, (size_p)count);
#endif
	while(cnt < count)
	{
		ret = fr->rdat.fdread(fr,buf+cnt,count-cnt);
		if(ret < 0) return READER_ERROR;
		if(ret == 0) break;
		if(!(fr->rdat.flags & READER_BUFFERED)) fr->rdat.filepos += ret;
		cnt += ret;
	}
	return cnt;
}
########################rank 7#############################
int dbt_is_database(str *_s)
{
	DIR *dirp = NULL;
	char buf[512];
	if(!_s || !_s->s || _s->len <= 0 || _s->len > 510)
		return 0;
	strncpy(buf, _s->s, _s->len);
	buf[_s->len] = 0;
	dirp = opendir(buf);
	if(!dirp)
		return 0;
	closedir(dirp);
	return 1;
}
########################rank 8#############################
extern int determine_if_TS_file(int    input,
                                int   *is_TS)
{
  int  err;
  int  ii;
  byte buf[TS_PACKET_SIZE];
  *is_TS = TRUE;
  for (ii = 0; ii < 100; ii++)
  {
    err = read_bytes(input,TS_PACKET_SIZE,buf);
    if (err == EOF)
      break;
    else if (err)
    {
      print_err("### Error trying to check if file is TS\n");
      return 1;
    }
    if (buf[0] != 0x47)
    {
      *is_TS = FALSE;
      break;
    }
  }
  err = seek_file(input,0);
  if (err)
  {
    print_err("### Error rewinding file after determining if it is TS\n");
    return 1;
  }
  return 0;
}
########################rank 9#############################
int ZEXPORT gzungetc(c, file)
    int c;
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;
    s->back = c;
    s->out--;
    s->last = (s->z_err == Z_STREAM_END);
    if (s->last) s->z_err = Z_OK;
    s->z_eof = 0;
    return c;
}
########################rank 10#############################
static SRes FileSeqInStream_Read(void *pp, void *buf, size_t *size)
{
  CFileSeqInStream *p = (CFileSeqInStream *)pp;
  return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;
}
----------------------------QUERY-------------------------------
remove trailing blanks, tabs and newlines
########################rank 1#############################
BOOL nosubst;
void copy(IOPTR ioparg)
{
	CHAR c, *ends;
	register CHAR *cline, *clinep;
	int fd;
	register IOPTR iop;
	if ( (iop = ioparg) ) {
		copy(iop->iolst);
		ends = mactrim(iop->ioname);
		if (nosubst)
			iop->iofile &= ~IODOC;
		fd = tmpfil();
		iop->ioname = cpystak(tmpout);
		iop->iolst = iotemp;
		iotemp = iop;
		cline = locstak();
		for (;;) {
			clinep = cline;
			chkpr(NL);
			while ((c = (nosubst ? readc() : nextc(*ends)),!eolchar(c))) {
				*clinep++ = c;
			}
			*clinep = 0;
			if (eof || eq(cline, ends))
				break;
			*clinep++ = NL;
			write(fd, cline, clinep - cline);
		}
		close(fd);
	}
}
########################rank 2#############################
void SkipRestOfLine( char **data ) {
	char    *p;
	int c;
	p = *data;
	while ( ( c = *p++ ) != 0 ) {
		if ( c == '\n' ) {
			com_lines++;
			break;
		}
	}
	*data = p;
}
########################rank 3#############################
void SkipRestOfLine( char **data ) {
	char    *p;
	int c;
	p = *data;
	while ( ( c = *p++ ) != 0 ) {
		if ( c == '\n' ) {
			com_lines++;
			break;
		}
	}
	*data = p;
}
########################rank 4#############################
void RemoveColorEscapeSequences( char *text ) {
	int i, l;
	l = 0;
	for ( i = 0; text[i]; i++ ) {
		if (Q_IsColorString(&text[i])) {
			i++;
			continue;
		}
		if (text[i] > 0x7E)
			continue;
		text[l++] = text[i];
	}
	text[l] = '\0';
}
########################rank 5#############################
static void Con_ClearTyping( void ) {
	key_lines[edit_line][1] = 0; // clear any typing
	key_linepos = 1;
	search_line = edit_line;
	search_text[0] = 0;
}
########################rank 6#############################
int
find_label(FILE *fp, char *ttylabel)
{
	char *p;		/* working pointer */
	int line = 0;		/* line number we found entry on */
	static char buf[BUFSIZ];/* scratch buffer */
	while (fgets(buf, BUFSIZ, fp)) {
		line++;
		p = buf;
		while (isspace(*p))
			p++;
		if ((p = strtok(p, " :")) != NULL) {
			if (!(strcmp(p, ttylabel)))
				return(line);
		}
	}
	if (!feof(fp)) {
		(void)fprintf(stderr, "error reading \"%s\"\n", TTYDEFS);
		return(0);
	}
	return(0);
}
########################rank 7#############################
static void
conspsfonts(void)
{
  char *p;
  const char *q;
  p = newstring (xbasename (outname));
  q = find_suffix (p);
  if (q)
    p[q - p - 1] = 0;
  openout (p, 0, ".map");
  (void) fprintf (outfile, "%s %s", p, fontname);
  free (p);
  if (slantparam || efactorparam || encfilename) {
    (void) fprintf (outfile, " \"");
    if (slantparam)
      (void) fprintf (outfile, " %s SlantFont", slantparam);
    if (efactorparam)
      (void) fprintf (outfile, " %s ExtendFont", efactorparam);
    if (encfilename)
      (void) fprintf (outfile, " %s ReEncodeFont", outencoding->name);
    (void) fprintf (outfile, " \"");
    if (encfilename) {
      const char *base = xbasename (encfilename);
      (void) fprintf (outfile, " <%s", base);
    }
  }
  p = newstring (xbasename (afmname));
  q = find_suffix (p);
  if (q)
    p[q - p - 1] = 0;
  (void) fprintf (outfile, " <%s.pfb", p);
  free (p);
  (void) fprintf (outfile, "\n");
  fclose (outfile);
}
########################rank 8#############################
static void
display_tree(const struct qt_atom *self,
             unsigned indent,
             FILE *output)
{
    struct qt_atom_list *list;
    display_indent(indent, output);
    display_name(self->name, output);
    fputs("\n", output);
    for (list = self->_.tree; list; list = list->next) {
        list->atom->display(list->atom, indent + 1, output);
    }
}
########################rank 9#############################
void tg_print(tetris_game *obj, FILE *f) {
  int i, j;
  for (i = 0; i < obj->rows; i++) {
    for (j = 0; j < obj->cols; j++) {
      if (TC_IS_EMPTY(tg_get(obj, i, j))) {
        fputs(TC_EMPTY_STR, f);
      } else {
        fputs(TC_BLOCK_STR, f);
      }
    }
    fputc('\n', f);
  }
}
########################rank 10#############################
void
dowhich(v, c)
    register char **v;
    struct command *c;
{
    struct wordent lex[3];
    struct varent *vp;
    lex[0].next = &lex[1];
    lex[1].next = &lex[2];
    lex[2].next = &lex[0];
    lex[0].prev = &lex[2];
    lex[1].prev = &lex[0];
    lex[2].prev = &lex[1];
    lex[0].word = "";
    lex[2].word = "\n";
    while (*++v) {
	if ((vp = adrof1(*v, &aliases)) != NULL) {
	    (void) printf("%s: \t aliased to ", *v);
	    blkpr(vp->vec);
	    (void) putchar('\n');
	}
	else {
	    lex[1].word = *v;
	    tellmewhat(lex);
	}
    }
}
----------------------------QUERY-------------------------------
search last occurrence of char in string
########################rank 1#############################
int
untabify(s1,s2,max) char * s1, * s2; int max; {
    int i, j, k, x, z;
    x = strlen(s1);
    for (i = 0, k = 0; k < x; k++) {
	if (s1[k] != '\t') {
	    if (i >= max-1) {
		s2[max-1] = '\0';
		return(-1);
	    }
	    s2[i++] = s1[k];
	    continue;
	}
	z = 8 - i%8;
	if (z == 0) z = 8;
	for (j = 0; j < z && i < max; j++)
	  s2[i++] = ' ';
    }
    s2[i] = '\0';
    return(0);
}
########################rank 2#############################
int compare_str(const void * a, const void * b) {
	return strcmp(*(const char **)a, *(const char **)b);
}
########################rank 3#############################
char * _strnstr(const char* s, const char* find, size_t slen)
{
	char c, sc;
	size_t len;
	if ((c = *find++) != '\0') {
		len = strlen(find);
		do {
			do {
				if (slen-- < 1 || (sc = *s++) == '\0')
					return (NULL);
			} while (sc != c);
			if (len > slen)
				return (NULL);
		} while (strncmp(s, find, len) != 0);
		s--;
	}
	return ((char *)s);
}
########################rank 4#############################
static int cmp_str(const void *v1, const void *v2)
{
    register int c1, c2;
    register int n1, n2;
    register const STR *p1, *p2;
#define SET_N(nf,ch)    (nf = (ch == '\n'))
#define IS_END(ch,nf)   (ch == Delimch && nf)
    p1 = (const STR *) v1;
    p2 = (const STR *) v2;
    c1 = p1->first;
    c2 = p2->first;
    if (c1 != c2)
        return c1 - c2;
    fseek(Sort_1, p1->pos, 0);
    fseek(Sort_2, p2->pos, 0);
    n1 = FALSE;
    n2 = FALSE;
    while (!isalnum(c1 = getc(Sort_1)) && c1 != '\0')
        SET_N(n1, c1);
    while (!isalnum(c2 = getc(Sort_2)) && c2 != '\0')
        SET_N(n2, c2);
    while (!IS_END(c1, n1) && !IS_END(c2, n2))
    {
        if (Iflag)
        {
            if (isupper(c1))
                c1 = tolower(c1);
            if (isupper(c2))
                c2 = tolower(c2);
        }
        if (c1 != c2)
            return c1 - c2;
        SET_N(n1, c1);
        SET_N(n2, c2);
        c1 = getc(Sort_1);
        c2 = getc(Sort_2);
    }
    if (IS_END(c1, n1))
        c1 = 0;
    if (IS_END(c2, n2))
        c2 = 0;
    return c1 - c2;
}
########################rank 5#############################
void *find_string(void *start, void *end, char *string) {
    void *cur = start;
    while (cur < end) {
        if (strcmp(cur, string) == 0) {
            return cur;
        }
        cur++;
    }
    return NULL;
}
########################rank 6#############################
bool valid_int_str(const char *str, size_t n)
{
	bool found_num = false;
	if (!str)
		return false;
	if (!*str)
		return false;
	if (!n)
		n = strlen(str);
	if (*str == '-' || *str == '+')
		++str;
	do {
		if (*str > '9' || *str < '0')
			return false;
		found_num = true;
	} while(*++str && --n);
	return found_num;
}
########################rank 7#############################
bool valid_int_str(const char *str, size_t n)
{
	bool found_num = false;
	if (!str)
		return false;
	if (!*str)
		return false;
	if (!n)
		n = strlen(str);
	if (*str == '-' || *str == '+')
		++str;
	do {
		if (*str > '9' || *str < '0')
			return false;
		found_num = true;
	} while(*++str && --n);
	return found_num;
}
########################rank 8#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 9#############################
const char * memrstr(const char *hay, const char *need, size_t haylen)
{
  size_t nl = strlen(need);
  int i = (int)(nl - haylen);
  while (i > -1) {
    if (hay[i] == *need && 0 == memcmp(hay+i, need, nl))
      goto found;
    i--;
  }
found:
  return (i > -1 ? hay+i : NULL);
}
########################rank 10#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
----------------------------QUERY-------------------------------
compare two string without case
########################rank 1#############################
int ss_cmp(const srt_string *s1, const srt_string *s2)
{
	return ss_ncmp(s1, 0, s2, get_cmp_size(s1, s2));
}
########################rank 2#############################
bool valid_int_str(const char *str, size_t n)
{
	bool found_num = false;
	if (!str)
		return false;
	if (!*str)
		return false;
	if (!n)
		n = strlen(str);
	if (*str == '-' || *str == '+')
		++str;
	do {
		if (*str > '9' || *str < '0')
			return false;
		found_num = true;
	} while(*++str && --n);
	return found_num;
}
########################rank 3#############################
bool valid_int_str(const char *str, size_t n)
{
	bool found_num = false;
	if (!str)
		return false;
	if (!*str)
		return false;
	if (!n)
		n = strlen(str);
	if (*str == '-' || *str == '+')
		++str;
	do {
		if (*str > '9' || *str < '0')
			return false;
		found_num = true;
	} while(*++str && --n);
	return found_num;
}
########################rank 4#############################
const char * memrstr(const char *hay, const char *need, size_t haylen)
{
  size_t nl = strlen(need);
  int i = (int)(nl - haylen);
  while (i > -1) {
    if (hay[i] == *need && 0 == memcmp(hay+i, need, nl))
      goto found;
    i--;
  }
found:
  return (i > -1 ? hay+i : NULL);
}
########################rank 5#############################
int strcmp(char s1[], char s2[]) {
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
        if (s1[i] == '\0') return 0;
    }
    return s1[i] - s2[i];
}
########################rank 6#############################
tommy_inline tommy_uint32_t tommy_le_uint32_read(const void* ptr)
{
#if defined(__i386__) || defined(_M_IX86) || defined(_X86_) || defined(__x86_64__) || defined(_M_X64)
	return *(const tommy_uint32_t*)ptr;
#else
	const unsigned char* ptr8 = tommy_cast(const unsigned char*, ptr);
	return ptr8[0] + ((tommy_uint32_t)ptr8[1] << 8) + ((tommy_uint32_t)ptr8[2] << 16) + ((tommy_uint32_t)ptr8[3] << 24);
#endif
}
########################rank 7#############################
int compare_str(const void * a, const void * b) {
	return strcmp(*(const char **)a, *(const char **)b);
}
########################rank 8#############################
static char DBFGetNullCharacter(char chType)
{
    switch (chType)
    {
      case 'N':
      case 'F':
        return '*';
      case 'D':
        return '0';
      case 'L':
       return '?';
      default:
       return ' ';
    }
}
########################rank 9#############################
void skip_space(const char **s)
{
  for(;;)
  {
    if ( **s == '\0' )
      return;
    if ( **s > 32 )
      return;
    (*s)++;
  }
}
########################rank 10#############################
void skip_space(const char **s)
{
  for(;;)
  {
    if ( **s == '\0' )
      return;
    if ( **s > 32 )
      return;
    (*s)++;
  }
}
----------------------------QUERY-------------------------------
binary search in sorted array of size
########################rank 1#############################
int mrbc_hash_compare(const mrbc_value *v1, const mrbc_value *v2)
{
  if( v1->hash->n_stored != v2->hash->n_stored ) return 1;
  mrbc_value *d1 = v1->hash->data;
  int i;
  for( i = 0; i < mrbc_hash_size(v1); i++, d1++ ) {
    mrbc_value *d2 = mrbc_hash_search(v2, d1);	// check key
    if( d2 == NULL ) return 1;
    if( mrbc_compare( ++d1, ++d2 ) ) return 1;	// check data
  }
  return 0;
}
########################rank 2#############################
static inline unsigned short *block_header(void *header)
{
    //assert(header < mem_get_brk());
    return half_word(header);
}
########################rank 3#############################
int GetWordHash(char *word) {
  unsigned long long a, hash = 1;
  for (a = 0; a < strlen(word); a++) hash = hash * 257 + word[a];
  hash = hash % vocab_hash_size;
  return hash;
}
########################rank 4#############################
int SearchVocab(char *word) {
  // Compute the hash value for 'word'.
  unsigned int hash = GetWordHash(word);
  // Lookup the index in the hash table, handling collisions as needed.
  // See 'AddWordToVocab' to see how collisions are handled.
  while (1) {
    // If the word isn't in the hash table, it's not in the vocab.
    if (vocab_hash[hash] == -1) return -1;
    // If the input word matches the word stored at the index, we're good,
    // return the index.
    if (!strcmp(word, vocab[vocab_hash[hash]].word)) return vocab_hash[hash];
    // Otherwise, we need to scan through the hash table until we find it.
    hash = (hash + 1) % vocab_hash_size;
  }
  // This will never be reached.
  return -1;
}
########################rank 5#############################
BOOL APIENTRY binn_map_get_value(void* ptr, int id, binn *value) {
  int type, count, size=0, header_size;
  unsigned char *p;
  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (value == 0)) return FALSE;
  // check the header
  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;
  if (type != BINN_MAP) return FALSE;
  if (count == 0) return FALSE;
  p = (unsigned char *) ptr;
  p = SearchForID(p, header_size, size, count, id);
  if (p == FALSE) return FALSE;
  return GetValue(p, value);
}
########################rank 6#############################
static HashElem *findElementGivenHash(
  const Hash *pH, /* The pH to be searched */
  const void *pKey,   /* The key we are searching for */
  int nKey,
  int h               /* The hash for this key. */
){
  HashElem *elem;            /* Used to loop thru the element list */
  int count;                     /* Number of elements left to test */
  if( pH->ht ){
    struct _ht *pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
    while( count-- && elem ){
      if( binCompare(elem->pKey,elem->nKey,pKey,nKey)==0 ){
        return elem;
      }
      elem = elem->next;
    }
  }
  return 0;
}
########################rank 7#############################
int csv2_is_hash(int32 in) {
        return in == '#';
}
########################rank 8#############################
static void
accumulate()
{
	int i;
	for(i=1; i<MAXHASH; i++)  {
	HASH[i] = HASH[i-1] + HASH[i];
	}
	HASH[0] = 0;
	return;
}
########################rank 9#############################
unsigned long htab_djb_hash(unsigned long hash, const void *_buf, size_t buflen)
{
	const unsigned char *buf = _buf;
	int c;
	while (buflen > 0) {
		c = *buf++;
		buflen--;
		hash = ((hash << 5) + hash) ^ c; 
	}
	return hash;
}
########################rank 10#############################
unsigned 
entry_chain_length(const struct DBEntry *entry)
{
    unsigned chain_length;
    chain_length = 0;
    while (entry) {
        entry = entry->next;
        chain_length++;
    }
    return chain_length;
}
----------------------------QUERY-------------------------------
check bits of two strings are equal
########################rank 1#############################
int
range_is_valid(struct Range range)
{
    return range.begin <= range.end;
}
########################rank 2#############################
int
range_is_valid(struct Range range)
{
    return range.begin <= range.end;
}
########################rank 3#############################
static int bitcount16(int inword)
{
    unsigned int word = inword;
    word = ((word & 0xAAAA) >> 1) + (word & 0x5555);
    word = ((word & 0xCCCC) >> 2) + (word & 0x3333);
    word = ((word & 0xF0F0) >> 4) + (word & 0x0F0F);
    word = ((word & 0xFF00) >> 8) + (word & 0x00FF);
    return (int)word;
}
########################rank 4#############################
static nkf_encoding*
nkf_utf8_encoding()
{
    return &nkf_encoding_table[UTF_8];
}
########################rank 5#############################
static nkf_encoding*
nkf_utf8_encoding()
{
    return &nkf_encoding_table[UTF_8];
}
########################rank 6#############################
static int sqlite3FitsIn32Bits(const char *zNum){
  int i, c;
  if( *zNum=='-' || *zNum=='+' ) zNum++;
  for(i=0; (c=zNum[i])>='0' && c<='9'; i++){}
  return i<10 || (i==10 && memcmp(zNum,"2147483647",10)<=0);
}
########################rank 7#############################
size_t
base64len(size_t len)
{
	return (((len + 2) / 3 * 4) + 1);
}
########################rank 8#############################
static size_t
utf8(unsigned int cp, char out[7])
{
	size_t		 rc;
	rc = 0;
	if (cp <= 0x0000007F) {
		rc = 1;
		out[0] = (char)cp;
	} else if (cp <= 0x000007FF) {
		rc = 2;
		out[0] = (cp >> 6  & 31) | 192;
		out[1] = (cp       & 63) | 128;
	} else if (cp <= 0x0000FFFF) {
		rc = 3;
		out[0] = (cp >> 12 & 15) | 224;
		out[1] = (cp >> 6  & 63) | 128;
		out[2] = (cp       & 63) | 128;
	} else if (cp <= 0x001FFFFF) {
		rc = 4;
		out[0] = (cp >> 18 &  7) | 240;
		out[1] = (cp >> 12 & 63) | 128;
		out[2] = (cp >> 6  & 63) | 128;
		out[3] = (cp       & 63) | 128;
	} else if (cp <= 0x03FFFFFF) {
		rc = 5;
		out[0] = (cp >> 24 &  3) | 248;
		out[1] = (cp >> 18 & 63) | 128;
		out[2] = (cp >> 12 & 63) | 128;
		out[3] = (cp >> 6  & 63) | 128;
		out[4] = (cp       & 63) | 128;
	} else if (cp <= 0x7FFFFFFF) {
		rc = 6;
		out[0] = (cp >> 30 &  1) | 252;
		out[1] = (cp >> 24 & 63) | 128;
		out[2] = (cp >> 18 & 63) | 128;
		out[3] = (cp >> 12 & 63) | 128;
		out[4] = (cp >> 6  & 63) | 128;
		out[5] = (cp       & 63) | 128;
	} else
		return 0;
	out[rc] = '\0';
	return rc;
}
########################rank 9#############################
static int len_0_to_n(int n)
{
    int len = 1; /* Counting 0 as a bit of a special case */
    int i;
    for (i = 1; i < n; i *= 10) {
        len += max(n - i, 0);
    }
    return len;
}
########################rank 10#############################
static size_t extract_size(word_t word)
{
    return (word & size_mask);
}
----------------------------QUERY-------------------------------
calculate checksum of checkpoint
########################rank 1#############################
static void ckptChecksum(u32 *aCkpt, u32 nCkpt, u32 *piCksum1, u32 *piCksum2){
  u32 i;
  u32 cksum1 = 1;
  u32 cksum2 = 2;
  if( nCkpt % 2 ){
    cksum1 += aCkpt[nCkpt-3] & 0x0000FFFF;
    cksum2 += aCkpt[nCkpt-3] & 0xFFFF0000;
  }
  for(i=0; (i+3)<nCkpt; i+=2){
    cksum1 += cksum2 + aCkpt[i];
    cksum2 += cksum1 + aCkpt[i+1];
  }
  *piCksum1 = cksum1;
  *piCksum2 = cksum2;
}
########################rank 2#############################
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;
    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 
    return (unsigned short)(~cksum); 
}
########################rank 3#############################
static uint32_t do_checksum(void)
{
	uint32_t c = 0;
	size_t i = 0x400/4;
	while(i<(0x400+firmware_sz)/4)
		c += ((uint32_t*)buf)[i++];
	return c;
}
########################rank 4#############################
int get_GPSweek() {
    int i;
    unsigned byte;
    ui8_t gpsweek_bytes[2];
    int gpsweek;
    for (i = 0; i < 2; i++) {
        byte = frame_bytes[pos_GPSweek + i];
        gpsweek_bytes[i] = byte;
    }
    gpsweek = (gpsweek_bytes[0] << 8) + gpsweek_bytes[1];
    datum.week = gpsweek;
    if (gpsweek < 0 || gpsweek > 3000) return -1;
    return 0;
}
########################rank 5#############################
int32 matrixRsaReadKeysEx(psPool_t *pool, sslKeys_t **keys,
				const char *certFile, const char *privFile,
				const char *privPass, const char *trustedCAFiles)
{
	sslKeys_t		*lkeys;
	unsigned char	*privKeyMem;
	int32			rc, privKeyMemLen;
#ifdef USE_CLIENT_SIDE_SSL
	sslRsaCert_t	*currCert, *prevCert = NULL;
	unsigned char	*caCert, *caStream;
	sslChainLen_t	chain;
	int32			caCertLen, first, i;
#endif /* USE_CLIENT_SIDE_SSL */
	*keys = lkeys = psMalloc(pool, sizeof(sslKeys_t));
	if (lkeys == NULL) {
		return -8; /* SSL_MEM_ERROR */
	}
	memset(lkeys, 0x0, sizeof(sslKeys_t));
	Load certificate files.  Any additional certificate files should chain
	to the root CA held on the other side.
*/
	rc = readCertChain(pool, certFile, &lkeys->cert);
	if (rc < 0 ) {
		matrixRsaFreeKeys(lkeys);
		return rc;
	}
	The first cert in certFile must be associated with the provided
	private key. 
*/
	if (privFile) {
		rc = matrixRsaReadPrivKey(pool, privFile, privPass, &privKeyMem,
			&privKeyMemLen);
		if (rc < 0) {
			matrixStrDebugMsg("Error reading private key file: %s\n",
				(char*)privFile);
			matrixRsaFreeKeys(lkeys);
			return rc;
		}
		rc = matrixRsaParsePrivKey(pool, privKeyMem, privKeyMemLen,
			&lkeys->cert.privKey);
		if (rc < 0) {
			matrixStrDebugMsg("Error parsing private key file: %s\n",
				(char*)privFile);
			psFree(privKeyMem);
			matrixRsaFreeKeys(lkeys);
			return rc;
		}
		psFree(privKeyMem);
	}
#ifdef USE_CLIENT_SIDE_SSL
	Now deal with Certificate Authorities
*/
	if (trustedCAFiles != NULL) {
		if (matrixX509ReadCert(pool, trustedCAFiles, &caCert, &caCertLen,
				&chain) < 0 || caCert == NULL) {
			matrixStrDebugMsg("Error reading CA cert files %s\n",
				(char*)trustedCAFiles);
			matrixRsaFreeKeys(lkeys);
			return -1;
		}
		caStream = caCert;
		i = first = 0;
		while (chain[i] != 0) {
			Don't allow one bad cert to ruin the whole bunch if possible
*/
			if (matrixX509ParseCert(pool, caStream, chain[i], &currCert) < 0) {
				matrixX509FreeCert(currCert);
				matrixStrDebugMsg("Error parsing CA cert %s\n",
					(char*)trustedCAFiles);
				caStream += chain[i]; caCertLen -= chain[i];
				i++;
				continue;
			}
			if (first == 0) {
				lkeys->caCerts = currCert;
			} else {
				prevCert->next = currCert;
			}
			first++;
			prevCert = currCert;
			currCert = NULL;
			caStream += chain[i]; caCertLen -= chain[i];
			i++;
		}
		sslAssert(caCertLen == 0);
		psFree(caCert);
	}
	Check to see that if a set of CAs were passed in at least
	one ended up being valid.
*/
	if (trustedCAFiles != NULL && lkeys->caCerts == NULL) {
		matrixStrDebugMsg("No valid CA certs in %s\n",
			(char*)trustedCAFiles);
		matrixRsaFreeKeys(lkeys);
		return -1;
	}
#endif /* USE_CLIENT_SIDE_SSL */
	return 0; 
}
########################rank 6#############################
static size_t
generate_message(unsigned char *buf, size_t buflen)
{
	const unsigned len = fast_random() % (buflen - 2);
	unsigned i = 1, n = len;
	unsigned char cksum = 0;
	while (n--) {
		buf[i] = '!' + (fast_random() % ('~' - '!'));
		cksum ^= buf[i];
		i++;
	}
	 * Write the length and checksum last, trying to exploit a
	 * possibility of a race condition.  NOTE: depending on an
	 * architecture, might want to try a memory barrier here.
	 */
	buf[i++] = cksum;
	buf[0] = len;
	return i;
}
########################rank 7#############################
static int walIndexTryHdr(Wal *pWal, int *pChanged){
  u32 aCksum[2];                  /* Checksum on the header content */
  WalIndexHdr h1, h2;             /* Two copies of the header content */
  WalIndexHdr volatile *aHdr;     /* Header in shared memory */
  assert( pWal->nWiData>0 && pWal->apWiData[0] );
  ** same area of shared memory on a different CPU in a SMP,
  ** meaning it is possible that an inconsistent snapshot is read
  ** from the file. If this happens, return non-zero.
  **
  ** There are two copies of the header at the beginning of the wal-index.
  ** When reading, read [0] first then [1].  Writes are in the reverse order.
  ** Memory barriers are used to prevent the compiler or the hardware from
  ** reordering the reads and writes.
  */
  aHdr = walIndexHdr(pWal);
  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));
  walShmBarrier(pWal);
  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));
  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){
    return 1;   /* Dirty read */
  }  
  if( h1.isInit==0 ){
    return 1;   /* Malformed header - probably all zeros */
  }
  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);
  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){
    return 1;   /* Checksum does not match */
  }
  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){
    *pChanged = 1;
    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
    testcase( pWal->szPage<=32768 );
    testcase( pWal->szPage>=65536 );
  }
  return 0;
}
########################rank 8#############################
static int TS_program_packet_hdr(uint32_t pid,
                                 int      data_len,
                                 byte     TS_hdr[TS_PACKET_SIZE],
                                 int     *TS_hdr_len)
{
  uint32_t controls = 0;
  int     pointer, ii;
  if (data_len > (TS_PACKET_SIZE - 5))  // i.e., 183
  {
    fprint_err("### PMT/PAT data for PID %02x is too long (%d > 183)",
               pid,data_len);
    return 1;
  }
  // We always start with a sync_byte to identify this as a
  // Transport Stream packet
  TS_hdr[0] = 0x47;
  // We want the "payload_unit_start_indicator" bit set
  TS_hdr[1] = (byte)(0x40 | ((pid & 0x1f00) >> 8));
  TS_hdr[2] = (byte)(pid & 0xff);
  // We don't need any adaptation field controls
  controls = 0x10;
  TS_hdr[3] = (byte)(controls | next_continuity_count(pid));
  // Next comes a pointer to the actual payload data
  // (i.e., 0 if the data is 183 bytes long)
  // followed by pad bytes until we *get* to the data
  pointer = (byte)(TS_PACKET_SIZE - 5 - data_len);
  TS_hdr[4] = pointer;
  for (ii=0; ii<pointer; ii++)
    TS_hdr[5+ii] = 0xff;
  *TS_hdr_len = 5+pointer;
  return 0;
}
########################rank 9#############################
int getc_crc(FILE *ib)
{
	int c;
	c = getc(ib);
	if (c != EOF)
		crc += c;		/* checksum */
	return c;
}
########################rank 10#############################
uint16_t cksum( char *b, int len ){
    uint16_t sum = 0;
    uint16_t t;
    char *e = b + len;
    b[len] = 0;
    while(b < e){
	t = (b[0] << 8) + b[1];
	sum += t;
	if(sum < t) sum++;
	b += 2;
    }
    return ~sum;
}
----------------------------QUERY-------------------------------
build the huffman tree
########################rank 1#############################
static void huffman_tree_init(huffman_tree* tree, unsigned* buffer, unsigned numcodes, unsigned maxbitlen)
{
	tree->tree2d = buffer;
	tree->numcodes = numcodes;
	tree->maxbitlen = maxbitlen;
}
########################rank 2#############################
local void
build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc;	/* the tree descriptor */
{
	ct_data *tree   = desc->dyn_tree;
	const ct_data *stree  = desc->stat_desc->static_tree;
	int elems	= desc->stat_desc->elems;
	int n, m;	/* iterate over heap elements */
	int max_code = -1;	/* largest code with non zero frequency */
	int node;	/* new node being created */
	 * Construct the initial heap, with least frequent element in
	 * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and
	 * heap[2*n+1].  heap[0] is not used.
	 */
	s->heap_len = 0, s->heap_max = HEAP_SIZE;
	for (n = 0; n < elems; n++) {
		if (tree[n].Freq != 0) {
			s->heap[++(s->heap_len)] = max_code = n;
			s->depth[n] = 0;
		} else {
			tree[n].Len = 0;
		}
	}
	 * The pkzip format requires that at least one distance code
	 * exists, and that at least one bit should be sent even if
	 * there is only one possible code. So to avoid special checks
	 * later on we force at least two codes of non zero frequency.
	 */
	while (s->heap_len < 2) {
		node = s->heap[++(s->heap_len)] = (max_code < 2 ?
		    ++max_code : 0);
		tree[node].Freq = 1;
		s->depth[node] = 0;
		s->opt_len--; if (stree) s->static_len -= stree[node].Len;
	}
	desc->max_code = max_code;
	 * The elements heap[heap_len/2+1 .. heap_len] are leaves of
	 * the tree, establish sub-heaps of increasing lengths:
	 */
	for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
	 * Construct the Huffman tree by repeatedly combining the
	 * least two frequent nodes.
	 */
	node = elems;	/* next internal node of the tree */
	do {
		pqremove(s, tree, n);	/* n = node of least frequency */
		m = s->heap[SMALLEST];	/* m = node of next least frequency */
		s->heap[--(s->heap_max)] = n;
		s->heap[--(s->heap_max)] = m;
		tree[node].Freq = tree[n].Freq + tree[m].Freq;
		s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
		tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
		if (tree == s->bl_tree) {
			fprintf(stderr, "\nnode %d(%d), sons %d(%d) %d(%d)",
			    node, tree[node].Freq, n, tree[n].Freq, m,
			    tree[m].Freq);
		}
#endif
		s->heap[SMALLEST] = node++;
		pqdownheap(s, tree, SMALLEST);
	} while (s->heap_len >= 2);
	s->heap[--(s->heap_max)] = s->heap[SMALLEST];
	 * At this point, the fields freq and dad are set. We can now
	 * generate the bit lengths.
	 */
	gen_bitlen(s, (tree_desc *)desc);
	gen_codes((ct_data *)tree, max_code, s->bl_count);
}
########################rank 3#############################
static void
deflate_init_static_codes(struct libdeflate_compressor *c)
{
	unsigned i;
	for (i = 0; i < 144; i++)
		c->freqs.litlen[i] = 1 << (9 - 8);
	for (; i < 256; i++)
		c->freqs.litlen[i] = 1 << (9 - 9);
	for (; i < 280; i++)
		c->freqs.litlen[i] = 1 << (9 - 7);
	for (; i < 288; i++)
		c->freqs.litlen[i] = 1 << (9 - 8);
	for (i = 0; i < 32; i++)
		c->freqs.offset[i] = 1 << (5 - 5);
	deflate_make_huffman_codes(&c->freqs, &c->static_codes);
}
########################rank 4#############################
void
jbig2_release_huffman_table(Jbig2Ctx *ctx, Jbig2HuffmanTable *table)
{
    if (table != NULL) {
        jbig2_free(ctx->allocator, table->entries);
        jbig2_free(ctx->allocator, table);
    }
}
########################rank 5#############################
local void
init_block(s)
    deflate_state *s;
{
	int n;	/* iterates over tree elements */
	for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
	for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
	for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
	s->dyn_ltree[END_BLOCK].Freq = 1;
	s->opt_len = s->static_len = 0L;
	s->last_lit = s->matches = 0;
}
########################rank 6#############################
static unsigned HUF_isError(size_t code) { return ERR_isError(code); }
#define HUF_ABSOLUTEMAX_TABLELOG  16   
#define HUF_MAX_TABLELOG  12           /* max configured tableLog (for static allocation); can be modified up to HUF_ABSOLUTEMAX_TABLELOG */
#define HUF_DEFAULT_TABLELOG  HUF_MAX_TABLELOG   /* tableLog by default, when not specified */
#define HUF_MAX_SYMBOL_VALUE 255
#if (HUF_MAX_TABLELOG > HUF_ABSOLUTEMAX_TABLELOG)
#  error "HUF_MAX_TABLELOG is too large !"
#endif
*  Huff0 : Huffman block decompression
*********************************************************/
typedef struct { BYTE byte; BYTE nbBits; } HUF_DEltX2;   /* single-symbol decoding */
typedef struct { U16 sequence; BYTE nbBits; BYTE length; } HUF_DEltX4;  /* double-symbols decoding */
typedef struct { BYTE symbol; BYTE weight; } sortedSymbol_t;
    Read compact Huffman tree, saved by HUF_writeCTable
    @huffWeight : destination buffer
    @return : size read from `src`
*/
static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
                            U32* nbSymbolsPtr, U32* tableLogPtr,
                            const void* src, size_t srcSize)
{
    U32 weightTotal;
    U32 tableLog;
    const BYTE* ip = (const BYTE*) src;
    size_t iSize;
    size_t oSize;
    U32 n;
    if (!srcSize) return ERROR(srcSize_wrong);
    iSize = ip[0];
    //memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */
    if (iSize >= 128)  /* special header */
    {
        if (iSize >= (242))   /* RLE */
        {
            static int l[14] = { 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 127, 128 };
            oSize = l[iSize-242];
            memset(huffWeight, 1, hwSize);
            iSize = 0;
        }
        else   /* Incompressible */
        {
            oSize = iSize - 127;
            iSize = ((oSize+1)/2);
            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
            if (oSize >= hwSize) return ERROR(corruption_detected);
            ip += 1;
            for (n=0; n<oSize; n+=2)
            {
                huffWeight[n]   = ip[n/2] >> 4;
                huffWeight[n+1] = ip[n/2] & 15;
            }
        }
    }
    else  /* header compressed with FSE (normal case) */
    {
        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
        oSize = FSE_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
        if (FSE_isError(oSize)) return oSize;
    }
    memset(rankStats, 0, (HUF_ABSOLUTEMAX_TABLELOG + 1) * sizeof(U32));
    weightTotal = 0;
    for (n=0; n<oSize; n++)
    {
        if (huffWeight[n] >= HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
        rankStats[huffWeight[n]]++;
        weightTotal += (1 << huffWeight[n]) >> 1;
    }
    if (weightTotal == 0) return ERROR(corruption_detected);
    tableLog = BIT_highbit32(weightTotal) + 1;
    if (tableLog > HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
    {
        U32 total = 1 << tableLog;
        U32 rest = total - weightTotal;
        U32 verif = 1 << BIT_highbit32(rest);
        U32 lastWeight = BIT_highbit32(rest) + 1;
        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
        huffWeight[oSize] = (BYTE)lastWeight;
        rankStats[lastWeight]++;
    }
    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */
    *nbSymbolsPtr = (U32)(oSize+1);
    *tableLogPtr = tableLog;
    return iSize+1;
}
########################rank 7#############################
static unsigned HUF_isError(size_t code) { return ERR_isError(code); }
#define HUF_ABSOLUTEMAX_TABLELOG  16   
#define HUF_MAX_TABLELOG  12           /* max configured tableLog (for static allocation); can be modified up to HUF_ABSOLUTEMAX_TABLELOG */
#define HUF_DEFAULT_TABLELOG  HUF_MAX_TABLELOG   /* tableLog by default, when not specified */
#define HUF_MAX_SYMBOL_VALUE 255
#if (HUF_MAX_TABLELOG > HUF_ABSOLUTEMAX_TABLELOG)
#  error "HUF_MAX_TABLELOG is too large !"
#endif
*  Huff0 : Huffman block decompression
*********************************************************/
typedef struct { BYTE byte; BYTE nbBits; } HUF_DEltX2;   /* single-symbol decoding */
typedef struct { U16 sequence; BYTE nbBits; BYTE length; } HUF_DEltX4;  /* double-symbols decoding */
typedef struct { BYTE symbol; BYTE weight; } sortedSymbol_t;
    Read compact Huffman tree, saved by HUF_writeCTable
    @huffWeight : destination buffer
    @return : size read from `src`
*/
static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
                            U32* nbSymbolsPtr, U32* tableLogPtr,
                            const void* src, size_t srcSize)
{
    U32 weightTotal;
    U32 tableLog;
    const BYTE* ip = (const BYTE*) src;
    size_t iSize;
    size_t oSize;
    U32 n;
    if (!srcSize) return ERROR(srcSize_wrong);
    iSize = ip[0];
    //memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */
    if (iSize >= 128)  /* special header */
    {
        if (iSize >= (242))   /* RLE */
        {
            static int l[14] = { 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 127, 128 };
            oSize = l[iSize-242];
            memset(huffWeight, 1, hwSize);
            iSize = 0;
        }
        else   /* Incompressible */
        {
            oSize = iSize - 127;
            iSize = ((oSize+1)/2);
            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
            if (oSize >= hwSize) return ERROR(corruption_detected);
            ip += 1;
            for (n=0; n<oSize; n+=2)
            {
                huffWeight[n]   = ip[n/2] >> 4;
                huffWeight[n+1] = ip[n/2] & 15;
            }
        }
    }
    else  /* header compressed with FSE (normal case) */
    {
        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
        oSize = FSE_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
        if (FSE_isError(oSize)) return oSize;
    }
    memset(rankStats, 0, (HUF_ABSOLUTEMAX_TABLELOG + 1) * sizeof(U32));
    weightTotal = 0;
    for (n=0; n<oSize; n++)
    {
        if (huffWeight[n] >= HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
        rankStats[huffWeight[n]]++;
        weightTotal += (1 << huffWeight[n]) >> 1;
    }
    if (weightTotal == 0) return ERROR(corruption_detected);
    tableLog = BIT_highbit32(weightTotal) + 1;
    if (tableLog > HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
    {
        U32 total = 1 << tableLog;
        U32 rest = total - weightTotal;
        U32 verif = 1 << BIT_highbit32(rest);
        U32 lastWeight = BIT_highbit32(rest) + 1;
        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
        huffWeight[oSize] = (BYTE)lastWeight;
        rankStats[lastWeight]++;
    }
    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */
    *nbSymbolsPtr = (U32)(oSize+1);
    *tableLogPtr = tableLog;
    return iSize+1;
}
########################rank 8#############################
size_t HUF_readDTableX1_wksp(HUF_DTable* DTable, const void* src, size_t srcSize, void* workSpace, size_t wkspSize)
{
    U32 tableLog = 0;
    U32 nbSymbols = 0;
    size_t iSize;
    void* const dtPtr = DTable + 1;
    HUF_DEltX1* const dt = (HUF_DEltX1*)dtPtr;
    U32* rankVal;
    BYTE* huffWeight;
    size_t spaceUsed32 = 0;
    rankVal = (U32 *)workSpace + spaceUsed32;
    spaceUsed32 += HUF_TABLELOG_ABSOLUTEMAX + 1;
    huffWeight = (BYTE *)((U32 *)workSpace + spaceUsed32);
    spaceUsed32 += HUF_ALIGN(HUF_SYMBOLVALUE_MAX + 1, sizeof(U32)) >> 2;
    if ((spaceUsed32 << 2) > wkspSize) return ERROR(tableLog_tooLarge);
    DEBUG_STATIC_ASSERT(sizeof(DTableDesc) == sizeof(HUF_DTable));
    iSize = HUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX + 1, rankVal, &nbSymbols, &tableLog, src, srcSize);
    if (HUF_isError(iSize)) return iSize;
    {   DTableDesc dtd = HUF_getDTableDesc(DTable);
        if (tableLog > (U32)(dtd.maxTableLog+1)) return ERROR(tableLog_tooLarge);   /* DTable too small, Huffman tree cannot fit in */
        dtd.tableType = 0;
        dtd.tableLog = (BYTE)tableLog;
        memcpy(DTable, &dtd, sizeof(dtd));
    }
    {   U32 n, nextRankStart = 0;
        for (n=1; n<tableLog+1; n++) {
            U32 const current = nextRankStart;
            nextRankStart += (rankVal[n] << (n-1));
            rankVal[n] = current;
    }   }
    {   U32 n;
        for (n=0; n<nbSymbols; n++) {
            U32 const w = huffWeight[n];
            U32 const length = (1 << w) >> 1;
            U32 u;
            HUF_DEltX1 D;
            D.byte = (BYTE)n; D.nbBits = (BYTE)(tableLog + 1 - w);
            for (u = rankVal[w]; u < rankVal[w] + length; u++)
                dt[u] = D;
            rankVal[w] += length;
    }   }
    return iSize;
}
########################rank 9#############################
static BrotliErrorCode ReadSimpleHuffmanSymbols(uint32_t alphabet_size,
                                                BrotliState* s) {
  BrotliBitReader* br = &s->br;
  uint32_t max_bits = Log2Floor(alphabet_size - 1);
  uint32_t i = s->sub_loop_counter;
  uint32_t num_symbols = s->symbol;
  while (i <= num_symbols) {
    uint32_t v;
    if (PREDICT_FALSE(!BrotliSafeReadBits(br, max_bits, &v))) {
      s->sub_loop_counter = i;
      s->substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_READ;
      return BROTLI_NEEDS_MORE_INPUT;
    }
    if (v >= alphabet_size) {
      return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET);
    }
    s->symbols_lists_array[i] = (uint16_t)v;
    BROTLI_LOG_UINT(s->symbols_lists_array[i]);
    ++i;
  }
  for (i = 0; i < num_symbols; ++i) {
    uint32_t k = i + 1;
    for (; k <= num_symbols; ++k) {
      if (s->symbols_lists_array[i] == s->symbols_lists_array[k]) {
        return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME);
      }
    }
  }
  return BROTLI_SUCCESS;
}
########################rank 10#############################
unsigned HUFv05_isError(size_t code) { return ERR_isError(code); }
const char* HUFv05_getErrorName(size_t code) { return ERR_getErrorName(code); }
#define HUFv05_STATIC_ASSERT(c) { enum { HUFv05_static_assert = 1/(int)(!!(c)) }; }   
*  Huff0 : Huffman block decompression
*********************************************************/
typedef struct { BYTE byte; BYTE nbBits; } HUFv05_DEltX2;   /* single-symbol decoding */
typedef struct { U16 sequence; BYTE nbBits; BYTE length; } HUFv05_DEltX4;  /* double-symbols decoding */
typedef struct { BYTE symbol; BYTE weight; } sortedSymbol_t;
    Read compact Huffman tree, saved by HUFv05_writeCTable
    @huffWeight : destination buffer
    @return : size read from `src`
*/
static size_t HUFv05_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
                            U32* nbSymbolsPtr, U32* tableLogPtr,
                            const void* src, size_t srcSize)
{
    U32 weightTotal;
    U32 tableLog;
    const BYTE* ip = (const BYTE*) src;
    size_t iSize;
    size_t oSize;
    U32 n;
    if (!srcSize) return ERROR(srcSize_wrong);
    iSize = ip[0];
    //memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */
    if (iSize >= 128)  { /* special header */
        if (iSize >= (242)) {  /* RLE */
            static int l[14] = { 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 127, 128 };
            oSize = l[iSize-242];
            memset(huffWeight, 1, hwSize);
            iSize = 0;
        }
        else {   /* Incompressible */
            oSize = iSize - 127;
            iSize = ((oSize+1)/2);
            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
            if (oSize >= hwSize) return ERROR(corruption_detected);
            ip += 1;
            for (n=0; n<oSize; n+=2) {
                huffWeight[n]   = ip[n/2] >> 4;
                huffWeight[n+1] = ip[n/2] & 15;
    }   }   }
    else  {   /* header compressed with FSEv05 (normal case) */
        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
        oSize = FSEv05_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
        if (FSEv05_isError(oSize)) return oSize;
    }
    memset(rankStats, 0, (HUFv05_ABSOLUTEMAX_TABLELOG + 1) * sizeof(U32));
    weightTotal = 0;
    for (n=0; n<oSize; n++) {
        if (huffWeight[n] >= HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
        rankStats[huffWeight[n]]++;
        weightTotal += (1 << huffWeight[n]) >> 1;
    }
    if (weightTotal == 0) return ERROR(corruption_detected);
    tableLog = BITv05_highbit32(weightTotal) + 1;
    if (tableLog > HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
    {   /* determine last weight */
        U32 total = 1 << tableLog;
        U32 rest = total - weightTotal;
        U32 verif = 1 << BITv05_highbit32(rest);
        U32 lastWeight = BITv05_highbit32(rest) + 1;
        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
        huffWeight[oSize] = (BYTE)lastWeight;
        rankStats[lastWeight]++;
    }
    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */
    *nbSymbolsPtr = (U32)(oSize+1);
    *tableLogPtr = tableLog;
    return iSize+1;
}
----------------------------QUERY-------------------------------
return pointer to url of lame website
########################rank 1#############################
static void init_timetables( FM_ST *ST , const UINT8 *dttable )
{
	int i,d;
	double rate;
#if 0
	logerror("FM.C: samplerate=%8i chip clock=%8i  freqbase=%f  \n",
			 ST->rate, ST->clock, ST->freqbase );
#endif
	for (d = 0;d <= 3;d++)
	{
		for (i = 0;i <= 31;i++)
		{
			rate = ((double)dttable[d*32 + i]) * SIN_LEN  * ST->freqbase  * (1<<FREQ_SH) / ((double)(1<<20));
			ST->dt_tab[d][i]   = (INT32) rate;
			ST->dt_tab[d+4][i] = -ST->dt_tab[d][i];
#if 0
			logerror("FM.C: DT [%2i %2i] = %8x  \n", d, i, ST->dt_tab[d][i] );
#endif
		}
	}
}
########################rank 2#############################
static void init_timetables(const UINT8 *dttable)
{
	int i,d;
	double rate;
	for (d = 0;d <= 3;d++){
		for (i = 0;i <= 31;i++){
			rate = ((double)dttable[d*32 + i]) * SIN_LEN  * ym2612.OPN.ST.freqbase  * (1<<FREQ_SH) / ((double)(1<<20));
			ym2612.OPN.ST.dt_tab[d][i]   = (INT32) rate;
			ym2612.OPN.ST.dt_tab[d+4][i] = -ym2612.OPN.ST.dt_tab[d][i];
		}
	}
}
########################rank 3#############################
const char *
get_lame_short_version(void)
{
       validation */
#if   LAME_ALPHA_VERSION
    static /*@observer@ */ const char *const str =
        STR(LAME_MAJOR_VERSION) "." STR(LAME_MINOR_VERSION) " (alpha " STR(LAME_PATCH_VERSION) ")";
#elif LAME_BETA_VERSION
    static /*@observer@ */ const char *const str =
        STR(LAME_MAJOR_VERSION) "." STR(LAME_MINOR_VERSION) " (beta " STR(LAME_PATCH_VERSION) ")";
#elif LAME_RELEASE_VERSION && (LAME_PATCH_VERSION > 0)
    static /*@observer@ */ const char *const str =
        STR(LAME_MAJOR_VERSION) "." STR(LAME_MINOR_VERSION) "." STR(LAME_PATCH_VERSION);
#else
    static /*@observer@ */ const char *const str =
        STR(LAME_MAJOR_VERSION) "." STR(LAME_MINOR_VERSION);
#endif
    return str;
}
########################rank 4#############################
static void forward_reorg_layer(const layer l, network_state state)
{
	if (l.reverse) {
		reorg_cpu(state.input, l.w, l.h, l.c, l.batch, l.stride, 1, l.output);
	}
	else {
		reorg_cpu(state.input, l.w, l.h, l.c, l.batch, l.stride, 0, l.output);
	}
}
########################rank 5#############################
int
lame_set_brate( lame_global_flags*  gfp,
                int                 brate )
{
    gfp->brate = brate;
    return 0;
}
########################rank 6#############################
static void freegroup(upb_refcounted *r) {
  mgroup *g = (mgroup*)r;
  upb_inttable_uninit(&g->methods);
#ifdef UPB_USE_JIT_X64
  upb_pbdecoder_freejit(g);
#endif
  upb_gfree(g->bytecode);
  upb_gfree(g);
}
########################rank 7#############################
static void freegroup(upb_refcounted *r) {
  mgroup *g = (mgroup*)r;
  upb_inttable_uninit(&g->methods);
#ifdef UPB_USE_JIT_X64
  upb_pbdecoder_freejit(g);
#endif
  upb_gfree(g->bytecode);
  upb_gfree(g);
}
########################rank 8#############################
static void dtmf_demod(struct demod_state *s, buffer_t buffer, int length)
{
	float s_in;
	int i;
	for (; length > 0; length--, buffer.fbuffer++) {
		s_in = *buffer.fbuffer;
		s->l1.dtmf.energy[0] += fsqr(s_in);
		for (i = 0; i < 8; i++) {
			s->l1.dtmf.tenergy[0][i] += COS(s->l1.dtmf.ph[i]) * s_in;
			s->l1.dtmf.tenergy[0][i+8] += SIN(s->l1.dtmf.ph[i]) * s_in;
			s->l1.dtmf.ph[i] += dtmf_phinc[i];
		}
		if ((s->l1.dtmf.blkcount--) <= 0) {
			s->l1.dtmf.blkcount = BLOCKLEN;
			i = process_block(s);
			if (i != s->l1.dtmf.lastch && i >= 0)
				verbprintf(0, "DTMF: %c\n", dtmf_transl[i]);
			s->l1.dtmf.lastch = i;
		}
	}
}
########################rank 9#############################
void
sPrintPerf(SuperMatrix *L, SuperMatrix *U, mem_usage_t *mem_usage,
           double rpg, double rcond, double *ferr,
           double *berr, char *equed, SuperLUStat_t *stat)
{
    SCformat *Lstore;
    NCformat *Ustore;
    double   *utime;
    flops_t  *ops;
    utime = stat->utime;
    ops   = stat->ops;
    if ( utime[FACT] != 0. )
	printf("Factor flops = %e\tMflops = %8.2f\n", ops[FACT],
	       ops[FACT]*1e-6/utime[FACT]);
    printf("Identify relaxed snodes	= %8.2f\n", utime[RELAX]);
    if ( utime[SOLVE] != 0. )
	printf("Solve flops = %.0f, Mflops = %8.2f\n", ops[SOLVE],
	       ops[SOLVE]*1e-6/utime[SOLVE]);
    Lstore = (SCformat *) L->Store;
    Ustore = (NCformat *) U->Store;
    printf("\tNo of nonzeros in factor L = %d\n", Lstore->nnz);
    printf("\tNo of nonzeros in factor U = %d\n", Ustore->nnz);
    printf("\tNo of nonzeros in L+U = %d\n", Lstore->nnz + Ustore->nnz);
    printf("L\\U MB %.3f\ttotal MB needed %.3f\texpansions %d\n",
	   mem_usage->for_lu/1e6, mem_usage->total_needed/1e6,
	   mem_usage->expansions);
    printf("\tFactor\tMflops\tSolve\tMflops\tEtree\tEquil\tRcond\tRefine\n");
    printf("PERF:%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f%8.2f\n",
	   utime[FACT], ops[FACT]*1e-6/utime[FACT],
	   utime[SOLVE], ops[SOLVE]*1e-6/utime[SOLVE],
	   utime[ETREE], utime[EQUIL], utime[RCOND], utime[REFINE]);
    printf("\tRpg\t\tRcond\t\tFerr\t\tBerr\t\tEquil?\n");
    printf("NUM:\t%e\t%e\t%e\t%e\t%s\n",
	   rpg, rcond, ferr[0], berr[0], equed);
}
########################rank 10#############################
static void
show_select_args(const char *msg, fd_set *source_fds, struct source_info *ifiles, fd_set *sink_fds, struct sink_info *ofiles, bool check)
{
	#ifdef DEBUG
	struct sink_info *ofp;
	struct source_info *ifp;
	int nbits = 0;
	fprintf(stderr, "%s: ", msg);
	for (ifp = ifiles; ifp; ifp = ifp->next)
		if (FD_ISSET(ifp->fd, source_fds)) {
			fprintf(stderr, "%s ", fp_name(ifp));
			nbits++;
		}
	for (ofp = ofiles; ofp; ofp = ofp->next)
		if (FD_ISSET(ofp->fd, sink_fds)) {
			fprintf(stderr, "%s ", fp_name(ofp));
			nbits++;
		}
	fputc('\n', stderr);
	if (check && nbits == 0)
		abort();
	#endif
}
----------------------------QUERY-------------------------------
add the deleted file to log
########################rank 1#############################
DBFHandle SHPAPI_CALL
DBFCreate( const char * pszFilename )
{
    DBFHandle	psDBF;
    FILE	*fp;
    char	*pszFullname, *pszBasename;
    int		i;
    pszBasename = (char *) malloc(strlen(pszFilename)+5);
    strcpy( pszBasename, pszFilename );
    for( i = strlen(pszBasename)-1; 
	 i > 0 && pszBasename[i] != '.' && pszBasename[i] != '/'
	       && pszBasename[i] != '\\';
	 i-- ) {}
    if( pszBasename[i] == '.' )
        pszBasename[i] = '\0';
    pszFullname = (char *) malloc(strlen(pszBasename) + 5);
    sprintf( pszFullname, "%s.dbf", pszBasename );
    free( pszBasename );
    fp = fopen( pszFullname, "wb" );
    if( fp == NULL )
        return( NULL );
    fputc( 0, fp );
    fclose( fp );
    fp = fopen( pszFullname, "rb+" );
    if( fp == NULL )
        return( NULL );
    free( pszFullname );
    psDBF = (DBFHandle) malloc(sizeof(DBFInfo));
    psDBF->fp = fp;
    psDBF->nRecords = 0;
    psDBF->nFields = 0;
    psDBF->nRecordLength = 1;
    psDBF->nHeaderLength = 33;
    psDBF->bUpdated = FALSE;
    psDBF->panFieldOffset = NULL;
    psDBF->panFieldSize = NULL;
    psDBF->panFieldDecimals = NULL;
    psDBF->pachFieldType = NULL;
    psDBF->pszHeader = NULL;
    psDBF->nCurrentRecord = -1;
    psDBF->bCurrentRecordModified = FALSE;
    psDBF->pszCurrentRecord = NULL;
    psDBF->bNoHeader = TRUE;
    return( psDBF );
}
########################rank 2#############################
void *debug_malloc(const size_t size, const char *file, const int line) {
    void *ptr = (malloc)(size);
    printf("%s:%d: malloc(%d)=%p\n", file, line, (int)size, ptr);
    return ptr;
}
########################rank 3#############################
int output_prx(const char *prxfile)
{
	int size;
	unsigned char *data;
	FILE *fp;
	do
	{
		size = calculate_outsize();
		data = (unsigned char *) malloc(size);
		if(data == NULL)
		{
			fprintf(stderr, "Error, couldn't allocate output data\n");
			break;
		}
		memset(data, 0, size);
		output_header(data);
		output_ph(data + g_phbase);
		output_alloc(data + g_allocbase);
		output_sh(data + g_shbase);
		output_relocs(data + g_relocbase);
		output_shstrtab(data + g_shstrbase);
		fp = fopen(prxfile, "wb");
		if(fp != NULL)
		{
			fwrite(data, 1, size, fp);
			fclose(fp);
		}
		else
		{
			fprintf(stderr, "Error, could not open output file %s\n", prxfile);
		}
		free(data);
	}
	while(0);
	return 0;
}
########################rank 4#############################
void *debug_calloc(const size_t num, const size_t size, const char *file, const int line) {
    void *ptr = (calloc)(num, size);
    printf("%s:%d: calloc(%d, %d)=%p\n", file, line, (int)num, (int)size, ptr);
    return ptr;
}
########################rank 5#############################
void
dodiv(n)
register int n;
{
	if (n < 0 || n >= MAXOUT)
		n = 0;		       /* bitbucket */
	if (outfile[n] == NULL) {
		m4temp[UNIQUE] = n + '0';
		if ((outfile[n] = fopen(m4temp, "w")) == NULL)
			oops("%s: cannot divert.", m4temp);
	}
	oindex = n;
	active = outfile[n];
}
########################rank 6#############################
int
benchmark_initbatch(void *tsd)
{
	tsd_t			*ts = (tsd_t *)tsd;
	if (ts->ts_buf == NULL) {
		ts->ts_fd = open(optf, O_RDONLY);
	}
	return (0);
}
########################rank 7#############################
int
d_create_directory(int f, int n)
{
	char	 tocreate[MAXPATHLEN], *bufp;
	size_t  off;
	struct buffer	*bp;
	off = strlcpy(tocreate, curbp->b_fname, sizeof(tocreate));
	if (off >= sizeof(tocreate) - 1)
		return (FALSE);
	if ((bufp = eread("Create directory: ", tocreate,
	    sizeof(tocreate), EFDEF | EFNEW | EFCR)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if (mkdir(tocreate, 0755) == -1) {
		ewprintf("Creating directory: %s, %s", strerror(errno),
		    tocreate);
		return (FALSE);
	}
	bp = dired_(curbp->b_fname);
	return (showbuffer(bp, curwp, WFFULL | WFMODE));
}
########################rank 8#############################
static char *
extendfile(char *file, char *ext)
{
	char *res;
	char *p;
	res = alloc(strlen(file) + strlen(ext) + 1);
	if (res == NULL) {
		abort();
	}
	p = strrchr(file, '.');
	if (p == NULL) {
		p = file + strlen(file);
	}
	(void) strcpy(res, file);
	(void) strcpy(res + (p - file), ext);
	return (res);
}
########################rank 9#############################
static int posixOpen(const char *zFile, int flags, int mode){
  return open(zFile, flags, mode);
}
########################rank 10#############################
OutputFile *OpenOutputFile(const  char *name)
{
   return io_OpenFile(name, READWRITE);
}
----------------------------QUERY-------------------------------
swap bytes between two pointers symmetrically
########################rank 1#############################
DWR_WORD dwr_rng(dwr_rg *in) {
        DWR_WORD *o;
        DWR_WORD out;
        if(in == 0) {
                return 0;
        }
        if(DWR_WORDSIZE != 32) {
                return 0;
        }
        o = in->mill + 1;
        if(in->index >= 100000000) {
                in->index = 0; /* I am considering rekeying here */
        }
        if(in->index % 2 == 0) {
                dwr_belt(in->mill, in->belt);
                in->index++;
                out = o[0];
        } else {
                in->index++;
                out = o[1];
                }
        out = ((out & 0xff0000) >> 8) | ((out & 0xff000000) >> 24) |
              ((out & 0xff00) << 8) | ((out & 0xff) << 24);
        return out;
}
########################rank 2#############################
l_int32
pixCleanupByteProcessing(PIX      *pix,
                         l_uint8 **lineptrs)
{
    PROCNAME("pixCleanupByteProcessing");
    if (!pix)
        return ERROR_INT("pix not defined", procName, 1);
    if (!lineptrs)
        return ERROR_INT("lineptrs not defined", procName, 1);
    pixEndianByteSwap(pix);
    FREE(lineptrs);
    return 0;
}
########################rank 3#############################
static void swap_bytes(unsigned char *a, unsigned char *b) {
    unsigned char t = *a;
    *a = *b;
    *b = t;
}
########################rank 4#############################
static void swap(void *x,void *y,int bytes,int mask)
{
  int i;
  char xi, yi, c, t;
  c = mask;
  for (i = 0;i < bytes;++i) {
    xi = i[(char *) x];
    yi = i[(char *) y];
    t = c & (xi ^ yi);
    xi ^= t;
    yi ^= t;
    i[(char *) x] = xi;
    i[(char *) y] = yi;
  }
}
########################rank 5#############################
static void Float32_To_Int24_DitherClip(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt32 temp;
    while( count-- )
    {
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        double dithered = ((double)*src * (2147483646.0)) + dither;
        PA_CLIP_( dithered, -2147483648., 2147483647.  );
        temp = (PaInt32) dithered;
#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 24);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 8);
#endif
        src += sourceStride;
        dest += destinationStride * 3;
    }
}
########################rank 6#############################
void mpi_swap( mpi *X, mpi *Y )
{
    mpi T;
    memcpy( &T,  X, sizeof( mpi ) );
    memcpy(  X,  Y, sizeof( mpi ) );
    memcpy(  Y, &T, sizeof( mpi ) );
}
########################rank 7#############################
void *md5_read_ctx(const struct md5_ctx *ctx, void *resbuf)
{
  ((md5_uint32 *) resbuf)[0] = SWAP(ctx->A);
  ((md5_uint32 *) resbuf)[1] = SWAP(ctx->B);
  ((md5_uint32 *) resbuf)[2] = SWAP(ctx->C);
  ((md5_uint32 *) resbuf)[3] = SWAP(ctx->D);
  return resbuf;
}
########################rank 8#############################
static void Float32_To_Int24_Dither(
    void *destinationBuffer, signed int destinationStride,
    void *sourceBuffer, signed int sourceStride,
    unsigned int count, struct PaUtilTriangularDitherGenerator *ditherGenerator )
{
    float *src = (float*)sourceBuffer;
    unsigned char *dest = (unsigned char*)destinationBuffer;
    PaInt32 temp;
    while( count-- )
    {
        double dither  = PaUtil_GenerateFloatTriangularDither( ditherGenerator );
        double dithered = ((double)*src * (2147483646.0)) + dither;
        temp = (PaInt32) dithered;
#if defined(PA_LITTLE_ENDIAN)
        dest[0] = (unsigned char)(temp >> 8);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 24);
#elif defined(PA_BIG_ENDIAN)
        dest[0] = (unsigned char)(temp >> 24);
        dest[1] = (unsigned char)(temp >> 16);
        dest[2] = (unsigned char)(temp >> 8);
#endif
        src += sourceStride;
        dest += destinationStride * 3;
    }
}
########################rank 9#############################
static
void
tr_heapsort(const int *ISAd, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(ISAd[SA[m / 2]] < ISAd[SA[m]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { tr_fixdown(ISAd, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); tr_fixdown(ISAd, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    tr_fixdown(ISAd, SA, 0, i);
    SA[i] = t;
  }
}
########################rank 10#############################
static
void
tr_heapsort(const saidx_t *ISAd, saidx_t *SA, saidx_t size) {
  saidx_t i, m;
  saidx_t t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(ISAd[SA[m / 2]] < ISAd[SA[m]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { tr_fixdown(ISAd, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); tr_fixdown(ISAd, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    tr_fixdown(ISAd, SA, 0, i);
    SA[i] = t;
  }
}
----------------------------QUERY-------------------------------
send an event to the object
########################rank 1#############################
static void
transport_send(uint8_t *buf, int len)
{
  agentx_entry.buf = buf;
  agentx_entry.len = len;
  snmp_event_add(agentx_entry.sock, SNMP_EV_WRITE, agentx_write_handler, &agentx_entry);
}
########################rank 2#############################
static void
transport_send(uint8_t *buf, int len)
{
  snmp_entry.buf = buf;
  snmp_entry.len = len;
  snmp_event_add(snmp_entry.sock, SNMP_EV_WRITE, snmp_write_handler, &snmp_entry);
}
########################rank 3#############################
void USBHwSetAddress(U8 bAddr)
{
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
}
########################rank 4#############################
void event_init(void)
{
	ringbuf_init(&events, (uint8_t*) buffer, sizeof(buffer));
	memset(buffer, 0, sizeof(buffer));
}
########################rank 5#############################
bool event_get(event_t *event, uint8_t *data)
{
	bool got_event = true;
	uint16_t e;
	if (!ringbuf_get(&events, &e)) {
		*event = event_none;
		*data = 0;
		got_event = false;
	} else {
		*event = e >> 8;
		*data = e & 0xff;
	}
	return got_event;
}
########################rank 6#############################
void mlt_field_disconnect_service( mlt_field self, mlt_service service )
{
	mlt_service p = mlt_service_producer( service );
	mlt_service c = mlt_service_consumer( service);
	int i;
	switch ( mlt_service_identify(c) )
	{
		case filter_type:
			i = mlt_filter_get_track( MLT_FILTER(c) );
			mlt_service_connect_producer( c, p, i );
			break;
		case transition_type:
			i = mlt_transition_get_a_track ( MLT_TRANSITION(c) );
			mlt_service_connect_producer( c, p, i );
			MLT_TRANSITION(c)->producer = p;
			break;
		case tractor_type:
			self->producer = p;
			mlt_tractor_connect( MLT_TRACTOR(c), p );
		default:
			break;
	}
	mlt_events_fire( mlt_field_properties( self ), "service-changed", NULL );
}
########################rank 7#############################
void ft6x06_Init(uint16_t DeviceAddr)
{  
  uint8_t instance;
  uint8_t empty;
  instance = ft6x06_GetInstance(DeviceAddr);
  if(instance == 0xFF)
  {
    empty = ft6x06_GetInstance(0);
    if(empty < FT6x06_MAX_INSTANCE)
    {
      ft6x06[empty] = DeviceAddr;
      TS_IO_Init(); 
    }
  }
}
########################rank 8#############################
void mlt_consumer_stopped( mlt_consumer self )
{
	mlt_properties_set_int( MLT_CONSUMER_PROPERTIES( self ), "running", 0 );
	mlt_events_fire( MLT_CONSUMER_PROPERTIES( self ), "consumer-stopped", NULL );
	mlt_event_unblock( ( ( consumer_private* ) self->local )->event_listener );
}
########################rank 9#############################
static void
save_ports(void)
{
    char *cat = "Ports (COM & LPT)";
    char temp[512];
    int c, d;
    for (c = 0; c < 2; c++) {
	sprintf(temp, "serial%d_enabled", c + 1);
	if (serial_enabled[c])
		config_delete_var(cat, temp);
	else
		config_set_int(cat, temp, serial_enabled[c]);
    }
    for (c = 0; c < 3; c++) {
	sprintf(temp, "lpt%d_enabled", c + 1);
	d = (c == 0) ? 1 : 0;
	if (lpt_ports[c].enabled == d)
		config_delete_var(cat, temp);
	else
		config_set_int(cat, temp, lpt_ports[c].enabled);
	sprintf(temp, "lpt%d_device", c + 1);
	if (lpt_ports[c].device == 0)
		config_delete_var(cat, temp);
	  else
		config_set_string(cat, temp,
				  (char *) lpt_device_get_internal_name(lpt_ports[c].device));
    }
    delete_section_if_empty(cat);
}
########################rank 10#############################
static void Selections_Init(void) {
	Event_RegisterVoid(&GfxEvents.ContextLost,      NULL, Selections_ContextLost);
	Event_RegisterVoid(&GfxEvents.ContextRecreated, NULL, Selections_ContextRecreated);
}
----------------------------QUERY-------------------------------
set to use system logger
########################rank 1#############################
static void netreceive_notify(t_netreceive *x, int fd)
{
    int i;
    for (i = 0; i < x->x_nconnections; i++)
    {
        if (x->x_connections[i] == fd)
        {
            memmove(x->x_connections+i, x->x_connections+(i+1),
                sizeof(int) * (x->x_nconnections - (i+1)));
            x->x_connections = (int *)t_resizebytes(x->x_connections,
                x->x_nconnections * sizeof(int),
                    (x->x_nconnections-1) * sizeof(int));
            x->x_nconnections--;
        }
    }
    outlet_float(x->x_ns.x_connectout, x->x_nconnections);
}
########################rank 2#############################
static void netreceive_notify(t_netreceive *x, int fd)
{
    int i;
    for (i = 0; i < x->x_nconnections; i++)
    {
        if (x->x_connections[i] == fd)
        {
            memmove(x->x_connections+i, x->x_connections+(i+1),
                sizeof(int) * (x->x_nconnections - (i+1)));
            x->x_connections = (int *)t_resizebytes(x->x_connections,
                x->x_nconnections * sizeof(int),
                    (x->x_nconnections-1) * sizeof(int));
            memmove(x->x_receivers+i, x->x_receivers+(i+1),
                sizeof(t_socketreceiver*) * (x->x_nconnections - (i+1)));
            if(x->x_receivers[i])
                socketreceiver_free(x->x_receivers[i]);
            x->x_receivers[i]=NULL;
            x->x_receivers = (t_socketreceiver **)t_resizebytes(x->x_receivers,
                x->x_nconnections * sizeof(t_socketreceiver*),
                    (x->x_nconnections-1) * sizeof(t_socketreceiver*));
            x->x_nconnections--;
        }
    }
    outlet_float(x->x_ns.x_connectout, x->x_nconnections);
}
########################rank 3#############################
static void netreceive_notify(t_netreceive *x, int fd)
{
    int i;
    for (i = 0; i < x->x_nconnections; i++)
    {
        if (x->x_connections[i] == fd)
        {
            memmove(x->x_connections+i, x->x_connections+(i+1),
                sizeof(int) * (x->x_nconnections - (i+1)));
            x->x_connections = (int *)t_resizebytes(x->x_connections,
                x->x_nconnections * sizeof(int),
                    (x->x_nconnections-1) * sizeof(int));
            if (x->x_receivers[i])
                socketreceiver_free(x->x_receivers[i]);
            memmove(x->x_receivers+i, x->x_receivers+(i+1),
                sizeof(t_socketreceiver*) * (x->x_nconnections - (i+1)));
            x->x_receivers = (t_socketreceiver **)t_resizebytes(x->x_receivers,
                x->x_nconnections * sizeof(t_socketreceiver*),
                    (x->x_nconnections-1) * sizeof(t_socketreceiver*));
            x->x_nconnections--;
        }
    }
    outlet_float(x->x_ns.x_connectout, x->x_nconnections);
}
########################rank 4#############################
static void bios_SysEnqIntRP() { // 02
	SysIntRP[a0] = a1;
	v0 = 0; pc0 = ra;
}
########################rank 5#############################
static void bios_SysDeqIntRP() { // 03
	SysIntRP[a0] = 0;
	v0 = 0; pc0 = ra;
}
########################rank 6#############################
static void err_raise_ext(int errcode)
{
  RaiseException(LJ_EXCODE_MAKE(errcode), 1 , 0, NULL);
}
########################rank 7#############################
l_int32
pixSetColormap(PIX      *pix,
               PIXCMAP  *colormap)
{
    PROCNAME("pixSetColormap");
    if (!pix)
        return ERROR_INT("pix not defined", procName, 1);
    pixDestroyColormap(pix);
    pix->colormap = colormap;
    return 0;
}
########################rank 8#############################
static void err_raise_ext(int errcode)
{
  RaiseException(LJ_EXCODE_MAKE(errcode), 1 , 0, NULL);
}
########################rank 9#############################
void
_icv_close(_iconv_st *st)
{
	if (st == NULL)
		errno = EBADF;
	else
		free(st);
}
########################rank 10#############################
l_int32
l_byteaJoin(L_BYTEA   *ba1,
            L_BYTEA  **pba2)
{
l_uint8  *data2;
size_t    nbytes2;
L_BYTEA  *ba2;
    PROCNAME("l_byteaJoin");
    if (!ba1)
        return ERROR_INT("ba1 not defined", procName, 1);
    if (!pba2)
        return ERROR_INT("&ba2 not defined", procName, 1);
    if ((ba2 = *pba2) == NULL) return 0;
    data2 = l_byteaGetData(ba2, &nbytes2);
    l_byteaAppendData(ba1, data2, nbytes2);
    l_byteaDestroy(pba2);
    return 0;
}
----------------------------QUERY-------------------------------
get number of table rows
########################rank 1#############################
static int Table_X(struct TableWidget* w) { return w->x - 5 - 10; }
static int Table_Y(struct TableWidget* w) { return w->y - 5 - 30; }
static int Table_Width(struct TableWidget* w) {
	return w->blocksPerRow * w->cellSize + 10 + 20; 
}
########################rank 2#############################
static void recomputeColumnsNotIndexed(Index *pIdx){
  Bitmask m = 0;
  int j;
  Table *pTab = pIdx->pTable;
  for(j=pIdx->nColumn-1; j>=0; j--){
    int x = pIdx->aiColumn[j];
    if( x>=0 && (pTab->aCol[x].colFlags & COLFLAG_VIRTUAL)==0 ){
      testcase( x==BMS-1 );
      testcase( x==BMS-2 );
      if( x<BMS-1 ) m |= MASKBIT(x);
    }
  }
  pIdx->colNotIdxed = ~m;
  assert( (pIdx->colNotIdxed>>63)==1 );
}
########################rank 3#############################
static void insertCell(
  MemPage *pPage,   /* Page into which we are copying */
  int i,            /* New cell becomes the i-th cell of the page */
  u8 *pCell,        /* Content of the new cell */
  int sz,           /* Bytes of content in pCell */
  u8 *pTemp,        /* Temp storage space for pCell, if needed */
  Pgno iChild,      /* If non-zero, replace first 4 bytes with this value */
  int *pRC          /* Read and write return code from here */
){
  int idx = 0;      /* Where to write new cell content in data[] */
  int j;            /* Loop counter */
  u8 *data;         /* The content of the whole page */
  u8 *pIns;         /* The point in pPage->aCellIdx[] where no cell inserted */
  assert( *pRC==SQLITE_OK );
  assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );
  assert( MX_CELL(pPage->pBt)<=10921 );
  assert( pPage->nCell<=MX_CELL(pPage->pBt) || CORRUPT_DB );
  assert( pPage->nOverflow<=ArraySize(pPage->apOvfl) );
  assert( ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) );
  assert( sqlite3_mutex_held(pPage->pBt->mutex) );
  ** malformed cell from a leaf page to an interior page, if the cell size
  ** wanted to be less than 4 but got rounded up to 4 on the leaf, then size
  ** might be less than 8 (leaf-size + pointer) on the interior node.  Hence
  ** the term after the || in the following assert(). */
  assert( sz==pPage->xCellSize(pPage, pCell) || (sz==8 && iChild>0) );
  if( pPage->nOverflow || sz+2>pPage->nFree ){
    if( pTemp ){
      memcpy(pTemp, pCell, sz);
      pCell = pTemp;
    }
    if( iChild ){
      put4byte(pCell, iChild);
    }
    j = pPage->nOverflow++;
    ** as a contingency.  In other words, never need more than 3 overflow
    ** slots but 4 are allocated, just to be safe. */
    assert( j < ArraySize(pPage->apOvfl)-1 );
    pPage->apOvfl[j] = pCell;
    pPage->aiOvfl[j] = (u16)i;
    ** sorted order.  This invariants arise because multiple overflows can
    ** only occur when inserting divider cells into the parent page during
    ** balancing, and the dividers are adjacent and sorted.
    */
    assert( j==0 || pPage->aiOvfl[j-1]<(u16)i ); /* Overflows in sorted order */
    assert( j==0 || i==pPage->aiOvfl[j-1]+1 );   /* Overflows are sequential */
  }else{
    int rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc!=SQLITE_OK ){
      *pRC = rc;
      return;
    }
    assert( sqlite3PagerIswriteable(pPage->pDbPage) );
    data = pPage->aData;
    assert( &data[pPage->cellOffset]==pPage->aCellIdx );
    rc = allocateSpace(pPage, sz, &idx);
    if( rc ){ *pRC = rc; return; }
    ** if it returns successfully */
    assert( idx >= 0 );
    assert( idx >= pPage->cellOffset+2*pPage->nCell+2 || CORRUPT_DB );
    assert( idx+sz <= (int)pPage->pBt->usableSize );
    pPage->nFree -= (u16)(2 + sz);
    memcpy(&data[idx], pCell, sz);
    if( iChild ){
      put4byte(&data[idx], iChild);
    }
    pIns = pPage->aCellIdx + i*2;
    memmove(pIns+2, pIns, 2*(pPage->nCell - i));
    put2byte(pIns, idx);
    pPage->nCell++;
    if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;
    assert( get2byte(&data[pPage->hdrOffset+3])==pPage->nCell );
#ifndef SQLITE_OMIT_AUTOVACUUM
    if( pPage->pBt->autoVacuum ){
      ** the entry for the overflow page into the pointer map.
      */
      ptrmapPutOvflPtr(pPage, pCell, pRC);
    }
#endif
  }
}
########################rank 4#############################
int detect_settings(unsigned char *httpd, size_t httpd_size)
{
	int retval = 0;
	if(parse_elf_header(httpd, httpd_size))
	{
		if(find_websRomPageIndex((char *) httpd, httpd_size))
		{
			if(!are_entry_offsets_valid(httpd, httpd_size))
			{
				globals.use_new_format = 1;
			}
			retval = 1;
		}
		else
		{
			fprintf(stderr, "Failed to locate websRomPageIndex!\n");
		}
	}
	else
	{
		fprintf(stderr, "Failed to parse ELF header!\n");
	}
	return retval;
}
########################rank 5#############################
PIXCMAP *
pixcmapGrayToColor(l_uint32  color)
{
l_int32   i, rval, gval, bval;
PIXCMAP  *cmap;
    extractRGBValues(color, &rval, &gval, &bval);
    cmap = pixcmapCreate(8);
    for (i = 0; i < 256; i++) {
        pixcmapAddColor(cmap, rval + (i * (255 - rval)) / 255,
                        gval + (i * (255 - gval)) / 255,
                        bval + (i * (255 - bval)) / 255);
    }
    return cmap;
}
########################rank 6#############################
static size_t
calculate_max_width(const column_t *col, size_t len, size_t max_line_width)
{
	if(col->info.cropping == CT_NONE)
	{
		const size_t left_bound = (col->info.align == AT_LEFT) ? col->start : 0;
		const size_t max_col_width = max_line_width - left_bound;
		return MIN(len, max_col_width);
	}
	else
	{
		return col->print_width;
	}
}
########################rank 7#############################
static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes){
  int rc;
  MemPage *pPage;
  assert( cursorOwnsBtShared(pCur) );
  assert( pRes!=0 );
  assert( *pRes==0 );
  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
  assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
  assert( pCur->info.nSize==0 );
  if( pCur->eState!=CURSOR_VALID ){
    rc = restoreCursorPosition(pCur);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( CURSOR_INVALID==pCur->eState ){
      *pRes = 1;
      return SQLITE_OK;
    }
    if( pCur->skipNext ){
      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
      pCur->eState = CURSOR_VALID;
      if( pCur->skipNext<0 ){
        pCur->skipNext = 0;
        return SQLITE_OK;
      }
      pCur->skipNext = 0;
    }
  }
  pPage = pCur->apPage[pCur->iPage];
  assert( pPage->isInit );
  if( !pPage->leaf ){
    int idx = pCur->aiIdx[pCur->iPage];
    rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));
    if( rc ) return rc;
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->aiIdx[pCur->iPage]==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = CURSOR_INVALID;
        *pRes = 1;
        return SQLITE_OK;
      }
      moveToParent(pCur);
    }
    assert( pCur->info.nSize==0 );
    assert( (pCur->curFlags & (BTCF_ValidNKey|BTCF_ValidOvfl))==0 );
    pCur->aiIdx[pCur->iPage]--;
    pPage = pCur->apPage[pCur->iPage];
    if( pPage->intKey && !pPage->leaf ){
      rc = sqlite3BtreePrevious(pCur, pRes);
    }else{
      rc = SQLITE_OK;
    }
  }
  return rc;
}
########################rank 8#############################
static int f_zero(ACMStream *acm, unsigned ind, unsigned col)
{
	unsigned i;
	for (i = 0; i < acm->info.acm_rows; i++)
		set_pos(acm, i, col, 0);
	return 1;
}
########################rank 9#############################
static int f_zero(ACMStream *acm, unsigned ind, unsigned col)
{
	unsigned i;
	for (i = 0; i < acm->info.acm_rows; i++)
		set_pos(acm, i, col, 0);
	return 1;
}
########################rank 10#############################
static int autoIncBegin(
  Parse *pParse,      /* Parsing context */
  int iDb,            /* Index of the database holding pTab */
  Table *pTab         /* The table we are writing to */
){
  int memId = 0;      /* Register holding maximum rowid */
  if( (pTab->tabFlags & TF_Autoincrement)!=0
   && (pParse->db->flags & SQLITE_Vacuum)==0
  ){
    Parse *pToplevel = sqlite3ParseToplevel(pParse);
    AutoincInfo *pInfo;
    pInfo = pToplevel->pAinc;
    while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }
    if( pInfo==0 ){
      pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));
      if( pInfo==0 ) return 0;
      pInfo->pNext = pToplevel->pAinc;
      pToplevel->pAinc = pInfo;
      pInfo->pTab = pTab;
      pInfo->iDb = iDb;
      pToplevel->nMem++;                  /* Register to hold name of table */
      pInfo->regCtr = ++pToplevel->nMem;  /* Max rowid register */
      pToplevel->nMem++;                  /* Rowid in sqlite_sequence */
    }
    memId = pInfo->regCtr;
  }
  return memId;
}
----------------------------QUERY-------------------------------
generate random message of random length
########################rank 1#############################
int32 matrixX509ValidateCert(psPool_t *pool, sslRsaCert_t *subjectCert, 
						   sslRsaCert_t *issuerCert, int32 *valid)
{
	if (matrixX509ValidateCertInternal(pool, subjectCert, issuerCert, 0) < 0) {
		*valid = -1;
		return -1;
	}
	*valid = subjectCert->valid;
	return 0;
}
########################rank 2#############################
unsigned int utl_random(RND_CTX * rndContext)
{
  unsigned int xh, xl;
  xh = rndContext->x >> 16, xl = rndContext->x & 65535;
  rndContext->x = rndContext->x * rndContext->a + rndContext->c;
  rndContext->c =
    xh * rndContext->ah + ((xh * rndContext->al) >> 16) +
    ((xl * rndContext->ah) >> 16);
  if (xl * rndContext->al >= (~rndContext->c + 1))
    rndContext->c++;
  return (rndContext->x);
}
########################rank 3#############################
static void small_random(small *g)
{
  int i;
  for (i = 0;i < p;++i) {
    crypto_uint32 r = small_random32();
    g[i] = (small) (((1073741823 & r) * 3) >> 30) - 1;
  }
}
########################rank 4#############################
int
encrypt(char *block, int flag)
{
	return __crypt_encrypt(block, flag);
}
########################rank 5#############################
static void oversamp_ann_circle(double r, double *r_in2, double *r_out2)
{
   *r_in2 = r - 0.7072;
   *r_in2 = (*r_in2 > 0.0) ? (*r_in2)*(*r_in2) : 0.0;
   *r_out2 = r + 0.7072;
   *r_out2 = (*r_out2) * (*r_out2);
}
########################rank 6#############################
uint64_t twister_genrand64_int64(void)
{
	int i;
	uint64_t x;
	static uint64_t mag01[2]={0ULL, MATRIX_A};
	if (mti >= NN) { /* generate NN words at one time */
		if (mti == NN+1)
			twister_init_genrand64(5489ULL);
		for (i=0;i<NN-MM;i++) {
			x = (mt[i]&UM)|(mt[i+1]&LM);
			mt[i] = mt[i+MM] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
		}
		for (;i<NN-1;i++) {
			x = (mt[i]&UM)|(mt[i+1]&LM);
			mt[i] = mt[i+(MM-NN)] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
		}
		x = (mt[NN-1]&UM)|(mt[0]&LM);
		mt[NN-1] = mt[MM-1] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
		mti = 0;
	}
	x = mt[mti++];
	x ^= (x >> 29) & 0x5555555555555555ULL;
	x ^= (x << 17) & 0x71D67FFFEDA60000ULL;
	x ^= (x << 37) & 0xFFF7EEE000000000ULL;
	x ^= (x >> 43);
	return x;
}
########################rank 7#############################
static void _fillcharbuf(char* buffer, int size) {
    for (int i = 0; i < size; i++) {
        int n = rand() % 26;
        buffer[i] = 'a' + n;
    }
}
########################rank 8#############################
void tinymt64_init(tinymt64_t * random, uint64_t seed) {
    random->status[0] = seed ^ ((uint64_t)random->mat1 << 32);
    random->status[1] = random->mat2 ^ random->tmat;
    for (int i = 1; i < MIN_LOOP; i++) {
	random->status[i & 1] ^= i + UINT64_C(6364136223846793005)
	    * (random->status[(i - 1) & 1]
	       ^ (random->status[(i - 1) & 1] >> 62));
    }
    period_certification(random);
}
########################rank 9#############################
void tinymt64_init_by_array(tinymt64_t * random, const uint64_t init_key[],
			    int key_length) {
    const int lag = 1;
    const int mid = 1;
    const int size = 4;
    int i, j;
    int count;
    uint64_t r;
    uint64_t st[4];
    st[0] = 0;
    st[1] = random->mat1;
    st[2] = random->mat2;
    st[3] = random->tmat;
    if (key_length + 1 > MIN_LOOP) {
	count = key_length + 1;
    } else {
	count = MIN_LOOP;
    }
    r = ini_func1(st[0] ^ st[mid % size]
		  ^ st[(size - 1) % size]);
    st[mid % size] += r;
    r += key_length;
    st[(mid + lag) % size] += r;
    st[0] = r;
    count--;
    for (i = 1, j = 0; (j < count) && (j < key_length); j++) {
	r = ini_func1(st[i] ^ st[(i + mid) % size] ^ st[(i + size - 1) % size]);
	st[(i + mid) % size] += r;
	r += init_key[j] + i;
	st[(i + mid + lag) % size] += r;
	st[i] = r;
	i = (i + 1) % size;
    }
    for (; j < count; j++) {
	r = ini_func1(st[i] ^ st[(i + mid) % size] ^ st[(i + size - 1) % size]);
	st[(i + mid) % size] += r;
	r += i;
	st[(i + mid + lag) % size] += r;
	st[i] = r;
	i = (i + 1) % size;
    }
    for (j = 0; j < size; j++) {
	r = ini_func2(st[i] + st[(i + mid) % size] + st[(i + size - 1) % size]);
	st[(i + mid) % size] ^= r;
	r -= i;
	st[(i + mid + lag) % size] ^= r;
	st[i] = r;
	i = (i + 1) % size;
    }
    random->status[0] = st[0] ^ st[1];
    random->status[1] = st[2] ^ st[3];
    period_certification(random);
}
########################rank 10#############################
const char *random_device_mac(void)
{
    const char key[] = "0123456789abcdef";
    static char mac[18];
    int i;
    srand(getpid());
    for (i = 0; i < sizeof(mac) - 1; ++i) {
        if ((i + 1) % 3 == 0) {
            mac[i] = ':';
            continue;
        }
#ifdef WIN32
#define random() rand()
#endif
        mac[i] = key[random() % sizeof(key)];
#ifdef WIN32
#undef random()
#endif
    }
    mac[sizeof(mac) - 1] = '\0';
    return mac;
}
----------------------------QUERY-------------------------------
Doubles allocated size of a pointer
########################rank 1#############################
static Header *morecore(unsigned nu)
{
    char *cp;
    Header *up;
    if(nu < NALLOC)
        nu = NALLOC;
    cp = sbrk(nu * sizeof(Header));
    printf("morecore: cp 0x%x, size %d\n",cp,nu * sizeof(Header));
    if(cp == (char *)-1)    /* no space at all*/
        return NULL;
    up = (Header *)cp;
    up->s.size = nu;
    kr_free((void *)(up+1));
    return freep;
}
########################rank 2#############################
MONGO_EXPORT bson_iterator* bson_iterator_alloc( void ) {
    return ( bson_iterator* )bson_malloc( sizeof( bson_iterator ) );
}
########################rank 3#############################
size_t get_used_size(void *mem_pool)
{
#if TLSF_STATISTIC
    return ((tlsf_t *) mem_pool)->used_size;
#else
    return 0;
#endif
}
########################rank 4#############################
size_t get_used_size(void *mem_pool)
{
#if TLSF_STATISTIC
    return ((tlsf_t *) mem_pool)->used_size;
#else
    return 0;
#endif
}
########################rank 5#############################
int memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
    memset( &heap, 0, sizeof(buffer_alloc_ctx) );
    memset( buf, 0, len );
#if defined(POLARSSL_THREADING_C)
    polarssl_mutex_init( &heap.mutex );
    platform_set_malloc_free( buffer_alloc_malloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    platform_set_malloc_free( buffer_alloc_malloc, buffer_alloc_free );
#endif
    if( (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE )
    {
        len -= POLARSSL_MEMORY_ALIGN_MULTIPLE
             - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
        buf += POLARSSL_MEMORY_ALIGN_MULTIPLE
             - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
    }
    heap.buf = buf;
    heap.len = len;
    heap.first = (memory_header *) buf;
    heap.first->size = len - sizeof(memory_header);
    heap.first->magic1 = MAGIC1;
    heap.first->magic2 = MAGIC2;
    heap.first_free = heap.first;
    return( 0 );
}
########################rank 6#############################
static inline void *realloc_it(void *ptrmem, size_t size) {
  void *p = realloc(ptrmem, size);
  if (!p) {
    free(ptrmem);
    fprintf(stderr, "realloc(): errno=%d\n", errno);
  }
  return p;
}
########################rank 7#############################
static
void*  ft_realloc( FT_Memory memory,
				   long cur_size,
				   long new_size,
				   void*      block ) {
	FT_UNUSED( memory );
	FT_UNUSED( cur_size );
	return realloc( block, new_size );
}
########################rank 8#############################
static void* SHPAllocBuffer(unsigned char** pBuffer, int nSize)
{
    unsigned char* pRet;
    if( pBuffer == NULL )
        return calloc(1, nSize);
    pRet = *pBuffer;
    if( pRet == NULL )
        return NULL;
    (*pBuffer) += nSize;
    return pRet;
}
########################rank 9#############################
static inline void *realloc_it(void *ptrmem, size_t size) {
	void *p = realloc(ptrmem, size);
	if (!p)  {
		free (ptrmem);
		fprintf(stderr, "realloc(): errno=%d\n", errno);
	}
	return p;
}
########################rank 10#############################
void *tlsf_realloc(void *ptr, size_t size)
{
    void *ret;
#if USE_MMAP || USE_SBRK
	if (!mp) {
		return tlsf_malloc(size);
	}
#endif
    TLSF_ACQUIRE_LOCK(&((tlsf_t *)mp)->lock);
    ret = realloc_ex(ptr, size, mp);
    TLSF_RELEASE_LOCK(&((tlsf_t *)mp)->lock);
    return ret;
}
----------------------------QUERY-------------------------------
save xml tree to file descriptor
########################rank 1#############################
static void AU_FreeDownload( filedownload_t *fd ) {
	AU_MemFree( fd->url );
	AU_MemFree( fd->filepath );
	AU_MemFree( fd->temppath );
	AU_MemFree( fd->writepath );
	AU_MemFree( fd );
}
########################rank 2#############################
fsHandle_t *FS_HandleForFile(const char *path, fileHandle_t *f)
{
  int i;
  fsHandle_t *handle;
  handle = fs_handles;
  for (i = 0; i < MAX_HANDLES; i++, handle++) {
    if (handle->file == NULL) {
      Q_strlcpy(handle->name, path, sizeof(handle->name));
      *f = i + 1;
      return handle;
    }
  }
  Com_Error(ERR_DROP, "FS_HandleForFile: none free");
  return NULL;
}
########################rank 3#############################
static void zlog_file_del(zlog_file_t * a_file)
{
	zc_debug("del onefile[%p]", a_file);
	zc_debug("a_file->path[%s]", a_file->path);
	free(a_file);
}
########################rank 4#############################
int parse_uri(char *uri, char *filename, char *cgiargs) 
{
    char *ptr;
    if (!strstr(uri, "cgi-bin")) {   //line:netp:parseuri:isstatic
	strcpy(cgiargs, "");                             //line:netp:parseuri:clearcgi
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert1
	strcat(filename, uri);                           //line:netp:parseuri:endconvert1
	if (uri[strlen(uri)-1] == '/')                   //line:netp:parseuri:slashcheck
	    strcat(filename, "home.html");               //line:netp:parseuri:appenddefault
	return 1;
    }
    else {  /* Dynamic content */                        //line:netp:parseuri:isdynamic
	ptr = index(uri, '?');                           //line:netp:parseuri:beginextract
	if (ptr) {
	    strcpy(cgiargs, ptr+1);
	    *ptr = '\0';
	}
	else 
	    strcpy(cgiargs, "");                         //line:netp:parseuri:endextract
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert2
	strcat(filename, uri);                           //line:netp:parseuri:endconvert2
	return 0;
    }
}
########################rank 5#############################
int parse_uri(char *uri, char *filename, char *cgiargs) 
{
    char *ptr;
    if (!strstr(uri, "cgi-bin")) {   //line:netp:parseuri:isstatic
	strcpy(cgiargs, "");                             //line:netp:parseuri:clearcgi
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert1
	strcat(filename, uri);                           //line:netp:parseuri:endconvert1
	if (uri[strlen(uri)-1] == '/')                   //line:netp:parseuri:slashcheck
	    strcat(filename, "home.html");               //line:netp:parseuri:appenddefault
	return 1;
    }
    else {  /* Dynamic content */                        //line:netp:parseuri:isdynamic
	ptr = index(uri, '?');                           //line:netp:parseuri:beginextract
	if (ptr) {
	    strcpy(cgiargs, ptr+1);
	    *ptr = '\0';
	}
	else 
	    strcpy(cgiargs, "");                         //line:netp:parseuri:endextract
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert2
	strcat(filename, uri);                           //line:netp:parseuri:endconvert2
	return 0;
    }
}
########################rank 6#############################
int parse_uri(char *uri, char *filename, char *cgiargs) 
{
    char *ptr;
    if (!strstr(uri, "cgi-bin")) {   //line:netp:parseuri:isstatic
	strcpy(cgiargs, "");                             //line:netp:parseuri:clearcgi
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert1
	strcat(filename, uri);                           //line:netp:parseuri:endconvert1
	if (uri[strlen(uri)-1] == '/')                   //line:netp:parseuri:slashcheck
	    strcat(filename, "home.html");               //line:netp:parseuri:appenddefault
	return 1;
    }
    else {  /* Dynamic content */                        //line:netp:parseuri:isdynamic
	ptr = index(uri, '?');                           //line:netp:parseuri:beginextract
	if (ptr) {
	    strcpy(cgiargs, ptr+1);
	    *ptr = '\0';
	}
	else 
	    strcpy(cgiargs, "");                         //line:netp:parseuri:endextract
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert2
	strcat(filename, uri);                           //line:netp:parseuri:endconvert2
	return 0;
    }
}
########################rank 7#############################
static MARK	undocurs;	
static long	oldnlines;
static long	oldlnum[MAXBLKS];
 * It defines the state that undo() will reset the file to.
 */
void beforedo(forundo)
	int		forundo;	/* boolean: is this for an undo? */
{
	int		i;
	long	l;
	if (b4cnt++ > 0)
	{
		return;
	}
	blksync();
#ifndef NO_RECYCLE
	garbage();
#endif
	lseek(tmpfd, 0L, 0);
	if (write(tmpfd, hdr.c, (unsigned)BLKSIZE) != BLKSIZE)
	{
		msg("Trouble writing header to tmp file ");
	}
	if (forundo)
	{
		for (i = 0; i < MAXBLKS; i++)
		{
			l = lnum[i];
			lnum[i] = oldlnum[i];
			oldlnum[i] = l;
		}
		l = nlines;
		nlines = oldnlines;
		oldnlines = l;
	}
	else
	{
		for (i = 0; i < MAXBLKS; i++)
		{
			oldlnum[i] = lnum[i];
		}
		oldnlines = nlines;
	}
	undocurs = cursor;
}
########################rank 8#############################
int parse_uri(char *uri, char *filename, char *cgiargs) 
{
    char *ptr;
    if (!strstr(uri, "cgi-bin")) {   //line:netp:parseuri:isstatic
	strcpy(cgiargs, "");                             //line:netp:parseuri:clearcgi
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert1
	strcat(filename, uri);                           //line:netp:parseuri:endconvert1
	if (uri[strlen(uri)-1] == '/')                   //line:netp:parseuri:slashcheck
	    strcat(filename, "home.html");               //line:netp:parseuri:appenddefault
	return 1;
    }
    else {  /* Dynamic content */                        //line:netp:parseuri:isdynamic
	ptr = index(uri, '?');                           //line:netp:parseuri:beginextract
	if (ptr) {
	    strcpy(cgiargs, ptr+1);
	    *ptr = '\0';
	}
	else 
	    strcpy(cgiargs, "");                         //line:netp:parseuri:endextract
	strcpy(filename, ".");                           //line:netp:parseuri:beginconvert2
	strcat(filename, uri);                           //line:netp:parseuri:endconvert2
	return 0;
    }
}
########################rank 9#############################
struct list *rmsummary_parse_file_multiple(const char *filename)
{
	FILE *stream;
	stream = fopen(filename, "r");
	if(!stream)
	{
		debug(D_NOTICE, "Cannot open resources summary file: %s : %s\n", filename, strerror(errno));
		return NULL;
	}
	struct jx_parser *p = jx_parser_create(0);
	jx_parser_read_stream(p, stream);
	struct list      *lst = list_create();
	struct rmsummary *s;
	do
	{
		struct jx *j = jx_parser_yield(p);
		if(!j)
			break;
		s = json_to_rmsummary(j);
		jx_delete(j);
		if(s)
			list_push_tail(lst, s);
	} while(s);
	fclose(stream);
	jx_parser_delete(p);
	return lst;
}
########################rank 10#############################
void EntryList_Load(struct EntryList* list, EntryList_Filter filter) {
	String entry; char entryBuffer[768];
	String path;  char pathBuffer[FILENAME_SIZE];
	String key, value;
	cc_uint8 buffer[2048];
	struct Stream stream, buffered;
	cc_result res;
	String_InitArray(path, pathBuffer);
	String_AppendConst(&path, list->path);
	res = Stream_OpenFile(&stream, &path);
	if (res == ReturnCode_FileNotFound) return;
	if (res) { Logger_Warn2(res, "opening", &path); return; }
	Stream_ReadonlyBuffered(&buffered, &stream, buffer, sizeof(buffer));
	String_InitArray(entry, entryBuffer);
	for (;;) {
		res = Stream_ReadLine(&buffered, &entry);
		if (res == ERR_END_OF_STREAM) break;
		if (res) { Logger_Warn2(res, "reading from", &path); break; }
		String_UNSAFE_TrimStart(&entry);
		String_UNSAFE_TrimEnd(&entry);
		if (!entry.length) continue;
		if (filter && !filter(&entry)) continue;
		if (entry.length > STRINGSBUFFER_LEN_MASK) {
			entry.length = 0;
			String_Format1(&entry, "Skipping extremely long line in %c, file may have been corrupted", list->path);
			Logger_WarnFunc(&entry); continue;
		}
		String_UNSAFE_Separate(&entry, list->separator, &key, &value);
		EntryList_Set(list, &key, &value);
	}
	res = stream.Close(&stream);
	if (res) { Logger_Warn2(res, "closing", &path); }
}
----------------------------QUERY-------------------------------
find last lump between start and end
########################rank 1#############################
lumpinfo_t *lumpinfo; // location of each lump on disk
int numlumps;
wadinfo_t header;
FILE *wadhandle;
void W_OpenWad(char *filename)
{
  lumpinfo_t *lump_p;
  unsigned i;
  int length;
  //
  // open the file and add to directory
  //
  wadhandle = SafeOpenRead(filename);
  SafeRead(wadhandle, &header, sizeof(header));
  if (strncmp(header.identification, "WAD2", 4))
    Error("Wad file %s doesn't have WAD2 id\n", filename);
  header.numlumps = LittleLong(header.numlumps);
  header.infotableofs = LittleLong(header.infotableofs);
  numlumps = header.numlumps;
  length = numlumps * sizeof(lumpinfo_t);
  lumpinfo = malloc(length);
  lump_p = lumpinfo;
  fseek(wadhandle, header.infotableofs, SEEK_SET);
  SafeRead(wadhandle, lumpinfo, length);
  //
  // Fill in lumpinfo
  //
  for (i = 0; i < numlumps; i++, lump_p++) {
    lump_p->filepos = LittleLong(lump_p->filepos);
    lump_p->size = LittleLong(lump_p->size);
  }
}
########################rank 2#############################
void Mod_LoadRighting(lump_t *l)
{
	if (!l->filelen)
	{
		loadmodel->lightdata = NULL;
		return;
	}
	loadmodel->lightdata = Hunk_Alloc(l->filelen);
	memcpy(loadmodel->lightdata, mod_base + l->fileofs, l->filelen);
}
########################rank 3#############################
int
ffropen(const char *fn, struct buffer *bp)
{
  // On Mona, we can't assume fopen succeed on directory.
#ifdef MONA
  if (fisdir(fn) == TRUE) {
		return (FIODIR);
  }
	if ((ffp = fopen(fn, "r")) == NULL) {
		if (errno == ENOENT) {
			return (FIOFNF);
        }
		return (FIOERR);
	}
	ffstat(bp);
	return (FIOSUC);
#else
	if ((ffp = fopen(fn, "r")) == NULL) {
		if (errno == ENOENT)
			return (FIOFNF);
		return (FIOERR);
	}
	if (fisdir(fn) == TRUE)
		return (FIODIR);
	ffstat(bp);
	return (FIOSUC);
#endif
}
########################rank 4#############################
int binbuf_read_via_path(t_binbuf *b, char *filename, char *dirname,
    int crflag)
{
    int filedesc;
    char buf[MAXPDSTRING], *bufptr;
    if ((filedesc = open_via_path(
        dirname, filename, "", buf, &bufptr, MAXPDSTRING, 0)) < 0)
    {
        error("%s: can't open", filename);
        return (1);
    }
    else close (filedesc);
    if (binbuf_read(b, bufptr, buf, crflag))
        return (1);
    else return (0);
}
########################rank 5#############################
int binbuf_read_via_path(t_binbuf *b, const char *filename, const char *dirname,
    int crflag)
{
    int filedesc;
    char buf[MAXPDSTRING], *bufptr;
    if ((filedesc = open_via_path(
        dirname, filename, "", buf, &bufptr, MAXPDSTRING, 0)) < 0)
    {
        error("%s: can't open", filename);
        return (1);
    }
    else close (filedesc);
    if (binbuf_read(b, bufptr, buf, crflag))
        return (1);
    else return (0);
}
########################rank 6#############################
int xmkstemp(char *template)
{
	int fd;
	fd = mkstemp(template);
	if (fd < 0)
		die("Unable to create temporary file");
	return fd;
}
########################rank 7#############################
void Mod_LoadVisibility(lump_t *l)
{
  int i;
  if (!l->filelen) {
    loadmodel->vis = NULL;
    return;
  }
  loadmodel->vis = Hunk_Alloc(l->filelen);
  memcpy(loadmodel->vis, mod_base + l->fileofs, l->filelen);
  loadmodel->vis->numclusters = LittleLong(loadmodel->vis->numclusters);
  for (i = 0; i < loadmodel->vis->numclusters; i++) {
    loadmodel->vis->bitofs[i][0] = LittleLong(loadmodel->vis->bitofs[i][0]);
    loadmodel->vis->bitofs[i][1] = LittleLong(loadmodel->vis->bitofs[i][1]);
  }
}
########################rank 8#############################
void Mod_LoadVisibility(lump_t *l)
{
	int		i;
	if (!l->filelen)
	{
		loadmodel->vis = NULL;
		return;
	}
	loadmodel->vis = Hunk_Alloc(l->filelen);
	memcpy(loadmodel->vis, mod_base + l->fileofs, l->filelen);
	loadmodel->vis->numclusters = LittleLong(loadmodel->vis->numclusters);
	for (i = 0; i < loadmodel->vis->numclusters; i++)
	{
		loadmodel->vis->bitofs[i][0] = LittleLong(loadmodel->vis->bitofs[i][0]);
		loadmodel->vis->bitofs[i][1] = LittleLong(loadmodel->vis->bitofs[i][1]);
	}
}
########################rank 9#############################
int
changedir(int f, int n)
{
	char	bufc[NFILEN], *bufp;
	(void)strlcpy(bufc, mgcwd, sizeof(bufc));
	if ((bufp = eread("Change default directory: ", bufc, NFILEN,
	    EFDEF | EFNEW | EFCR | EFFILE)) == NULL)
		return (ABORT);
	else if (bufp[0] == '\0')
		return (FALSE);
	if (chdir(bufc) == -1) {
		ewprintf("Can't change dir to %s", bufc);
		return (FALSE);
	}
	if ((bufp = getcwd(mgcwd, sizeof(mgcwd))) == NULL)
		panic("Can't get current directory!");
	if (mgcwd[strlen(mgcwd) - 1] != '/')
		(void)strlcat(mgcwd, "/", sizeof(mgcwd));
	ewprintf("Current directory is now %s", bufp);
	return (TRUE);
}
########################rank 10#############################
static char *
l_genDescrString(const char  *filein,
                 l_int32      ifunc,
                 l_int32      itype)
{
char   buf[256];
char  *tail;
    PROCNAME("l_genDescrString");
    if (!filein)
        return (char *)ERROR_PTR("filein not defined", procName, NULL);
    splitPathAtDirectory(filein, NULL, &tail);
    snprintf(buf, sizeof(buf), " *     %-2d       %-10s    %-14s   %s",
             ifunc, l_assoc[itype].type, l_assoc[itype].reader, tail);
    LEPT_FREE(tail);
    return stringNew(buf);
}
----------------------------QUERY-------------------------------
get size of ECC key
########################rank 1#############################
static void *searchHashTable(HashTable *hashtable, void *value, unsigned int hashValue)
{
  unsigned int 
    position = hashValue % hashtable->tableSize;
  HashElem 
    *elem, 
    *result = (HashElem*)NULL; 
  for(elem = hashtable->table[position]; 
      elem; 
      elem = elem->next)
    {
      if(elem->fullKey  == hashValue && 
	 hashtable->equalFunction(hashtable, elem->value, value))
	{
	  result = elem->value; 
	  break;
	}
    }
  return result;
}
########################rank 2#############################
BINN_PRIVATE BOOL binn_object_set_raw(binn *item, char *key, int type, void *pvalue, int size) {
  unsigned char *p, len;
  int int32;
  if ((item == NULL) || (item->type != BINN_OBJECT) || (item->writable == FALSE)) return FALSE;
  if (key == NULL) return FALSE;
  int32 = strlen(key);
  if (int32 > 255) return FALSE;
  // is the key already in it?
  p = SearchForKey(item->pbuf, MAX_BINN_HEADER, item->used_size, item->count, key);
  if (p) return FALSE;
  // start adding it
  if (CheckAllocation(item, 1 + int32) == FALSE) return FALSE;  // bytes used for the key size and the key itself.
  p = ((unsigned char *) item->pbuf) + item->used_size;
  len = int32;
  *p = len;
  p++;
  memcpy(p, key, int32);
  int32++;  // now contains the strlen + 1 byte for the len
  item->used_size += int32;
  if (AddValue(item, type, pvalue, size) == FALSE) {
    item->used_size -= int32;
    return FALSE;
  }
  item->count++;
  return TRUE;
}
########################rank 3#############################
static void *getCurrentValueFromHashTableIterator(HashTableIterator *hashTableIterator)
{  
  return ((hashTableIterator->hashElem) 
	  ?  hashTableIterator->hashElem->value
	  : NULL);
}
########################rank 4#############################
const void *hashMapGet(HashMap *map, const char key[]) {
  HashMapEntry *e;
  uint32_t      hash  = doHash(key);
  size_t        index = indexFor(hash, map->capacity);
  for (e = map->table[index]; e != NULL; e = e->next) {
    if (isHit(e, key, hash))
      return e->value;
  }
  return NULL;
}
########################rank 5#############################
ion_status_t
oadict_get(
	ion_dictionary_t	*dictionary,
	ion_key_t			key,
	ion_value_t			value
) {
	return oah_get((ion_hashmap_t *) dictionary->instance, key, value);
}
########################rank 6#############################
int intmap_elem_get_key(map_elem_t *elem)
{
	return elem->key;
}
########################rank 7#############################
static void c_hash_size(struct VM *vm, mrbc_value v[], int argc)
{
  int n = mrbc_hash_size(v);
  SET_INT_RETURN(n);
}
########################rank 8#############################
static int
hash_val(char *name)
{
	unsigned char *name_u = (unsigned char *)name;
	unsigned char v;
	for(v = 0; *name_u; name_u++)
		v += *name_u;
	return (v%NUM_HASH_BUCKET);
}
########################rank 9#############################
val_t v7_array_get(struct v7 *v7, val_t arr, unsigned long index) {
  return v7_array_get2(v7, arr, index, NULL);
}
########################rank 10#############################
int iniparser_getboolean(const dictionary * d, const char * key, int notfound)
{
    int          ret ;
    const char * c ;
    c = iniparser_getstring(d, key, INI_INVALID_KEY);
    if (c==INI_INVALID_KEY) return notfound ;
    if (c[0]=='y' || c[0]=='Y' || c[0]=='1' || c[0]=='t' || c[0]=='T') {
        ret = 1 ;
    } else if (c[0]=='n' || c[0]=='N' || c[0]=='0' || c[0]=='f' || c[0]=='F') {
        ret = 0 ;
    } else {
        ret = notfound ;
    }
    return ret;
}
----------------------------QUERY-------------------------------
post to at least one thread
########################rank 1#############################
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;
	be removed as it is known to be the highest priority.  Remove the TCB from
	the delayed list, and add it to the ready list.
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyList( pxUnblockedTCB );
	}
	else
	{
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
	{
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
	}
	#if( configUSE_TICKLESS_IDLE != 0 )
	{
		might be set to the blocked task's time out time.  If the task is
		unblocked for a reason other than a timeout xNextTaskUnblockTime is
		normally left unchanged, because it is automatically reset to a new
		value when the tick count equals xNextTaskUnblockTime.  However if
		tickless idling is used it might be more important to enter sleep mode
		at the earliest possible time - so reset xNextTaskUnblockTime here to
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif
	return xReturn;
}
########################rank 2#############################
ITT_EXTERN_C void JITAPI FinalizeThread()
{
    if (threadLocalStorageHandle)
    {
#if ITT_PLATFORM==ITT_PLATFORM_WIN
        pThreadStack threadStack = 
            (pThreadStack)TlsGetValue (threadLocalStorageHandle);
#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
        pThreadStack threadStack = 
            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);
#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
        if (threadStack)
        {
            free (threadStack);
            threadStack = NULL;
#if ITT_PLATFORM==ITT_PLATFORM_WIN
            TlsSetValue (threadLocalStorageHandle, threadStack);
#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */
            pthread_setspecific(threadLocalStorageHandle, threadStack);
#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */
        }
    }
}
########################rank 3#############################
int xio_thread_create(xio_thread_t *thr, xio_thread_start_t func, void *arg)
{
	struct xio_thread_start_info *ti =
		(struct xio_thread_start_info *)malloc(sizeof(*ti));
	if (ti == NULL)
		return XIO_THREAD_NOMEM;
	ti->function = func;
	ti->arg = arg;
#if defined(_XIO_THREAD_WIN32_)
	*thr = (HANDLE)_beginthreadex(NULL, 0,
			_xio_thread_wrapper_function,
			(void *)ti, 0, NULL);
#elif defined(_XIO_THREAD_POSIX_)
	if (pthread_create(thr, NULL,
			   _xio_thread_wrapper_function,
			   (void *)ti) != 0)
		*thr = 0;
#endif
	if (!*thr) {
		free(ti);
		return XIO_THREAD_ERROR;
	}
	return XIO_THREAD_SUCCESS;
}
########################rank 4#############################
int zlog_init(const char *confpath)
{
	int rc;
	zc_debug("------zlog_init start------");
	zc_debug("------compile time[%s %s], version[%s]------", __DATE__, __TIME__, ZLOG_VERSION);
	rc = pthread_rwlock_wrlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_wrlock fail, rc[%d]", rc);
		return -1;
	}
	if (zlog_env_is_init) {
		zc_error("already init, use zlog_reload pls");
		goto err;
	}
	if (zlog_init_inner(confpath)) {
		zc_error("zlog_init_inner[%s] fail", confpath);
		goto err;
	}
	zlog_env_is_init = 1;
	zlog_env_init_version++;
	zc_debug("------zlog_init success end------");
	rc = pthread_rwlock_unlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_unlock fail, rc=[%d]", rc);
		return -1;
	}
	return 0;
err:
	zc_error("------zlog_init fail end------");
	rc = pthread_rwlock_unlock(&zlog_env_lock);
	if (rc) {
		zc_error("pthread_rwlock_unlock fail, rc=[%d]", rc);
		return -1;
	}
	return -1;
}
########################rank 5#############################
static void heap_bubble_up(int idx) {
  while (PARENT(idx) >= 0) {
    int fidx = PARENT(idx); // fidx is father of idx;
    connection_t *c = lotos_connections[idx];
    connection_t *fc = lotos_connections[fidx];
    if (c->active_time >= fc->active_time)
      break;
    c_swap(idx, fidx);
    idx = fidx;
  }
}
########################rank 6#############################
static void bsem_post(bsem *bsem_p) {
	pthread_mutex_lock(&bsem_p->mutex);
	bsem_p->v = 1;
	pthread_cond_signal(&bsem_p->cond);
	pthread_mutex_unlock(&bsem_p->mutex);
}
########################rank 7#############################
static void heap_bubble_up(int idx) {
  while (PARENT(idx) >= 0) {
    int fidx = PARENT(idx); // fidx is father of idx;
    connection_t *c = lotos_connections[idx];
    connection_t *fc = lotos_connections[fidx];
    if (c->active_time >= fc->active_time)
      break;
    c_swap(idx, fidx);
    idx = fidx;
  }
}
########################rank 8#############################
int
__objc_mutex_allocate(objc_mutex_t mutex)
{
  mutex->backend = objc_malloc(sizeof(pthread_mutex_t));
  if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))
    {
      objc_free(mutex->backend);
      mutex->backend = NULL;
      return -1;
    }
  return 0;
}
########################rank 9#############################
static void closure_deref( SGS_CTX, sgs_Closure* cl )
{
	if( --cl->refcount < 1 )
	{
		VAR_RELEASE( &cl->var );
		sgs_Dealloc( cl );
	}
}
########################rank 10#############################
struct mpscq *mpscq_create(struct mpscq *n, size_t capacity)
{
	if(!n) {
		n = calloc(1, sizeof(*n));
		n->flags |= MPSCQ_MALLOC;
	} else {
		n->flags = 0;
	}
	n->count = ATOMIC_VAR_INIT(0);
	n->head = ATOMIC_VAR_INIT(0);
	n->tail = 0;
	n->buffer = calloc(capacity, sizeof(void *));
	n->max = capacity;
	atomic_thread_fence(memory_order_release);
	return n;
}
----------------------------QUERY-------------------------------
check l3cat id is correct
########################rank 1#############################
int funcB() {
  return 3;
}
########################rank 2#############################
NUMA *
numaOpen(NUMA    *nas,
         l_int32  size)
{
NUMA  *nat, *nad;
    PROCNAME("numaOpen");
    if (!nas)
        return (NUMA *)ERROR_PTR("nas not defined", procName, NULL);
    if (size <= 0)
        return (NUMA *)ERROR_PTR("size must be > 0", procName, NULL);
    if ((size & 1) == 0 ) {
        L_WARNING("sel size must be odd; increasing by 1", procName);
        size++;
    }
    if (size == 1)
        return numaCopy(nas);
    nat = numaErode(nas, size);
    nad = numaDilate(nat, size);
    numaDestroy(&nat);
    return nad;
}
########################rank 3#############################
static int
tvcmp(const struct timeval * x, const struct timeval * y)
{
	if (x->tv_sec > y->tv_sec)
		return (1);
	if (x->tv_sec < y->tv_sec)
		return (-1);
	if (x->tv_usec > y->tv_usec)
		return (1);
	if (x->tv_usec < y->tv_usec)
		return (-1);
	return (0);
}
########################rank 4#############################
static int
p_lt_test(value vh, type th, value vmi, type tmi, value vma, type tma)
{
    long	min, max, n, n1, k;
    pword	*p;
    pword	*var;
    int		res = RES_NO_CHANGE;
    if (IsInteger(th)) {
	Succeed_
    }
    p = vh.ptr + 1;
    Dereference_(p);
    k = p->val.nint;
    p = vh.ptr + 2;
    Dereference_(p);
    if (IsInteger(p->tag)) {
	Succeed_
    }
    var = p->val.ptr;
    Var_Domain(var, p);
    (void) dom_range(p, &min, &max);
    if (k > 0) {
	n = -vma.nint/k + max;
	if (n <= min)
	    ;
	else if (n < max) {
	    res |= RES_MIN;
	}
	else 
	{
	    Bind_Var(var->val, var->tag, n, TINT)
	    Succeed_;
	}
	if (vmi.nint < vma.nint) {	/* equality */
	    n1 = -vmi.nint/k + min;
	    if (n1 >= max)
		;
	    else if (n1 > min) {
		if (res & RES_MIN) {
		    if (n == n1) {
			Bind_Var(var->val, var->tag, n, TINT)
			Succeed_;
		    }
		}
		res |= RES_MAX;
	    }
	    else /* if (n1 == max)  */
	    {
		Bind_Var(var->val, var->tag, n1, TINT)
		Succeed_;
	    }
	}
    }
    else {
	if (vmi.nint < vma.nint) {	/* equality */
	    n1 = -vmi.nint/k + max;
	    if (n1 <= min)
		;
	    else if (n1 < max) {
		res |= RES_MIN;
	    }
	    else /* if (n1 == max) */
	    {
		Bind_Var(var->val, var->tag, n1, TINT)
		Succeed_;
	    }
	}
	n = -vma.nint/k + min;
	if (n >= max)
	    ;
	else if (n > min) {
	    if (res & RES_MIN) {
		if (n == n1) {
		    Bind_Var(var->val, var->tag, n, TINT)
		    Succeed_;
		}
	    }
	    res |= RES_MAX;
	}
	else 
	{
	    Bind_Var(var->val, var->tag, n, TINT)
	    Succeed_;
	}
    }
    if (res & RES_MIN) {
	min = dom_remove_smaller(p, k > 0 ? n : n1);
	if (!min) {
	    Fail_
	}
    }
    if (res & RES_MAX) {
	min = dom_remove_greater(p, k > 0 ? n1 : n);
	if (!min) {
	    Fail_
	}
    }
    if (res) {
	k = _domain_changed(var, min, res);
	Check_Return(k)
    }
    Succeed_;
}
########################rank 5#############################
__thread int g_tlsdata;
int func1()
{
  g_tlsdata++;
  return g_tlsdata;
}
########################rank 6#############################
int allocdeblend(int deblend_nthresh)
{
  int status=RETURN_OK;
  QMALLOC(son, short,  deblend_nthresh*NSONMAX*NBRANCH, status);
  QMALLOC(ok, short,  deblend_nthresh*NSONMAX, status);
  QMALLOC(objlist, objliststruct, deblend_nthresh, status);
  return status;
 exit:
  freedeblend();
  return status;
}
########################rank 7#############################
static int
verify_l3cat_id(const unsigned l3cat_id, const struct pqos_cpuinfo *cpu)
{
	int ret = PQOS_RETVAL_PARAM;
	unsigned i;
	unsigned l3cat_num;
	unsigned *l3cat_ids;
	l3cat_ids = pqos_cpu_get_l3cat_ids(cpu, &l3cat_num);
	if (l3cat_ids == NULL)
		return PQOS_RETVAL_ERROR;
	for (i = 0; i < l3cat_num; ++i)
		if (l3cat_id == l3cat_ids[i]) {
			ret = PQOS_RETVAL_OK;
			break;
		}
	free(l3cat_ids);
	return ret;
}
########################rank 8#############################
L_KERNEL *
kernelInvert(L_KERNEL  *kels)
{
l_int32    i, j, sx, sy, cx, cy;
L_KERNEL  *keld;
    PROCNAME("kernelInvert");
    if (!kels)
        return (L_KERNEL *)ERROR_PTR("kels not defined", procName, NULL);
    kernelGetParameters(kels, &sy, &sx, &cy, &cx);
    if ((keld = kernelCreate(sy, sx)) == NULL)
        return (L_KERNEL *)ERROR_PTR("keld not made", procName, NULL);
    keld->cy = sy - 1 - cy;
    keld->cx = sx - 1 - cx;
    for (i = 0; i < sy; i++)
        for (j = 0; j < sx; j++)
            keld->data[i][j] = kels->data[sy - 1 - i][sx - 1 - j];
    return keld;
}
########################rank 9#############################
char cpu_le() {
	const uint32_t cpu_le_test = 0x12345678;
	return ((const unsigned char*)&cpu_le_test)[0] == 0x78;
}
########################rank 10#############################
inline double rate(size_t transferred, double elapsed)
{
	if (elapsed > 0)
		return (double)transferred / elapsed;
	return 0.;
}
----------------------------QUERY-------------------------------
combine two nodes into a single node
########################rank 1#############################
static void rotate_left(struct avltree_node *node, struct avltree *tree)
{
	struct avltree_node *p = node;
	struct avltree_node *q = node->right; /* can't be NULL */
	struct avltree_node *parent = get_parent(p);
	if (!is_root(p)) {
		if (parent->left == p)
			parent->left = q;
		else
			parent->right = q;
	} else
		tree->root = q;
	set_parent(parent, q);
	set_parent(q, p);
	p->right = q->left;
	if (p->right)
		set_parent(p, p->right);
	q->left = p;
}
########################rank 2#############################
struct avl_node *avl_node_first(struct avl_root *root)
{
	struct avl_node *node = root->node;
	if (node == NULL) return NULL;
	while (node->left) 
		node = node->left;
	return node;
}
########################rank 3#############################
unsigned long slDeleteByRank(skiplist *sl, unsigned int start, unsigned int end, slDeleteCb cb, void* ud) {
    skiplistNode *update[SKIPLIST_MAXLEVEL], *x;
    unsigned long traversed = 0, removed = 0;
    int i;
    x = sl->header;
    for (i = sl->level-1; i >= 0; i--) {
        while (x->level[i].forward && (traversed + x->level[i].span) < start) {
            traversed += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    traversed++;
    x = x->level[0].forward;
    while (x && traversed <= end) {
        skiplistNode *next = x->level[0].forward;
        slDeleteNode(sl,x,update);
        cb(ud, x->obj);
        slFreeNode(x);
        removed++;
        traversed++;
        x = next;
    }
    return removed;
}
########################rank 4#############################
static Node* left_right_rotation(AVLTree k3)
{
    k3->left = right_right_rotation(k3->left);
    return left_left_rotation(k3);
}
########################rank 5#############################
static Node* right_left_rotation(AVLTree k1)
{
    k1->right = left_left_rotation(k1->right);
    return right_right_rotation(k1);
}
########################rank 6#############################
void dict_free_nodes(dict_t *dict)
{
    dnode_t *nil = dict_nil(dict), *root = dict_root(dict);
    free_nodes(dict, root, nil);
    dict->nodecount = 0;
    dict->nilnode.left = &dict->nilnode;
    dict->nilnode.right = &dict->nilnode;
}
########################rank 7#############################
void destroy_avltree(AVLTree tree)
{
    if (tree==NULL)
        return ;
    if (tree->left != NULL)
        destroy_avltree(tree->left);
    if (tree->right != NULL)
        destroy_avltree(tree->right);
    free(tree);
}
########################rank 8#############################
void InsertNodeAfterElement(Node *element, Node *node)
{
    Node *parent;
    parent = element->parent;
    node->parent = parent;
    if (parent->last == element)
        parent->last = node;
    else
    {
        node->next = element->next;
        node->next->prev = node;
    }
    element->next = node;
    node->prev = element;
}
########################rank 9#############################
int buildenc(int level, int root)
{
	int l, r;
	l = node[root].lchild;
	r = node[root].rchild;
#ifdef DEBUG
	if (debug) printf("level=%d,root=%d,l=%d,r=%d,tcode=%04x\n",level,root,l,r,tcode);
#endif
	if( l == NOCHILD && r == NOCHILD) {
		 * code of length level (bits 0 to level - 1).
		 * Ensures unused code bits are zero.
		 */
		codelen[root] = level;
		code[root] = tcode & ((unsigned int)(~0) >> ((sizeof(int) * 8) - level));
#ifdef DEBUG
		if (debug) printf("  codelen[%d]=%d,code[%d]=%02x\n",root,codelen[root],root,code[root]);
#endif
		return ((level > 16) ? ERROR : OK);
	} else {
		if( l != NOCHILD) {
			tcode &= ~(1 << level);
			if(buildenc(level + 1, l) == ERROR)
				return ERROR;
		}
		if(r != NOCHILD) {
			tcode |= 1 << level;
			if(buildenc(level + 1, r) == ERROR)
				return ERROR;
		}
	}
	return (OK);	/* if we got here we're ok so far */
}
########################rank 10#############################
static inline struct avltree_node *get_first(struct avltree_node *node)
{
	while (node->left)
		node = node->left;
	return node;
}
----------------------------QUERY-------------------------------
allocate memory for file descriptors
########################rank 1#############################
void
util_init(void)
{
	if (Pagesize == 0)
		Pagesize = (unsigned long) sysconf(_SC_PAGESIZE);
#ifndef _WIN32
	Mmap_align = Pagesize;
#else
	if (Mmap_align == 0) {
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		Mmap_align = si.dwAllocationGranularity;
	}
#endif
#if ANY_VG_TOOL_ENABLED
	_On_valgrind = RUNNING_ON_VALGRIND;
#endif
#if VG_PMEMCHECK_ENABLED
	if (On_valgrind) {
		char *pmreorder_env = os_getenv("PMREORDER_EMIT_LOG");
		if (pmreorder_env)
			_Pmreorder_emit = atoi(pmreorder_env);
	} else {
			_Pmreorder_emit = 0;
	}
#endif
}
########################rank 2#############################
void cmd_mkexrc(frommark, tomark, cmd, bang, extra)
	MARK	frommark;
	MARK	tomark;
	CMD	cmd;
	int	bang;
	char	*extra;
{
	int	fd;
	if (!*extra)
	{
		extra = EXRC;
	}
	fd = creat(extra, FILEPERMS);
	if (fd < 0)
	{
		msg("Couldn't create a new \"%s\" file", extra);
		return;
	}
	savekeys(fd);
	saveopts(fd);
#ifndef NO_DIGRAPH
	savedigs(fd);
#endif
#ifndef	NO_ABBR
	saveabbr(fd);
#endif
	close(fd);
	msg("Created a new \"%s\" file", extra);
}
########################rank 3#############################
static enum op_result
alloc_fds(int **fds, int n_fds)
{
	if (n_fds) {
		*fds = (int *)malloc(sizeof(int) * n_fds);
		if (*fds == NULL)
			return OP_ERROR;
	}
	return OP_SUCCESS;
}
########################rank 4#############################
char *my_strerror(int errornum)
{
	return(strerror(errornum));
}
########################rank 5#############################
static int readable(const char *filename)
{
  FILE *f = fopen(filename, "r");  
  if (f == NULL) return 0;  /* open failed */
  fclose(f);
  return 1;
}
########################rank 6#############################
static int readable(const char *filename)
{
  FILE *f = fopen(filename, "r");  
  if (f == NULL) return 0;  /* open failed */
  fclose(f);
  return 1;
}
########################rank 7#############################
static int readable(const char *filename)
{
  FILE *f = fopen(filename, "r");  
  if (f == NULL) return 0;  /* open failed */
  fclose(f);
  return 1;
}
########################rank 8#############################
channel_t*  S_ChannelMalloc() {
	channel_t *v;
	if ( freelist == NULL ) {
		return NULL;
	}
	v = freelist;
	freelist = *(channel_t **)freelist;
	v->allocTime = Sys_Milliseconds();
	return v;
}
########################rank 9#############################
FILE *tmpfileplus(const char *dir, const char *prefix, char **pathname, int keep)
{
	FILE *fp = NULL;
	char *tmpname = NULL;
	char *tmpdir = NULL;
	const char *pfx = (prefix ? prefix : "tmp.");
	char *tempdirs[12] = { 0 };
#ifdef _WIN32
	char env1[FILENAME_MAX+1] = { 0 };
	char env2[FILENAME_MAX+1] = { 0 };
#else
	char env3[FILENAME_MAX+1] = { 0 };
#endif
	int ntempdirs = 0;
	int i;
	i = 0;
	tempdirs[i++] = (char *)dir;
#ifdef _WIN32
	tempdirs[i++] = getenv_save("TMP", env1, sizeof(env1));
	tempdirs[i++] = getenv_save("TEMP", env2, sizeof(env2));
#else
	tempdirs[i++] = getenv_save("TMPDIR", env3, sizeof(env3));
	tempdirs[i++] = P_tmpdir;
#endif
	tempdirs[i++] = ".";
	ntempdirs = i;
	errno = 0;
	for (i = 0; i < ntempdirs; i++)
	{
		tmpdir = tempdirs[i];
		DPRINTF1("Trying tmpdir=[%s]\n", tmpdir);
		fp = mktempfile_internal(tmpdir, pfx, &tmpname, keep);
		if (fp) break;
	}
	if (fp && pathname)
		*pathname = tmpname;
	else	/* Otherwise, free the alloc'd memory */
		free(tmpname);
	return fp;
}
########################rank 10#############################
static int readable(const char *filename)
{
  FILE *f = fopen(filename, "r");  
  if (f == NULL) return 0;  /* open failed */
  fclose(f);
  return 1;
}
----------------------------QUERY-------------------------------
add new edge
########################rank 1#############################
void b3dRemapFaces(B3DFaceAllocList *list, int attrOffset, int edgeOffset)
{
	int i;
	for(i=0; i<list->size;i++) {
		B3DPrimitiveFace *face = list->data + i;
		if(face->flags & B3D_ALLOC_FLAG) {
			if(face->attributes)
				face->attributes = (B3DPrimitiveAttribute*)((char*)face->attributes + attrOffset);
			if(face->leftEdge)
				face->leftEdge = (B3DPrimitiveEdge*)((char*)face->leftEdge + edgeOffset);
			if(face->rightEdge)
				face->rightEdge = (B3DPrimitiveEdge*)((char*)face->rightEdge + edgeOffset);
		}
	}
}
########################rank 2#############################
void b3dAddLastFill(B3DFillList *fillList, B3DPrimitiveFace *aFace)
{
	B3DPrimitiveFace *lastFace = fillList->lastFace;
	if(lastFace)
		lastFace->nextFace = aFace;
	else
		fillList->firstFace = aFace;
	aFace->prevFace = lastFace;
	aFace->nextFace = NULL;
	fillList->lastFace = aFace;
	if(b3dDebug) b3dValidateFillList(fillList);
}
########################rank 3#############################
void b3dAddFirstFill(B3DFillList *fillList, B3DPrimitiveFace *aFace)
{
	B3DPrimitiveFace *firstFace = fillList->firstFace;
	if(firstFace)
		firstFace->prevFace = aFace;
	else
		fillList->lastFace = aFace;
	aFace->nextFace = firstFace;
	aFace->prevFace = NULL;
	fillList->firstFace = aFace;
	if(b3dDebug) b3dValidateFillList(fillList);
}
########################rank 4#############################
void b3dAddFirstFill(B3DFillList *fillList, B3DPrimitiveFace *aFace)
{
	B3DPrimitiveFace *firstFace = fillList->firstFace;
	if(firstFace)
		firstFace->prevFace = aFace;
	else
		fillList->lastFace = aFace;
	aFace->nextFace = firstFace;
	aFace->prevFace = NULL;
	fillList->firstFace = aFace;
	if(b3dDebug) b3dValidateFillList(fillList);
}
########################rank 5#############################
void b3dAddLastFill(B3DFillList *fillList, B3DPrimitiveFace *aFace)
{
	B3DPrimitiveFace *lastFace = fillList->lastFace;
	if(lastFace)
		lastFace->nextFace = aFace;
	else
		fillList->firstFace = aFace;
	aFace->prevFace = lastFace;
	aFace->nextFace = NULL;
	fillList->lastFace = aFace;
	if(b3dDebug) b3dValidateFillList(fillList);
}
########################rank 6#############################
void MocAllocate2WayPartitionMemory(CtrlType *ctrl, GraphType *graph)
{
  int nvtxs, ncon;
  nvtxs = graph->nvtxs;
  ncon = graph->ncon;
  graph->rdata = idxmalloc(5*nvtxs, "Allocate2WayPartitionMemory: rdata");
  graph->where		= graph->rdata;
  graph->id		= graph->rdata + nvtxs;
  graph->ed		= graph->rdata + 2*nvtxs;
  graph->bndptr		= graph->rdata + 3*nvtxs;
  graph->bndind		= graph->rdata + 4*nvtxs;
  graph->npwgts 	= fmalloc(2*ncon, "npwgts");
}
########################rank 7#############################
void S_BeginRegistration( void )
{
	if( si.BeginRegistration ) {
		si.BeginRegistration( );
	}
}
########################rank 8#############################
void highorder(m, b)
struct mesh *m;
struct behavior *b;
#endif 
{
  struct otri triangleloop, trisym;
  struct osub checkmark;
  vertex newvertex;
  vertex torg, tdest;
  int i;
  triangle ptr;                         /* Temporary variable used by sym(). */
  subseg sptr;                      /* Temporary variable used by tspivot(). */
  if (!b->quiet) {
    printf("Adding vertices for second-order triangles.\n");
  }
  m->vertices.deaditemstack = (VOID *) NULL;
  traversalinit(&m->triangles);
  triangleloop.tri = triangletraverse(m);
  while (triangleloop.tri != (triangle *) NULL) {
    for (triangleloop.orient = 0; triangleloop.orient < 3;
         triangleloop.orient++) {
      sym(triangleloop, trisym);
      if ((triangleloop.tri < trisym.tri) || (trisym.tri == m->dummytri)) {
        org(triangleloop, torg);
        dest(triangleloop, tdest);
        newvertex = (vertex) poolalloc(&m->vertices);
        for (i = 0; i < 2 + m->nextras; i++) {
          newvertex[i] = 0.5 * (torg[i] + tdest[i]);
        }
        setvertexmark(newvertex, trisym.tri == m->dummytri);
        setvertextype(newvertex,
                      trisym.tri == m->dummytri ? FREEVERTEX : SEGMENTVERTEX);
        if (b->usesegments) {
          tspivot(triangleloop, checkmark);
          if (checkmark.ss != m->dummysub) {
            setvertexmark(newvertex, mark(checkmark));
            setvertextype(newvertex, SEGMENTVERTEX);
          }
        }
        if (b->verbose > 1) {
          printf("  Creating (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
        }
        triangleloop.tri[m->highorderindex + triangleloop.orient] =
                (triangle) newvertex;
        if (trisym.tri != m->dummytri) {
          trisym.tri[m->highorderindex + trisym.orient] = (triangle) newvertex;
        }
      }
    }
    triangleloop.tri = triangletraverse(m);
  }
}
########################rank 9#############################
static void highorder(m, b)
struct mesh *m;
struct behavior *b;
#endif 
{
  struct otri triangleloop, trisym;
  struct osub checkmark;
  vertex newvertex;
  vertex torg, tdest;
  int i;
  triangle ptr;                         /* Temporary variable used by sym(). */
  subseg sptr;                      /* Temporary variable used by tspivot(). */
  if (!b->quiet) {
    printf("Adding vertices for second-order triangles.\n");
  }
  m->vertices.deaditemstack = (VOID *) NULL;
  traversalinit(&m->triangles);
  triangleloop.tri = triangletraverse(m);
  while (triangleloop.tri != (triangle *) NULL) {
    for (triangleloop.orient = 0; triangleloop.orient < 3;
         triangleloop.orient++) {
      sym(triangleloop, trisym);
      if ((triangleloop.tri < trisym.tri) || (trisym.tri == m->dummytri)) {
        org(triangleloop, torg);
        dest(triangleloop, tdest);
        newvertex = (vertex) poolalloc(&m->vertices);
        for (i = 0; i < 2 + m->nextras; i++) {
          newvertex[i] = 0.5 * (torg[i] + tdest[i]);
        }
        setvertexmark(newvertex, trisym.tri == m->dummytri);
        setvertextype(newvertex,
                      trisym.tri == m->dummytri ? FREEVERTEX : SEGMENTVERTEX);
        if (b->usesegments) {
          tspivot(triangleloop, checkmark);
          if (checkmark.ss != m->dummysub) {
            setvertexmark(newvertex, mark(checkmark));
            setvertextype(newvertex, SEGMENTVERTEX);
          }
        }
        if (b->verbose > 1) {
          printf("  Creating (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
        }
        triangleloop.tri[m->highorderindex + triangleloop.orient] =
                (triangle) newvertex;
        if (trisym.tri != m->dummytri) {
          trisym.tri[m->highorderindex + trisym.orient] = (triangle) newvertex;
        }
      }
    }
    triangleloop.tri = triangletraverse(m);
  }
}
########################rank 10#############################
void InitParams()
{
	int i;
	params.nPatches=0;
	for (i=numberOfPolys; i--; )
		params.nPatches += roomPolys[i].patchLevel*roomPolys[i].patchLevel;
	params.patches = (TPatch*)calloc(params.nPatches, sizeof(TPatch));
	params.nElements=0;
	for (i=numberOfPolys; i--; )
		params.nElements += roomPolys[i].elementLevel*roomPolys[i].patchLevel*
						roomPolys[i].elementLevel*roomPolys[i].patchLevel;
	params.elements = (TElement*)calloc(params.nElements, sizeof(TElement));
	params.nPoints=0;
	for (i=numberOfPolys; i--; )
		params.nPoints += (roomPolys[i].elementLevel*roomPolys[i].patchLevel+1)*
						(roomPolys[i].elementLevel*roomPolys[i].patchLevel+1);
	params.points = (TPoint3f*)calloc(params.nPoints, sizeof(TPoint3f));
	iOffset = 0;
	pPatch= params.patches;
	pElement= params.elements;
	pPoint= params.points;
	for (i=0; i<numberOfPolys; i++)
		MeshQuad(&roomPolys[i]);
	params.displayView.buffer= (unsigned long*)calloc(
		params.displayView.xRes*params.displayView.yRes, sizeof(unsigned long));
	params.displayView.wid=0;
}
----------------------------QUERY-------------------------------
register an initialized display driver
########################rank 1#############################
int Mouse_X, Mouse_Y;
struct Pointer Pointers[INPUT_MAX_POINTERS];
cc_bool Input_RawMode, Input_TouchMode;
void Pointer_SetPressed(int idx, cc_bool pressed) {
#ifdef CC_BUILD_TOUCH
	if (Input_TouchMode && !(touches[idx].type & TOUCH_TYPE_GUI)) return;
#endif
	if (pressed) {
		Event_RaiseInt(&PointerEvents.Down, idx);
	} else {
		Event_RaiseInt(&PointerEvents.Up,   idx);
	}
}
########################rank 2#############################
void
_or1k_timer_interrupt_handler(void)
{
	OR1K_REENT.or1k_timer_ticks++;
	uint32_t ttmr = or1k_mfspr(OR1K_SPR_TICK_TTMR_ADDR);
	ttmr = OR1K_SPR_TICK_TTMR_IE_SET(ttmr, 1);
	ttmr = OR1K_SPR_TICK_TTMR_MODE_SET(ttmr, OR1K_SPR_TICK_TTMR_MODE_RESTART);
	ttmr = OR1K_SPR_TICK_TTMR_IP_SET(ttmr, 0);
	or1k_mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);
}
########################rank 3#############################
void do_u8x8_header(int controller_idx, int display_idx, int interface_idx)
{
  FILE *fp = u8x8_cpp_header_fp;
  fprintf(fp, "class U8X8_");
  fprintf(fp, "%s_", struppercase(controller_list[controller_idx].name));
  fprintf(fp, "%s", struppercase(controller_list[controller_idx].display_list[display_idx].name));
  if ( interface_list[interface_idx].interface_name[0] != '\0' )
    fprintf(fp, "_%s", struppercase(interface_list[interface_idx].interface_name));
  fprintf(fp, " : public U8X8 {\n");
  fprintf(fp, "  public: ");
  fprintf(fp, "U8X8_");
  fprintf(fp, "%s_", struppercase(controller_list[controller_idx].name));
  fprintf(fp, "%s", struppercase(controller_list[controller_idx].display_list[display_idx].name));
  if ( interface_list[interface_idx].interface_name[0] != '\0' )
    fprintf(fp, "_%s", struppercase(interface_list[interface_idx].interface_name));
  fprintf(fp, "(%s) : U8X8() {\n", interface_list[interface_idx].pins_with_type);
  fprintf(fp, "    ");
  fprintf(fp, "u8x8_Setup(getU8x8(), u8x8_d_");
  fprintf(fp, "%s_", strlowercase(controller_list[controller_idx].name));
  fprintf(fp, "%s, ", strlowercase(controller_list[controller_idx].display_list[display_idx].name));
  fprintf(fp, "%s, ", strlowercase(controller_list[controller_idx].cad));
  fprintf(fp, "%s, ", interface_list[interface_idx].arduino_com_procedure);  
  fprintf(fp, "%s);\n", interface_list[interface_idx].arduino_gpio_procedure);  
  fprintf(fp, "    ");
  fprintf(fp, "%s(getU8x8(), ", interface_list[interface_idx].setpin_function);  
  fprintf(fp, "%s);\n", interface_list[interface_idx].pins_plain);
  fprintf(fp, "  }\n");
  fprintf(fp, "};\n");
}
########################rank 4#############################
void lv_indev_drv_update(lv_indev_t * indev, lv_indev_drv_t * new_drv)
{
    memcpy(&indev->driver, new_drv, sizeof(lv_indev_drv_t));
}
########################rank 5#############################
dma_dev *DMA2 = &dma2;
#endif
 * @brief Initialize a DMA device.
 * @param dev Device to initialize.
 */
void dma_init(dma_dev *dev) {
    rcc_clk_enable(dev->clk_id);
}
########################rank 6#############################
static uint32_t ft6x06_TS_Configure(uint16_t DeviceAddr)
{
  uint32_t status = FT6206_STATUS_OK;
  return(status);
}
########################rank 7#############################
int gpioInitialise(void)
{
   int status;
   if (libInitialised) return PIGPIO_VERSION;
   DBG(DBG_STARTUP, "not initialised, initialising");
   runState = PI_STARTING;
   status = initInitialise();
   if (status < 0)
   {
      runState = PI_ENDING;
      initReleaseResources();
   }
   else
   {
      libInitialised = 1;
      runState = PI_RUNNING;
   }
   return status;
}
########################rank 8#############################
int32_t LAN8742_EnableIT(lan8742_Object_t *pObj, uint32_t Interrupt)
{
    uint32_t readval = 0;
    int32_t status = LAN8742_STATUS_OK;
    if (pObj->IO.ReadReg(pObj->DevAddr, LAN8742_IMR, &readval) >= 0) {
        readval |= Interrupt;
        if (pObj->IO.WriteReg(pObj->DevAddr, LAN8742_IMR, readval) < 0) {
            status =  LAN8742_STATUS_WRITE_ERROR;
        }
    } else {
        status = LAN8742_STATUS_READ_ERROR;
    }
    return status;
}
########################rank 9#############################
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
  u8 PinNumber = 0;
  u8 Counter = 0;
  u8 GPIO_Number = 0;
  GPIO_Number = GPIO_GetGPIONumber(GPIOx);
  if(GPIO_InitStruct->GPIO_Direction == GPIO_PinOutput)
  {
  GPIOx->DDR |= GPIO_InitStruct->GPIO_Pin;
  }
  else
  {
   GPIOx->DDR &= ~GPIO_InitStruct->GPIO_Pin;
  }
   for (Counter = 0; Counter < 8;Counter++)
    {
     PinNumber = (GPIO_InitStruct->GPIO_Pin & (1 <<Counter));
     if((PinNumber >> Counter) == 1)
     {
        SCU->GPIOOUT[GPIO_Number] &= ~(0x3 <<(Counter *2));
        if(GPIO_InitStruct->GPIO_Alternate == GPIO_OutputAlt1)
        {
          SCU->GPIOOUT[GPIO_Number] |= 1 << (Counter *2);
        }
        if(GPIO_InitStruct->GPIO_Alternate == GPIO_OutputAlt2)
        {
          SCU->GPIOOUT[GPIO_Number] |= 0x2 << (Counter *2);
        }
        if(GPIO_InitStruct->GPIO_Alternate == GPIO_OutputAlt3)
        {
          SCU->GPIOOUT[GPIO_Number] |= 0x3 << (Counter *2);
        }
        SCU->GPIOTYPE[GPIO_Number] &= ~(0x1 << Counter) ;
       if(GPIO_InitStruct->GPIO_Type == GPIO_Type_OpenCollector)
       {
        SCU->GPIOTYPE[GPIO_Number] |= 0x1 << Counter;
       }
       SCU->GPIOIN[GPIO_Number] &= ~(0x1 << Counter) ;
       if(GPIO_InitStruct->GPIO_IPConnected == GPIO_IPConnected_Enable)
       {
         SCU->GPIOIN[GPIO_Number] |= 0x1 << Counter;
       }
    }
 }
}
########################rank 10#############################
void lv_disp_remove(lv_disp_t * disp)
{
    bool was_default = false;
    if(disp == lv_disp_get_default()) was_default = true;
    lv_indev_t * indev;
    indev = lv_indev_get_next(NULL);
    while(indev) {
        if(indev->driver.disp == disp) {
            indev->driver.disp = NULL;
        }
        indev = lv_indev_get_next(indev);
    }
    lv_ll_rem(&LV_GC_ROOT(_lv_disp_ll), disp);
    lv_mem_free(disp);
    if(was_default) lv_disp_set_default(lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll)));
}
----------------------------QUERY-------------------------------
swap current bytecode container with given one
########################rank 1#############################
void
bis()
{
    load_src();
    load_dst();
    dstword = srcword | dstword;
    CHG_CC_N(dstword);
    CHG_CC_Z(dstword);
    CLR_CC_V();
    store_dst_2();
}
########################rank 2#############################
void
bic()
{
    load_src();
    load_dst();
    dstword = (~srcword) & dstword;
    CHG_CC_N(dstword);
    CHG_CC_Z(dstword);
    CLR_CC_V();
    store_dst_2();
}
########################rank 3#############################
static void InstrB(uint8_t b1)
{
    InstrClear();
    InstrAddB(b1);
}
########################rank 4#############################
static void InstrBW(uint8_t b1, uint16_t w1)
{
    InstrClear();
    InstrAddB(b1);
    InstrAddW(w1);
}
########################rank 5#############################
void ash() {
    u_int16_t temp;
    u_int16_t old;
    u_int16_t sign;
    u_int16_t count;
    temp = regs[SRC_REG];
    load_dst();
    old = temp;
    if ((dstword & 077) == 0) {		/* no shift */
	CHG_CC_N(temp);
	CHG_CC_Z(temp);
	CLR_CC_V();
	return;
    }
    if (dstword & 040) {		/* right shift */
	count = 0100 - (dstword & 077);
	sign = temp & SIGN;
	while (count--) {
	    if (temp & LSBIT) {
		SET_CC_C();
	    } else {
		CLR_CC_C();
	    }
	    temp >>= 1;
	    temp += sign;
	}
    } else {				/* left shift */
	count = dstword & 037;
	while (count--) {
	    if (temp & SIGN) {
		SET_CC_C();
	    } else {
		CLR_CC_C();
	    }
	    temp <<= 1;
	}
    }
    CHG_CC_N(temp);
    CHG_CC_Z(temp);
    if ((old & SIGN) == (temp & SIGN)) {
	CLR_CC_V();
    } else {
	SET_CC_V();
    }
    regs[SRC_REG] = temp;
}
########################rank 6#############################
DUK_INTERNAL void duk_hbuffer_insert_bytes(duk_hthread *thr, duk_hbuffer_dynamic *buf, duk_size_t offset, const duk_uint8_t *data, duk_size_t length) {
	duk_uint8_t *p;
	DUK_ASSERT(thr != NULL);
	DUK_ASSERT(buf != NULL);
	DUK_ASSERT(DUK_HBUFFER_HAS_DYNAMIC(buf));
	DUK_ASSERT_DISABLE(offset >= 0);  /* unsigned, so always true */
	DUK_ASSERT(offset <= DUK_HBUFFER_GET_SIZE(buf));  /* equality is OK (= append) */
	DUK_ASSERT(data != NULL);
	DUK_ASSERT_DISABLE(length >= 0);  /* unsigned, so always true */
	if (length == 0) {
		return;
	}
	if (DUK_HBUFFER_DYNAMIC_GET_SPARE_SIZE(buf) < length) {
		duk_hbuffer_resize(thr,
		                   buf,
		                   DUK_HBUFFER_GET_SIZE(buf),
		                   duk__add_spare(DUK_HBUFFER_GET_SIZE(buf) + length));
	}
	DUK_ASSERT(DUK_HBUFFER_DYNAMIC_GET_SPARE_SIZE(buf) >= length);
	p = (duk_uint8_t *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(thr->heap, buf);
	if (offset < DUK_HBUFFER_GET_SIZE(buf)) {
		DUK_ASSERT(DUK_HBUFFER_GET_SIZE(buf) - offset > 0);
		DUK_MEMMOVE((void *) (p + offset + length),
		            (void *) (p + offset),
		            DUK_HBUFFER_GET_SIZE(buf) - offset);
	}
	DUK_ASSERT(length > 0);
	DUK_MEMCPY((void *) (p + offset),
	           data,
	           length);
	DUK_HBUFFER_DYNAMIC_ADD_SIZE(buf, length);
}
########################rank 7#############################
void ashc() {
    u_int32_t temp;
    u_int32_t old;
    u_int32_t sign;
    u_int16_t count;
    temp = regs[SRC_REG];
    temp <<= 16;
    temp += regs[(SRC_REG) | 1];
    old = temp;
    load_dst();
    if ((dstword & 077) == 0) { /* no shift */
	CLR_CC_V();
	if (temp & 0x80000000) {
	    SET_CC_N();
	} else {
	    CLR_CC_N();
	}
	if (temp) {
	    CLR_CC_Z();
	} else {
	    SET_CC_Z();
	}
	return;
    }
    if (dstword & 040) {		/* right shift */
	count = 0100 - (dstword & 077);
	sign = temp & 0x80000000;
	while (count--) {
	    if (temp & LSBIT) {
		SET_CC_C();
	    } else {
		CLR_CC_C();
	    }
	    temp >>= 1;
	    temp += sign;
	}
    } else {			/* left shift */
	count = dstword & 037;
	while (count--) {
	    if (temp & 0x80000000) {
		SET_CC_C();
	    } else {
		CLR_CC_C();
	    }
	    temp <<= 1;
	}
    }
    if (temp & 0x80000000)
	SET_CC_N();
    else
	CLR_CC_N();
    if (temp)
	CLR_CC_Z();
    else
	SET_CC_Z();
    if ((old & 0x80000000) == (temp & 0x80000000)) {
	CLR_CC_V();
    } else {
	SET_CC_V();
    }
    regs[SRC_REG] = (u_int16_t)(temp >> 16);
    regs[(SRC_REG) | 1] = LOW16(temp);
}
########################rank 8#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 9#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 10#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
----------------------------QUERY-------------------------------
send fail message to all nodes
########################rank 1#############################
void clusterSendFail(char *nodename) {
    unsigned char buf[sizeof(clusterMsg)];
    clusterMsg *hdr = (clusterMsg*) buf;
    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
    memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
    clusterBroadcastMessage(server.cluster->nodes,buf,ntohl(hdr->totlen));
}
########################rank 2#############################
int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    size_t numnodes;
    char **ids = RedisModule_GetClusterNodesList(ctx,&numnodes);
    if (ids == NULL) {
        return RedisModule_ReplyWithError(ctx,"Cluster not enabled");
    }
    RedisModule_ReplyWithArray(ctx,numnodes);
    for (size_t j = 0; j < numnodes; j++) {
        int port;
        RedisModule_GetClusterNodeInfo(ctx,ids[j],NULL,NULL,&port,NULL);
        RedisModule_ReplyWithArray(ctx,2);
        RedisModule_ReplyWithStringBuffer(ctx,ids[j],REDISMODULE_NODE_ID_LEN);
        RedisModule_ReplyWithLongLong(ctx,port);
    }
    RedisModule_FreeClusterNodesList(ids);
    return REDISMODULE_OK;
}
########################rank 3#############################
static int getnodes(DHT *dht, IP_Port ip_port, const uint8_t *public_key, const uint8_t *client_id,
                    const Node_format *sendback_node)
{
    if (id_equal(public_key, dht->self_public_key)) {
        return -1;
    }
    uint8_t plain_message[sizeof(Node_format) * 2] = {0};
    Node_format receiver;
    memcpy(receiver.public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    receiver.ip_port = ip_port;
    memcpy(plain_message, &receiver, sizeof(receiver));
    uint64_t ping_id = 0;
    if (sendback_node != nullptr) {
        memcpy(plain_message + sizeof(receiver), sendback_node, sizeof(Node_format));
        ping_id = ping_array_add(dht->dht_harden_ping_array, dht->mono_time, plain_message, sizeof(plain_message));
    } else {
        ping_id = ping_array_add(dht->dht_ping_array, dht->mono_time, plain_message, sizeof(receiver));
    }
    if (ping_id == 0) {
        return -1;
    }
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + sizeof(ping_id)];
    uint8_t data[1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE];
    memcpy(plain, client_id, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, &ping_id, sizeof(ping_id));
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    dht_get_shared_key_sent(dht, shared_key, public_key);
    const int len = dht_create_packet(dht->self_public_key, shared_key, NET_PACKET_GET_NODES,
                                      plain, sizeof(plain), data);
    if (len != sizeof(data)) {
        return -1;
    }
    return sendpacket(dht->net, ip_port, data, len);
}
########################rank 4#############################
void raxDebugShowNode(const char *msg, raxNode *n) {
    if (raxDebugMsg == 0) return;
    printf("%s: %p [%.*s] key:%d size:%d children:",
        msg, (void*)n, (int)n->size, (char*)n->data, n->iskey, n->size);
    int numcld = n->iscompr ? 1 : n->size;
    raxNode **cldptr = raxNodeLastChildPtr(n) - (numcld-1);
    while(numcld--) {
        raxNode *child;
        memcpy(&child,cldptr,sizeof(child));
        cldptr++;
        printf("%p ", (void*)child);
    }
    printf("\n");
    fflush(stdout);
}
########################rank 5#############################
void redis_incr(char *key, client_context *cc) {
    redis_incr_by(key, 1, cc);
}
########################rank 6#############################
bool dht_isconnected(const DHT *dht)
{
    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        const Client_data *const client = &dht->close_clientlist[i];
        if (!mono_time_is_timeout(dht->mono_time, client->assoc4.timestamp, BAD_NODE_TIMEOUT) ||
                !mono_time_is_timeout(dht->mono_time, client->assoc6.timestamp, BAD_NODE_TIMEOUT)) {
            return true;
        }
    }
    return false;
}
########################rank 7#############################
static void HandleServerInfo(SINT8 node)
{
	// compute ping in ms
	const tic_t ticnow = I_GetTime();
	const tic_t ticthen = (tic_t)LONG(netbuffer->u.serverinfo.time);
	const tic_t ticdiff = (ticnow - ticthen)*1000/NEWTICRATE;
	netbuffer->u.serverinfo.time = (tic_t)LONG(ticdiff);
	netbuffer->u.serverinfo.servername[MAXSERVERNAME-1] = 0;
	netbuffer->u.serverinfo.application
		[sizeof netbuffer->u.serverinfo.application - 1] = '\0';
	netbuffer->u.serverinfo.gametypename
		[sizeof netbuffer->u.serverinfo.gametypename - 1] = '\0';
	SL_InsertServer(&netbuffer->u.serverinfo, node);
}
########################rank 8#############################
static uint8_t hardening_correct(const Hardening *h)
{
    return h->routes_requests_ok + (h->send_nodes_ok << 1) + (h->testing_requests << 2);
}
########################rank 9#############################
void connect(struct lnode* p1, struct lnode* p2)
{
    if (p1 == 0 || p2 == 0)
        error("connect: can't happen\n");
    p1->l_next = p2;
    p2->l_prev = p1;
}
########################rank 10#############################
void fastackCommand(client *c) {
    int j, known = 0;
    if (validateJobIDs(c,c->argv+1,c->argc-1) == C_ERR) return;
    for (j = 1; j < c->argc; j++) {
        job *job = lookupJob(c->argv[j]->ptr);
        if (job == NULL) {
            clusterBroadcastJobIDMessage(server.cluster->nodes,c->argv[j]->ptr,
                                         CLUSTERMSG_TYPE_DELJOB,0,
                                         CLUSTERMSG_NOFLAGS);
        } else {
            clusterBroadcastDelJob(job);
            unregisterJob(job);
            freeJob(job);
            known++;
        }
    }
    addReplyLongLong(c,known);
}
----------------------------QUERY-------------------------------
parse argname from string
########################rank 1#############################
static
uint32_t
coap_parse_int_option(uint8_t *bytes, size_t length)
{
  uint32_t var = 0;
  size_t i = 0;
  while (i<length)
  {
    var <<= 8;
    var |= bytes[i++];
  }
  return var;
}
########################rank 2#############################
static
uint32_t
coap_parse_int_option(uint8_t *bytes, size_t length)
{
  uint32_t var = 0;
  size_t i = 0;
  while (i<length)
  {
    var <<= 8;
    var |= bytes[i++];
  }
  return var;
}
########################rank 3#############################
static void
parse(register char *str, struct ptentry *t)
{
  struct ptentry *p;
  for(p = t; p->commandstr != NULL; ++p) {
    if(strncmp(p->commandstr, str, strlen(p->commandstr)) == 0) {
      break;
    }
  }
  p->pfunc(str);
}
########################rank 4#############################
static void
parse(register char *str, struct ptentry *t)
{
  struct ptentry *p;
  for(p = t; p->commandstr != NULL; ++p) {
    if(strncmp(p->commandstr, str, strlen(p->commandstr)) == 0) {
      break;
    }
  }
  p->pfunc(str);
}
########################rank 5#############################
int parse_string(char *val, char **t)
{
	char *s = *t;
	if (*s == '"') {
		++s;
		while (*s && *s != '\"') {
			parse_string_char(val++, &s);
		}
		*val = 0;
		if (*s == '"') {
			++s;
			*t = s;
			return 1;
		}
	}
	return 0;
}
########################rank 6#############################
static const char* format_head_string(format_type format)
{
    switch (format)
    {
        case CSV:
            return "%s,%s,%s,%s\n";
        case CLASSIC:
            return "%12s %12s %12s %12s\n\n";
        default:
            return "%12s %12s %12s %12s\n\n";
    }
}
########################rank 7#############################
static void
parse_ranges(struct RangeList *list, const char *value)
{
    unsigned offset = 0;
    unsigned max_offset = (unsigned)strlen(value);
    for (;;) {
        struct Range range;
        range = range_parse_ipv4(value, &offset, max_offset);
        if (range.end < range.begin) {
            fprintf(stderr, "FAIL: bad IP address/range: %s\n", value);
            my_exit(1);
        }
        rangelist_add_range(list, range.begin, range.end);
        if (offset >= max_offset || value[offset] != ',')
            break;
        else
            offset++; /* skip comma */
    }
}
########################rank 8#############################
void UnistdIsatty(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)
{
    ReturnValue->Val->Integer = isatty(Param[0]->Val->Integer);
}
########################rank 9#############################
void UnistdLseek(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)
{
    ReturnValue->Val->Integer = lseek(Param[0]->Val->Integer, Param[1]->Val->Integer, Param[2]->Val->Integer);
}
########################rank 10#############################
static const char* format_head_string(format_type format)
{
    switch (format)
    {
        case CSV:
            return "%s,%s,%s,%s\n";
        case CLASSIC:
            return "%12s %12s %12s %12s\n\n";
        default:
            return "%12s %12s %12s %12s\n\n";
    }
}
----------------------------QUERY-------------------------------
judge whether two strings are equal
########################rank 1#############################
int ss_cmp(const srt_string *s1, const srt_string *s2)
{
	return ss_ncmp(s1, 0, s2, get_cmp_size(s1, s2));
}
########################rank 2#############################
int _cmp(const void *hr1, const void *hr2)
{
    hostrange_t *h1 = (hostrange_t *) hr1;
    hostrange_t *h2 = (hostrange_t *) hr2;
    return hostrange_cmp((hostrange_t) * h1, (hostrange_t) * h2);
}
########################rank 3#############################
int 
ix_max(const int *ix, const int *end)
{
    int max1 = 0, max2 = 0;
    do {
	int x1 = *ix++;
	int x2 = *ix++;
	if (max1 < x1) 
	    max1 = x1;
	if (max2 < x2) 
	    max2 = x2;
    } while (ix < end);
    if (max1 < max2) 
	max1 = max2;
    return max1;
}
########################rank 4#############################
int strcmp(char s1[], char s2[]) {
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
        if (s1[i] == '\0') return 0;
    }
    return s1[i] - s2[i];
}
########################rank 5#############################
const char * memrstr(const char *hay, const char *need, size_t haylen)
{
  size_t nl = strlen(need);
  int i = (int)(nl - haylen);
  while (i > -1) {
    if (hay[i] == *need && 0 == memcmp(hay+i, need, nl))
      goto found;
    i--;
  }
found:
  return (i > -1 ? hay+i : NULL);
}
########################rank 6#############################
static int
streqn(const char *s1, const char *s2)
{
	if (s1 == NULL)
		s1 = "";
	if (s2 == NULL)
		s2 = "";
	if (s1 == s2)
		return (1);
	return (strcmp(s1, s2) == 0);
}
########################rank 7#############################
static int ilog2(int n) {
    int nn, lg;
    if (n == 1) {
	return 0;
    }
    lg = 1;
    nn = 2;
    while (nn < n) {
	nn = nn << 1;
	lg++;
    }
    return lg;
}
########################rank 8#############################
int compute_char(void)
{
  char x = 1;
  int i = 0;
  while (x)
    {
      x = x << 1;   // shift left by 1 bit
      ++i;
    }
  return (i / 8);  // transform bits in bytes
}
########################rank 9#############################
int
namesort(p1, p2)
	char	**p1;
	char	**p2;
{
	return strcmp(*p2, *p1);
}
########################rank 10#############################
int
untabify(s1,s2,max) char * s1, * s2; int max; {
    int i, j, k, x, z;
    x = strlen(s1);
    for (i = 0, k = 0; k < x; k++) {
	if (s1[k] != '\t') {
	    if (i >= max-1) {
		s2[max-1] = '\0';
		return(-1);
	    }
	    s2[i++] = s1[k];
	    continue;
	}
	z = 8 - i%8;
	if (z == 0) z = 8;
	for (j = 0; j < z && i < max; j++)
	  s2[i++] = ' ';
    }
    s2[i] = '\0';
    return(0);
}
----------------------------QUERY-------------------------------
recursively count children of object
########################rank 1#############################
static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
                          JSGCObjectTypeEnum type)
{
    h->mark = 0;
    h->gc_obj_type = type;
    list_add_tail(&h->link, &rt->gc_obj_list);
}
########################rank 2#############################
static void XMLCALL
start_element_fail(void *userData,
                   const XML_Char *name, const XML_Char **atts)
{
    fail("should never reach start_element_fail()");
}
########################rank 3#############################
void List_setSize_(List *self, size_t index)
{
	List_ifNeededSizeTo_(self, index);
	self->size = index;
}
########################rank 4#############################
int mlt_deque_push_back_int( mlt_deque self, int item )
{
	int error = mlt_deque_allocate( self );
	if ( error == 0 )
		self->list[ self->count ++ ].value = item;
	return error;
}
########################rank 5#############################
void List_setSize_(List *self, size_t index)
{
	List_ifNeededSizeTo_(self, index);
	self->size = index;
}
########################rank 6#############################
void EmptyTheList(List * plist)
{
	plist->items=0;
}
########################rank 7#############################
BOOL APIENTRY binn_is_container(binn *item) {
  if (item == NULL) return FALSE;
  switch (item->type) {
  case BINN_LIST:
  case BINN_MAP:
  case BINN_OBJECT:
    return TRUE;
  default:
    return FALSE;
  }
}
########################rank 8#############################
void
lstackDestroy(L_STACK  **plstack,
              l_int32    freeflag)
{
void     *item;
L_STACK  *lstack;
    PROCNAME("lstackDestroy");
    if (plstack == NULL) {
        L_WARNING("ptr address is NULL", procName);
        return;
    }
    if ((lstack = *plstack) == NULL)
        return;
    if (freeflag) {
        while(lstack->n > 0) {
            item = lstackRemove(lstack);
            FREE(item);
        }
    }
    else if (lstack->n > 0)
        L_WARNING_INT("memory leak of %d items in lstack", procName, lstack->n);
    if (lstack->auxstack)
        lstackDestroy(&lstack->auxstack, freeflag);
    if (lstack->array)
        FREE(lstack->array);
    FREE(lstack);
    *plstack = NULL;
}
########################rank 9#############################
BOOL APIENTRY binn_object_set_new(binn *obj, char *key, binn *value) {
  BOOL retval;
  retval = binn_object_set_value(obj, key, value);
  if (value) free_fn(value);
  return retval;
}
########################rank 10#############################
void b3dRemapAttributes(B3DAttrAllocList *list, int attrOffset)
{
	int i;
	for(i=0; i < list->size; i++) {
		B3DPrimitiveAttribute *attr = list->data + i;
		if(attr->next)
			attr->next = (B3DPrimitiveAttribute *)((char*) attr->next + attrOffset);
	}
}
----------------------------QUERY-------------------------------
get image color depth
########################rank 1#############################
void image_hflip(const RGB32 *src, RGB32 *dest, int width, int height)
{
	int x, y;
	src += width - 1;
	for(y=0; y<height; y++) {
		for(x=0; x<width; x++) {
			*dest++ = *src--;
		}
		src += width * 2;
	}
}
########################rank 2#############################
void WritePCXfile(char *filename, byte *data, int width, int height, byte *palette)
{
  int i, j, length;
  pcx_t *pcx;
  byte *pack;
  pcx = malloc(width * height * 2 + 1000);
  memset(pcx, 0, sizeof(*pcx));
  pcx->manufacturer = 0x0a; // PCX id
  pcx->version = 5;         // 256 color
  pcx->encoding = 1;        // uncompressed
  pcx->bits_per_pixel = 8;  // 256 color
  pcx->xmin = 0;
  pcx->ymin = 0;
  pcx->xmax = LittleShort((short) (width - 1));
  pcx->ymax = LittleShort((short) (height - 1));
  pcx->hres = LittleShort((short) width);
  pcx->vres = LittleShort((short) height);
  pcx->color_planes = 1; // chunky image
  pcx->bytes_per_line = LittleShort((short) width);
  pcx->palette_type = LittleShort(2); // not a grey scale
  // pack the image
  pack = &pcx->data;
  for (i = 0; i < height; i++) {
    for (j = 0; j < width; j++) {
      if ((*data & 0xc0) != 0xc0)
        *pack++ = *data++;
      else {
        *pack++ = 0xc1;
        *pack++ = *data++;
      }
    }
  }
  // write the palette
  *pack++ = 0x0c; // palette ID byte
  for (i = 0; i < 768; i++)
    *pack++ = *palette++;
  // write output file
  length = pack - (byte *) pcx;
  SaveFile(filename, pcx, length);
  free(pcx);
}
########################rank 3#############################
void bmp_get_size(struct bmp_decdata *bmp, int *width, int *height)
{
    *width = bmp->width;
    *height = bmp->height;
}
########################rank 4#############################
void bmp_get_size(struct bmp_decdata *bmp, int *width, int *height)
{
    *width = bmp->width;
    *height = bmp->height;
}
########################rank 5#############################
void bmp_get_size(struct bmp_decdata *bmp, int *width, int *height)
{
    *width = bmp->width;
    *height = bmp->height;
}
########################rank 6#############################
bool lv_img_color_format_has_alpha(lv_img_cf_t cf)
{
    bool has_alpha = false;
    switch(cf) {
        case LV_IMG_CF_TRUE_COLOR_ALPHA:
        case LV_IMG_CF_RAW_ALPHA:
        case LV_IMG_CF_ALPHA_1BIT:
        case LV_IMG_CF_ALPHA_2BIT:
        case LV_IMG_CF_ALPHA_4BIT:
        case LV_IMG_CF_ALPHA_8BIT: has_alpha = true; break;
        default: has_alpha = false; break;
    }
    return has_alpha;
}
########################rank 7#############################
void lv_draw_img(const lv_area_t * coords, const lv_area_t * mask, const void * src, const lv_style_t * style,
                 lv_opa_t opa_scale)
{
    if(src == NULL) {
        LV_LOG_WARN("Image draw: src is NULL");
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL, -1, -1, NULL);
        return;
    }
    lv_res_t res;
    res = lv_img_draw_core(coords, mask, src, style, opa_scale);
    if(res == LV_RES_INV) {
        LV_LOG_WARN("Image draw error");
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL, -1, -1, NULL);
        return;
    }
}
########################rank 8#############################
struct rect nothing()
{
    struct rect r;
    r.llx = r.lly = 0;
    r.color = 0xFF00FF;
    r.width = 10;
    r.height = 20;  
    return r;
}
########################rank 9#############################
void u8g2_ClearBuffer(u8g2_t *u8g2)
{
  size_t cnt;
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
  cnt *= u8g2->tile_buf_height;
  cnt *= 8;
  memset(u8g2->tile_buf_ptr, 0, cnt);
}
########################rank 10#############################
l_int32
pixBlendInRect(PIX       *pixs,
               BOX       *box,
               l_uint32   val,
               l_float32  fract)
{
l_int32    i, j, bx, by, bw, bh, w, h, wpls;
l_int32    prval, pgval, pbval, rval, gval, bval;
l_uint32   val32;
l_uint32  *datas, *lines;
    PROCNAME("pixBlendInRect");
    if (!pixs || pixGetDepth(pixs) != 32)
        return ERROR_INT("pixs not defined or not 32 bpp", procName, 1);
    if (!box)
        return ERROR_INT("box not defined", procName, 1);
    boxGetGeometry(box, &bx, &by, &bw, &bh);
    pixGetDimensions(pixs, &w, &h, NULL);
    datas = pixGetData(pixs);
    wpls = pixGetWpl(pixs);
    extractRGBValues(val, &rval, &gval, &bval);
    for (i = 0; i < bh; i++) {   /* scan over box */
        if (by + i < 0 || by + i >= h) continue;
        lines = datas + (by + i) * wpls;
        for (j = 0; j < bw; j++) {
            if (bx + j < 0 || bx + j >= w) continue;
            val32 = *(lines + bx + j);
            extractRGBValues(val32, &prval, &pgval, &pbval);
            prval = (l_int32)((1. - fract) * prval + fract * rval);
            pgval = (l_int32)((1. - fract) * pgval + fract * gval);
            pbval = (l_int32)((1. - fract) * pbval + fract * bval);
            composeRGBPixel(prval, pgval, pbval, &val32);
            *(lines + bx + j) = val32;
        }
    }
    return 0;
}
----------------------------QUERY-------------------------------
return all ports for one ip in a list
########################rank 1#############################
void CL_Reconnect_f( void ) {
	if ( !strlen( cls.servername ) || !strcmp( cls.servername, "localhost" ) ) {
		Com_Printf( "Can't reconnect to localhost.\n" );
		return;
	}
	Cbuf_AddText( va( "connect %s\n", cls.servername ) );
}
########################rank 2#############################
void CL_Reconnect_f( void ) {
	if ( !strlen( cls.servername ) || !strcmp( cls.servername, "localhost" ) ) {
		Com_Printf( "Can't reconnect to localhost.\n" );
		return;
	}
	Cbuf_AddText( va( "connect %s\n", cls.servername ) );
}
########################rank 3#############################
void NET_OpenIP( void ) {
	int		i;
	int		err;
	int		port;
	int		port6;
	net_ip = Cvar_Get( "net_ip", "0.0.0.0", CVAR_LATCH );
	net_ip6 = Cvar_Get( "net_ip6", "::", CVAR_LATCH );
	net_port = Cvar_Get( "net_port", va( "%i", PORT_SERVER ), CVAR_LATCH );
	net_port6 = Cvar_Get( "net_port6", va( "%i", PORT_SERVER ), CVAR_LATCH );
	port = net_port->integer;
	port6 = net_port6->integer;
	NET_GetLocalAddress();
	// automatically scan for a valid port, so multiple
	// dedicated servers can be started without requiring
	// a different net_port for each one
	if(net_enabled->integer & NET_ENABLEV6)
	{
		for( i = 0 ; i < 10 ; i++ )
		{
			ip6_socket = NET_IP6Socket(net_ip6->string, port6 + i, &boundto, &err);
			if (ip6_socket != INVALID_SOCKET)
			{
				Cvar_SetValue( "net_port6", port6 + i );
				break;
			}
			else
			{
				if(err == EAFNOSUPPORT)
					break;
			}
		}
		if(ip6_socket == INVALID_SOCKET)
			Com_Printf( "WARNING: Couldn't bind to a v6 ip address.\n");
	}
	if(net_enabled->integer & NET_ENABLEV4)
	{
		for( i = 0 ; i < 10 ; i++ ) {
			ip_socket = NET_IPSocket( net_ip->string, port + i, &err );
			if (ip_socket != INVALID_SOCKET) {
				Cvar_SetValue( "net_port", port + i );
				if (net_socksEnabled->integer)
					NET_OpenSocks( port + i );
				break;
			}
			else
			{
				if(err == EAFNOSUPPORT)
					break;
			}
		}
		if(ip_socket == INVALID_SOCKET)
			Com_Printf( "WARNING: Couldn't bind to a v4 ip address.\n");
	}
}
########################rank 4#############################
void Netchan_Init( int port ) {
	port &= 0xffff;
	showpackets = Cvar_Get( "showpackets", "0", CVAR_TEMP );
	showdrop = Cvar_Get( "showdrop", "0", CVAR_TEMP );
	qport = Cvar_Get( "net_qport", va( "%i", port ), CVAR_INIT );
}
########################rank 5#############################
void DNS_time_handler(void)
{
	dns_1s_tick++;
}
########################rank 6#############################
char *s_home(HttpRequest *r) {
    return "<h1>home</h1>";
}
########################rank 7#############################
void Netchan_Init( int port ) {
	port &= 0xffff;
	showpackets = Cvar_Get( "showpackets", "0", CVAR_TEMP );
	showdrop = Cvar_Get( "showdrop", "0", CVAR_TEMP );
	qport = Cvar_Get( "net_qport", va( "%i", port ), CVAR_INIT );
}
########################rank 8#############################
void
do_cd(argc, argv)
	char	**argv;
{
	char	*path;
	if (argc > 1)
		path = argv[1];
	else {
		path = getenv("HOME");
		if (path == NULL) {
			fprintf(stderr, "No HOME environment variable\n");
			return;
		}
	}
	if (chdir(path) < 0)
		perror(path);
}
########################rank 9#############################
void *fxp_get_userdata(struct sftp_request *req)
{
    return req->userdata;
}
########################rank 10#############################
void get_info(char * output)
{
    int pos = 0;
    char line_buffer[512];
    sprintf(line_buffer,"======= mproxy (v0.1) ========\n");
    int len = strlen(line_buffer);
    memcpy(output,line_buffer,len);
    pos += len ;
    sprintf(line_buffer,"%s\n",get_work_mode());
    len = strlen(line_buffer);
    memcpy(output + pos,line_buffer,len);
    pos += len;
    if(strlen(remote_host) > 0) 
    {
        sprintf(line_buffer,"start server on %d and next hop is %s:%d\n",local_port,remote_host,remote_port);
    } else 
    {
        sprintf(line_buffer,"start server on %d\n",local_port);
    }
    len = strlen(line_buffer);
    memcpy(output+ pos,line_buffer,len);
    pos += len ;
    output[pos] = '\0';
}
----------------------------QUERY-------------------------------
fetch next event in queue
########################rank 1#############################
void LAN_LoadCachedServers() {
	int size;
	fileHandle_t fileIn;
	cls.numglobalservers = cls.nummplayerservers = cls.numfavoriteservers = 0;
	cls.numGlobalServerAddresses = 0;
	if ( FS_SV_FOpenFileRead( "servercache.dat", &fileIn ) ) {
		FS_Read( &cls.numglobalservers, sizeof( int ), fileIn );
		FS_Read( &cls.nummplayerservers, sizeof( int ), fileIn );
		FS_Read( &cls.numfavoriteservers, sizeof( int ), fileIn );
		FS_Read( &size, sizeof( int ), fileIn );
		if ( size == sizeof( cls.globalServers ) + sizeof( cls.favoriteServers ) + sizeof( cls.mplayerServers ) ) {
			FS_Read( &cls.globalServers, sizeof( cls.globalServers ), fileIn );
			FS_Read( &cls.mplayerServers, sizeof( cls.mplayerServers ), fileIn );
			FS_Read( &cls.favoriteServers, sizeof( cls.favoriteServers ), fileIn );
		} else {
			cls.numglobalservers = cls.nummplayerservers = cls.numfavoriteservers = 0;
			cls.numGlobalServerAddresses = 0;
		}
		FS_FCloseFile( fileIn );
	}
}
########################rank 2#############################
void EventSync(void)
{
  NOOP;
}
########################rank 3#############################
int FCGX_Accept_r(FCGX_Request *reqDataPtr)
{
    if (!libInitialized) {
        return -9998;
    }
//    FCGX_Finish_r(reqDataPtr);
    for (;;) {
         * If a connection isn't open, accept a new connection (blocking).
         * If an OS error occurs in accepting the connection,
         * return -1 to the caller, who should exit.
         */
        if (reqDataPtr->ipcFd < 0) {
            int fail_on_intr = reqDataPtr->flags & FCGI_FAIL_ACCEPT_ON_INTR;
            reqDataPtr->ipcFd = OS_Accept(reqDataPtr->listen_sock, fail_on_intr, webServerAddressList);
            if (reqDataPtr->ipcFd < 0) {
                return (errno > 0) ? (0 - errno) : -9999;
            }
        }
         * A connection is open.  Read from the connection in order to
         * get the request's role and environment.  If protocol or other
         * errors occur, close the connection and try again.
         */
        reqDataPtr->isBeginProcessed = FALSE;
        reqDataPtr->in = NewReader(reqDataPtr, 8192, 0);
        FillBuffProc(reqDataPtr->in);
        if(!reqDataPtr->isBeginProcessed) {
            goto TryAgain;
        }
        {
            char *roleStr;
            switch(reqDataPtr->role) {
                case FCGI_RESPONDER:
                    roleStr = "FCGI_ROLE=RESPONDER";
                    break;
                case FCGI_AUTHORIZER:
                    roleStr = "FCGI_ROLE=AUTHORIZER";
                    break;
                case FCGI_FILTER:
                    roleStr = "FCGI_ROLE=FILTER";
                    break;
                default:
                    goto TryAgain;
            }
            reqDataPtr->paramsPtr = NewParams(30);
            PutParam(reqDataPtr->paramsPtr, StringCopy(roleStr));
        }
        SetReaderType(reqDataPtr->in, FCGI_PARAMS);
        if(ReadParams(reqDataPtr->paramsPtr, reqDataPtr->in) >= 0) {
             * Finished reading the environment.  No errors occurred, so
             * leave the connection-retry loop.
             */
            break;
        }
         * Close the connection and try again.
         */
TryAgain:
        FCGX_Free(reqDataPtr, 1);
    } /* for (;;) */
     * Build the remaining data structures representing the new
     * request and return successfully to the caller.
     */
    SetReaderType(reqDataPtr->in, FCGI_STDIN);
    reqDataPtr->out = NewWriter(reqDataPtr, 8192, FCGI_STDOUT);
    reqDataPtr->err = NewWriter(reqDataPtr, 512, FCGI_STDERR);
    reqDataPtr->nWriters = 2;
    reqDataPtr->envp = reqDataPtr->paramsPtr->vec;
    return 0;
}
########################rank 4#############################
void mlt_events_unblock( mlt_properties self, void *service )
{
	mlt_events events = mlt_events_fetch( self );
	if ( events != NULL )
	{
		int i = 0, j = 0;
		mlt_properties list = events->list;
		for ( j = 0; j < mlt_properties_count( list ); j ++ )
		{
			char *temp = mlt_properties_get_name( list, j );
			if ( !strncmp( temp, "list:", 5 ) )
			{
				mlt_properties listeners = mlt_properties_get_data( list, temp, NULL );
				for ( i = 0; i < mlt_properties_count( listeners ); i ++ )
				{
					mlt_event entry = mlt_properties_get_data_at( listeners, i, NULL );
					if ( entry != NULL && entry->service == service )
						mlt_event_unblock( entry );
				}
			}
		}
	}
}
########################rank 5#############################
void zlog_thread_del(zlog_thread_t * a_thread)
{
	zc_assert(a_thread,);
	if (a_thread->mdc)
		zlog_mdc_del(a_thread->mdc);
	if (a_thread->event)
		zlog_event_del(a_thread->event);
	if (a_thread->pre_path_buf)
		zlog_buf_del(a_thread->pre_path_buf);
	if (a_thread->path_buf)
		zlog_buf_del(a_thread->path_buf);
	if (a_thread->archive_path_buf)
		zlog_buf_del(a_thread->archive_path_buf);
	if (a_thread->pre_msg_buf)
		zlog_buf_del(a_thread->pre_msg_buf);
	if (a_thread->msg_buf)
		zlog_buf_del(a_thread->msg_buf);
	free(a_thread);
	zc_debug("zlog_thread_del[%p]", a_thread);
	return;
}
########################rank 6#############################
void alarm_handler( int signum ){
    return;
}
########################rank 7#############################
int picoquic_prepare_path_challenge_frame(uint8_t* bytes,
    size_t bytes_max, size_t* consumed, uint64_t challenge)
{
    int ret = 0;
    if (bytes_max < (1 + 8)) {
        ret = PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL;
        *consumed = 0;
    } else {
        bytes[0] = picoquic_frame_type_path_challenge;
        picoformat_64(bytes + 1, challenge);
        *consumed = 1 + 8;
    }
    return ret;
}
########################rank 8#############################
static int bftw_state_destroy(struct bftw_state *state) {
	dstrfree(state->path);
	bftw_release_reader(state, BFTW_VISIT_NONE);
	bftw_release_file(state, BFTW_VISIT_NONE);
	bftw_drain_queue(state, &state->prequeue);
	bftw_drain_queue(state, &state->queue);
	bftw_cache_destroy(&state->cache);
	errno = state->error;
	return state->error ? -1 : 0;
}
########################rank 9#############################
void SV_Web_GameFrame( http_game_query_cb cb ) {
	SV_Web_ReadIncomingQueueCmds( cb );
}
########################rank 10#############################
void KillAllProcs(void)
{
  PROC *Proc;
  Proc = ListFirst(ExecutionQueue);
  while(Proc)
	{
	Proc->EndFrame = FrameCounter;
	Proc = ListNext(ExecutionQueue);
	}
  Proc = ListFirst(ReadyQueue);
  while(Proc)
	{
	  Proc->EndFrame = FrameCounter;
	  Proc = ListNext(ReadyQueue);
	}
  Reschedual();
}
----------------------------QUERY-------------------------------
sort a list using quicksort
########################rank 1#############################
static void
p_b_eclass(struct parse *p, cset *cs)
{
	char c;
	c = p_b_coll_elem(p, '=');
	CHadd(cs, c);
}
########################rank 2#############################
static void
p_b_eclass(p, cs)
register struct parse *p;
register cset *cs;
{
	register char c;
	c = p_b_coll_elem(p, '=');
	CHadd(cs, c);
}
########################rank 3#############################
PQkey pqExtractMin( PriorityQ *pq )
{
	PQkey sortMin, heapMin;
	if( pq->size == 0 ) {
		return pqHeapExtractMin( pq->heap );
	}
	sortMin = *(pq->order[pq->size-1]);
	if( ! pqHeapIsEmpty( pq->heap )) {
		heapMin = pqHeapMinimum( pq->heap );
		if( LEQ( heapMin, sortMin )) {
			return pqHeapExtractMin( pq->heap );
		}
	}
	do {
		-- pq->size;
	} while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL );
	return sortMin;
}
########################rank 4#############################
PQkey pqExtractMin( PriorityQ *pq )
{
	PQkey sortMin, heapMin;
	if( pq->size == 0 ) {
		return pqHeapExtractMin( pq->heap );
	}
	sortMin = *(pq->order[pq->size-1]);
	if( ! pqHeapIsEmpty( pq->heap )) {
		heapMin = pqHeapMinimum( pq->heap );
		if( LEQ( heapMin, sortMin )) {
			return pqHeapExtractMin( pq->heap );
		}
	}
	do {
		-- pq->size;
	} while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL );
	return sortMin;
}
########################rank 5#############################
PQkey pqExtractMin( PriorityQ *pq )
{
	PQkey sortMin, heapMin;
	if( pq->size == 0 ) {
		return pqHeapExtractMin( pq->heap );
	}
	sortMin = *(pq->order[pq->size-1]);
	if( ! pqHeapIsEmpty( pq->heap )) {
		heapMin = pqHeapMinimum( pq->heap );
		if( LEQ( heapMin, sortMin )) {
			return pqHeapExtractMin( pq->heap );
		}
	}
	do {
		-- pq->size;
	} while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL );
	return sortMin;
}
########################rank 6#############################
srt_tree *st_dup(const srt_tree *t)
{
	srt_tree *t2;
	RETURN_IF(!t, NULL);
	t2 = st_alloc(t->cmp_f, t->d.elem_size, t->d.size);
	RETURN_IF(!t2, NULL);
	memcpy(t2, t, t->d.header_size + t->d.size * t->d.elem_size);
	return t2;
}
########################rank 7#############################
static SorterRecord *vdbeSorterMerge(
  SortSubtask *pTask,             /* Calling thread context */
  SorterRecord *p1,               /* First list to merge */
  SorterRecord *p2                /* Second list to merge */
){
  SorterRecord *pFinal = 0;
  SorterRecord **pp = &pFinal;
  int bCached = 0;
  assert( p1!=0 && p2!=0 );
  for(;;){
    int res;
    res = pTask->xCompare(
        pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal
    );
    if( res<=0 ){
      *pp = p1;
      pp = &p1->u.pNext;
      p1 = p1->u.pNext;
      if( p1==0 ){
        *pp = p2;
        break;
      }
    }else{
      *pp = p2;
      pp = &p2->u.pNext;
      p2 = p2->u.pNext;
      bCached = 0;
      if( p2==0 ){
        *pp = p1;
        break;
      }
    }
  }
  return pFinal;
}
########################rank 8#############################
PQkey pqMinimum( PriorityQ *pq )
{
	PQkey sortMin, heapMin;
	if( pq->size == 0 ) {
		return pqHeapMinimum( pq->heap );
	}
	sortMin = *(pq->order[pq->size-1]);
	if( ! pqHeapIsEmpty( pq->heap )) {
		heapMin = pqHeapMinimum( pq->heap );
		if( LEQ( heapMin, sortMin )) {
			return heapMin;
		}
	}
	return sortMin;
}
########################rank 9#############################
PQkey pqMinimum( PriorityQ *pq )
{
	PQkey sortMin, heapMin;
	if( pq->size == 0 ) {
		return pqHeapMinimum( pq->heap );
	}
	sortMin = *(pq->order[pq->size-1]);
	if( ! pqHeapIsEmpty( pq->heap )) {
		heapMin = pqHeapMinimum( pq->heap );
		if( LEQ( heapMin, sortMin )) {
			return heapMin;
		}
	}
	return sortMin;
}
########################rank 10#############################
PQkey pqMinimum( PriorityQ *pq )
{
	PQkey sortMin, heapMin;
	if( pq->size == 0 ) {
		return pqHeapMinimum( pq->heap );
	}
	sortMin = *(pq->order[pq->size-1]);
	if( ! pqHeapIsEmpty( pq->heap )) {
		heapMin = pqHeapMinimum( pq->heap );
		if( LEQ( heapMin, sortMin )) {
			return heapMin;
		}
	}
	return sortMin;
}
----------------------------QUERY-------------------------------
get frame size
########################rank 1#############################
static int service_get_frame( mlt_service self, mlt_frame_ptr frame, int index )
{
	mlt_service_base *base = self->local;
	if ( index < base->count )
	{
		mlt_service producer = base->in[ index ];
		if ( producer != NULL )
			return mlt_service_get_frame( producer, frame, index );
	}
	*frame = mlt_frame_init( self );
	return 0;
}
########################rank 2#############################
int
ring_at_mark(Ring *ring)
{
    if (ring->mark == ring->consume) {
	return 1;
    } else {
	return 0;
    }
}
########################rank 3#############################
static int montgomery_normalization(void *a, void *b)
{
   LTC_ARGCHK(a != NULL);
   LTC_ARGCHK(b != NULL);
   return mpi_to_ltc_error(mp_montgomery_calc_normalization(a, b));
}
########################rank 4#############################
static int montgomery_normalization(void *a, void *b) {
    LTC_ARGCHK(a != NULL);
    LTC_ARGCHK(b != NULL);
    return mpi_to_ltc_error(mp_montgomery_calc_normalization(a, b));
}
########################rank 5#############################
static int set_int(void *a, unsigned long b) {
    LTC_ARGCHK(a != NULL);
    return mpi_to_ltc_error(mp_set_int(a, b));
}
########################rank 6#############################
static int set_int(void *a, unsigned long b)
{
   LTC_ARGCHK(a != NULL);
   return mpi_to_ltc_error(mp_set_int(a, b));
}
########################rank 7#############################
static int32_t SyroComp_GetPcm(ReadSample *prp)
{
	int32_t dat;
	if (prp->SampleEndian == LittleEndian) {
		dat = (int32_t)((int8_t)(prp->ptr[1]));
		dat <<= 8;
		dat |= (int32_t)(*prp->ptr);
		prp->ptr += 2;
	} else {
		dat = (int32_t)((int8_t)(*prp->ptr++));
		dat <<= 8;
		dat |= (int32_t)(*prp->ptr++);
	}
	if (prp->bitlen_eff < 16) {
		dat /= (1 << (16 - prp->bitlen_eff));	//replace from  dat >>= (16 - prp->bitlen_eff);
		prp->sum += (uint16_t)(dat << (16 - prp->bitlen_eff));
	} else {
		prp->sum += (uint16_t)dat;
	}
	return dat;
}
########################rank 8#############################
struct smk_bit_t *smk_bs_init(unsigned char *b, const unsigned long size)
{
	struct smk_bit_t *ret = NULL;
	smk_null_check(b);
	smk_malloc(ret,sizeof(struct smk_bit_t));
	ret->bitstream = b;
	ret->size = size;
	ret->byte_num = -1;
	ret->bit_num = 7;
error:
	return ret;
}
########################rank 9#############################
static int invmod(void *a, void *b, void *c) {
    LTC_ARGCHK(a != NULL);
    LTC_ARGCHK(b != NULL);
    LTC_ARGCHK(c != NULL);
    return mpi_to_ltc_error(mp_invmod(a, b, c));
}
########################rank 10#############################
static int lcm(void *a, void *b, void *c) {
    LTC_ARGCHK(a != NULL);
    LTC_ARGCHK(b != NULL);
    LTC_ARGCHK(c != NULL);
    return mpi_to_ltc_error(mp_lcm(a, b, c));
}
----------------------------QUERY-------------------------------
Copy characters from substring to sized buffer
########################rank 1#############################
static int encbase64(char *str, const unsigned char *byte, int n)
{
    const char table[]=
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    int i,j,k,b;
    tracet(4,"encbase64: n=%d\n",n);
    for (i=j=0;i/8<n;) {
        for (k=b=0;k<6;k++,i++) {
            b<<=1; if (i/8<n) b|=(byte[i/8]>>(7-i%8))&0x1;
        }
        str[j++]=table[b];
    }
    while (j&0x3) str[j++]='=';
    str[j]='\0';
    tracet(5,"encbase64: str=%s\n",str);
    return j;
}
########################rank 2#############################
int ss_at(const srt_string *s, size_t off)
{
	size_t ss;
	RETURN_IF(!s, 0);
	ss = ss_size(s);
	return off < ss ? ss_get_buffer_r(s)[off] : 0;
}
########################rank 3#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 4#############################
static void replace_char(char *string, char from, char to, int maxlen)
{
	char *lastchar = string + maxlen;
	while (string) {
		string = strchr(string, from);
		if (string) {
			*string = to;
			if (string >= lastchar)
				return;
		}
	}
}
########################rank 5#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 6#############################
int len(char *s) {
    return strlen(s);
}
########################rank 7#############################
int len(char *s) {
    return strlen(s);
}
########################rank 8#############################
char *
sarrayToString(SARRAY  *sa,
               l_int32  addnlflag)
{
    PROCNAME("sarrayToString");
    if (!sa)
        return (char *)ERROR_PTR("sa not defined", procName, NULL);
    return sarrayToStringRange(sa, 0, 0, addnlflag);
}
########################rank 9#############################
extern int str_len(const struct str * str) {
    return SIZE(str->data);
}
########################rank 10#############################
int xj_jconf_check_addr(str *addr, char dl)
{
	char *p;
	int i;
	if(!addr || !addr->s || addr->len <= 0)
		return -1;
	p = addr->s;
	i= 0;
	while((p < addr->s+addr->len) && *p != '@')
	{
		if(*p==dl)
			i++;
		p++;
	}
	if(i==2 && *p=='@')
		return 0;
	return -1;
}
----------------------------QUERY-------------------------------
add new input object to sorted queue
########################rank 1#############################
int list_for_each(List_t * list, list_item_callback_func cb){
	ListItem_t * nextItem;
	int idx;
	if(!list->head) return(0);
	nextItem = list->head;
	idx = 0;
	while(nextItem){
		cb(idx, nextItem->data);
		nextItem = nextItem->next;
		idx++;
	}
	return(1);
}
########################rank 2#############################
void
lqueueDestroy(L_QUEUE  **plq,
              l_int32    freeflag)
{
void     *item;
L_QUEUE  *lq;
    PROCNAME("lqueueDestroy");
    if (plq == NULL) {
        L_WARNING("ptr address is NULL", procName);
        return;
    }
    if ((lq = *plq) == NULL)
        return;
    if (freeflag) {
        while(lq->nelem > 0) {
            item = lqueueRemove(lq);
            FREE(item);
        }
    }
    else if (lq->nelem > 0)
        L_WARNING_INT("memory leak of %d items in lqueue!",
                      procName, lq->nelem);
    if (lq->array)
        FREE(lq->array);
    if (lq->stack)
        lstackDestroy(&lq->stack, freeflag);
    FREE(lq);
    *plq = NULL;
    return;
}
########################rank 3#############################
int mlt_deque_push_back_int( mlt_deque self, int item )
{
	int error = mlt_deque_allocate( self );
	if ( error == 0 )
		self->list[ self->count ++ ].value = item;
	return error;
}
########################rank 4#############################
void stackDestroy(Stack *stack) {
    if (stack == NULL) return;
    while (size(&stack->queue) > 0) {
        pop(&stack->queue);
    }
}
########################rank 5#############################
static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
                          JSGCObjectTypeEnum type)
{
    h->mark = 0;
    h->gc_obj_type = type;
    list_add_tail(&h->link, &rt->gc_obj_list);
}
########################rank 6#############################
binn * APIENTRY binn_object_next_value(binn_iter *iter, char *pkey) {
  binn *value;
  value = (binn *) binn_malloc(sizeof(binn));
  if (binn_object_next(iter, pkey, value) == FALSE) {
    free_fn(value);
    return NULL;
  }
  value->allocated = TRUE;
  return value;
}
########################rank 7#############################
void
lstackDestroy(L_STACK  **plstack,
              l_int32    freeflag)
{
void     *item;
L_STACK  *lstack;
    PROCNAME("lstackDestroy");
    if (plstack == NULL) {
        L_WARNING("ptr address is NULL", procName);
        return;
    }
    if ((lstack = *plstack) == NULL)
        return;
    if (freeflag) {
        while(lstack->n > 0) {
            item = lstackRemove(lstack);
            FREE(item);
        }
    }
    else if (lstack->n > 0)
        L_WARNING_INT("memory leak of %d items in lstack", procName, lstack->n);
    if (lstack->auxstack)
        lstackDestroy(&lstack->auxstack, freeflag);
    if (lstack->array)
        FREE(lstack->array);
    FREE(lstack);
    *plstack = NULL;
}
########################rank 8#############################
void queuePop(Queue *queue) {
    if (queue == NULL) return;
    if (isEmpty(&queue->out)) {
        while (!isEmpty(&queue->in)) {
            int top = pop(&queue->in);
            push(&queue->out, top);
        }
    }
    pop(&queue->out);
}
########################rank 9#############################
binn * APIENTRY binn_object_value(void *ptr, char *key) {
  binn *value;
  value = (binn *) binn_malloc(sizeof(binn));
  if (binn_object_get_value(ptr, key, value) == FALSE) {
    free_fn(value);
    return NULL;
  }
  value->allocated = TRUE;
  return value;
}
########################rank 10#############################
void
numaDestroy(NUMA  **pna)
{
NUMA  *na;
    PROCNAME("numaDestroy");
    if (pna == NULL) {
        L_WARNING("ptr address is NULL", procName);
        return;
    }
    if ((na = *pna) == NULL)
        return;
    numaChangeRefcount(na, -1);
    if (numaGetRefcount(na) <= 0) {
        if (na->array)
            FREE(na->array);
        FREE(na);
    }
    *pna = NULL;
    return;
}
----------------------------QUERY-------------------------------
clear input buffer
########################rank 1#############################
local void
bi_windup(s)
    deflate_state *s;
{
	if (s->bi_valid > 8) {
		put_short(s, s->bi_buf);
	} else if (s->bi_valid > 0) {
		put_byte(s, (Byte)s->bi_buf);
	}
	s->bi_buf = 0;
	s->bi_valid = 0;
#ifdef DEBUG_ZLIB
	s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}
########################rank 2#############################
static void generate_unit_start(struct generator * g) {
    write_start_comment(g, "{ ", " }");
    w(g, "Unit ~n;~N~N{$HINTS OFF}~N~NInterface~N~NUses " BASE_UNIT ";~N");
}
########################rank 3#############################
static ID_INLINE void WRITE_4BYTES( int x )
{
  buffer[ bufIndex + 0 ] = (byte)( ( x >>  0 ) & 0xFF );
  buffer[ bufIndex + 1 ] = (byte)( ( x >>  8 ) & 0xFF );
  buffer[ bufIndex + 2 ] = (byte)( ( x >> 16 ) & 0xFF );
  buffer[ bufIndex + 3 ] = (byte)( ( x >> 24 ) & 0xFF );
  bufIndex += 4;
}
########################rank 4#############################
static ID_INLINE void WRITE_2BYTES( int x )
{
  buffer[ bufIndex + 0 ] = (byte)( ( x >>  0 ) & 0xFF );
  buffer[ bufIndex + 1 ] = (byte)( ( x >>  8 ) & 0xFF );
  bufIndex += 2;
}
########################rank 5#############################
static void pad(unsigned char *buf, int len)
{
	for (int i = 0; i < len; i++)
		buf[i] = PADDING_CHAR;
}
########################rank 6#############################
static void assemble_write_tram(struct ivals_context *ctx,
				unsigned int offset,
				unsigned int value)
{
	assemble_write_mmio(ctx, 0x130, SIZE_32BIT, offset);
	assemble_write_mmio(ctx, 0x134, SIZE_32BIT, value);
}
########################rank 7#############################
void SKP_Silk_range_enc_init(
    SKP_Silk_range_coder_state      *psRC               
)
{
    psRC->bufferLength = MAX_ARITHM_BYTES;
    psRC->range_Q16    = 0x0000FFFF;
    psRC->bufferIx     = 0;
    psRC->base_Q32     = 0;
    psRC->error        = 0;
}
########################rank 8#############################
static inline
int fx_write_block(const FX_STATE state, const fx_kind_t kind_in, 
                   const uint32_t len, const void* data){
    const uint16_t kind = kind_in;
    u8 head[] = {'L','Z','F','X',   0, 0,   0, 0, 0, 0};
    head[4] = kind >> 8; head[5] = kind;
    head[6] = len >> 24; head[7] =  len >> 16;
    head[8] = len >> 8; head[9] = len;
    if(fx_write_bytes(state, head, 10) < 0) return -1;
    if(fx_write_bytes(state, data, len) < 0) return -1;
    return 0;
}
########################rank 9#############################
int adbuf_addchar(struct adbuf *b, int c)
{
	if (adbuf_ptr(b) == NULL)
		return 1; /* bad buffer in input */
	if (b->left >= 2) {
		unsigned char *p = (unsigned char*) b->buf + adbuf_used(b);
		*p = c;
		*(p+1) = '\0';
		b->left -= 1;
		return 0;
	} else {
		unsigned char t[1];
		t[0] = c;
		return adbuf_add(b, &t, 1);
	}
	return 0; /* unreached */
}
########################rank 10#############################
local void
bi_flush(s)
    deflate_state *s;
{
	if (s->bi_valid == 16) {
		put_short(s, s->bi_buf);
		s->bi_buf = 0;
		s->bi_valid = 0;
	} else if (s->bi_valid >= 8) {
		put_byte(s, (Byte)s->bi_buf);
		s->bi_buf >>= 8;
		s->bi_valid -= 8;
	}
}
----------------------------QUERY-------------------------------
return random integer value between min and max
########################rank 1#############################
int mpi_mod_mpi( mpi *R, const mpi *A, const mpi *B )
{
    int ret;
    if( mpi_cmp_int( B, 0 ) < 0 )
        return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
    MPI_CHK( mpi_div_mpi( NULL, R, A, B ) );
    while( mpi_cmp_int( R, 0 ) < 0 )
      MPI_CHK( mpi_add_mpi( R, R, B ) );
    while( mpi_cmp_mpi( R, B ) >= 0 )
      MPI_CHK( mpi_sub_mpi( R, R, B ) );
cleanup:
    return( ret );
}
########################rank 2#############################
unsigned int ph7_context_random_num(ph7_context *pCtx)
{
	sxu32 n;
	n = PH7_VmRandomNum(pCtx->pVm);
	return n;
}
########################rank 3#############################
JX9_PRIVATE unsigned int jx9_context_random_num(jx9_context *pCtx)
{
	sxu32 n;
	n = jx9VmRandomNum(pCtx->pVm);
	return n;
}
########################rank 4#############################
static unsigned char equal(unsigned char a, unsigned char b) {
    unsigned char x = a ^ b;
    crypto_uint32 y = x;
    y -= 1;
    y >>= 31;
    return y;
}
########################rank 5#############################
uint8_t bigAddVariableSizeNoModulo(uint8_t *r, uint8_t *op1, uint8_t *op2, uint8_t op_size)
{
	uint16_t partial;
	uint8_t carry;
	uint8_t i;
	carry = 0;
	for (i = 0; i < op_size; i++)
	{
		partial = (uint16_t)((uint16_t)op1[i] + (uint16_t)op2[i] + (uint16_t)carry);
		r[i] = (uint8_t)partial;
		carry = (uint8_t)(partial >> 8);
	}
	return carry;
}
########################rank 6#############################
static int random_val(int min, int max)
{
    double weight = rand()/(double) RAND_MAX;
    int result = min * (1-weight) + max * weight;
    return result;
}
########################rank 7#############################
mp_err mp_invmod(const mp_int *a, const mp_int *b, mp_int *c)
{
   if ((b->sign == MP_NEG) || (mp_cmp_d(b, 1uL) != MP_GT)) {
      return MP_VAL;
   }
   if (MP_HAS(S_MP_INVMOD_FAST) && MP_IS_ODD(b)) {
      return s_mp_invmod_fast(a, b, c);
   }
   return MP_HAS(S_MP_INVMOD_SLOW)
          ? s_mp_invmod_slow(a, b, c)
          : MP_VAL;
}
########################rank 8#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%intrev32ifbe(is->length));
}
########################rank 9#############################
int mbedtls_mpi_sub_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b )
{
    mbedtls_mpi _B;
    mbedtls_mpi_uint p[1];
    p[0] = ( b < 0 ) ? -b : b;
    _B.s = ( b < 0 ) ? -1 : 1;
    _B.n = 1;
    _B.p = p;
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
}
########################rank 10#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%intrev32ifbe(is->length));
}
----------------------------QUERY-------------------------------
send onion packet via TCP and UDP
########################rank 1#############################
void do_net_crypto(Net_Crypto *c, void *userdata)
{
	if (c == nullptr)  // !!!!!!!!!!!!!!!!!
		return;
    kill_timedout(c, userdata);
    do_tcp(c, userdata);
    send_crypto_packets(c);
}
########################rank 2#############################
static int send_onion_packet_tcp_udp(const Onion_Client *onion_c, const Onion_Path *path, IP_Port dest,
                                     const uint8_t *data, uint16_t length)
{
    if (net_family_is_ipv4(path->ip_port1.ip.family) || net_family_is_ipv6(path->ip_port1.ip.family)) {
        uint8_t packet[ONION_MAX_PACKET_SIZE];
        int len = create_onion_packet(packet, sizeof(packet), path, dest, data, length);
        if (len == -1) {
            return -1;
        }
        if (sendpacket(onion_c->net, path->ip_port1, packet, len) != len) {
            return -1;
        }
        return 0;
    }
    if (net_family_is_tcp_family(path->ip_port1.ip.family)) {
        uint8_t packet[ONION_MAX_PACKET_SIZE];
        int len = create_onion_packet_tcp(packet, sizeof(packet), path, dest, data, length);
        if (len == -1) {
            return -1;
        }
        return send_tcp_onion_request(onion_c->c, path->ip_port1.ip.ip.v4.uint32, packet, len);
    }
    return -1;
}
########################rank 3#############################
static void dht_ip_callback(void *object, int32_t number, IP_Port ip_port)
{
    Friend_Connections *const fr_c = (Friend_Connections *)object;
    Friend_Conn *const friend_con = get_conn(fr_c, number);
    if (!friend_con) {
        return;
    }
    if (friend_con->crypt_connection_id == -1) {
        friend_new_connection(fr_c, number);
    }
    set_direct_ip_port(fr_c->net_crypto, friend_con->crypt_connection_id, ip_port, 1);
    friend_con->dht_ip_port = ip_port;
    friend_con->dht_ip_port_lastrecv = mono_time_get(fr_c->mono_time);
    if (friend_con->hosting_tcp_relay) {
        friend_add_tcp_relay(fr_c, number, ip_port, friend_con->dht_temp_pk);
        friend_con->hosting_tcp_relay = 0;
    }
}
########################rank 4#############################
static int handle_TCP_oob_send(TCP_Server *tcp_server, uint32_t con_id, const uint8_t *public_key, const uint8_t *data,
                               uint16_t length)
{
    if (length == 0 || length > TCP_MAX_OOB_DATA_LENGTH) {
        return -1;
    }
    TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[con_id];
    int other_index = get_TCP_connection_index(tcp_server, public_key);
    if (other_index != -1) {
        VLA(uint8_t, resp_packet, 1 + CRYPTO_PUBLIC_KEY_SIZE + length);
        resp_packet[0] = TCP_PACKET_OOB_RECV;
        memcpy(resp_packet + 1, con->public_key, CRYPTO_PUBLIC_KEY_SIZE);
        memcpy(resp_packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, data, length);
        write_packet_TCP_secure_connection(&tcp_server->accepted_connection_array[other_index], resp_packet,
                                           SIZEOF_VLA(resp_packet), 0);
    }
    return 0;
}
########################rank 5#############################
static int generate_handshake(TCP_Client_Connection *tcp_conn)
{
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
    crypto_new_keypair(plain, tcp_conn->temp_secret_key);
    random_nonce(tcp_conn->sent_nonce);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, tcp_conn->sent_nonce, CRYPTO_NONCE_SIZE);
    memcpy(tcp_conn->last_packet, tcp_conn->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    random_nonce(tcp_conn->last_packet + CRYPTO_PUBLIC_KEY_SIZE);
    int len = encrypt_data_symmetric(tcp_conn->shared_key, tcp_conn->last_packet + CRYPTO_PUBLIC_KEY_SIZE, plain,
                                     sizeof(plain), tcp_conn->last_packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);
    if (len != sizeof(plain) + CRYPTO_MAC_SIZE) {
        return -1;
    }
    tcp_conn->last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
    tcp_conn->last_packet_sent = 0;
    return 0;
}
########################rank 6#############################
int send_data(TCP_Client_Connection *con, uint8_t con_id, const uint8_t *data, uint16_t length)
{
    if (con_id >= NUM_CLIENT_CONNECTIONS) {
        return -1;
    }
    if (con->connections[con_id].status != 2) {
        return -1;
    }
    if (tcp_send_ping_response(con) == 0 || tcp_send_ping_request(con) == 0) {
        return 0;
    }
    VLA(uint8_t, packet, 1 + length);
    packet[0] = con_id + NUM_RESERVED_PORTS;
    memcpy(packet + 1, data, length);
    return write_packet_TCP_client_secure_connection(con, packet, SIZEOF_VLA(packet), 0);
}
########################rank 7#############################
int
htsp_tcp_read_data(socket_t fd, char *buf, const size_t bufsize, htsbuf_queue_t *spill)
{
  int x, tot = htsbuf_read(spill, buf, bufsize);
  if(tot == (int)bufsize)
    return 0;
  x = recv(fd, buf + tot, bufsize - tot, MSG_WAITALL);
  if(x != (int)bufsize - tot)
    return -1;
  return 0;
}
########################rank 8#############################
static int packet_queue_grow(packet_queue_t *queue)
{
    if (packet_queue_ensure(queue, queue->packets_size + 1) < 0)
        return -1;
    packet_construct(queue->packets + queue->packets_size);
    ++queue->packets_size;
    return 0;
}
########################rank 9#############################
static int handle_handshake(TCP_Client_Connection *tcp_conn, const uint8_t *data)
{
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
    int len = decrypt_data_symmetric(tcp_conn->shared_key, data, data + CRYPTO_NONCE_SIZE,
                                     TCP_SERVER_HANDSHAKE_SIZE - CRYPTO_NONCE_SIZE, plain);
    if (len != sizeof(plain)) {
        return -1;
    }
    memcpy(tcp_conn->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
    encrypt_precompute(plain, tcp_conn->temp_secret_key, tcp_conn->shared_key);
    crypto_memzero(tcp_conn->temp_secret_key, CRYPTO_SECRET_KEY_SIZE);
    return 0;
}
########################rank 10#############################
void
tcpcon_send_FIN(
    struct TCP_ConnectionTable *tcpcon,
    unsigned ip_me, unsigned ip_them,
    unsigned port_me, unsigned port_them,
    uint32_t seqno_them, uint32_t ackno_them)
{
    struct TCP_Control_Block tcb;
    memset(&tcb, 0, sizeof(tcb));
    tcb.ip_me = ip_me;
    tcb.ip_them = ip_them;
    tcb.port_me = (unsigned short)port_me;
    tcb.port_them = (unsigned short)port_them;
    tcb.seqno_me = ackno_them;
    tcb.ackno_me = seqno_them + 1;
    tcb.seqno_them = seqno_them + 1;
    tcb.ackno_them = ackno_them;
    tcpcon_send_packet(tcpcon, &tcb, 0x11, 0, 0, 0);
}
----------------------------QUERY-------------------------------
log to syslog
########################rank 1#############################
pid_t Fork(void) 
{
    pid_t pid;
    if ((pid = fork()) < 0)
	unix_error("Fork error");
    return pid;
}
########################rank 2#############################
pid_t Fork(void) 
{
    pid_t pid;
    if ((pid = fork()) < 0)
	unix_error("Fork error");
    return pid;
}
########################rank 3#############################
pid_t Fork(void) 
{
    pid_t pid;
    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
########################rank 4#############################
pid_t Fork(void)
{
    pid_t pid;
    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
########################rank 5#############################
void ptrace_detach(pid_t target)
{
	if(ptrace(PTRACE_DETACH, target, NULL, NULL) == -1)
	{
		fprintf(stderr, "ptrace(PTRACE_DETACH) failed\n");
		exit(1);
	}
}
########################rank 6#############################
pid_t Fork(void) 
{
    pid_t pid;
    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
########################rank 7#############################
pid_t Fork(void) 
{
    pid_t pid;
    if ((pid = fork()) < 0)
	unix_error("Fork error");
    return pid;
}
########################rank 8#############################
pid_t Fork(void) 
{
    pid_t pid;
    if ((pid = fork()) < 0)
	unix_error("Fork error");
    return pid;
}
########################rank 9#############################
static bool bfs_stat_retry(int ret, enum bfs_stat_flag flags) {
	return ret != 0
		&& (flags & (BFS_STAT_NOFOLLOW | BFS_STAT_TRYFOLLOW)) == BFS_STAT_TRYFOLLOW
		&& is_nonexistence_error(errno);
}
########################rank 10#############################
void ptrace_cont(pid_t target)
{
	struct timespec* sleeptime = malloc(sizeof(struct timespec));
	sleeptime->tv_sec = 0;
	sleeptime->tv_nsec = 5000000;
	if(ptrace(PTRACE_CONT, target, NULL, NULL) == -1)
	{
		fprintf(stderr, "ptrace(PTRACE_CONT) failed\n");
		exit(1);
	}
	nanosleep(sleeptime, NULL);
	// make sure the target process received SIGTRAP after stopping.
	checktargetsig(target);
}
----------------------------QUERY-------------------------------
build websocket frame for data transmission
########################rank 1#############################
int
htsp_tcp_read_data(socket_t fd, char *buf, const size_t bufsize, htsbuf_queue_t *spill)
{
  int x, tot = htsbuf_read(spill, buf, bufsize);
  if(tot == (int)bufsize)
    return 0;
  x = recv(fd, buf + tot, bufsize - tot, MSG_WAITALL);
  if(x != (int)bufsize - tot)
    return -1;
  return 0;
}
########################rank 2#############################
int initAuthSSL(int hSocket, _MODULE_DATA* _psSessionData)
{
  unsigned char bufSend[BUF_SIZE];
  unsigned char* bufReceive = NULL;
  int nReceiveBufferSize;
  writeError(ERR_NOTICE, "[%s] Establishing Explicit FTPS (FTP/SSL) session.", MODULE_NAME);
  memset(bufSend, 0, BUF_SIZE);
  sprintf((char*)bufSend, "AUTH TLS\r\n");
  if (medusaSend(hSocket, bufSend, strlen((char*)bufSend), 0) < 0)
  {
    writeError(ERR_ERROR, "[%s] failed: medusaSend was not successful", MODULE_NAME);
    return FAILURE;
  }
  nReceiveBufferSize = 0;
  if ((medusaReceiveRegex(hSocket, &bufReceive, &nReceiveBufferSize, "^[0-9]{3,3}-.*\r\n[0-9]{3,3} .*\r\n|^[0-9]{3,3} .*\r\n") == FAILURE) || (bufReceive == NULL))
  {
    writeError(ERR_DEBUG_MODULE, "[%s] failed: Server sent unknown or no response. Exiting...", MODULE_NAME);
    FREE(bufReceive);
    return FAILURE;
  }
  if (strncmp((char*)bufReceive, "234 ", 4) == 0)
  {
    FREE(bufReceive);
    if (medusaConnectSocketSSL(_psSessionData->params, hSocket) < 0)
    {
      writeError(ERR_ERROR, "[%s] Failed to establish SSL connection.", MODULE_NAME);
      return FAILURE;
    }
  }
  else
  {
    writeError(ERR_ERROR, "[%s] Failed to establish SSL connection. Server sent response: %c%c%c", MODULE_NAME, bufReceive[0], bufReceive[1], bufReceive[2]);
    return FAILURE;
  }
  return SUCCESS;
}
########################rank 3#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 4#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 5#############################
void Sys_SendPacket( int length, const void *data, netadr_t to ) {
	int				ret = SOCKET_ERROR;
	struct sockaddr_storage	addr;
	if( to.type != NA_BROADCAST && to.type != NA_IP && to.type != NA_IP6 && to.type != NA_MULTICAST6)
	{
		Com_Error( ERR_FATAL, "Sys_SendPacket: bad address type" );
		return;
	}
	if( (ip_socket == INVALID_SOCKET && to.type == NA_IP) ||
		(ip6_socket == INVALID_SOCKET && to.type == NA_IP6) ||
		(ip6_socket == INVALID_SOCKET && to.type == NA_MULTICAST6) )
		return;
	if(to.type == NA_MULTICAST6 && (net_enabled->integer & NET_DISABLEMCAST))
		return;
	memset(&addr, 0, sizeof(addr));
	NetadrToSockadr( &to, (struct sockaddr *) &addr );
	if( usingSocks && to.type == NA_IP ) {
		socksBuf[0] = 0;	// reserved
		socksBuf[1] = 0;
		socksBuf[2] = 0;	// fragment (not fragmented)
		socksBuf[3] = 1;	// address type: IPV4
		*(int *)&socksBuf[4] = ((struct sockaddr_in *)&addr)->sin_addr.s_addr;
		*(short *)&socksBuf[8] = ((struct sockaddr_in *)&addr)->sin_port;
		memcpy( &socksBuf[10], data, length );
		ret = sendto( ip_socket, socksBuf, length+10, 0, &socksRelayAddr, sizeof(socksRelayAddr) );
	}
	else {
		if(addr.ss_family == AF_INET)
			ret = sendto( ip_socket, data, length, 0, (struct sockaddr *) &addr, sizeof(struct sockaddr_in) );
		else if(addr.ss_family == AF_INET6)
			ret = sendto( ip6_socket, data, length, 0, (struct sockaddr *) &addr, sizeof(struct sockaddr_in6) );
	}
	if( ret == SOCKET_ERROR ) {
		int err = socketError;
		// wouldblock is silent
		if( err == EAGAIN ) {
			return;
		}
		// some PPP links do not allow broadcasts and return an error
		if( ( err == EADDRNOTAVAIL ) && ( ( to.type == NA_BROADCAST ) ) ) {
			return;
		}
		Com_Printf( "NET_SendPacket: %s\n", NET_ErrorString() );
	}
}
########################rank 6#############################
static int WebSocket_buildFrame(networkHandles* net, int opcode, int mask_data,
	char* buf0, size_t buf0len, int count, char** buffers, size_t* buflens)
{
	int i;
	int buf_len = 0u;
	size_t data_len = buf0len;
	FUNC_ENTRY;
	for (i = 0; i < count; ++i)
		data_len += buflens[i];
	buf0 -= WebSocket_calculateFrameHeaderSize(net, mask_data, data_len);
	if ( net->websocket )
	{
		uint8_t mask[4];
#if defined(OPENSSL)
		RAND_bytes( &mask[0], sizeof(mask) );
#else /* if defined(OPENSSL) */
		mask[0] = (rand() % UINT8_MAX);
		mask[1] = (rand() % UINT8_MAX);
		mask[2] = (rand() % UINT8_MAX);
		mask[3] = (rand() % UINT8_MAX);
#endif /* else if defined(OPENSSL) */
		buf0[buf_len] = (char)(1 << 7); /* final flag */
		buf0[buf_len] |= (char)(opcode & 0x0F); /* op code */
		++buf_len;
		buf0[buf_len] = (char)((mask_data & 0x1) << 7); /* masking bit */
		if ( data_len < 126u )
			buf0[buf_len++] |= data_len & 0x7F;
		else if ( data_len < 65536u )
		{
			uint16_t len = htobe16((uint16_t)data_len);
			buf0[buf_len++] |= (126u & 0x7F);
			memcpy( &buf0[buf_len], &len, 2u );
			buf_len += 2;
		}
		else if ( data_len < 0xFFFFFFFFFFFFFFFF )
		{
			uint64_t len = htobe64((uint64_t)data_len);
			buf0[buf_len++] |= (127u & 0x7F);
			memcpy( &buf0[buf_len], &len, 8 );
			buf_len += 8;
		}
		else
		{
			Log(TRACE_PROTOCOL, 1, "Data too large for websocket frame" );
			buf_len = -1;
		}
		if ( (mask_data & 0x1) && buf_len > 0 )
		{
			memcpy( &buf0[buf_len], &mask, sizeof(uint32_t));
			buf_len += sizeof(uint32_t);
		}
		if ( mask_data & 0x1 )
		{
			size_t idx = 0u;
			for (i = 0; i < (int)buf0len; ++i, ++idx)
				buf0[buf_len + i] ^= mask[idx % 4];
			for (i = 0; i < count; ++i)
			{
				size_t j;
				for ( j = 0u; j < buflens[i]; ++j, ++idx )
					buffers[i][j] ^= mask[idx % 4];
			}
		}
	}
	FUNC_EXIT_RC(buf_len);
	return buf_len;
}
########################rank 7#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 8#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 9#############################
static int handle_TCP_handshake(TCP_Secure_Connection *con, const uint8_t *data, uint16_t length,
                                const uint8_t *self_secret_key)
{
    if (length != TCP_CLIENT_HANDSHAKE_SIZE) {
        return -1;
    }
    if (con->status != TCP_STATUS_CONNECTED) {
        return -1;
    }
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    encrypt_precompute(data, self_secret_key, shared_key);
    uint8_t plain[TCP_HANDSHAKE_PLAIN_SIZE];
    int len = decrypt_data_symmetric(shared_key, data + CRYPTO_PUBLIC_KEY_SIZE,
                                     data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE, plain);
    if (len != TCP_HANDSHAKE_PLAIN_SIZE) {
        return -1;
    }
    memcpy(con->public_key, data, CRYPTO_PUBLIC_KEY_SIZE);
    uint8_t temp_secret_key[CRYPTO_SECRET_KEY_SIZE];
    uint8_t resp_plain[TCP_HANDSHAKE_PLAIN_SIZE];
    crypto_new_keypair(resp_plain, temp_secret_key);
    random_nonce(con->sent_nonce);
    memcpy(resp_plain + CRYPTO_PUBLIC_KEY_SIZE, con->sent_nonce, CRYPTO_NONCE_SIZE);
    memcpy(con->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
    uint8_t response[TCP_SERVER_HANDSHAKE_SIZE];
    random_nonce(response);
    len = encrypt_data_symmetric(shared_key, response, resp_plain, TCP_HANDSHAKE_PLAIN_SIZE,
                                 response + CRYPTO_NONCE_SIZE);
    if (len != TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
        return -1;
    }
    if (TCP_SERVER_HANDSHAKE_SIZE != net_send(con->sock, response, TCP_SERVER_HANDSHAKE_SIZE)) {
        return -1;
    }
    encrypt_precompute(plain, temp_secret_key, con->shared_key);
    con->status = TCP_STATUS_UNCONFIRMED;
    return 1;
}
########################rank 10#############################
static int handle_handshake(TCP_Client_Connection *tcp_conn, const uint8_t *data)
{
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
    int len = decrypt_data_symmetric(tcp_conn->shared_key, data, data + CRYPTO_NONCE_SIZE,
                                     TCP_SERVER_HANDSHAKE_SIZE - CRYPTO_NONCE_SIZE, plain);
    if (len != sizeof(plain)) {
        return -1;
    }
    memcpy(tcp_conn->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
    encrypt_precompute(plain, tcp_conn->temp_secret_key, tcp_conn->shared_key);
    crypto_memzero(tcp_conn->temp_secret_key, CRYPTO_SECRET_KEY_SIZE);
    return 0;
}
----------------------------QUERY-------------------------------
free memory for all traps on grid
########################rank 1#############################
void square_free_trap(struct chunk *c, struct loc grid)
{
	struct trap *next, *trap = square_trap(c, grid);
	while (trap) {
		next = trap->next;
		mem_free(trap);
		trap = next;
	}
}
########################rank 2#############################
static void project_feature_handler_DARK_WEAK(project_feature_handler_context_t *context)
{
	const struct loc grid = context->grid;
	if ((player->depth != 0 || !is_daytime()) && !square_isbright(cave, grid)) {
		sqinfo_off(square(cave, grid).info, SQUARE_GLOW);
	}
	if (square_isview(cave, grid)) {
		context->obvious = true;
		player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
	}
}
########################rank 3#############################
void PlayerModel_Cache( void )
{
	int	i;
	for( i = 0; playermodel_artlist[i]; i++ ) {
		trap_R_RegisterShaderNoMip( playermodel_artlist[i] );
	}
	PlayerModel_BuildList();
	for( i = 0; i < s_playermodel.nummodels; i++ ) {
		trap_R_RegisterShaderNoMip( s_playermodel.modelnames[i] );
	}
}
########################rank 4#############################
void PlayerModel_Cache( void )
{
	int	i;
	for( i = 0; playermodel_artlist[i]; i++ ) {
		trap_R_RegisterShaderNoMip( playermodel_artlist[i] );
	}
	PlayerModel_BuildList();
	for( i = 0; i < s_playermodel.nummodels; i++ ) {
		trap_R_RegisterShaderNoMip( s_playermodel.modelnames[i] );
	}
}
########################rank 5#############################
void SpecifyLeague_Cache( void )
{
	int	i;
	// touch all our pics
	for (i=0; ;i++)
	{
		if (!specifyleague_artlist[i])
			break;
		trap_R_RegisterShaderNoMip(specifyleague_artlist[i]);
	}
}
########################rank 6#############################
void CL_GameModule_AddViewAngles( vec3_t viewAngles ) {
	if( cge ) {
		cge->AddViewAngles( viewAngles );
	}
}
########################rank 7#############################
void SpecifyLeague_Cache( void )
{
	int	i;
	// touch all our pics
	for (i=0; ;i++)
	{
		if (!specifyleague_artlist[i])
			break;
		trap_R_RegisterShaderNoMip(specifyleague_artlist[i]);
	}
}
########################rank 8#############################
void UI_BotSelectMenu_Cache( void ) {
	trap_R_RegisterShaderNoMip( BOTSELECT_BACK0 );
	trap_R_RegisterShaderNoMip( BOTSELECT_BACK1 );
	trap_R_RegisterShaderNoMip( BOTSELECT_ACCEPT0 );
	trap_R_RegisterShaderNoMip( BOTSELECT_ACCEPT1 );
	trap_R_RegisterShaderNoMip( BOTSELECT_SELECT );
	trap_R_RegisterShaderNoMip( BOTSELECT_SELECTED );
	trap_R_RegisterShaderNoMip( BOTSELECT_ARROWS );
	trap_R_RegisterShaderNoMip( BOTSELECT_ARROWSL );
	trap_R_RegisterShaderNoMip( BOTSELECT_ARROWSR );
}
########################rank 9#############################
void UI_BotSelectMenu_Cache( void ) {
	trap_R_RegisterShaderNoMip( BOTSELECT_BACK0 );
	trap_R_RegisterShaderNoMip( BOTSELECT_BACK1 );
	trap_R_RegisterShaderNoMip( BOTSELECT_ACCEPT0 );
	trap_R_RegisterShaderNoMip( BOTSELECT_ACCEPT1 );
	trap_R_RegisterShaderNoMip( BOTSELECT_SELECT );
	trap_R_RegisterShaderNoMip( BOTSELECT_SELECTED );
	trap_R_RegisterShaderNoMip( BOTSELECT_ARROWS );
	trap_R_RegisterShaderNoMip( BOTSELECT_ARROWSL );
	trap_R_RegisterShaderNoMip( BOTSELECT_ARROWSR );
}
########################rank 10#############################
void monster_list_show_interactive(int height, int width)
{
	textblock *tb;
	monster_list_t *list;
	size_t max_width = 0, max_height = 0;
	int safe_height, safe_width;
	region r;
	if (height < 1 || width < 1)
		return;
	tb = textblock_new();
	list = monster_list_new();
	monster_list_collect(list);
	monster_list_get_glyphs(list);
	monster_list_sort(list, monster_list_standard_compare);
	 * and width limit so that we can calculate the maximum number of rows and
	 * columns to display the list nicely. We then adjust those values as
	 * needed to fit in the main term. Height is adjusted to account for the
	 * texblock prompt. The list is positioned on the right side of the term
	 * underneath the status line.
	 */
	monster_list_format_textblock(list, NULL, 1000, 1000, &max_height,
								  &max_width);
	safe_height = MIN(height - 2, (int)max_height + 2);
	safe_width = MIN(width - 13, (int)max_width);
	r.col = -safe_width;
	r.row = 1;
	r.width = safe_width;
	r.page_rows = safe_height;
	 * Actually draw the list. We pass in max_height to the format function so
	 * that all lines will be appended to the textblock. The textblock itself
	 * will handle fitting it into the region. However, we have to pass
	 * safe_width so that the format function will pad the lines properly so
	 * that the location string is aligned to the right edge of the list.
	 */
	monster_list_format_textblock(list, tb, (int)max_height, safe_width, NULL,
								  NULL);
	region_erase_bordered(&r);
	textui_textblock_show(tb, r, NULL);
	textblock_free(tb);
	monster_list_free(list);
}
----------------------------QUERY-------------------------------
set date of today
########################rank 1#############################
int curtime;
int sys_timeBase;
int Sys_Milliseconds( void ) {
	struct timeval tp;
	struct timezone tzp;
	gettimeofday( &tp, &tzp );
	if ( !sys_timeBase ) {
		sys_timeBase = tp.tv_sec;
		return tp.tv_usec / 1000;
	}
	curtime = ( tp.tv_sec - sys_timeBase ) * 1000 + tp.tv_usec / 1000;
	return curtime;
}
########################rank 2#############################
void
read_timer(void)
{
  getrusage(RUSAGE_SELF, &ru1);
  gettimeofday(&time1, (struct timezone *)0);
}
########################rank 3#############################
void SHPAPI_CALL
DBFSetLastModifiedDate( DBFHandle psDBF, int nYYSince1900, int nMM, int nDD )
{
    psDBF->nUpdateYearSince1900 = nYYSince1900;
    psDBF->nUpdateMonth = nMM;
    psDBF->nUpdateDay = nDD;
}
########################rank 4#############################
void lv_calendar_set_today_date(lv_obj_t * calendar, lv_calendar_date_t * today)
{
    lv_calendar_ext_t * ext = lv_obj_get_ext_attr(calendar);
    ext->today.year = today->year;
    ext->today.month = today->month;
    ext->today.day = today->day;
    lv_obj_invalidate(calendar);
}
########################rank 5#############################
int tsk_gettimeofday(struct timeval *tv, struct timezone *tz)
{
    return gettimeofday(tv, tz);
}
########################rank 6#############################
void ness_gettime(struct timespec *a)
{
	struct timeval tv;
	gettimeofday(&tv, 0);
	a->tv_sec  = tv.tv_sec;
	a->tv_nsec = tv.tv_usec * 1000LL;
}
########################rank 7#############################
struct timeval my_gettimeofday(void)
{
	struct timeval ret;
	if(gettimeofday(&ret, NULL) == -1)
	{
		perror("gettimeofday");
		exit(EXIT_FAILURE);
	}
	return ret;
}
########################rank 8#############################
void UTC_Calendar_Now(struct tm *cdate)
{
    time_t          t;
    t = time(0);
    *cdate = *gmtime(&t);
    cdate->tm_year += 1900;
    cdate->tm_mon += 1;
}
########################rank 9#############################
static int clock_time(void)
{
  struct timeval tv;
  struct timezone tz;   
  gettimeofday(&tv, &tz); 
  return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}
########################rank 10#############################
static int clock_time(void)
{
  struct timeval tv;
  struct timezone tz;   
  gettimeofday(&tv, &tz); 
  return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}
----------------------------QUERY-------------------------------
send file descriptor through unix socket
########################rank 1#############################
static void send_fd(int sockfd, int fd) {
    // Need to send some data in the message, this will do.
    struct iovec iov = {
        .iov_base = "",
        .iov_len  = 1,
    };
    struct msghdr msg = {
        .msg_iov        = &iov,
        .msg_iovlen     = 1,
    };
    char cmsgbuf[CMSG_SPACE(sizeof(int))];
    if (fd != -1) {
        // Is the file descriptor actually open?
        if (fcntl(fd, F_GETFD) == -1) {
            if (errno != EBADF) {
                goto error;
            }
            // It's closed, don't send a control message or sendmsg will EBADF.
        } else {
            // It's open, send the file descriptor in a control message.
            msg.msg_control    = cmsgbuf;
            msg.msg_controllen = sizeof(cmsgbuf);
            struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
            cmsg->cmsg_len   = CMSG_LEN(sizeof(int));
            cmsg->cmsg_level = SOL_SOCKET;
            cmsg->cmsg_type  = SCM_RIGHTS;
            *(int *)CMSG_DATA(cmsg) = fd;
        }
    }
    if (sendmsg(sockfd, &msg, 0) != 1) {
error:
        PLOGE("unable to send fd");
        exit(-1);
    }
}
########################rank 2#############################
static int send_fd(int fd, int fd_to_send)
{
    struct msghdr msg;
    struct iovec iov[1];
    int ret;
    char control[CMSG_SPACE(sizeof(int))];
    struct cmsghdr *cmsg;
    memset(&msg, 0, sizeof(msg));
    memset(control, 0, sizeof(control));
    iov[0].iov_base = (void *)" ";
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;
    msg.msg_control = control;
    msg.msg_controllen = sizeof(control);
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));
    do {
        ret = sendmsg(fd, &msg, 0);
    } while (ret < 0 && errno == EINTR);
    if (ret < 0) {
        fprintf(stderr, "Failed to send msg, reason: %s\n", strerror(errno));
    }
    return ret;
}
########################rank 3#############################
int
unixListen(const char *path, int backlog)
{
    return unixPassiveSocket(path, SOCK_STREAM, TRUE, backlog);
}
########################rank 4#############################
int rtnl_receive(struct rtnl_handle *rtnl_handle)
{
	int status;
	char buf[8192];
	struct sockaddr_nl nladdr;
	struct iovec iov = { buf, sizeof(buf) };
	struct nlmsghdr *h;
	struct msghdr msg = {
		.msg_name    = &nladdr,
		.msg_namelen = sizeof(nladdr),
		.msg_iov     = &iov,
		.msg_iovlen  = 1,
	};
	status = recvmsg(rtnl_handle->rtnl_fd, &msg, 0);
	if (status < 0) {
		if (errno == EINTR)
			return 0;
		rtnl_log(LOG_NOTICE, "OVERRUN on rtnl socket");
		return -1;
	}
	if (status == 0) {
		rtnl_log(LOG_ERROR, "EOF on rtnl socket");
		return -1;
	}
	if (msg.msg_namelen != sizeof(nladdr)) {
		rtnl_log(LOG_ERROR, "invalid address size");
		return -1;
	}
	h = (struct nlmsghdr *) buf;
	while (NLMSG_OK(h, status)) {
#if 0
		if (h->nlmsg_pid != rtnl_local.nl_pid ||
		    h->nlmsg_seq != rtnl_dump) {
			goto skip;
		}
#endif
		if (h->nlmsg_type == NLMSG_DONE) {
			rtnl_log(LOG_NOTICE, "NLMSG_DONE");
			return 0;
		}
		if (h->nlmsg_type == NLMSG_ERROR) { 
			struct nlmsgerr *err = NLMSG_DATA(h);
			if (h->nlmsg_len>=NLMSG_LENGTH(sizeof(struct nlmsgerr)))
				errno = -err->error;
			rtnl_log(LOG_ERROR, "NLMSG_ERROR, errnp=%d",
				 errno);
			return -1;
		}
		if (call_handler(rtnl_handle, h->nlmsg_type, h) == 0) 
			rtnl_log(LOG_NOTICE, "unhandled nlmsg_type %u",
				 h->nlmsg_type);
		h = NLMSG_NEXT(h, status);
	}
	return 1;
}
########################rank 5#############################
int http2DataStreamClose(struct handover *ho) {
	char dataClose[] = 	{	0x00, 0x00, 0x00, 		//3 bytes Length
					0x00,				//Type: Data
					0x01,				//Flags: End of data
					0x00, 0x00, 0x00, 0x01};	//Reserved; Stream id 1;
	int len, packetLen;
	struct pcap_packet_header ph;
	len = sizeof(dataClose);
	ph.time = ho->time;
	ph.usec = ho->usec;
        if(ho->ipV == 4)
                packetLen = packetLen4;
        else
                packetLen = packetLen6;
	ph.length1 = packetLen + len;
	ph.length2 = packetLen + len;
        write(fileno(ho->outFile), &ph, sizeof(struct pcap_packet_header));
        if(ho->direction == FROM_SERVER)
                write(fileno(ho->outFile), ho->fromEther, sizeof(ho->fromEther)-1);
        else
                write(fileno(ho->outFile), ho->toEther, sizeof(ho->toEther)-1);
	craftTcp(dataClose, len, ho->direction == FROM_SERVER ? FROM_SERVER : TO_SERVER, TH_ACK|TH_PUSH, ho);
	//and now send the ack
	ph.usec+=INTERVAL;
	ph.length1=packetLen;
	ph.length2=packetLen;
	write(fileno(ho->outFile), &ph, sizeof(struct pcap_packet_header));
	if(ho->direction == FROM_SERVER)
		write(fileno(ho->outFile), ho->toEther, sizeof(ho->toEther)-1);
	else
		write(fileno(ho->outFile), ho->fromEther, sizeof(ho->fromEther)-1);
	craftTcp(NULL,0, ho->direction == FROM_SERVER ? TO_SERVER : FROM_SERVER, TH_ACK, ho);    //direction - client to server
return 0;
}
########################rank 6#############################
int tcpShutdown(struct handover *ho) {
	int packetLen;
	if(ho->ipV == 4)
		packetLen = packetLen4;
	else
		packetLen = packetLen6;
	ph.time = ho->time;
	ph.usec = ho->usec;
       	ph.usec += INTERVAL;
       	ph.length1 = packetLen;
       	ph.length2 = packetLen;
	//server to client FIN
	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	write(fileno(outFile), ho->fromEther, sizeof(ho->fromEther)-1);
       	craftTcp(NULL, 0, FROM_SERVER, TH_ACK|TH_FIN, ho);  //direction - server to client
	ho->ack_seq+=1;
	//and now send the ack
	ph.usec+=INTERVAL;
       	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	write(fileno(outFile), ho->toEther, sizeof(ho->toEther)-1);
	craftTcp(NULL,0, TO_SERVER, TH_ACK, ho);	//direction - client to server
	//client to server FIN
	ph.usec+=INTERVAL;
       	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	write(fileno(outFile), ho->toEther, sizeof(ho->toEther)-1);
       	craftTcp(NULL, 0, TO_SERVER, TH_ACK|TH_FIN, ho);  //direction - client to server
	ho->seq+=1;	
	//and now send the ack
	ph.usec+=INTERVAL;
       	write(fileno(outFile), &ph, sizeof(struct pcap_packet_header));
	write(fileno(outFile), ho->fromEther, sizeof(ho->fromEther)-1);
	craftTcp(NULL,0, FROM_SERVER, TH_ACK, ho);	//direction - server to client
//	printf("Pcap replay length: %d second(s)\n", ph.time - 0x48f35358 + 1);
return(0);
}
########################rank 7#############################
int http2GoAway(struct handover *ho) {
	char goAway[] = 	{	0x00, 0x00, 0x08, 		//3 bytes Length
					0x07,				//Type: GoAway
					0x00,				//Flags
					0x00, 0x00, 0x00, 0x00,		//Reserved; Stream id 0
					0x00, 0x00, 0x00, 0x00,		//Reserved
					0x00, 0x00, 0x00, 0x00};	//No Error
	int len, packetLen;
	struct pcap_packet_header ph;
	len = sizeof(goAway);
	ph.time = ho->time;
	ph.usec = ho->usec;
        if(ho->ipV == 4)
                packetLen = packetLen4;
        else
                packetLen = packetLen6;
	ph.length1 = packetLen + len;
	ph.length2 = packetLen + len;
        write(fileno(ho->outFile), &ph, sizeof(struct pcap_packet_header));
        if(ho->direction == FROM_SERVER)
                write(fileno(ho->outFile), ho->fromEther, sizeof(ho->fromEther)-1);
        else
                write(fileno(ho->outFile), ho->toEther, sizeof(ho->toEther)-1);
	craftTcp(goAway, len, ho->direction == FROM_SERVER ? FROM_SERVER : TO_SERVER, TH_ACK|TH_PUSH, ho);
	//and now send the ack
	ph.usec+=INTERVAL;
	ph.length1=packetLen;
	ph.length2=packetLen;
	write(fileno(ho->outFile), &ph, sizeof(struct pcap_packet_header));
	if(ho->direction == FROM_SERVER)
		write(fileno(ho->outFile), ho->toEther, sizeof(ho->toEther)-1);
	else
		write(fileno(ho->outFile), ho->fromEther, sizeof(ho->fromEther)-1);
	craftTcp(NULL,0, ho->direction == FROM_SERVER ? TO_SERVER : FROM_SERVER, TH_ACK, ho);    //direction - client to server
return 0;
}
########################rank 8#############################
int64_t Sys_NET_SendFile( socket_handle_t handle, int fileno, size_t offset, size_t count ) {
	off_t len;
	off_t _offset = offset;
#if defined ( __APPLE__ )
	len = count;
	ssize_t result = sendfile( fileno, handle, _offset, &len, NULL, 0 );
	result = len;
#elif defined ( __linux__ )
	ssize_t result = sendfile( handle, fileno, &_offset, count );
	len = result;
#elif defined ( __DragonFly__ ) || defined ( __FreeBSD__ )
	ssize_t result = sendfile( fileno, handle, _offset, count, NULL, &len, 0 );
#else
        void *sendfilebuf = malloc(count);
	if (sendfilebuf == NULL) {
		return SOCKET_ERROR;
	}
        ssize_t result = pread(fileno, sendfilebuf, count, _offset);
        if (result > 0) {
            result = write(handle, sendfilebuf, (size_t) result);
        }
        len = result;
        free(sendfilebuf);
#endif
	if( result < 0 ) {
		return result;
	}
	return len;
}
########################rank 9#############################
static int zlog_rotater_trylock(zlog_rotater_t *a_rotater)
{
	int rc;
	struct flock fl;
	fl.l_type = F_WRLCK;
	fl.l_start = 0;
	fl.l_whence = SEEK_SET;
	fl.l_len = 0;
	rc = pthread_mutex_trylock(&(a_rotater->lock_mutex));
	if (rc == EBUSY) {
		zc_warn("pthread_mutex_trylock fail, as lock_mutex is locked by other threads");
		return -1;
	} else if (rc != 0) {
		zc_error("pthread_mutex_trylock fail, rc[%d]", rc);
		return -1;
	}
	if (fcntl(a_rotater->lock_fd, F_SETLK, &fl)) {
		if (errno == EAGAIN || errno == EACCES) {
			zc_warn("fcntl lock fail, as file is lock by other process");
		} else {
			zc_error("lock fd[%d] fail, errno[%d]", a_rotater->lock_fd, errno);
		}
		if (pthread_mutex_unlock(&(a_rotater->lock_mutex))) {
			zc_error("pthread_mutex_unlock fail, errno[%d]", errno);
		}
		return -1;
	}
	return 0;
}
########################rank 10#############################
static tcpsvr_t *opentcpsvr(const char *path, char *msg)
{
    tcpsvr_t *tcpsvr,tcpsvr0={{0}};
    char port[256]="";
    tracet(3,"opentcpsvr: path=%s\n",path);
    if (!(tcpsvr=(tcpsvr_t *)malloc(sizeof(tcpsvr_t)))) return NULL;
    *tcpsvr=tcpsvr0;
    decodetcppath(path,tcpsvr->svr.saddr,port,NULL,NULL,NULL,NULL);
    if (sscanf(port,"%d",&tcpsvr->svr.port)<1) {
        sprintf(msg,"port error: %s",port);
        tracet(1,"opentcpsvr: port error port=%s\n",port);
        free(tcpsvr);
        return NULL;
    }
    if (!gentcp(&tcpsvr->svr,0,msg)) {
        free(tcpsvr);
        return NULL;
    }
    tcpsvr->svr.tcon=0;
    return tcpsvr;
}
----------------------------QUERY-------------------------------
replace special XML characters########################rank 1#############################
void cmd_version(frommark, tomark, cmd, bang, extra)
	MARK	frommark;
	MARK	tomark;
	CMD	cmd;
	int	bang;
	char	*extra;
{
#ifndef DATE
	msg("%s", VERSION);
#else
	msg("%s  (%s)", VERSION, DATE);
#endif
#ifdef COMPILED_BY
	msg("Compiled by %s", COMPILED_BY);
#endif
#ifdef CREDIT
	msg("%s", CREDIT);
#endif
#ifdef COPYING
	msg("%s", COPYING);
#endif
}
########################rank 2#############################
static void
putnumbers(FILE *f, int *x, int linelength, int n)
{
    char s[60];
    int j,v1,v2,xval,curlen;
    curlen = 0;
    v1 = 0;
    while (v1 < n)
    {
        xval = x[v1];
        for (v2 = v1; v2 < n - 1 && x[v2+1] == xval; ++v2) {}
	if (v2 > v1)
	{
	    j = itos(v2-v1+1,s);
	    s[j++] = '*';
	}
	else
	    j = 0;
        j += itos(xval,&s[j]);
        s[j] = ' ';
        s[j+1] = '\0';
        if (linelength > 0 && curlen + j >= linelength)
        {
            PUTC('\n',f);
            curlen = 0;
        }
        curlen += j + 1;
        putstring(f,s);
        v1 = v2 + 1;
    }
    PUTC('\n',f);
}
########################rank 3#############################
static void *
wrapped_dlsym(const char *prefix, const char *name)
{
    char *wrap_name;
    void *symbol;
    if (asprintf(&wrap_name, "override_%s_%s", prefix, name) < 0) {
        fputs("Error: Failed to allocate memory.\n", stderr);
        abort();
    }
    symbol = dlwrap_real_dlsym(RTLD_DEFAULT, wrap_name);
    free(wrap_name);
    return symbol;
}
########################rank 4#############################
int trap_S_GetSoundLength( sfxHandle_t sfx ) {
	return syscall( CG_S_GETSOUNDLENGTH, sfx );
}
########################rank 5#############################
void
putset_firstbold(FILE *f, set *set1, int *curlenp, int linelength,
       int m, boolean compress)
{
    int slen,slen1,j1,j2;
    char s[50],c;
    boolean bold;
    bold = TRUE;
    j1 = -1;
    while ((j1 = nextelement(set1,m,j1)) >= 0)
    {
        j2 = j1;
        if (compress)
        {
            while (nextelement(set1,m,j2) == j2 + 1) ++j2;
            if (j2 == j1+1) j2 = j1;
        }
        slen1 = slen = itos(j1+labelorg,s);
        if (j2 >= j1 + 2)
        {
            s[slen] = ':';
            slen += 1 + itos(j2+labelorg,&s[slen+1]);
        }
	c = s[slen1];
        if (linelength > 0 && *curlenp + slen + 1 >= linelength)
        {
            fprintf(f,"\n   ");
            *curlenp = 3;
        }
        if (bold)
        {
	    s[slen1] = '\0';
            fprintf(f," \033[1m%s\033[0m",s);
            s[slen1] = c;
            fprintf(f,"%s",&s[slen1]);
            bold = FALSE;
        }
        else
            fprintf(f," %s",s);
        *curlenp += slen + 1;
        j1 = j2;
    }
}
########################rank 6#############################
static void
sadd(void)
{
	int i;
	for (i = 0; i <= savek; i++) *plast++ = savchr[i];
	*plast = '\n';
}
########################rank 7#############################
static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
{
    UnityPrint(file);
    UNITY_OUTPUT_CHAR(':');
    UnityPrintNumber((UNITY_INT)line);
    UNITY_OUTPUT_CHAR(':');
    UnityPrint(Unity.CurrentTestName);
    UNITY_OUTPUT_CHAR(':');
}
########################rank 8#############################
static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
{
    UnityPrint(file);
    UNITY_OUTPUT_CHAR(':');
    UnityPrintNumber((UNITY_INT)line);
    UNITY_OUTPUT_CHAR(':');
    UnityPrint(Unity.CurrentTestName);
    UNITY_OUTPUT_CHAR(':');
}
########################rank 9#############################
static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
{
    UnityPrint(file);
    UNITY_OUTPUT_CHAR(':');
    UnityPrintNumber((UNITY_INT)line);
    UNITY_OUTPUT_CHAR(':');
    UnityPrint(Unity.CurrentTestName);
    UNITY_OUTPUT_CHAR(':');
}
########################rank 10#############################
shomac(s1, s2) char *s1, *s2; {
    int x, n, pp;
    pp = 0;				
    if (!s1)
      return(0);
    else
      printf("\n%s = ",s1);		/* Print blank line and macro name */
    slc++;				/* Count the line */
    n = (int)strlen(s1) + 4;		/* Width of current line */
    if (!s2) s2 = "(null definition)";
    while (x = *s2++) {			/* Loop thru definition */
	if (x == '(') pp++;		/* Treat commas within parens */
	if (x == ')') pp--;		/* as ordinary text */
	if (pp < 0) pp = 0;		/* Outside parens, */
	if (x == ',' && pp == 0) {	/* comma becomes comma-dash-NL. */
	    putchar(',');
	    putchar('-');
	    x = '\n';
	}
	putchar(x);			/* Output the character */
	if (x == '\n') {		/* If it was a newline */
#ifdef UNIX
#ifdef NOSETBUF
	    fflush(stdout);
#endif /* NOSETBUF */
#endif /* UNIX */
	    putchar(' ');		/* Indent the next line 1 space */
	    while(*s2 == ' ') s2++;	/* skip past leading blanks */
	    n = 2;			/* restart the character counter */
	    slc++;			/* and increment the line counter. */
	} else if (++n > SCRNWID) {	/* If line is too wide */
	    putchar('-');		/* output a dash */
	    putchar(NL);		/* and a newline */
#ifdef UNIX
#ifdef NOSETBUF
	    fflush(stdout);
#endif /* NOSETBUF */
#endif /* UNIX */
	    n = 1;			/* and restart the char counter */
	    slc++;			/* and increment the line counter */
	}
	if (n < 3 && slc > SCRNLEN) {	/* If new line and screen is full */
	    if (!askmore()) return(-1);	/* ask if they want more. */
	    n = 1;			/* They do, start a new line */
	    slc = 0;			/* and restart line counter */
	}
    }
    putchar(NL);			/* End of definition */
    if (++slc > SCRNLEN) {
	if (!askmore()) return(-1);
	slc = 0;
    }
    return(0);
}
