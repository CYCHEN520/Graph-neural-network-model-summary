----------------------------QUERY-------------------------------
write a byte to output buffer of device
########################rank 1#############################
inline ssize_t write_safe(int fd, const void *buf, size_t count)
{
    ssize_t result;
    for (;;)
    {
        if ((result = write(fd, buf, count)) < 0 && errno == EINTR)
            continue;
        else
            return result;
    }
    return -2; 
}
########################rank 2#############################
static inline ssize_t
sockwrite(z_strm *strm, const void *buf, size_t sze)
{
	return write(strm->hdl.sock, buf, sze);
}
########################rank 3#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 4#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 5#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 6#############################
int write_dataflash(unsigned long addr_dest, unsigned int addr_src,
                    unsigned int size)
{
	unsigned int AddrToWrite = addr_dest;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect(pFlash, &AddrToWrite);
	if (AddrToWrite == -1)
		return -1;
	return AT91F_DataFlashWrite(pFlash, (unsigned char *) addr_src, AddrToWrite, size);
}
########################rank 7#############################
static int
_write_fd(int fd, char *buf, int n)
{
    int		cnt = 0;
    for (;;)
    {
	cnt = write(fd, buf, n);
	if (cnt == n)
	    return PSUCCEED;
	else if (cnt < 0 )
	{
#ifdef EINTR
	    if (errno == EINTR)
		continue;	/* an interrupted call, try again */
#endif
	    Set_Errno
	    return OUT_ERROR;
	}
	else
	{
	    n -= cnt;
	    buf += cnt;
	}
    }
}
########################rank 8#############################
l_int32
jbDataWrite(const char  *rootout,
            JBDATA      *jbdata)
{
char     buf[L_BUF_SIZE];
l_int32  w, h, nclass, npages, cellw, cellh, ncomp, i, x, y, iclass, ipage;
NUMA    *naclass, *napage;
PTA     *ptaul;
PIX     *pixt;
FILE    *fp;
    PROCNAME("jbDataWrite");
    if (!rootout)
        return ERROR_INT("no rootout", procName, 1);
    if (!jbdata)
        return ERROR_INT("no jbdata", procName, 1);
    npages = jbdata->npages;
    w = jbdata->w;
    h = jbdata->h;
    pixt = jbdata->pix;
    nclass = jbdata->nclass;
    cellw = jbdata->latticew;
    cellh = jbdata->latticeh;
    naclass = jbdata->naclass;
    napage = jbdata->napage;
    ptaul = jbdata->ptaul;
    snprintf(buf, L_BUF_SIZE, "%s%s", rootout, JB_TEMPLATE_EXT); 
    pixWrite(buf, pixt, IFF_PNG);
    snprintf(buf, L_BUF_SIZE, "%s%s", rootout, JB_DATA_EXT); 
    if ((fp = fopenWriteStream(buf, "wb")) == NULL)
        return ERROR_INT("stream not opened", procName, 1);
    ncomp = ptaGetCount(ptaul);
    fprintf(fp, "jb data file\n");
    fprintf(fp, "num pages = %d\n", npages);
    fprintf(fp, "page size: w = %d, h = %d\n", w, h);
    fprintf(fp, "num components = %d\n", ncomp);
    fprintf(fp, "num classes = %d\n", nclass);
    fprintf(fp, "template lattice size: w = %d, h = %d\n", cellw, cellh);
    for (i = 0; i < ncomp; i++) {
        numaGetIValue(napage, i, &ipage);
        numaGetIValue(naclass, i, &iclass);
        ptaGetIPt(ptaul, i, &x, &y);
        fprintf(fp, "%d %d %d %d\n", ipage, iclass, x, y);
    }
    fclose(fp);
    return 0;
}
########################rank 9#############################
l_int32
writeImageCompressedToPSFile(const char  *filein,
                             const char  *fileout,
                             l_int32      res,
                             l_int32     *pfirstfile,
                             l_int32     *pindex)
{
const char  *op;
l_int32      format, retval;
    PROCNAME("writeImageCompressedToPSFile");
    if (!pfirstfile || !pindex)
        return ERROR_INT("&firstfile and &index not defined", procName, 1);
    findFileFormat(filein, &format);
    if (format == IFF_UNKNOWN) {
        L_ERROR("format of %s not known\n", procName, filein);
        return 1;
    }
    op = (*pfirstfile == TRUE) ? "w" : "a";
    if (format == IFF_JFIF_JPEG) {
        retval = convertJpegToPS(filein, fileout, op, 0, 0,
                                 res, 1.0, *pindex + 1, TRUE);
        if (retval == 0) {
            *pfirstfile = FALSE;
            (*pindex)++;
        }
    } else if (format == IFF_TIFF_G4) {
        retval = convertG4ToPS(filein, fileout, op, 0, 0,
                               res, 1.0, *pindex + 1, FALSE, TRUE);
        if (retval == 0) {
            *pfirstfile = FALSE;
            (*pindex)++;
        }
    } else {  /* all other image formats */
        retval = convertFlateToPS(filein, fileout, op, 0, 0,
                                  res, 1.0, *pindex + 1, TRUE);
        if (retval == 0) {
            *pfirstfile = FALSE;
            (*pindex)++;
        }
    }
    return retval;
}
########################rank 10#############################
static int  bw_fd  = -1;
static long bw_pos = 0;
static char bw_outbuf[OUTBUFSZ];
long int
blocking_write(int outf, char *buffer, long num){
  long int words=0,temp;
  while(words<num){
    temp=write(outf,buffer+words,num-words);
    if(temp==-1){
      if(errno!=EINTR && errno!=EAGAIN)
	return(-1);
      temp=0;
    }
    words+=temp;
  }
  return(0);
}
----------------------------QUERY-------------------------------
insert a new value into list
########################rank 1#############################
void _i_insert_value(List* list, list_value value)
{
	register List *head, *ent;
	if (!_i_find_value(list, value))
	{	
		ent = (List *)malloc(sizeof(List));
		ent->value=value;
		ent->destruct = list->destruct;  /* destruction method */
		ent->next=list->next;
		ent->prev=(List *)0;
		if ((head=list->next)) head->prev=ent;
		list->next=ent;
	}
}
########################rank 2#############################
void List_setSize_(List *self, size_t index)
{
	List_ifNeededSizeTo_(self, index);
	self->size = index;
}
########################rank 3#############################
void List_setSize_(List *self, size_t index)
{
	List_ifNeededSizeTo_(self, index);
	self->size = index;
}
########################rank 4#############################
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
    item->prev = prev;
}
########################rank 5#############################
int sum_list_iter_abs(list_ptr ls) {
    int sum = 0;
    while (!is_null(ls)) {
	sum += val(ls);
	ls = next(ls);
    }
    return sum;
}
########################rank 6#############################
int sum_list_iter_abs(list_ptr ls) {
    int sum = 0;
    while (!is_null(ls)) {
	sum += val(ls);
	ls = next(ls);
    }
    return sum;
}
########################rank 7#############################
int list_add_item_before(List_t * list, int idx, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// Move to right before list index or return 1 if no such index
	while(idx-1 > 0){
		// Insert after last item in list
		if(!nextItem->next){ // Index doesn't exist
			return(0);
		}else{
			nextItem = nextItem->next;
			idx--;
		}
	}
	// Add item after current "nextItem" pointed too.
	if(nextItem->next){ // Middle of list
		if(!li->next){
			ListItem_t * tmpItem = list_item_initialize();
			// Save next item in list
			tmpItem = nextItem->next;
			// Attach new item to current item's next pointer
			nextItem->next = li;
			// Attach "old" next item pointer 
			li->next = tmpItem;
			return(1);
		}else{
			return(0);
		}
	}else if(!nextItem->next){ // End of list
		if(!li->next){
			nextItem->next = li;
			return(1);
		}else{
			return(0);
		}
	}
	return(0);
}
########################rank 8#############################
int list_add_item_after(List_t * list, int idx, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// Move to list index or return 1 if no such index
	while(idx > 0){
		// Insert after last item in list
		if(!nextItem->next){ // Index doesn't exist
			return(0);
		}else{
			nextItem = nextItem->next;
			idx--;
		}
	}
	// Add item after current "nextItem" pointed too.
	if(nextItem->next){ // Middle of list
		if(!li->next){
			ListItem_t * tmpItem = list_item_initialize();
			// Save next item in list
			tmpItem = nextItem->next;
			// Attach new item to current item's next pointer
			nextItem->next = li;
			// Attach "old" next item pointer 
			li->next = tmpItem;
		}else{
			return(0);
		}
	}else if(!nextItem->next){ // End of list
		if(!li->next){
			nextItem->next = li;
		}else{
			return(0);
		}
	}
	return(1);
}
########################rank 9#############################
int exprValListCreate(exprValList ** vlist)
{
	exprValList *tmp;
	if (vlist == NULL)
		return EXPR_ERROR_NULLPOINTER;
	*vlist = NULL;				/* Set to NULL initially */
	tmp = exprAllocMem(sizeof(exprValList));
	if (tmp == NULL)
		return EXPR_ERROR_MEMORY;	/* Could not allocate memory */
	*vlist = tmp;
	return EXPR_ERROR_NOERROR;
}
########################rank 10#############################
BOOL APIENTRY binn_list_add_new(binn *list, binn *value) {
  BOOL retval;
  retval = binn_list_add_value(list, value);
  if (value) free_fn(value);
  return retval;
}
----------------------------QUERY-------------------------------
check string is suffix of another string
########################rank 1#############################
unsigned char * _mbschr(const unsigned char *str, unsigned int c)
{
  return (unsigned char *)strchr((const char*)str, c);
}
########################rank 2#############################
unsigned char * _mbschr(const unsigned char *str, unsigned int c)
{
  return (unsigned char *)strchr((const char*)str, c);
}
########################rank 3#############################
char *strchr(const char *str, int c) 
{
    for (; *str; str++)
        if (*str == c) return (char*)++str;
    return (char*)0;
}
########################rank 4#############################
char *
strchr(const char *str, int c)
{
   char *sp = (char *)str;
   char  ch = (char)(c & 0xff);
   while (*sp != '\0')
   {
      if (*sp == ch)
      {
         return (sp);
      }
      ++sp;
   }
   return (NULL);
}
########################rank 5#############################
char *
strchr(const char *str, int c)
{
   char *sp = (char *)str;
   char  ch = (char)(c & 0xff);
   while (*sp != '\0')
   {
      if (*sp == ch)
      {
         return (sp);
      }
      ++sp;
   }
   return (NULL);
}
########################rank 6#############################
void
URLparse(char *str)
{
	char *p, *q;
	p = q = str;
	while (*p) {
		*q = *p;
		if (*p++ == '%') {
			if (*p) {
				*q = fromhex(*p) * 16;
				p++;
				if (*p) {
					*q += fromhex(*p);
					p++;
				}
			}
		}
		q++;
	}
	*q = '\0';
}
########################rank 7#############################
int rl_str_pfadd(unsigned char *str, long strlen, int argc, unsigned char **argv, long *argvlen, unsigned char **_str, long *_strlen) {
    struct hllhdr *hdr;
    int updated = 0, j;
    if (str == NULL) {
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */
        if (createHLLObject(&str, &strlen)) {
            return -1;
        }
        updated++;
    } else {
        if (isHLLObject(str, strlen) != 0) return -1;
    }
    for (j = 0; j < argc; j++) {
        int retval = hllAdd(str, strlen, argv[j], argvlen[j], &str, &strlen);
        switch(retval) {
        case 1:
            updated++;
            break;
        case -1:
            return -1;
        }
    }
    hdr = (struct hllhdr *)str;
    if (updated) {
        HLL_INVALIDATE_CACHE(hdr);
    }
    *_str = str;
    *_strlen = strlen;
    return updated ? 1 : 0;
}
########################rank 8#############################
bool valid_int_str(const char *str, size_t n)
{
	bool found_num = false;
	if (!str)
		return false;
	if (!*str)
		return false;
	if (!n)
		n = strlen(str);
	if (*str == '-' || *str == '+')
		++str;
	do {
		if (*str > '9' || *str < '0')
			return false;
		found_num = true;
	} while(*++str && --n);
	return found_num;
}
########################rank 9#############################
bool valid_int_str(const char *str, size_t n)
{
	bool found_num = false;
	if (!str)
		return false;
	if (!*str)
		return false;
	if (!n)
		n = strlen(str);
	if (*str == '-' || *str == '+')
		++str;
	do {
		if (*str > '9' || *str < '0')
			return false;
		found_num = true;
	} while(*++str && --n);
	return found_num;
}
########################rank 10#############################
void str_sanitize(char *str_in)
{
	unsigned char *str = (unsigned char *)str_in;
	while(*str)
	{
		if(*str < 32 && !(*str == '\r') && !(*str == '\n') && !(*str == '\t'))
			*str = ' ';
		str++;
	}
}
----------------------------QUERY-------------------------------
remove all elements in list
########################rank 1#############################
int list_remove_item_at(List_t * list, int idx, list_item_remove_callback_func cb){
	ListItem_t * nextItem, * lastItem;
	if(!list->head) return(1);
	if(idx == 0 && !list->head->next) return list_remove_item_head(list, cb);
	nextItem = list->head;
	lastItem = NULL;
	// Move to index
	while(idx-1 > 0){
		// Index does not exist
		if(!nextItem->next){
			return(0);
		}else{
			// Move to next Item
			lastItem = nextItem;
			nextItem = nextItem->next;
		}
		idx--;
	}
	// Last Item
	if(!nextItem->next){
		free(nextItem);
		return(1);
	}else{ // Middle Item
		// Connect item before and after index
		lastItem->next = nextItem->next;
		// Free unconnected item index
		free(nextItem);
		return(1);
	}
}
########################rank 2#############################
void list_remove(list_t list, void *item)
{
	struct list *l, *r;
	if (*list == NULL) {
		return;
	}
	r = NULL;
	for (l = *list; l != NULL; l = l->next) {
		if (l == item) {
			if (r == NULL) {
				*list = l->next;
			} else {
				r->next = l->next;
			}
			l->next = NULL;
			return;
		}
		r = l;
	}
}
########################rank 3#############################
void *list_pop(list_t list)
{
	struct list *l;
	l = *list;
	if (*list != NULL) {
		*list = ((struct list *)*list)->next;
	}
	return l;
}
########################rank 4#############################
int list_remove(List_t * list, list_item_remove_callback_func cb){
	// Loop through entire list removing each item
	while(1){
		if( list_remove_item_head(list, cb) ){
			if(!list->head){
				break;
			}
		}else{
			return(0);
		}
	}
	return(1);
}
########################rank 5#############################
void pvl_clear(pvl_list l)
{
    pvl_elem e = pvl_head(l);
    pvl_elem next;
    if (e == 0) {
        return;
    }
    while (e != 0) {
        next = pvl_next(e);
        (void)pvl_remove(l, e);
        e = next;
    }
}
########################rank 6#############################
void list_delete_at(list_t *list, int i)
{
    if(i >= list->num_objs || i < 0)
        return;
    list->obj_free(list->obj_arr[i]);
    for(; i < list->num_objs - 1; i++)
        list->obj_arr[i] = list->obj_arr[i+1];
    list->obj_arr[i] = NULL;
    list->num_objs--;
}
########################rank 7#############################
typedef int fd_list_t;
static fd_list_t fd_list[MAX_FD_CLEANUP];
 * XXX This should only be run by CHILD processes.
 */
static void
cleanup_fds(void)
{
    unsigned int i;
    for (i = 0; i < sizeof(fd_list) / sizeof(int); i++) {
        if (fd_list[i]) {
            close(fd_list[i]);
            fd_list[i] = 0;
        }
    }
}
########################rank 8#############################
void
list_clear(linked_list_t *list)
{
    list_entry_t *e;
    while((e = shift_entry(list)) != NULL)
    {
        * let's free memory also for it */
        if(e->tagged && e->value)
            list_destroy_tagged_value_internal((tagged_value_t *)e->value, list->free_value_cb);
        else if (list->free_value_cb)
            list->free_value_cb(e->value);
        destroy_entry(e);
    }
}
########################rank 9#############################
static int listlength(js_Ast *list)
{
	int n = 0;
	while (list) ++n, list = list->b;
	return n;
}
########################rank 10#############################
static int listlength(js_Ast *list)
{
	int n = 0;
	while (list) ++n, list = list->b;
	return n;
}
----------------------------QUERY-------------------------------
stop logging messages to syslog
########################rank 1#############################
void
zed_log_syslog_close(void)
{
	if (_ctx.do_syslog) {
		_ctx.do_syslog = 0;
		closelog();
	}
}
########################rank 2#############################
void ym2608_shutdown(void *chip)
{
	YM2608 *F2608 = (YM2608 *)chip;
	free(F2608->deltaT.memory);	F2608->deltaT.memory = NULL;
	FMCloseTable();
	free(F2608);
}
########################rank 3#############################
void L10n_Shutdown( void ) {
	podomain_t *podomain, *next;
	for( podomain = podomains_head; podomain; podomain = next ) {
		next = podomain->next;
		L10n_DestroyPODomain( podomain );
	}
	Mem_FreePool( &pomempool );
	podomains_head = NULL;
}
########################rank 4#############################
void ym2612_shutdown(void *chip)
{
	YM2612 *F2612 = (YM2612 *)chip;
	//fclose(hFile);
	FMCloseTable();
	//auto_free(F2612->OPN.ST.device->machine, F2612);
	free(F2612);
}
########################rank 5#############################
void ym2203_shutdown(void *chip)
{
	YM2203 *FM2203 = (YM2203 *)chip;
	FMCloseTable();
	free(FM2203);
}
########################rank 6#############################
void
pixie_close_library(void *library_handle)
{
#ifdef WIN32
	BOOL x;
	x = FreeLibrary(library_handle);
	if (x == 0)
		fprintf(stderr, "FreeLibrary(): return error #%u\n", (unsigned)GetLastError());
#else
	int x;
	x = dlclose(library_handle);
	if (x != 0)
		fprintf(stderr, "dlclose(): returned error #%u (%s)\n", errno, dlerror());
#endif
}
########################rank 7#############################
void ym2610_shutdown(void *chip)
{
	YM2610 *F2610 = (YM2610 *)chip;
	free(F2610->pcmbuf);		F2610->pcmbuf = NULL;
	free(F2610->deltaT.memory);	F2610->deltaT.memory = NULL;
	FMCloseTable();
	free(F2610);
}
########################rank 8#############################
void donkeyid_shutdown() {
    if (shmctx.size){
        int i;
        for (i = 0; i <= MAX_DONKEYID_TYPE ; i++) {
            if((mlock+i)->lock == pid){
                spin_unlock(&((mlock+i)->lock),pid);
            }
        }
        shm_free(&shmctx);
        shmctx.size = 0;
    }
}
########################rank 9#############################
void SHPAPI_CALL
SHPClose(SHPHandle psSHP )
{
    if( psSHP == NULL )
        return;
    if( psSHP->bUpdated )
	SHPWriteHeader( psSHP );
    free( psSHP->panRecOffset );
    free( psSHP->panRecSize );
    if ( psSHP->fpSHX != NULL)
        psSHP->sHooks.FClose( psSHP->fpSHX );
    psSHP->sHooks.FClose( psSHP->fpSHP );
    if( psSHP->pabyRec != NULL )
    {
        free( psSHP->pabyRec );
    }
    if( psSHP->pabyObjectBuf != NULL )
    {
        free( psSHP->pabyObjectBuf );
    }
    if( psSHP->psCachedObject != NULL )
    {
        free( psSHP->psCachedObject );
    }
    free( psSHP );
}
########################rank 10#############################
void rtnl_close(struct rtnl_handle *rtnl_handle)
{
	close(rtnl_handle->rtnl_fd);
	free(rtnl_handle);
	return;
}
----------------------------QUERY-------------------------------
render bignum into decimal
########################rank 1#############################
char *bignum_decimal(Bignum x)
{
  int ndigits, ndigit;
  int i, iszero;
  BignumInt carry;
  char *ret;
  BignumInt *workspace;
   * First, estimate the number of digits. Since log(10)/log(2)
   * is just greater than 93/28 (the joys of continued fraction
   * approximations...) we know that for every 93 bits, we need
   * at most 28 digits. This will tell us how much to malloc.
   *
   * Formally: if x has i bits, that means x is strictly less
   * than 2^i. Since 2 is less than 10^(28/93), this is less than
   * 10^(28i/93). We need an integer power of ten, so we must
   * round up (rounding down might make it less than x again).
   * Therefore if we multiply the bit count by 28/93, rounding
   * up, we will have enough digits.
   *
   * i=0 (i.e., x=0) is an irritating special case.
   */
  i = bignum_bitcount(x);
  if (!i)
    ndigits = 1; /* x = 0 */
  else
    ndigits = (28 * i + 92) / 93; /* multiply by 28/93 and round up */
  ndigits++;                      /* allow for trailing \0 */
  ret = snewn(ndigits, char);
   * Now allocate some workspace to hold the binary form as we
   * repeatedly divide it by ten. Initialise this to the
   * big-endian form of the number.
   */
  workspace = snewn(x[0], BignumInt);
  for (i = 0; i < (int)x[0]; i++)
    workspace[i] = x[x[0] - i];
   * Next, write the decimal number starting with the last digit.
   * We use ordinary short division, dividing 10 into the
   * workspace.
   */
  ndigit = ndigits - 1;
  ret[ndigit] = '\0';
  do {
    iszero = 1;
    carry = 0;
    for (i = 0; i < (int)x[0]; i++) {
       * Conceptually, we want to compute
       *
       *   (carry << BIGNUM_INT_BITS) + workspace[i]
       *   -----------------------------------------
       *                      10
       *
       * but we don't have an integer type longer than BignumInt
       * to work with. So we have to do it in pieces.
       */
      BignumInt q, r;
      q = workspace[i] / 10;
      r = workspace[i] % 10;
      q += carry * ((BIGNUM_INT_MASK - 9) / 10 + 1);
      r += carry * ((BIGNUM_INT_MASK - 9) % 10);
      q += r / 10;
      r %= 10;
      workspace[i] = q;
      carry = r;
      if (workspace[i])
        iszero = 0;
    }
    ret[--ndigit] = (char)(carry + '0');
  } while (!iszero);
   * There's a chance we've fallen short of the start of the
   * string. Correct if so.
   */
  if (ndigit > 0)
    memmove(ret, ret + ndigit, ndigits - ndigit);
   * Done.
   */
  smemclr(workspace, x[0] * sizeof(*workspace));
  sfree(workspace);
  return ret;
}
########################rank 2#############################
void mp_zero(mp_int *a)
{
   a->sign = MP_ZPOS;
   a->used = 0;
   MP_ZERO_DIGITS(a->dp, a->alloc);
}
########################rank 3#############################
l_int32
genRandomIntegerInRange(l_int32   range,
                        l_int32   seed,
                        l_int32  *pval)
{
    PROCNAME("genRandomIntegerInRange");
    if (!pval)
        return ERROR_INT("&val not defined", procName, 1);
    *pval = 0;
    if (range < 2)
        return ERROR_INT("range must be >= 2", procName, 1);
    if (seed > 0) srand(seed);
    *pval = (l_int32)((l_float64)range *
                       ((l_float64)rand() / (l_float64)RAND_MAX));
    return 0;
}
########################rank 4#############################
mp_err mp_sub_d(const mp_int *a, mp_digit b, mp_int *c)
{
   mp_digit *tmpa, *tmpc;
   mp_err    err;
   int       ix, oldused;
   if (c->alloc < (a->used + 1)) {
      if ((err = mp_grow(c, a->used + 1)) != MP_OKAY) {
         return err;
      }
   }
    * addition [with fudged signs]
    */
   if (a->sign == MP_NEG) {
      mp_int a_ = *a;
      a_.sign = MP_ZPOS;
      err     = mp_add_d(&a_, b, c);
      c->sign = MP_NEG;
      mp_clamp(c);
      return err;
   }
   oldused = c->used;
   tmpa    = a->dp;
   tmpc    = c->dp;
   if (((a->used == 1) && (a->dp[0] <= b)) || (a->used == 0)) {
      if (a->used == 1) {
         *tmpc++ = b - *tmpa;
      } else {
         *tmpc++ = b;
      }
      ix      = 1;
      c->sign = MP_NEG;
      c->used = 1;
   } else {
      mp_digit mu = b;
      c->sign = MP_ZPOS;
      c->used = a->used;
      for (ix = 0; ix < a->used; ix++) {
         *tmpc    = *tmpa++ - mu;
         mu       = *tmpc >> (MP_SIZEOF_BITS(mp_digit) - 1u);
         *tmpc++ &= MP_MASK;
      }
   }
   MP_ZERO_DIGITS(tmpc, oldused - ix);
   mp_clamp(c);
   return MP_OKAY;
}
########################rank 5#############################
int
mp_sub_d(mp_int *a, mp_digit b, mp_int *c) {
    mp_digit *tmpa, *tmpc, mu;
    int      res, ix, oldused;
    if (c->alloc < (a->used + 1)) {
        if ((res = mp_grow(c, a->used + 1)) != MP_OKAY) {
            return res;
        }
    }
     * addition [with fudged signs]
     */
    if (a->sign == MP_NEG) {
        a->sign = MP_ZPOS;
        res     = mp_add_d(a, b, c);
        a->sign = c->sign = MP_NEG;
        mp_clamp(c);
        return res;
    }
    oldused = c->used;
    tmpa    = a->dp;
    tmpc    = c->dp;
    if (((a->used == 1) && (a->dp[0] <= b)) || (a->used == 0)) {
        if (a->used == 1) {
            *tmpc++ = b - *tmpa;
        } else {
            *tmpc++ = b;
        }
        ix = 1;
        c->sign = MP_NEG;
        c->used = 1;
    } else {
        c->sign = MP_ZPOS;
        c->used = a->used;
        *tmpc    = *tmpa++ - b;
        mu       = *tmpc >> ((sizeof(mp_digit) * CHAR_BIT) - 1);
        *tmpc++ &= MP_MASK;
        for (ix = 1; ix < a->used; ix++) {
            *tmpc    = *tmpa++ - mu;
            mu       = *tmpc >> ((sizeof(mp_digit) * CHAR_BIT) - 1);
            *tmpc++ &= MP_MASK;
        }
    }
    while (ix++ < oldused) {
        *tmpc++ = 0;
    }
    mp_clamp(c);
    return MP_OKAY;
}
########################rank 6#############################
void
spSetReal( eMatrix )
char *eMatrix;
{
    ASSERT( IS_SPARSE( (MatrixPtr)eMatrix ) AND REAL);
    ((MatrixPtr)eMatrix)->Complex = NO;
    return;
}
########################rank 7#############################
void eye(real_T I[9])
{
  int32_T i;
  memset(&I[0], 0, 9U * sizeof(real_T));
  for (i = 0; i < 3; i++) {
    I[i + 3 * i] = 1.0;
  }
}
########################rank 8#############################
typedef int *var_matrix;
var_matrix *new_var_matrix(int n)
{
    return (var_matrix *) malloc(sizeof(int[n][n]));
}
########################rank 9#############################
int ssh2_bignum_length(Bignum bn)
{
  return 4 + (bignum_bitcount(bn) + 8) / 8;
}
########################rank 10#############################
int rand_between(int low, int high)
{
    return low + rand() / (RAND_MAX / (high - low + 1) + 1);
}
----------------------------QUERY-------------------------------
look for match name in system dictionary
########################rank 1#############################
ficlWord *ficlSystemLookup(ficlSystem *system, char *name)
{
    ficlString s;
    FICL_STRING_SET_FROM_CSTRING(s, name);
    return ficlDictionaryLookup(system->dictionary, s);
}
########################rank 2#############################
void ficlDictionaryClearFlags(ficlDictionary *dictionary, ficlUnsigned8 clear)
{
    FICL_DICTIONARY_ASSERT(dictionary, dictionary->smudge);
    dictionary->smudge->flags &= ~clear;
    return;
}
########################rank 3#############################
static inline int ht_match(const void *key, size_t len, str_set_item_t item)
{
    return strncmp(key, item, len) == 0;
}
########################rank 4#############################
void ficlDictionarySetFlags(ficlDictionary *dictionary, ficlUnsigned8 set)
{
    FICL_DICTIONARY_ASSERT(dictionary, dictionary->smudge);
    dictionary->smudge->flags |= set;
    return;
}
########################rank 5#############################
void ficlVmDictionaryAllot(ficlVm *vm, ficlDictionary *dictionary, int n)
{
	FICL_VM_DICTIONARY_SIMPLE_CHECK(vm, dictionary, n);
	FICL_IGNORE(vm);
	ficlDictionaryAllot(dictionary, n);
}
########################rank 6#############################
static void
m_preprocess(Pattern)
CHARTYPE *Pattern;
{
	int i, j, m;
	unsigned hash;
	m = strlen(Pattern);
	for (i = 0; i < MAX_SHIFT_2; i++) SHIFT_2[i] = m;
	for (i = m-1; i>=1; i--) {
		hash = TR[Pattern[i]];
		hash = hash << 3;
		for (j = 0; j< MAXSYM; j++) {
			if(SHIFT_2[hash+j] == m) SHIFT_2[hash+j] = m-1;
		}
		hash = hash + TR[Pattern[i-1]];
		if((int)(SHIFT_2[hash]) >= (int)(m - 1)) SHIFT_2[hash] = m-1-i;
	}
	shift_1 = m-1;
	for (i= m-2; i>=0; i--) {
		if(TR[Pattern[i]] == TR[Pattern[m-1]] )
		{ 
			shift_1 = m-1 - i;  
			i = -1; 
		}
	}
	if(shift_1 == 0) shift_1 = 1;
	SHIFT_2[0] = 0;
}
########################rank 7#############################
void ficlDictionaryAbortDefinition(ficlDictionary *dictionary)
{
    ficlWord *word;
    ficlDictionaryLock(dictionary, FICL_TRUE);
    word = dictionary->smudge;
    if (word->flags & FICL_WORD_SMUDGED)
        dictionary->here = (ficlCell *)word->name;
    ficlDictionaryLock(dictionary, FICL_FALSE);
    return;
}
########################rank 8#############################
const char*
ud_lookup_mnemonic(enum ud_mnemonic_code c)
{
  if (c < UD_MAX_MNEMONIC_CODE) {
    return ud_mnemonics_str[c];
  } else {
    return NULL;
  }
}
########################rank 9#############################
static void
f_prep(pat_index, Pattern)
uchar *Pattern;   int pat_index;
{
int i, m;
register unsigned hash=0;
#ifdef debug
	puts(Pattern);
#endif
	m = p_size;
		for (i=m-1; i>=(1+LONG); i--) {
				hash = (tr1[Pattern[i]]);
				hash = (hash << Hbits) + (tr1[Pattern[i-1]]);
		if(LONG) hash = (hash << Hbits) + (tr1[Pattern[i-2]] );
		if(SHIFT1[hash] >= m-1-i) SHIFT1[hash] = m-1-i;
	}
	i=m-1;
		hash = (tr1[Pattern[i]]);
		hash = (hash << Hbits) + (tr1[Pattern[i-1]]);
	if(LONG) hash = (hash << Hbits) + (tr1[Pattern[i-2]] );
		if(SHORT) hash=tr[Pattern[0]];
#ifdef debug
	printf("hash = %d\n", hash);
#endif
		HASH[hash]++;
		return;
}
########################rank 10#############################
size_t lookup_token(const struct CF_Token *token)
{
    unsigned offset = 0;
    unsigned state = 0;
    return smack_search_next(   statement_names, 
                                &state, 
                                token->name, 
                                &offset, 
                                (unsigned)token->name_length + 1);
}
----------------------------QUERY-------------------------------
remove an element from a row vector
########################rank 1#############################
void
sm_row_remove(prow, col)
register sm_row *prow;
register int col;
{
    register sm_element *p;
    for(p = prow->first_col; p != 0 && p->col_num < col; p = p->next_col)
	;
    if (p != 0 && p->col_num == col) {
	dll_unlink(p, prow->first_col, prow->last_col, 
			    next_col, prev_col, prow->length);
	sm_element_free(p);
    }
}
########################rank 2#############################
uint8_t bigSubtractVariableSizeNoModulo(uint8_t *r, uint8_t *op1, uint8_t *op2, uint8_t op_size)
{
	uint16_t partial;
	uint8_t borrow;
	uint8_t i;
	borrow = 0;
	for (i = 0; i < op_size; i++)
	{
		partial = (uint16_t)((uint16_t)op1[i] - (uint16_t)op2[i] - (uint16_t)borrow);
		r[i] = (uint8_t)partial;
		borrow = (uint8_t)((uint8_t)(partial >> 8) & 1);
	}
	return borrow;
}
########################rank 3#############################
void libconfig_strvec_delete(const char *const *vec)
{
  const char *const *p;
  if(!vec) return;
  for(p = vec; *p; ++p)
    __delete(*p);
  __delete(vec);
}
########################rank 4#############################
static int distance_to(struct klingon *k)
{
	uint16_t j;
	j = square00(TO_FIXED00(k->y) - ship_y);
	j += square00(TO_FIXED00(k->x) - ship_x);
	j = isqrt(j);
	j *= 10;
	return j;
}
########################rank 5#############################
static inline void gf2_matrix_square(uint32_t *square, uint32_t *mat)
{
    int n;
    for (n = 0; n < 32; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}
########################rank 6#############################
double projectarea(vect)
Vector3 *vect[PONPATCH];
{
    int i;
    double out= 0, twopntarea();
    for (i = 0; i < PONPATCH; i++)
    out += twopntarea(vect[i], vect[(i+1)%PONPATCH]);
    return(out);
}
########################rank 7#############################
local void gf2_matrix_square(
    unsigned long *square,
    unsigned long *mat)
{
    int n;
    for (n = 0; n < GF2_DIM; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}
########################rank 8#############################
void Matrix4_InfiniteOrthoProjection( vec_t left, vec_t right, vec_t bottom, vec_t top,
										   mat4_t m ) {
	m[0] = 2.0f / ( right - left );
	m[1] = 0.0f;
	m[2] = 0.0f;
	m[3] = 0.0f;
	m[4] = 0.0f;
	m[5] = 2.0f / ( top - bottom );
	m[6] = 0.0f;
	m[7] = 0.0f;
	m[8] = 0.0f;
	m[9] = 0.0f;
	m[10] = 0.0f;
	m[11] = 0.0f;
	m[12] = -( right + left ) / ( right - left );
	m[13] = -( top + bottom ) / ( top - bottom );
	m[14] = -1.0f;
	m[15] = 1.0f;
}
########################rank 9#############################
size_t eb_aom_vector_byte_size(const Vector *vector) { return vector->size * vector->element_size; }
Iterator eb_aom_vector_begin(Vector *vector) { return eb_aom_vector_iterator(vector, 0); }
Iterator eb_aom_vector_iterator(Vector *vector, size_t index) {
    Iterator iterator = {NULL, 0};
    assert(vector != NULL);
    assert(index <= vector->size);
    if (vector == NULL) return iterator;
    if (index > vector->size) return iterator;
    if (vector->element_size == 0) return iterator;
    iterator.pointer      = _vector_offset(vector, index);
    iterator.element_size = vector->element_size;
    return iterator;
}
########################rank 10#############################
static int height(int n)
{
	int h = 0;
	while ((n & 1) == 0) {
		h++;
		n = n >> 1;
	}
	return h;
}
----------------------------QUERY-------------------------------
load a bignum from int
########################rank 1#############################
int ssh2_bignum_length(Bignum bn)
{
  return 4 + (bignum_bitcount(bn) + 8) / 8;
}
########################rank 2#############################
int mp_toradix(mp_int *a, char *str, int radix) {
    int      res, digs;
    mp_int   t;
    mp_digit d;
    char     *_s = str;
    if ((radix < 2) || (radix > 64)) {
        return MP_VAL;
    }
    if (mp_iszero(a) == MP_YES) {
        *str++ = '0';
        *str   = '\0';
        return MP_OKAY;
    }
    if ((res = mp_init_copy(&t, a)) != MP_OKAY) {
        return res;
    }
    if (t.sign == MP_NEG) {
        ++_s;
        *str++ = '-';
        t.sign = MP_ZPOS;
    }
    digs = 0;
    while (mp_iszero(&t) == MP_NO) {
        if ((res = mp_div_d(&t, (mp_digit)radix, &t, &d)) != MP_OKAY) {
            mp_clear(&t);
            return res;
        }
        *str++ = mp_s_rmap[d];
        ++digs;
    }
     * to the first digit [exluding the sign] of the number]
     */
    bn_reverse((unsigned char *)_s, digs);
    *str = '\0';
    mp_clear(&t);
    return MP_OKAY;
}
########################rank 3#############################
int mp_toradix_n(mp_int * a, char *str, int radix, int maxlen)
{
  int     res, digs;
  mp_int  t;
  mp_digit d;
  char   *_s = str;
  if (maxlen < 2 || radix < 2 || radix > 64) {
    return MP_VAL;
  }
  if (mp_iszero(a) == MP_YES) {
     *str++ = '0';
     *str = '\0';
     return MP_OKAY;
  }
  if ((res = mp_init_copy (&t, a)) != MP_OKAY) {
    return res;
  }
  if (t.sign == MP_NEG) {
    ++_s;
    *str++ = '-';
    t.sign = MP_ZPOS;
    --maxlen;
  }
  digs = 0;
  while (mp_iszero (&t) == 0) {
    if (--maxlen < 1) {
       break;
    }
    if ((res = mp_div_d (&t, (mp_digit) radix, &t, &d)) != MP_OKAY) {
      mp_clear (&t);
      return res;
    }
    *str++ = mp_s_rmap[d];
    ++digs;
  }
   * to the first digit [exluding the sign] of the number
   */
  bn_reverse ((unsigned char *)_s, digs);
  *str = '\0';
  mp_clear (&t);
  return MP_OKAY;
}
########################rank 4#############################
const char * unqlite_lib_version(void)
{
	return UNQLITE_VERSION;
}
########################rank 5#############################
const char * ph7_lib_version(void)
{
	return PH7_VERSION;
}
########################rank 6#############################
static int LD(int n, const double *Q, double *L, double *D)
{
    int i,j,k,info=0;
    double a,*A=mat(n,n);
    memcpy(A,Q,sizeof(double)*n*n);
    for (i=n-1;i>=0;i--) {
        if ((D[i]=A[i+i*n])<=0.0) {info=-1; break;}
        a=sqrt(D[i]);
        for (j=0;j<=i;j++) L[i+j*n]=A[i+j*n]/a;
        for (j=0;j<=i-1;j++) for (k=0;k<=j;k++) A[j+k*n]-=L[i+k*n]*L[i+j*n];
        for (j=0;j<=i;j++) L[i+j*n]/=L[i+i*n];
    }
    free(A);
    if (info) fprintf(stderr,"%s : LD factorization error\n",__FILE__);
    return info;
}
########################rank 7#############################
void Matrix3_Copy(float* a, float* b)
{
    uint8_t i;
    for(i=0; i<9; i++)
    {
        b[i] = a[i];
    }
}
########################rank 8#############################
static
float *vector(int nl, int nh)
{
  float *v;
  v=(float *)malloc((unsigned) (nh-nl+1)*sizeof(float));
  if (!v) fail("allocation failure in vector()");
  return v-nl;
}
########################rank 9#############################
void bignum_fromint(bignum* b, unsigned int num) {
	b->length = 1;
	if(b->capacity < b->length) {
		b->capacity = b->length;
		b->data = realloc(b->data, b->capacity * sizeof(word));
	}
	b->data[0] = num;
}
########################rank 10#############################
void Matrix6_Copy(float a[6][6], float b[6][6])
{
    uint8_t i,j;
    for (i=0; i<6; i++)
    {
        for (j=0; j<6; j++)
        {
            b[i][j] = a[i][j];
        }
    }
}
----------------------------QUERY-------------------------------
grab a lock on a mutex
########################rank 1#############################
SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){
  if( p ){
    assert( sqlite3GlobalConfig.mutex.xMutexLeave );
    sqlite3GlobalConfig.mutex.xMutexLeave(p);
  }
}
########################rank 2#############################
SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){
  int rc = SQLITE_OK;
  if( p ){
    assert( sqlite3GlobalConfig.mutex.xMutexTry );
    return sqlite3GlobalConfig.mutex.xMutexTry(p);
  }
  return rc;
}
########################rank 3#############################
SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){
  if( p ){
    assert( sqlite3GlobalConfig.mutex.xMutexEnter );
    sqlite3GlobalConfig.mutex.xMutexEnter(p);
  }
}
########################rank 4#############################
SQLITE_API void wx_sqlite3_mutex_leave(wx_sqlite3_mutex *p){
  if( p ){
    assert( wx_sqlite3GlobalConfig.mutex.xMutexLeave );
    wx_sqlite3GlobalConfig.mutex.xMutexLeave(p);
  }
}
########################rank 5#############################
SQLITE_PRIVATE int sqlite3MutexEnd(void){
  int rc = SQLITE_OK;
  if( sqlite3GlobalConfig.mutex.xMutexEnd ){
    rc = sqlite3GlobalConfig.mutex.xMutexEnd();
  }
#ifdef SQLITE_DEBUG
  GLOBAL(int, mutexIsInit) = 0;
#endif
  return rc;
}
########################rank 6#############################
a_mutex_lock(plock)
volatile a_mutex_t *plock;
{
    Disable_Int();
    while (mutex_lock_failed(plock))
    {
	Enable_Int();
	while (*plock)
	    continue;
	Disable_Int();
    }
}
########################rank 7#############################
SQLITE_PRIVATE int wx_sqlite3MutexEnd(void){
  int rc = SQLITE_OK;
  if( wx_sqlite3GlobalConfig.mutex.xMutexEnd ){
    rc = wx_sqlite3GlobalConfig.mutex.xMutexEnd();
  }
#ifdef SQLITE_DEBUG
  GLOBAL(int, mutexIsInit) = 0;
#endif
  return rc;
}
########################rank 8#############################
int
__objc_mutex_allocate(objc_mutex_t mutex)
{
  mutex->backend = objc_malloc(sizeof(pthread_mutex_t));
  if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))
    {
      objc_free(mutex->backend);
      mutex->backend = NULL;
      return -1;
    }
  return 0;
}
########################rank 9#############################
static sqlite3_mutex *unixBigLock = 0;
static void unixEnterMutex(void){
  sqlite3_mutex_enter(unixBigLock);
}
########################rank 10#############################
int
__objc_mutex_deallocate(objc_mutex_t mutex)
{
  int count = 1;
  while (count)
    {
      if ((count = pthread_mutex_unlock((pthread_mutex_t*)mutex->backend)) < 0)
        return -1;
    }
  if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))
    return -1;
  objc_free(mutex->backend);
  mutex->backend = NULL;
  return 0;
}
----------------------------QUERY-------------------------------
advance a carray cursor to next row of output
########################rank 1#############################
static int carrayNext(sqlite3_vtab_cursor *cur){
  carray_cursor *pCur = (carray_cursor*)cur;
  pCur->iRowid++;
  return SQLITE_OK;
}
########################rank 2#############################
SQLITE_PRIVATE int wx_sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 3#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 4#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 5#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 6#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 7#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 8#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 9#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
########################rank 10#############################
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  assert( pCur!=0 );
  return pCur->eState==CURSOR_VALID;
}
----------------------------QUERY-------------------------------
split string into args respecting backwhack and quote
########################rank 1#############################
l_int32
sarraySplitString(SARRAY      *sa,
                  const char  *str,
                  const char  *separators)
{
char  *cstr, *substr, *saveptr;
    PROCNAME("sarraySplitString");
    if (!sa)
        return ERROR_INT("sa not defined", procName, 1);
    if (!str)
        return ERROR_INT("str not defined", procName, 1);
    if (!separators)
        return ERROR_INT("separators not defined", procName, 1);
    cstr = stringNew(str);  /* preserves const-ness of input str */
    substr = strtokSafe(cstr, separators, &saveptr);
    if (substr)
        sarrayAddString(sa, substr, L_INSERT);
    while ((substr = strtokSafe(NULL, separators, &saveptr)))
        sarrayAddString(sa, substr, L_INSERT);
    FREE(cstr);
    return 0;
}
########################rank 2#############################
char *chomp(char *str)
{
    if (str) {
        int len = strlen(str);
        while (len > 0 && (str[len-1] == '\r' || str[len-1] == '\n'))
            len--;
        str[len] = '\0';
    }
    return str;
}
########################rank 3#############################
int string_split_quotes(char *str, int *argc, char ***argv)
{
	*argc = 0;
	*argv = malloc((strlen(str) + 1) * sizeof(char *));
	if(!*argv)
		return 0;
	while(*str) {
		while(isspace((int) *str)) {
			str++;
		}
		if(!*str)
			break;
		(*argv)[(*argc)++] = str;
		while(*str) {
			if(*str == '\\') {
				memmove(str, str + 1, strlen(str));
				if(*str)
					str++;
			} else if(isspace((int) *str)) {
				*str = 0;
				str++;
				break;
			} else if(*str == '\'' || *str == '\"') {
				char quote = *str;
				memmove(str, str + 1, strlen(str));
				while(*str) {
					if(*str == '\\') {
						memmove(str, str + 1, strlen(str));
						if(*str)
							str++;
					} else if(*str == quote) {
						memmove(str, str + 1, strlen(str));
						break;
					} else {
						str++;
					}
				}
			} else if(!*str) {
				break;
			} else {
				str++;
			}
		}
	}
	(*argv)[*argc] = 0;
	return 1;
}
########################rank 4#############################
static void
unknown(char *str)
{
  if(strlen(str) > 0) {
    shell_output("Unknown command: ", str);
  }
}
########################rank 5#############################
static void
unknown(char *str)
{
  if(strlen(str) > 0) {
    shell_output("Unknown command: ", str);
  }
}
########################rank 6#############################
static void
tosort(FILE *f, char *cdstr, char *dstr, nauty_counter index)
{
    int i;
    char buff[30];
    for (i = 0; cdstr[i] != '\n'; ++i) {}
    cdstr[i] = '\0';
    writeline(f,cdstr);
    if (dstr != NULL)
    {
        writeline(f," ");
        for (i = 0; dstr[i] != '\n'; ++i) {}
        dstr[i] = '\0';
        writeline(f,dstr);
    }
    if (index > 0)
    {
#if LONG_LONG_COUNTERS
        sprintf(buff,"\t%11llu\n",index);
#else
        sprintf(buff,"\t%10lu\n",index);
#endif
        writeline(f,buff);
    }
    else
        writeline(f,"\n");
}
########################rank 7#############################
l_int32
stringReplace(char       **pdest,
              const char  *src)
{
char    *scopy;
l_int32  len;
    PROCNAME("stringReplace");
    if (!pdest)
        return ERROR_INT("pdest not defined", procName, 1);
    if (*pdest)
        FREE(*pdest);
    if (src) {
        len = strlen(src);
        if ((scopy = (char *)CALLOC(len + 1, sizeof(char))) == NULL)
            return ERROR_INT("scopy not made", procName, 1);
        stringCopy(scopy, src, len);
        *pdest = scopy;
    }
    else
        *pdest = NULL;
    return 0;
}
########################rank 8#############################
char *cclass(char *source, char *src)
{
   char   *s;        /* Source pointer    */
   char   *cp;       /* Pattern start     */
   int    c;         /* Current character */
   int             o;         /* Temp              */
   s = src;
   o = CLASS;
   if (*s == '^') {
      ++s;
      o = NCLASS;
   }
   store(o);
   cp = pp;
   store(0);                          /* Byte count      */
   while ((c = *s++) && c!=']') {
      if (c == '\\') {                /* Store quoted char    */
         if ((c = *s++) == '\0')      /* Gotta get something  */
            badpat("Class terminates badly", source, s);
         else    store(tolower(c));
      }
      else if (c == '-' &&
            (pp - cp) > 1 && *s != ']' && *s != '\0') {
         c = pp[-1];             /* Range start     */
         pp[-1] = RANGE;         /* Range signal    */
         store(c);               /* Re-store start  */
         c = *s++;               /* Get end char and*/
         store(tolower(c));      /* Store it        */
      }
      else {
         store(tolower(c));      /* Store normal char */
      }
   }
   if (c != ']')
      badpat("Unterminated class", source, s);
   if ((c = (pp - cp)) >= 256)
      badpat("Class too large", source, s);
   if (c == 0)
      badpat("Empty class", source, s);
   *cp = c;
   return(s);
}
########################rank 9#############################
int Xcode_puny_encodeString( const DWORD *  pdwzInputString,
                             const int      iInputSize,
                             UCHAR8 *       pzOutputString,
                             int *          piOutputSize )
{
  int status;
  int offset        = 0;
  int output_offset = 0;
  unsigned int punycode_input_length;
  DWORD punycode_input[MAX_LABEL_SIZE_32];
  unsigned int encoded_string_length;
  char encoded_string[MAX_LABEL_SIZE_8];
  if ( iInputSize < 1 || pzOutputString == 0 ) 
  {
    return XCODE_BAD_ARGUMENT_ERROR;
  }
  memset( pzOutputString, 0, *piOutputSize );
  if (iInputSize > MAX_LABEL_SIZE_32) 
  {
    return XCODE_BUFFER_OVERFLOW_ERROR;
  }
  punycode_input_length = 0;
  for( offset = 0; offset < iInputSize; offset++ ) 
  {
    punycode_input[offset] = pdwzInputString[offset];
    punycode_input_length++;
  }
  if so just copy the input to output. no need to encode
  otherwise try to encode it */
  if( is_all_basic(punycode_input_length, punycode_input) == 1 ) 
  {
    for (offset = 0; offset < punycode_input_length; offset++) 
    {
	    *(pzOutputString + offset) = (char)*(punycode_input + offset);
    }
    *piOutputSize = punycode_input_length;
    return XCODE_SUCCESS;
  }
  encoded_string_length = MAX_LABEL_SIZE_8;
  status = punycode_encode(
    punycode_input_length,
    punycode_input,
    &encoded_string_length,
    encoded_string );
  if (status != XCODE_SUCCESS) 
  {
    return status;
  }
  if( ( strlen( ACE_PREFIX ) + encoded_string_length ) > MAX_LABEL_SIZE_8 ) 
  {
    return XCODE_BUFFER_OVERFLOW_ERROR;
  }
  output_offset = strlen(ACE_PREFIX);
  strncat( (char*)pzOutputString, ACE_PREFIX, strlen(ACE_PREFIX) );
  for ( offset = 0; offset < encoded_string_length; offset++ ) 
  {
    *(pzOutputString + output_offset++) = *(encoded_string + offset);
  }
  *piOutputSize = strlen(ACE_PREFIX) + encoded_string_length;
  *(pzOutputString + output_offset) = '\0';
  return XCODE_SUCCESS;
}
########################rank 10#############################
wdparse(string, w, nums, flag)            /* if flag != 0 add to wrds list */
char	*string;                 /* if flag == 0 (user inp) put #s in nums */
int	w[], nums[];                              /* and return # of words */
{
        char *bp;
	char wdbuf[128];
	int numactwds, i, numnums;
	if (flag == 0)
	    nums[0] = nums[1] = numnums = 0;
	cpyn(bp = wdbuf, string, sizeof(wdbuf) - 1);
	for (numactwds = 0; numactwds < MAXACTWDS; ) {
	    bp = movchars(bp, wdbuf, wrdels);
	    if (wdbuf[0] == '\0')
		break;
	    if (flag) {                                    /* script input */
		w[numactwds] = wrdadd(wdbuf, 0, 0, 0);
		cpy(inwrd[numactwds++], wdbuf);
	    } else {                                         /* user input */
		i = which(wdbuf, wrds);
		if (i > 0) {                              /* hashed symbol */
		    w[numactwds] = i;
		    cpy(inwrd[numactwds++], wdbuf);
		} else if ((*wdbuf == '-' ||
		 (*wdbuf >= '0' && *wdbuf <= '9'))
		 && numnums < MAXINPNUMS) {                      /* number */
		    w[numactwds] = numnums == 0? objnum1 : objnum2;
		    cpy(inwrd[numactwds++], wdbuf);
		    nums[numnums++] = atoi(wdbuf);
		}
	    }
	}
	for (i = numactwds; i < MAXACTWDS; ) {
	    w[i] = NO_WORD;
	    inwrd[i++][0] = '\0';
	}
	return(numactwds);
}
----------------------------QUERY-------------------------------
retrieve page from the pager cache
########################rank 1#############################
SQLITE_PRIVATE int sqlite3PagerWalInfo(Pager *pPager, u32 *pnPrior, u32 *pnFrame){
  return sqlite3WalInfo(pPager->pWal, pnPrior, pnFrame);
}
########################rank 2#############################
static int pager_write(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc = SQLITE_OK;
  ** been started. The journal file may or may not be open at this point.
  ** It is never called in the ERROR state.
  */
  assert( pPager->eState==PAGER_WRITER_LOCKED
       || pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
  );
  assert( assert_pager_state(pPager) );
  assert( pPager->errCode==0 );
  assert( pPager->readOnly==0 );
  CHECK_PAGE(pPg);
  ** obtained the necessary locks to begin the write-transaction, but the
  ** rollback journal might not yet be open. Open it now if this is the case.
  **
  ** This is done before calling sqlite3PcacheMakeDirty() on the page. 
  ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then
  ** an error might occur and the pager would end up in WRITER_LOCKED state
  ** with pages marked as dirty in the cache.
  */
  if( pPager->eState==PAGER_WRITER_LOCKED ){
    rc = pager_open_journal(pPager);
    if( rc!=SQLITE_OK ) return rc;
  }
  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );
  assert( assert_pager_state(pPager) );
  sqlite3PcacheMakeDirty(pPg);
  ** to change is in the rollback journal, or if the page is a new page off
  ** then end of the file, make sure it is marked as PGHDR_NEED_SYNC.
  */
  assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );
  if( pPager->pInJournal!=0
   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0
  ){
    assert( pagerUseWal(pPager)==0 );
    if( pPg->pgno<=pPager->dbOrigSize ){
      rc = pagerAddPageToRollbackJournal(pPg);
      if( rc!=SQLITE_OK ){
        return rc;
      }
    }else{
      if( pPager->eState!=PAGER_WRITER_DBMOD ){
        pPg->flags |= PGHDR_NEED_SYNC;
      }
      PAGERTRACE(("APPEND %d page %d needSync=%d\n",
              PAGERID(pPager), pPg->pgno,
             ((pPg->flags&PGHDR_NEED_SYNC)?1:0)));
    }
  }
  ** and before writing the page into the rollback journal.  Wait until now,
  ** after the page has been successfully journalled, before setting the
  ** PGHDR_WRITEABLE bit that indicates that the page can be safely modified.
  */
  pPg->flags |= PGHDR_WRITEABLE;
  ** then write the page into the statement journal.
  */
  if( pPager->nSavepoint>0 ){
    rc = subjournalPageIfRequired(pPg);
  }
  if( pPager->dbSize<pPg->pgno ){
    pPager->dbSize = pPg->pgno;
  }
  return rc;
}
########################rank 3#############################
static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
  int rc = SQLITE_OK;                  /* Return code */
  assert( !pagerUseWal(pPager) );
  assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );
  assert( pPager->eLock==EXCLUSIVE_LOCK );
  assert( isOpen(pPager->fd) || pList->pDirty==0 );
  ** is not possible for rc to be other than SQLITE_OK if this branch
  ** is taken, as pager_wait_on_lock() is a no-op for temp-files.
  */
  if( !isOpen(pPager->fd) ){
    assert( pPager->tempFile && rc==SQLITE_OK );
    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
  }
  ** file size will be.
  */
  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );
  if( rc==SQLITE_OK 
   && pPager->dbHintSize<pPager->dbSize
   && (pList->pDirty || pList->pgno>pPager->dbHintSize)
  ){
    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);
    pPager->dbHintSize = pPager->dbSize;
  }
  while( rc==SQLITE_OK && pList ){
    Pgno pgno = pList->pgno;
    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to
    ** make the file smaller (presumably by auto-vacuum code). Do not write
    ** any such pages to the file.
    **
    ** Also, do not write out any page that has the PGHDR_DONT_WRITE flag
    ** set (set by sqlite3PagerDontWrite()).
    */
    if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){
      i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */
      char *pData;                                   /* Data to write */    
      assert( (pList->flags&PGHDR_NEED_SYNC)==0 );
      if( pList->pgno==1 ) pager_write_changecounter(pList);
      CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM_BKPT, pData);
      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);
      ** the value now stored in the database file. If writing this 
      ** page caused the database file to grow, update dbFileSize. 
      */
      if( pgno==1 ){
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
      }
      if( pgno>pPager->dbFileSize ){
        pPager->dbFileSize = pgno;
      }
      pPager->aStat[PAGER_STAT_WRITE]++;
      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);
      PAGERTRACE(("STORE %d page %d hash(%08x)\n",
                   PAGERID(pPager), pgno, pager_pagehash(pList)));
      IOTRACE(("PGOUT %p %d\n", pPager, pgno));
      PAGER_INCR(sqlite3_pager_writedb_count);
    }else{
      PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));
    }
    pager_set_pagehash(pList);
    pList = pList->pDirty;
  }
  return rc;
}
########################rank 4#############################
SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager){
  return pPager->tempFile;
}
########################rank 5#############################
SQLITE_PRIVATE int wx_sqlite3PagerCommitPhaseOne(
  Pager *pPager,                  /* Pager object */
  const char *zMaster,            /* If not NULL, the master journal name */
  int noSync                      /* True to omit the xSync on the db file */
){
  int rc = SQLITE_OK;             /* Return code */
  assert( pPager->eState==PAGER_WRITER_LOCKED
       || pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
       || pPager->eState==PAGER_ERROR
  );
  assert( assert_pager_state(pPager) );
  if( NEVER(pPager->errCode) ) return pPager->errCode;
  if( wx_sqlite3FaultSim(400) ) return SQLITE_IOERR;
  PAGERTRACE(("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n", 
      pPager->zFilename, zMaster, pPager->dbSize));
  if( pPager->eState<PAGER_WRITER_CACHEMOD ) return SQLITE_OK;
  assert( MEMDB==0 || pPager->tempFile );
  assert( isOpen(pPager->fd) || pPager->tempFile );
  if( 0==pagerFlushOnCommit(pPager, 1) ){
    ** function has already been called, it is mostly a no-op.  However, any
    ** backup in progress needs to be restarted.  */
    wx_sqlite3BackupRestart(pPager->pBackup);
  }else{
    if( pagerUseWal(pPager) ){
      PgHdr *pList = wx_sqlite3PcacheDirtyList(pPager->pPCache);
      PgHdr *pPageOne = 0;
      if( pList==0 ){
        ** Ticket [2d1a5c67dfc2363e44f29d9bbd57f] 2011-05-18 */
        rc = wx_sqlite3PagerGet(pPager, 1, &pPageOne, 0);
        pList = pPageOne;
        pList->pDirty = 0;
      }
      assert( rc==SQLITE_OK );
      if( ALWAYS(pList) ){
        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
      }
      wx_sqlite3PagerUnref(pPageOne);
      if( rc==SQLITE_OK ){
        wx_sqlite3PcacheCleanAll(pPager->pPCache);
      }
    }else{
      ** should be used.  No rollback journal is created if batch-atomic-write
      ** is enabled.
      */
      wx_sqlite3_file *fd = pPager->fd;
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
      const int bBatch = zMaster==0    /* An SQLITE_IOCAP_BATCH_ATOMIC commit */
        && (wx_sqlite3OsDeviceCharacteristics(fd) & SQLITE_IOCAP_BATCH_ATOMIC)
        && !pPager->noSync
        && wx_sqlite3JournalIsInMemory(pPager->jfd);
#else
# define bBatch 0
#endif
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
      ** does this depends on whether or not the atomic-update optimization
      ** was enabled at compile time, and if this transaction meets the 
      ** runtime criteria to use the operation: 
      **
      **    * The file-system supports the atomic-write property for
      **      blocks of size page-size, and 
      **    * This commit is not part of a multi-file transaction, and
      **    * Exactly one page has been modified and store in the journal file.
      **
      ** If the optimization was not enabled at compile time, then the
      ** pager_incr_changecounter() function is called to update the change
      ** counter in 'indirect-mode'. If the optimization is compiled in but
      ** is not applicable to this transaction, call wx_sqlite3JournalCreate()
      ** to make sure the journal file has actually been created, then call
      ** pager_incr_changecounter() to update the change-counter in indirect
      ** mode. 
      **
      ** Otherwise, if the optimization is both enabled and applicable,
      ** then call pager_incr_changecounter() to update the change-counter
      ** in 'direct' mode. In this case the journal file will never be
      ** created for this transaction.
      */
      if( bBatch==0 ){
        PgHdr *pPg;
        assert( isOpen(pPager->jfd) 
            || pPager->journalMode==PAGER_JOURNALMODE_OFF 
            || pPager->journalMode==PAGER_JOURNALMODE_WAL 
            );
        if( !zMaster && isOpen(pPager->jfd) 
         && pPager->journalOff==jrnlBufferSize(pPager) 
         && pPager->dbSize>=pPager->dbOrigSize
         && (!(pPg = wx_sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)
        ){
          ** following call will modify the in-memory representation of page 1 
          ** to include the updated change counter and then write page 1 
          ** directly to the database file. Because of the atomic-write 
          ** property of the host file-system, this is safe.
          */
          rc = pager_incr_changecounter(pPager, 1);
        }else{
          rc = wx_sqlite3JournalCreate(pPager->jfd);
          if( rc==SQLITE_OK ){
            rc = pager_incr_changecounter(pPager, 0);
          }
        }
      }
#else 
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
      if( zMaster ){
        rc = wx_sqlite3JournalCreate(pPager->jfd);
        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
      }
#endif
      rc = pager_incr_changecounter(pPager, 0);
#endif
      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
      ** journal file name has already been written to the journal file, 
      ** or if zMaster is NULL (no master journal), then this call is a no-op.
      */
      rc = writeMasterJournal(pPager, zMaster);
      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
      ** If the atomic-update optimization is being used, this sync will not 
      ** create the journal file or perform any real IO.
      **
      ** Because the change-counter page was just modified, unless the
      ** atomic-update optimization is used it is almost certain that the
      ** journal requires a sync here. However, in locking_mode=exclusive
      ** on a system under memory pressure it is just possible that this is 
      ** not the case. In this case it is likely enough that the redundant
      ** xSync() call will be changed to a no-op by the OS anyhow. 
      */
      rc = syncJournal(pPager, 0);
      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
      if( bBatch ){
        ** next, attempting to play the journal back into the database would
        ** be unsafe. Close it now to make sure that does not happen.  */
        wx_sqlite3OsClose(pPager->jfd);
        rc = wx_sqlite3OsFileControl(fd, SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, 0);
        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
      }
      rc = pager_write_pagelist(pPager,wx_sqlite3PcacheDirtyList(pPager->pPCache));
      if( bBatch ){
        if( rc==SQLITE_OK ){
          rc = wx_sqlite3OsFileControl(fd, SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, 0);
        }
        if( rc!=SQLITE_OK ){
          wx_sqlite3OsFileControlHint(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);
        }
      }
      if( rc!=SQLITE_OK ){
        assert( rc!=SQLITE_IOERR_BLOCKED );
        goto commit_phase_one_exit;
      }
      wx_sqlite3PcacheCleanAll(pPager->pPCache);
      ** pager_truncate to grow the file here. This can happen if the database
      ** image was extended as part of the current transaction and then the
      ** last page in the db image moved to the free-list. In this case the
      ** last page is never written out to disk, leaving the database file
      ** undersized. Fix this now if it is the case.  */
      if( pPager->dbSize>pPager->dbFileSize ){
        Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));
        assert( pPager->eState==PAGER_WRITER_DBMOD );
        rc = pager_truncate(pPager, nNew);
        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
      }
      if( !noSync ){
        rc = wx_sqlite3PagerSync(pPager, zMaster);
      }
      IOTRACE(("DBSYNC %p\n", pPager))
    }
  }
commit_phase_one_exit:
  if( rc==SQLITE_OK && !pagerUseWal(pPager) ){
    pPager->eState = PAGER_WRITER_FINISHED;
  }
  return rc;
}
########################rank 6#############################
SQLITE_PRIVATE int sqlite3PagerOpenWal(
  Pager *pPager,                  /* Pager object */
  int *pbOpen                     /* OUT: Set to true if call is a no-op */
){
  int rc = SQLITE_OK;             /* Return code */
  assert( assert_pager_state(pPager) );
  assert( pPager->eState==PAGER_OPEN   || pbOpen );
  assert( pPager->eState==PAGER_READER || !pbOpen );
  assert( pbOpen==0 || *pbOpen==0 );
  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );
  if( !pPager->tempFile && !pPager->pWal ){
    if( !sqlite3PagerWalSupported(pPager) ) return SQLITE_CANTOPEN;
    sqlite3OsClose(pPager->jfd);
    rc = pagerOpenWal(pPager);
    if( rc==SQLITE_OK ){
      pPager->journalMode = PAGER_JOURNALMODE_WAL;
      pPager->eState = PAGER_OPEN;
    }
  }else{
    *pbOpen = 1;
  }
  return rc;
}
########################rank 7#############################
SQLITE_PRIVATE int keen_io_sqlite3WalBeginWriteTransaction(Wal *pWal){
  int rc;
  ** transaction. */
  assert( pWal->readLock>=0 );
  if( pWal->readOnly ){
    return SQLITE_READONLY;
  }
  ** SQLITE_BUSY if unable.
  */
  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);
  if( rc ){
    return rc;
  }
  pWal->writeLock = 1;
  ** time the read transaction on this connection was started, then
  ** the write is disallowed.
  */
  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){
    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
    pWal->writeLock = 0;
    rc = SQLITE_BUSY_SNAPSHOT;
  }
  return rc;
}
########################rank 8#############################
SQLITE_PRIVATE int wx_sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
  int rc;                         /* Return code */
  int cnt = 0;                    /* Number of TryBeginRead attempts */
#ifdef SQLITE_ENABLE_SNAPSHOT
  int bChanged = 0;
  WalIndexHdr *pSnapshot = pWal->pSnapshot;
  if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){
    bChanged = 1;
  }
#endif
  do{
    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);
  }while( rc==WAL_RETRY );
  testcase( (rc&0xff)==SQLITE_BUSY );
  testcase( (rc&0xff)==SQLITE_IOERR );
  testcase( rc==SQLITE_PROTOCOL );
  testcase( rc==SQLITE_OK );
#ifdef SQLITE_ENABLE_SNAPSHOT
  if( rc==SQLITE_OK ){
    if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){
      ** a value equal to or smaller than pSnapshot->mxFrame, but pWal->hdr
      ** is populated with the wal-index header corresponding to the head
      ** of the wal file. Verify that pSnapshot is still valid before
      ** continuing.  Reasons why pSnapshot might no longer be valid:
      **
      **    (1)  The WAL file has been reset since the snapshot was taken.
      **         In this case, the salt will have changed.
      **
      **    (2)  A checkpoint as been attempted that wrote frames past
      **         pSnapshot->mxFrame into the database file.  Note that the
      **         checkpoint need not have completed for this to cause problems.
      */
      volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
      assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );
      assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame );
      ** concurrent with this code. If this is the case, it may be that the
      ** checkpointer has already determined that it will checkpoint 
      ** snapshot X, where X is later in the wal file than pSnapshot, but 
      ** has not yet set the pInfo->nBackfillAttempted variable to indicate 
      ** its intent. To avoid the race condition this leads to, ensure that
      ** there is no checkpointer process by taking a shared CKPT lock 
      ** before checking pInfo->nBackfillAttempted.  
      **
      ** TODO: Does the aReadMark[] lock prevent a checkpointer from doing
      **       this already?
      */
      rc = walLockShared(pWal, WAL_CKPT_LOCK);
      if( rc==SQLITE_OK ){
        ** not, also check that no checkpointer has attempted to checkpoint any
        ** frames beyond pSnapshot->mxFrame. If either of these conditions are
        ** true, return SQLITE_BUSY_SNAPSHOT. Otherwise, overwrite pWal->hdr
        ** with *pSnapshot and set *pChanged as appropriate for opening the
        ** snapshot.  */
        if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))
         && pSnapshot->mxFrame>=pInfo->nBackfillAttempted
        ){
          assert( pWal->readLock>0 );
          memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));
          *pChanged = bChanged;
        }else{
          rc = SQLITE_BUSY_SNAPSHOT;
        }
        walUnlockShared(pWal, WAL_CKPT_LOCK);
      }
      if( rc!=SQLITE_OK ){
        wx_sqlite3WalEndReadTransaction(pWal);
      }
    }
  }
#endif
  return rc;
}
########################rank 9#############################
SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
  int rc;                         /* Return code */
  int cnt = 0;                    /* Number of TryBeginRead attempts */
#ifdef SQLITE_ENABLE_SNAPSHOT
  int bChanged = 0;
  WalIndexHdr *pSnapshot = pWal->pSnapshot;
  if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){
    bChanged = 1;
  }
#endif
  do{
    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);
  }while( rc==WAL_RETRY );
  testcase( (rc&0xff)==SQLITE_BUSY );
  testcase( (rc&0xff)==SQLITE_IOERR );
  testcase( rc==SQLITE_PROTOCOL );
  testcase( rc==SQLITE_OK );
#ifdef SQLITE_ENABLE_SNAPSHOT
  if( rc==SQLITE_OK ){
    if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){
      ** a value equal to or smaller than pSnapshot->mxFrame, but pWal->hdr
      ** is populated with the wal-index header corresponding to the head
      ** of the wal file. Verify that pSnapshot is still valid before
      ** continuing.  Reasons why pSnapshot might no longer be valid:
      **
      **    (1)  The WAL file has been reset since the snapshot was taken.
      **         In this case, the salt will have changed.
      **
      **    (2)  A checkpoint as been attempted that wrote frames past
      **         pSnapshot->mxFrame into the database file.  Note that the
      **         checkpoint need not have completed for this to cause problems.
      */
      volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
      assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );
      assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame );
      ** concurrent with this code. If this is the case, it may be that the
      ** checkpointer has already determined that it will checkpoint 
      ** snapshot X, where X is later in the wal file than pSnapshot, but 
      ** has not yet set the pInfo->nBackfillAttempted variable to indicate 
      ** its intent. To avoid the race condition this leads to, ensure that
      ** there is no checkpointer process by taking a shared CKPT lock 
      ** before checking pInfo->nBackfillAttempted.  
      **
      ** TODO: Does the aReadMark[] lock prevent a checkpointer from doing
      **       this already?
      */
      rc = walLockShared(pWal, WAL_CKPT_LOCK);
      if( rc==SQLITE_OK ){
        ** not, also check that no checkpointer has attempted to checkpoint any
        ** frames beyond pSnapshot->mxFrame. If either of these conditions are
        ** true, return SQLITE_BUSY_SNAPSHOT. Otherwise, overwrite pWal->hdr
        ** with *pSnapshot and set *pChanged as appropriate for opening the
        ** snapshot.  */
        if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))
         && pSnapshot->mxFrame>=pInfo->nBackfillAttempted
        ){
          assert( pWal->readLock>0 );
          memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));
          *pChanged = bChanged;
        }else{
          rc = SQLITE_BUSY_SNAPSHOT;
        }
        walUnlockShared(pWal, WAL_CKPT_LOCK);
      }
      if( rc!=SQLITE_OK ){
        sqlite3WalEndReadTransaction(pWal);
      }
    }
  }
#endif
  return rc;
}
########################rank 10#############################
static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){
  Pgno nFreeList;           /* Number of pages still on the free-list */
  int rc;
  assert( sqlite3_mutex_held(pBt->mutex) );
  assert( iLastPg>nFin );
  if( !PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg!=PENDING_BYTE_PAGE(pBt) ){
    u8 eType;
    Pgno iPtrPage;
    nFreeList = get4byte(&pBt->pPage1->aData[36]);
    if( nFreeList==0 ){
      return SQLITE_DONE;
    }
    rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( eType==PTRMAP_ROOTPAGE ){
      return SQLITE_CORRUPT_BKPT;
    }
    if( eType==PTRMAP_FREEPAGE ){
      if( bCommit==0 ){
        ** if bCommit is non-zero. In that case, the free-list will be
        ** truncated to zero after this function returns, so it doesn't 
        ** matter if it still contains some garbage entries.
        */
        Pgno iFreePg;
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, BTALLOC_EXACT);
        if( rc!=SQLITE_OK ){
          return rc;
        }
        assert( iFreePg==iLastPg );
        releasePage(pFreePg);
      }
    } else {
      Pgno iFreePg;             /* Index of free page to move pLastPg to */
      MemPage *pLastPg;
      u8 eMode = BTALLOC_ANY;   /* Mode parameter for allocateBtreePage() */
      Pgno iNear = 0;           /* nearby parameter for allocateBtreePage() */
      rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);
      if( rc!=SQLITE_OK ){
        return rc;
      }
      ** is swapped with the first free page pulled off the free list.
      **
      ** On the other hand, if bCommit is greater than zero, then keep
      ** looping until a free-page located within the first nFin pages
      ** of the file is found.
      */
      if( bCommit==0 ){
        eMode = BTALLOC_LE;
        iNear = nFin;
      }
      do {
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);
        if( rc!=SQLITE_OK ){
          releasePage(pLastPg);
          return rc;
        }
        releasePage(pFreePg);
      }while( bCommit && iFreePg>nFin );
      assert( iFreePg<iLastPg );
      rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);
      releasePage(pLastPg);
      if( rc!=SQLITE_OK ){
        return rc;
      }
    }
  }
  if( bCommit==0 ){
    do {
      iLastPg--;
    }while( iLastPg==PENDING_BYTE_PAGE(pBt) || PTRMAP_ISPAGE(pBt, iLastPg) );
    pBt->bDoTruncate = 1;
    pBt->nPage = iLastPg;
  }
  return SQLITE_OK;
}
----------------------------QUERY-------------------------------
round up to nearest integer
########################rank 1#############################
static uint8_t gfmul(uint8_t a, uint8_t b)
{
	uint8_t v;
	v = 0;
	while (b) {
		if ((b & 1) != 0)
			v ^= a;
		if ((a & 0x80) != 0) {
			a <<= 1;
			a ^= 0x1d;
		} else {
			a <<= 1;
		}
		b >>= 1;
	}
	return v;
}
########################rank 2#############################
static int toint32(double d)
{
	double two32 = 4294967296.0;
	double two31 = 2147483648.0;
	if (!isfinite(d) || d == 0)
		return 0;
	d = fmod(d, two32);
	d = d >= 0 ? floor(d) : ceil(d) + two32;
	if (d >= two31)
		return d - two32;
	else
		return d;
}
########################rank 3#############################
static int toint32(double d)
{
	double two32 = 4294967296.0;
	double two31 = 2147483648.0;
	if (!isfinite(d) || d == 0)
		return 0;
	d = fmod(d, two32);
	d = d >= 0 ? floor(d) : ceil(d) + two32;
	if (d >= two31)
		return d - two32;
	else
		return d;
}
########################rank 4#############################
static void rq_round3(modq *h,const modq *f)
{
  int i;
  for (i = 0;i < p;++i)
    h[i] = ((21846 * (f[i] + 2295) + 32768) >> 16) * 3 - 2295;
}
########################rank 5#############################
void round2int(a, b, n, cprec)
double *a, *b;
int n, cprec;
{
	int i,k;
	for(i=0; i<n; i++) {
		k = a[i] > 0.0 ? 1 : -1;
		b[i] = (int)(a[i]*(1<<cprec) + k*0.5);
		b[i] /= (double)(1<<cprec);
	}
}
########################rank 6#############################
static SKP_int32 gcd(
    SKP_int32 a,
    SKP_int32 b
)
{
    SKP_int32 tmp;
    while( b > 0 ) {
        tmp = a - b * SKP_DIV32( a, b );
        a   = b;
        b   = tmp;
    }
    return a;
}
########################rank 7#############################
static void power_spectrum(spx_word16_t *X, spx_word32_t *ps, int N)
{
   int i, j;
   ps[0]=MULT16_16(X[0],X[0]);
   for (i=1,j=1;i<N-1;i+=2,j++)
   {
      ps[j] =  MULT16_16(X[i],X[i]) + MULT16_16(X[i+1],X[i+1]);
   }
   ps[j]=MULT16_16(X[i],X[i]);
}
########################rank 8#############################
static OPUS_INLINE float tansig_approx(float x)
{
	int i;
	float y, dy;
	float sign=1;
    if (!(x<8))
        return 1;
    if (!(x>-8))
        return -1;
	if (x<0)
	{
	   x=-x;
	   sign=-1;
	}
	i = (int)floor(.5f+25*x);
	x -= .04f*i;
	y = tansig_table[i];
	dy = 1-y*y;
	y = y + x*dy*(1 - y*x);
	return sign*y;
}
########################rank 9#############################
double
__floatunsdidf(u_quad_t x)
{
	double d;
	union uu u;
	u.uq = x;
	d = (double)u.ul[H] * (((int)1 << (INT_BITS - 2)) * 4.0);
	d += u.ul[L];
	return (d);
}
########################rank 10#############################
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
unsigned cvt_to_2digit(uint8_t i, uint8_t base)
{
  return ((i / base) | (uint32_t)(i % base)<<8);
}
----------------------------QUERY-------------------------------
create a new thread safe queue of size siz
########################rank 1#############################
QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
	( void ) ucQueueType;
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
	if( uxItemSize == ( UBaseType_t ) 0 )
	{
		xQueueSizeInBytes = ( size_t ) 0;
	}
	else
	{
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
	if( pxNewQueue != NULL )
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
		}
		else
		{
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
		}
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
		pxNewQueue->uxItemSize = uxItemSize;
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			pxNewQueue->ucQueueType = ucQueueType;
		}
		#endif /* configUSE_TRACE_FACILITY */
		#if( configUSE_QUEUE_SETS == 1 )
		{
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */
		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
	configASSERT( xReturn );
	return xReturn;
}
########################rank 2#############################
inline size_t
queue_size(queue *q)
{
	return q->end;
}
########################rank 3#############################
BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
	system call (or maximum API call) interrupt priority.  Interrupts that are
	above the maximum system call priority are kept permanently enabled, even
	when the RTOS kernel is in a critical section, but cannot make any calls to
	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has been
	assigned a priority above the configured maximum system call priority.
	Only FreeRTOS functions that end in FromISR can be called from interrupts
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
					{
						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
						{
							posting	to the queue set caused a higher priority
							task to	unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
							{
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
								}
								else
								{
									mtCOVERAGE_TEST_MARKER();
								}
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */
			}
			else
			{
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	return xReturn;
}
########################rank 4#############################
void needJobsForQueue(queue *q, int type) {
    uint32_t import_per_sec; 
    uint32_t to_fetch;       /* Number of jobs we should try to obtain. */
    unsigned long num_responders = 0;
    mstime_t bcast_delay, adhoc_delay;
    mstime_t now = mstime();
    if (myselfLeaving()) return;
    import_per_sec = getQueueImportRate(q);
     * if there is some active traffic, in order to improve latency.
     * Otherwise we wait for the first client to block, that will trigger
     * a new call to this function, but with NEEDJOBS_CLIENTS_WAITING type. */
    if (type == NEEDJOBS_REACHED_ZERO && import_per_sec == 0) return;
     * a list of sources, assume that each source is capable of providing
     * some message. */
    num_responders = getQueueValidResponders(q);
    to_fetch = NEEDJOBS_MIN_REQUEST;
    if (num_responders > 0)
        to_fetch = import_per_sec / num_responders;
    if (to_fetch < NEEDJOBS_MIN_REQUEST) to_fetch = NEEDJOBS_MIN_REQUEST;
    else if (to_fetch > NEEDJOBS_MAX_REQUEST) to_fetch = NEEDJOBS_MAX_REQUEST;
     * We use exponential intervals (with a max time limit) */
    bcast_delay = NEEDJOBS_BCAST_ALL_MIN_DELAY *
                  (1 << q->needjobs_bcast_attempt);
    if (bcast_delay > NEEDJOBS_BCAST_ALL_MAX_DELAY)
        bcast_delay = NEEDJOBS_BCAST_ALL_MAX_DELAY;
    if (now - q->needjobs_bcast_time > bcast_delay) {
        q->needjobs_bcast_time = now;
        q->needjobs_bcast_attempt++;
         * ask for a single job in this case. */
        clusterSendNeedJobs(q->name,1,server.cluster->nodes);
    }
     * have at least a source node, send an ad-hoc message to
     * nodes known to be sources for this queue.
     *
     * We use exponential delays here as well (but don't care about
     * the delay if the queue just dropped to zero), however with
     * much shorter times compared to the cluster-wide broadcast. */
    adhoc_delay = NEEDJOBS_BCAST_ADHOC_MIN_DELAY *
                  (1 << q->needjobs_adhoc_attempt);
    if (adhoc_delay > NEEDJOBS_BCAST_ADHOC_MAX_DELAY)
        adhoc_delay = NEEDJOBS_BCAST_ADHOC_MAX_DELAY;
    if ((type == NEEDJOBS_REACHED_ZERO ||
         now - q->needjobs_adhoc_time > adhoc_delay) &&
         num_responders > 0)
    {
        q->needjobs_adhoc_time = now;
        q->needjobs_adhoc_attempt++;
        clusterSendNeedJobs(q->name,to_fetch,q->needjobs_responders);
    }
}
########################rank 5#############################
BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( pxQueue->uxItemSize != 0 ); 
	system call (or maximum API call) interrupt priority.  Interrupts that are
	above the maximum system call priority are kept permanently enabled, even
	when the RTOS kernel is in a critical section, but cannot make any calls to
	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has been
	assigned a priority above the configured maximum system call priority.
	Only FreeRTOS functions that end in FromISR can be called from interrupts
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
			prvCopyDataFromQueue( pxQueue, pvBuffer );
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	return xReturn;
}
########################rank 6#############################
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;
	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
	{
		xReturn = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
	}
	return xReturn;
} 
static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;
	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
	return xReturn;
}
########################rank 7#############################
BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}
			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	return xReturn;
}
########################rank 8#############################
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
						{
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
							{
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
								}
								else
								{
									mtCOVERAGE_TEST_MARKER();
								}
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */
			}
			else
			{
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	return xReturn;
}
########################rank 9#############################
void needJobsForQueue(RedisModuleCtx *ctx, queue *q, int type) {
    uint32_t import_per_sec; 
    uint32_t to_fetch;       /* Number of jobs we should try to obtain. */
    unsigned long num_responders = 0;
    mstime_t bcast_delay, adhoc_delay;
    mstime_t now = mstime();
    if (myselfLeaving()) return;
    import_per_sec = getQueueImportRate(q);
     * if there is some active traffic, in order to improve latency.
     * Otherwise we wait for the first client to block, that will trigger
     * a new call to this function, but with NEEDJOBS_CLIENTS_WAITING type. */
    if (type == NEEDJOBS_REACHED_ZERO && import_per_sec == 0) return;
     * a list of sources, assume that each source is capable of providing
     * some message. */
    num_responders = getQueueValidResponders(q);
    to_fetch = NEEDJOBS_MIN_REQUEST;
    if (num_responders > 0)
        to_fetch = import_per_sec / num_responders;
    if (to_fetch < NEEDJOBS_MIN_REQUEST) to_fetch = NEEDJOBS_MIN_REQUEST;
    else if (to_fetch > NEEDJOBS_MAX_REQUEST) to_fetch = NEEDJOBS_MAX_REQUEST;
     * We use exponential intervals (with a max time limit) */
    bcast_delay = NEEDJOBS_BCAST_ALL_MIN_DELAY *
                  (1 << q->needjobs_bcast_attempt);
    if (bcast_delay > NEEDJOBS_BCAST_ALL_MAX_DELAY)
        bcast_delay = NEEDJOBS_BCAST_ALL_MAX_DELAY;
    if (now - q->needjobs_bcast_time > bcast_delay) {
        q->needjobs_bcast_time = now;
        q->needjobs_bcast_attempt++;
         * ask for a single job in this case. */
        clusterSendNeedJobs(ctx,q->name,1,NULL);
    }
     * have at least a source node, send an ad-hoc message to
     * nodes known to be sources for this queue.
     *
     * We use exponential delays here as well (but don't care about
     * the delay if the queue just dropped to zero), however with
     * much shorter times compared to the cluster-wide broadcast. */
    adhoc_delay = NEEDJOBS_BCAST_ADHOC_MIN_DELAY *
                  (1 << q->needjobs_adhoc_attempt);
    if (adhoc_delay > NEEDJOBS_BCAST_ADHOC_MAX_DELAY)
        adhoc_delay = NEEDJOBS_BCAST_ADHOC_MAX_DELAY;
    if ((type == NEEDJOBS_REACHED_ZERO ||
         now - q->needjobs_adhoc_time > adhoc_delay) &&
         num_responders > 0)
    {
        q->needjobs_adhoc_time = now;
        q->needjobs_adhoc_attempt++;
        clusterSendNeedJobs(ctx,q->name,to_fetch,q->needjobs_responders);
    }
}
########################rank 10#############################
void q_enqueue( Queue q, void *data )
{
   Node n;
#ifdef DEBUGGING
   if (q == NULL) {
      WARN("q == NULL");
      return;
   }
#endif /* DEBUGGING */
   n = malloc(sizeof(Node_));
   n->data = data;
   n->next = NULL;
   if (q->first == NULL)
      q->first = n;
   else
      q->last->next = n;
   q->last = n;
   return;
}
----------------------------QUERY-------------------------------
push integer to end of list
########################rank 1#############################
void gdbwire_mi_result_list_push_back(struct gdbwire_mi_result_list *list,
        struct gdbwire_mi_result *result)
{
    *list->tail = result;
    list->tail = &result->next;
}
########################rank 2#############################
static obj_t entry_lambda(obj_t env, obj_t op_env, obj_t operator, obj_t operands)
{
  obj_t list;
  unless(TYPE(operands) == TYPE_PAIR &&
         TYPE(CDR(operands)) == TYPE_PAIR)
    error("%s: illegal syntax", operator->operator.name);
  list = CAR(operands);
  while(list != obj_empty && TYPE(list) != TYPE_SYMBOL) {
    unless(TYPE(list) == TYPE_PAIR &&
           TYPE(CAR(list)) == TYPE_SYMBOL)
      error("%s: illegal argument list", operator->operator.name);
    list = CDR(list);
  }
  return make_operator("anonymous function",
                       entry_interpret, CAR(operands),
                       make_pair(obj_begin, CDR(operands)),
                       env, op_env);
}
########################rank 3#############################
LVAL xnull(void)
{
    LVAL arg;
    arg = xlgetarg();
    xllastarg();
    return (null(arg) ? s_true : NIL);
}
########################rank 4#############################
LOCAL LVAL nth(int carflag)
{
    LVAL list,num;
    FIXTYPE n;
    num = xlgafixnum();
    list = xlgacons();
    xllastarg();
    if ((n = getfixnum(num)) < 0)
        xlfail("bad argument");
    while (consp(list) && --n >= 0)
        list = cdr(list);
    return (carflag && consp(list) ? car(list) : list);
}
########################rank 5#############################
SGSONE sgs_PushNulls( SGS_CTX, int count )
{
	stk_push_nulls( C, count );
	return 1;
}
########################rank 6#############################
void pvl_push(pvl_list L, void *d)
{
    struct pvl_elem_t *E = pvl_new_element(d, 0, L->tail);
       E->next = 0;
       E->prior = L->tail;
     */
    if (L->tail != 0) {
        L->tail->next = E;
    }
    if (L->head == 0) {
        L->head = E;
    }
    L->tail = E;
    L->count++;
}
########################rank 7#############################
LVAL xlistp(void)
{
    LVAL arg;
    arg = xlgetarg();
    xllastarg();
    return (listp(arg) ? s_true : NIL);
}
########################rank 8#############################
LVAL xintegerp(void)
{
    LVAL arg;
    arg = xlgetarg();
    xllastarg();
    return (fixp(arg) ? s_true : NIL);
}
########################rank 9#############################
LVAL xsymbolp(void)
{
    LVAL arg;
    arg = xlgetarg();
    xllastarg();
    return (arg == NIL || symbolp(arg) ? s_true : NIL);
}
########################rank 10#############################
LVAL xfloatp(void)
{
    LVAL arg;
    arg = xlgetarg();
    xllastarg();
    return (floatp(arg) ? s_true : NIL);
}
----------------------------QUERY-------------------------------
restart timer from current point in time
########################rank 1#############################
void
stimer_restart(struct stimer *t)
{
  t->start = clock_seconds();
}
########################rank 2#############################
void
restart_inactivity_timer(uint32_t timeout)
{
    struct timeval now;
    if (g_this_event.ssn == NULL  ||  g_this_event.ssn->ssn_is_valid != TRUE)   return;
    gettimeofday(&now, NULL);
    timeval_add_ms(&now, timeout);
    CANCEL(g_this_event.ssn->ssn_InactivityTimer);
    g_this_event.ssn->ssn_InactivityTimer = event_add(&now, state_inactivity_timeout, g_this_event.ssn);
}
########################rank 3#############################
void CL_RestartTimeDeltas( int newTimeDelta ) {
	int i;
	cl.serverTimeDelta = cl.newServerTimeDelta = newTimeDelta;
	for( i = 0; i < MAX_TIMEDELTAS_BACKUP; i++ )
		cl.serverTimeDeltas[i] = newTimeDelta;
	if( cl_debug_timeDelta->integer ) {
		Com_Printf( S_COLOR_CYAN "***** timeDelta restarted\n" );
	}
}
########################rank 4#############################
void
uip_timer_restart(struct uip_timer *t)
{
  t->start = clock_time();
}
########################rank 5#############################
static int locktime(gtime_t time, gtime_t *lltime, unsigned char LLI)
{
    if (!lltime->time||(LLI&1)) *lltime=time;
    return (int)timediff(time,*lltime);
}
########################rank 6#############################
void Cvar_Reset_f( void ) {
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: reset <variable>\n" );
		return;
	}
	Cvar_Reset( Cmd_Argv( 1 ) );
}
########################rank 7#############################
void Cvar_Reset_f( void ) {
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: reset <variable>\n" );
		return;
	}
	Cvar_Reset( Cmd_Argv( 1 ) );
}
########################rank 8#############################
static void detslp_gf_L1L5(rtk_t *rtk, const obsd_t *obs, int i, int j,
                           const nav_t *nav)
{
    int sat=obs[i].sat;
    double g0,g1;
    trace(3,"detslp_gf_L1L5: i=%d j=%d\n",i,j);
    if (rtk->opt.nf<=2||(g1=gfobs_L1L5(obs,i,j,nav->lam[sat-1]))==0.0) return;
    g0=rtk->ssat[sat-1].gf2; rtk->ssat[sat-1].gf2=g1;
    if (g0!=0.0&&fabs(g1-g0)>rtk->opt.thresslip) {
        rtk->ssat[sat-1].slip[0]|=1;
        rtk->ssat[sat-1].slip[2]|=1;
        errmsg(rtk,"slip detected (sat=%2d GF_L1_L5=%.3f %.3f)\n",sat,g0,g1);
    }
}
########################rank 9#############################
static void detslp_gf_L1L2(rtk_t *rtk, const obsd_t *obs, int i, int j,
                           const nav_t *nav)
{
    int sat=obs[i].sat;
    double g0,g1;
    trace(3,"detslp_gf_L1L2: i=%d j=%d\n",i,j);
    if (rtk->opt.nf<=1||(g1=gfobs_L1L2(obs,i,j,nav->lam[sat-1]))==0.0) return;
    g0=rtk->ssat[sat-1].gf; rtk->ssat[sat-1].gf=g1;
    if (g0!=0.0&&fabs(g1-g0)>rtk->opt.thresslip) {
        rtk->ssat[sat-1].slip[0]|=1;
        rtk->ssat[sat-1].slip[1]|=1;
        errmsg(rtk,"slip detected (sat=%2d GF_L1_L2=%.3f %.3f)\n",sat,g0,g1);
    }
}
########################rank 10#############################
static void upd7759_reset(upd7759_state *chip)
{
	chip->pos                = 0;
	chip->fifo_in            = 0;
	chip->drq                = 0;
	chip->state              = STATE_IDLE;
	chip->clocks_left        = 0;
	chip->nibbles_left       = 0;
	chip->repeat_count       = 0;
	chip->post_drq_state     = STATE_IDLE;
	chip->post_drq_clocks    = 0;
	chip->req_sample         = 0;
	chip->last_sample        = 0;
	chip->block_header       = 0;
	chip->sample_rate        = 0;
	chip->first_valid_header = 0;
	chip->offset             = 0;
	chip->repeat_offset      = 0;
	chip->adpcm_state        = 0;
	chip->adpcm_data         = 0;
	chip->sample             = 0;
	// Valley Bell: reset buffer
	chip->data_buf[0] = chip->data_buf[1] = 0x00;
	chip->dbuf_pos_read = 0x00;
	chip->dbuf_pos_write = 0x00;
	//if (chip->timer)
	//	timer_adjust_oneshot(chip->timer, attotime_never, 0);
	if (chip->ChipMode)
		chip->clocks_left = -1;
}
----------------------------QUERY-------------------------------
return file name in path
########################rank 1#############################
char *
filename_get_directory(const char *filename)
{
    char *filename2;
    size_t len = strlen(filename);
    char *result;
    while (len && filename[len] != '/' && filename[len] != '\\')
        len--;
    filename2 = malloc(len+1);
    if (filename2 == NULL)
        exit(1);
    memcpy(filename2, filename, len+1);
    filename2[len] = '\0';
    if (filename_is_absolute(filename2))
        result = filename_combine(filename2, "");
    else {
        char buf[512];
        if (getcwd(buf, sizeof(buf)) == NULL)
            exit(1);
        result = filename_combine(buf, filename2);
    }
    free(filename2);
    return result;
}
########################rank 2#############################
static char *fileNameToSymbol(const char *fileName)
{
    char *name;
    int i;
    name = malloc(strlen(fileName) + 1);
    check(name != 0, cantMalloc, "the symbol name");
    strcpy(name, fileName);
    for (i = 0; name[i]; ++i) {
        if (!((name[i] >= 'a' && name[i] <= 'z') || 
                (name[i] >= 'A' && name[i] <= 'Z') || 
                (name[i] >= '0' && name[i] <= '9'))) {
            name[i] = '_';
        }
    }
    if (name[0] >= '0' && name[0] <= '9') {
        name[0] = '_';
    }
    return name;
}
########################rank 3#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 4#############################
int
filename_is_absolute(const char *filename)
{
    if (filename == NULL || filename[0] == '\0')
        return 0;
    if (filename[0] == '/')
        return 1;
#if WIN32
    if (filename[0] == '\\')
        return 1;
    if (strlen(filename) >= 3) {
        if (my_isalpha(filename[0]) && filename[1] == ':') {
            if (filename[2] == '\\' || filename[2] == '/')
                return 1;
        }
    }
#endif
    return 0;
}
########################rank 5#############################
char * file_basename(char * file) {
	char * c = strrchr(file, '/');
	if (!c) return file;
	return (c+1);
}
########################rank 6#############################
PRIVATE char *pathsearch(argv0,name,modemask)
char *argv0;
char *name;
int modemask;
{
  char *pathlist;
  char *path,*cp;
  char c;
  extern int access();
#ifdef __WIN32__
  cp = strrchr(argv0,'\\');
#else
  cp = strrchr(argv0,'/');
#endif
  if( cp ){
    c = *cp;
    *cp = 0;
    path = (char *)malloc( strlen(argv0) + strlen(name) + 2 );
    if( path ) sprintf(path,"%s/%s",argv0,name);
    *cp = c;
  }else{
    extern char *getenv();
    pathlist = getenv("PATH");
    if( pathlist==0 ) pathlist = ".:/bin:/usr/bin";
    path = (char *)malloc( strlen(pathlist)+strlen(name)+2 );
    if( path!=0 ){
      while( *pathlist ){
        cp = strchr(pathlist,':');
        if( cp==0 ) cp = &pathlist[strlen(pathlist)];
        c = *cp;
        *cp = 0;
        sprintf(path,"%s/%s",pathlist,name);
        *cp = c;
        if( c==0 ) pathlist = "";
        else pathlist = &cp[1];
        if( access(path,modemask)==0 ) break;
      }
    }
  }
  return path;
}
########################rank 7#############################
int
tuncompressible_filename()
{
	return 0;
}
########################rank 8#############################
int
tuncompressible_filename()
{
	return 0;
}
########################rank 9#############################
char path_file_name[256];
char * getfilename(int idx) {
  sprintf(path_file_name,"%d", idx);
  return path_file_name;
}
########################rank 10#############################
static const char* bt_get_basename(const char* path)
{
	const char* p = strchr(path, '\0') - 1;
	for (; p >= path && *p != '/' && *p != '\\'; p--);
	return (p + 1);
}
----------------------------QUERY-------------------------------
get name of current executable
########################rank 1#############################
const char *private_get_extension(const char *filename) {
    const char *dot_pos = strrchr(filename, '.');
    return dot_pos == NULL ? "" : dot_pos + 1;
}
########################rank 2#############################
mlt_position mlt_properties_get_position( mlt_properties self, const char *name )
{
	mlt_position result = 0;
	mlt_property value = mlt_properties_find( self, name );
	if ( value )
	{
		mlt_profile profile = mlt_properties_get_data( self, "_profile", NULL );
		double fps = mlt_profile_fps( profile );
		property_list *list = self->local;
		result = mlt_property_get_position( value, fps, list->locale );
	}
	return result;
}
########################rank 3#############################
int tgetent(bp, name)
	char	*bp;	
	char	*name;	/* name of the entry */
{
#if MSDOS
	nansi = strcmp(name, "ansi");
#endif
	return 1;
}
########################rank 4#############################
char *get_basename(char *filename)
{
	char *c;
	int len;
	char *basefilename;
	if (!filename)
		return NULL;
	len = strlen(filename);
	basefilename = (char *)malloc(len + 1);
	if (basefilename == NULL)
	{
		return NULL;
	}
	strcpy(basefilename, filename);
	for (c = basefilename + len; c > basefilename &&*c != '.'; c--)
	{
		;
	} // Get last .
	if (*c == '.')
		*c = 0;
	return basefilename;
}
########################rank 5#############################
static int get_lang(char *b)
{
	char *s;
	s = getenv("LANG");
	if (!s || strlen(s) < 2)
		return -1;
	b[0] = s[0];
	b[1] = s[1];
	b[2] = '\0';
	return 0;
}
########################rank 6#############################
char* mlt_properties_anim_get( mlt_properties self, const char *name, int position, int length )
{
	mlt_profile profile = mlt_properties_get_data( self, "_profile", NULL );
	double fps = mlt_profile_fps( profile );
	mlt_property value = mlt_properties_find( self, name );
	property_list *list = self->local;
	return value == NULL ? NULL : mlt_property_anim_get_string( value, fps, list->locale, position, length );
}
########################rank 7#############################
int proc(void)
{
    int x,y;
    scanf("%x %x", &y, &x);
    return x-y;
}
########################rank 8#############################
static int
p_get_var_type(value vvar, type tvar, value vvtype, type ttype)
{
    dident	dtype;
    Check_Output_Atom_Or_Nil(vvtype, ttype);
    if (IsRef(tvar))
    {
	switch (TagType(tvar))
	{
	case TNAME:
	case TVAR_TAG:
	    dtype = d_.free;
	    break;
	case TUNIV:
	    dtype = d_.universally_quantified;
	    break;
	case TMETA:
	    dtype = d_.meta0;
	    break;
	default:
	    Bip_Error(UNIFY_OVNI);
	}
	Return_Unify_Atom(vvtype, ttype, dtype);
    }
    else
    {
	Set_Bip_Error(0);
	Fail_;
    }
}
########################rank 9#############################
static struct adobeinfo *
findtfm(const char *p)
{
  return findname (tfmptrs, 256, p);
}
########################rank 10#############################
const char *
Clp_SetProgramName(Clp_Parser *clp, const char *name)
{
    const char *old = clp->internal->program_name;
    clp->internal->program_name = name;
    return old;
}
----------------------------QUERY-------------------------------
read machine uptime
########################rank 1#############################
void read_uptime(unsigned long long *uptime)
{
	FILE *fp = NULL;
	char line[128];
	unsigned long up_sec, up_cent;
	int err = FALSE;
	if ((fp = fopen(UPTIME, "r")) == NULL) {
		err = TRUE;
	}
	else if (fgets(line, sizeof(line), fp) == NULL) {
		err = TRUE;
	}
	else if (sscanf(line, "%lu.%lu", &up_sec, &up_cent) == 2) {
		*uptime = (unsigned long long) up_sec * 100 +
			  (unsigned long long) up_cent;
	}
	else {
		err = TRUE;
	}
	if (fp != NULL) {
		fclose(fp);
	}
	if (err) {
		fprintf(stderr, _("Cannot read %s\n"), UPTIME);
		exit(2);
	}
}
########################rank 2#############################
SEL  *
selReadStream(FILE  *fp)
{
char    *selname;
char     linebuf[L_BUF_SIZE];
l_int32  sy, sx, cy, cx, i, j, version, ignore;
SEL     *sel;
    PROCNAME("selReadStream");
    if (!fp)
        return (SEL *)ERROR_PTR("stream not defined", procName, NULL);
    if (fscanf(fp, "  Sel Version %d\n", &version) != 1)
        return (SEL *)ERROR_PTR("not a sel file", procName, NULL);
    if (version != SEL_VERSION_NUMBER)
        return (SEL *)ERROR_PTR("invalid sel version", procName, NULL);
    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)
        return (SEL *)ERROR_PTR("error reading into linebuf", procName, NULL);
    selname = stringNew(linebuf);
    sscanf(linebuf, "  ------  %s  ------", selname);
    if (fscanf(fp, "  sy = %d, sx = %d, cy = %d, cx = %d\n",
            &sy, &sx, &cy, &cx) != 4)
        return (SEL *)ERROR_PTR("dimensions not read", procName, NULL);
    if ((sel = selCreate(sy, sx, selname)) == NULL)
        return (SEL *)ERROR_PTR("sel not made", procName, NULL);
    selSetOrigin(sel, cy, cx);
    for (i = 0; i < sy; i++) {
        ignore = fscanf(fp, "    ");
        for (j = 0; j < sx; j++)
            ignore = fscanf(fp, "%1d", &sel->data[i][j]);
        ignore = fscanf(fp, "\n");
    }
    ignore = fscanf(fp, "\n");
    FREE(selname);
    return sel;
}
########################rank 3#############################
int read_dataflash(unsigned long addr, unsigned long size, char *result)
{
	unsigned int AddrToRead = addr;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
	if (pFlash == 0)
		return -1;
	return (AT91F_DataFlashRead(pFlash, AddrToRead, size, result));
}
########################rank 4#############################
int read_dataflash(unsigned long addr, unsigned long size, char *result)
{
	unsigned int AddrToRead = addr;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
	if (pFlash == 0)
		return -1;
	return (AT91F_DataFlashRead(pFlash, AddrToRead, size, result));
}
########################rank 5#############################
int read_dataflash(unsigned long addr, unsigned long size, char *result)
{
	unsigned int AddrToRead = addr;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
	if (pFlash == 0)
		return -1;
	return (AT91F_DataFlashRead(pFlash, AddrToRead, size, result));
}
########################rank 6#############################
int read_dataflash(unsigned long addr, unsigned long size, char *result)
{
	unsigned int AddrToRead = addr;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
	if (pFlash == 0)
		return -1;
	return (AT91F_DataFlashRead(pFlash, AddrToRead, size, result));
}
########################rank 7#############################
static int read_and_print_one(unsigned int port,int size)
{
    static int fd = -1;
    unsigned char b; unsigned short w; unsigned int l;
    if (fd < 0)
	fd = open(PORT_FILE, O_RDONLY);
    if (fd < 0) {
	fprintf(stderr, "%s: %s: %s\n", prgname, PORT_FILE, strerror(errno));
	return 1;
    }
    lseek(fd, port, SEEK_SET);
    if (size == 4) {
	read(fd, &l, 4);
	printf("%04x: 0x%08x\n", port, l);
    } else if (size == 2) {
	read(fd, &w, 2);
	printf("%04x: 0x%04x\n", port, w & 0xffff);
    } else {
	read(fd, &b, 1);
	printf("%04x: 0x%02x\n", port, b & 0xff);
    }
    return 0;
}
########################rank 8#############################
static void _ksa_read_idt(t_nubit8 intid, t_vaddrcc rdata) {
    _cb("_s_read_idt");
    if (!_GetCR0_PE) {
        _bb("CR0_PE(0)");
        if (GetMax16(intid * 4 + 3) > GetMax16(vcpu.data.idtr.limit)) _impossible_r_;
        _chr(_kma_read_logical(&vcpu.data.idtr, (intid * 4), rdata, 4, 0x00, 0));
        _be;
    } else {
        _bb("CR0_PE(1)");
        if (GetMax16(intid * 8 + 7) > GetMax16(vcpu.data.idtr.limit)) _impossible_r_;
        _chr(_kma_read_logical(&vcpu.data.idtr, (intid * 8), rdata, 8, 0x00, 0));
        _be;
    }
    _ce;
}
########################rank 9#############################
__read_funct_t wrap_read_stat_cpu(struct activity *a)
{
	struct stats_cpu *st_cpu
		= (struct stats_cpu *) a->_buf0;
	__nr_t nr_read = 0;
	do {
		nr_read = read_stat_cpu(st_cpu, a->nr_allocated);
		if (nr_read < 0) {
			st_cpu = (struct stats_cpu *) reallocate_buffer(a);
		}
	}
	while (nr_read < 0);
	a->_nr0 = nr_read;
	return;
}
########################rank 10#############################
static int readFromStdin(int clientfd, int stdi) {
  static escMode mode = EOL;
  char c[MAX_BYTE];
  int nbytes;
  nbytes = read(stdi, &c, sizeof(c));
  if (nbytes < 0) {
    perror("mTerm_client: Client socket read error to mTerm_server");
    return 0;
  }
  if((mode == EOL) && (c[0] == ASCII_CTRL_L)) {
    mode = ESC;
    return 1;
  } else if (mode == ESC) {
    return (processEscMode(clientfd, c[0], &mode));
  } else if (mode == SEND) {
    if (escSend(clientfd, c[0] , &mode) < 0) {
      mode = EOL;
      perror("mTerm_client: Invalid input to read buffer");
    }
    return 1;
  }
  charSend(clientfd, &c[0], nbytes);
  return 1;
}
----------------------------QUERY-------------------------------
store integer into register
########################rank 1#############################
void op_int_store(struct svm *svm)
{
    unsigned int reg = next_byte(svm);
    BOUNDS_TEST_REGISTER(reg);
    unsigned int val1 = next_byte(svm);
    unsigned int val2 = next_byte(svm);
    int value = BYTES_TO_ADDR(val1, val2);
    if (getenv("DEBUG") != NULL)
        printf("STORE_INT(Reg:%02x) => %04d [Hex:%04x]\n", reg, value, value);
    if ((svm->registers[reg].type == STRING) && (svm->registers[reg].content.string))
        free(svm->registers[reg].content.string);
    svm->registers[reg].content.integer = value;
    svm->registers[reg].type = INTEGER;
    svm->ip += 1;
}
########################rank 2#############################
float32 float32_div( float32 a, float32 b )
{
    flag aSign, bSign, zSign;
    int16 aExp, bExp, zExp;
    bits32 aSig, bSig, zSig, rem0, rem1, term0, term1;
    aSig = extractFloat32Frac( a );
    aExp = extractFloat32Exp( a );
    aSign = extractFloat32Sign( a );
    bSig = extractFloat32Frac( b );
    bExp = extractFloat32Exp( b );
    bSign = extractFloat32Sign( b );
    zSign = aSign ^ bSign;
    if ( aExp == 0xFF ) {
        if ( aSig ) return propagateFloat32NaN( a, b );
        if ( bExp == 0xFF ) {
            if ( bSig ) return propagateFloat32NaN( a, b );
            float_raise( float_flag_invalid );
            return float32_default_nan;
        }
        return packFloat32( zSign, 0xFF, 0 );
    }
    if ( bExp == 0xFF ) {
        if ( bSig ) return propagateFloat32NaN( a, b );
        return packFloat32( zSign, 0, 0 );
    }
    if ( bExp == 0 ) {
        if ( bSig == 0 ) {
            if ( ( aExp | aSig ) == 0 ) {
                float_raise( float_flag_invalid );
                return float32_default_nan;
            }
            float_raise( float_flag_divbyzero );
            return packFloat32( zSign, 0xFF, 0 );
        }
        normalizeFloat32Subnormal( bSig, &bExp, &bSig );
    }
    if ( aExp == 0 ) {
        if ( aSig == 0 ) return packFloat32( zSign, 0, 0 );
        normalizeFloat32Subnormal( aSig, &aExp, &aSig );
    }
    zExp = aExp - bExp + 0x7D;
    aSig = ( aSig | 0x00800000 )<<7;
    bSig = ( bSig | 0x00800000 )<<8;
    if ( bSig <= ( aSig + aSig ) ) {
        aSig >>= 1;
        ++zExp;
    }
    zSig = estimateDiv64To32( aSig, 0, bSig );
    if ( ( zSig & 0x3F ) <= 2 ) {
        mul32To64( bSig, zSig, &term0, &term1 );
        sub64( aSig, 0, term0, term1, &rem0, &rem1 );
        while ( (sbits32) rem0 < 0 ) {
            --zSig;
            add64( rem0, rem1, 0, bSig, &rem0, &rem1 );
        }
        zSig |= ( rem1 != 0 );
    }
    return roundAndPackFloat32( zSign, zExp, zSig );
}
########################rank 3#############################
ldiv_t
ldiv(long num, long denom)
{
	ldiv_t r;
	r.quot = num / denom;
	r.rem = num % denom;
	if (num >= 0 && r.rem < 0) {
		r.quot++;
		r.rem -= denom;
	}
	return (r);
}
########################rank 4#############################
ldiv_t
ldiv(long num, long denom)
{
	ldiv_t r;
	r.quot = num / denom;
	r.rem = num % denom;
	if (num >= 0 && r.rem < 0) {
		r.quot++;
		r.rem -= denom;
	}
	return (r);
}
########################rank 5#############################
ldiv_t
ldiv(long num, long denom)
{
	ldiv_t r;
	r.quot = num / denom;
	r.rem = num % denom;
	if (num >= 0 && r.rem < 0) {
		r.quot++;
		r.rem -= denom;
	}
	return (r);
}
########################rank 6#############################
ldiv_t ldiv(num, denom) long num, denom;
{
	ldiv_t r;
	r.quot = num / denom;
	r.rem = num % denom;
	if(num >= 0 && r.rem < 0)
	{
		r.quot++;
		r.rem -= denom;
	}
	return (r);
}
########################rank 7#############################
ph7_value * ph7_context_new_scalar(ph7_context *pCtx)
{
	ph7_value *pVal;
	pVal = ph7_new_scalar(pCtx->pVm);
	if( pVal ){
		 * when the calling function returns. 
		 */
		SySetPut(&pCtx->sVar,(const void *)&pVal);
	}
	return pVal;
}
########################rank 8#############################
JX9_PRIVATE jx9_value * jx9_context_new_scalar(jx9_context *pCtx)
{
	jx9_value *pVal;
	pVal = jx9_new_scalar(pCtx->pVm);
	if( pVal ){
		 * when the calling function returns. 
		 */
		SySetPut(&pCtx->sVar, (const void *)&pVal);
	}
	return pVal;
}
########################rank 9#############################
bool store_will_buy_tester(const struct object *obj)
{
	struct store *store = store_at(cave, player->grid);
	if (!store) return false;
	return store_will_buy(store, obj);
}
########################rank 10#############################
static void ir_value_code_setaddr(ir_value *self, int32_t gaddr)
{
    self->code.globaladdr = gaddr;
    if (self->members[0]) self->members[0]->code.globaladdr = gaddr;
    if (self->members[1]) self->members[1]->code.globaladdr = gaddr;
    if (self->members[2]) self->members[2]->code.globaladdr = gaddr;
}
----------------------------QUERY-------------------------------
stop stream server
########################rank 1#############################
void *thread(void *vargp){
    int connfd = (int)vargp;
    Pthread_detach(pthread_self());
    doit(connfd);
    Close(connfd);
}
########################rank 2#############################
static void consumer_stop(void)
{
    pthread_mutex_lock(&g_producer.mutex);
    g_producer.stop = true;
    pthread_cond_broadcast(&g_producer.req_cond);
    pthread_cond_broadcast(&g_producer.avail_cond);
    pthread_mutex_unlock(&g_producer.mutex);
}
########################rank 3#############################
Res ThreadDescribe(Thread thread, mps_lib_FILE *stream, Count depth)
{
  Res res;
  res = WriteF(stream, depth,
               "Thread $P ($U) {\n", (WriteFP)thread, (WriteFU)thread->serial,
               "  arena $P ($U)\n",
               (WriteFP)thread->arena, (WriteFU)thread->arena->serial,
               "  alive $S\n", WriteFYesNo(thread->alive),
               "  id $U\n",          (WriteFU)thread->id,
               "} Thread $P ($U)\n", (WriteFP)thread, (WriteFU)thread->serial,
               NULL);
  if(res != ResOK)
    return res;
  return ResOK;
}
########################rank 4#############################
static void
thread_cleanup_master(thread_master_t * m)
{
	thread_destroy_list(m, m->read);
	thread_destroy_list(m, m->write);
	thread_destroy_list(m, m->timer);
	thread_destroy_list(m, m->event);
	thread_destroy_list(m, m->ready);
	thread_destroy_list(m, m->child);
	epoll_cleanup(&m->epfd, &m->events);
	thread_clean_unuse(m);
}
########################rank 5#############################
static int s_silent;
 * Each modification of an element of p->array is a data race. */
static void* threadfunc(struct threadinfo* p)
{
  int i;
  int* const array = p->array;
  pthread_barrier_t* const b = p->b;
  if (! s_silent)
    printf("thread %lx iteration 0\n", pthread_self());
  pthread_barrier_wait(b);
  for (i = 0; i < p->iterations; i++)
  {
    if (! s_silent)
      printf("thread %lx iteration %d; writing to %p\n",
             pthread_self(), i + 1, &array[i]);
    array[i] = i;
    pthread_barrier_wait(b);
  }
  return 0;
}
########################rank 6#############################
int xdag_rpc_service_stop(void)
{
	g_rpc_stop = 2;
	xdag_rpc_command_host_clear(); //clear all white list.
	return 0;
}
########################rank 7#############################
void Con_Shutdown( void ) {
	if( !con_initialized ) {
		return;
	}
	Con_Clear_f();  // free scrollback text
	Cmd_RemoveCommand( "toggleconsole" );
	Cmd_RemoveCommand( "messagemode" );
	Cmd_RemoveCommand( "messagemode2" );
	Cmd_RemoveCommand( "clear" );
	Cmd_RemoveCommand( "condump" );
	QMutex_Destroy( &con.mutex );
	con_initialized = false;
}
########################rank 8#############################
void CL_Ping_f( void ) {
	netadr_t	to;
	ping_t*		pingptr;
	char*		server;
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: ping [server]\n");
		return;	
	}
	Com_Memset( &to, 0, sizeof(netadr_t) );
	server = Cmd_Argv(1);
	if ( !NET_StringToAdr( server, &to ) ) {
		return;
	}
	pingptr = CL_GetFreePing();
	memcpy( &pingptr->adr, &to, sizeof (netadr_t) );
	pingptr->start = cls.realtime;
	pingptr->time  = 0;
	CL_SetServerInfoByAddress(pingptr->adr, NULL, 0);
	NET_OutOfBandPrint( NS_CLIENT, to, "getinfo xxx" );
}
########################rank 9#############################
void CL_Ping_f( void ) {
	netadr_t to;
	ping_t*     pingptr;
	char*       server;
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: ping [server]\n" );
		return;
	}
	memset( &to, 0, sizeof( netadr_t ) );
	server = Cmd_Argv( 1 );
	if ( !NET_StringToAdr( server, &to ) ) {
		return;
	}
	pingptr = CL_GetFreePing();
	memcpy( &pingptr->adr, &to, sizeof( netadr_t ) );
	pingptr->start = cls.realtime;
	pingptr->time  = 0;
	CL_SetServerInfoByAddress( pingptr->adr, NULL, 0 );
	NET_OutOfBandPrint( NS_CLIENT, to, "getinfo xxx" );
}
########################rank 10#############################
void CL_Ping_f( void ) {
	netadr_t to;
	ping_t*     pingptr;
	char*       server;
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: ping [server]\n" );
		return;
	}
	memset( &to, 0, sizeof( netadr_t ) );
	server = Cmd_Argv( 1 );
	if ( !NET_StringToAdr( server, &to ) ) {
		return;
	}
	pingptr = CL_GetFreePing();
	memcpy( &pingptr->adr, &to, sizeof( netadr_t ) );
	pingptr->start = cls.realtime;
	pingptr->time  = 0;
	CL_SetServerInfoByAddress( pingptr->adr, NULL, 0 );
	NET_OutOfBandPrint( NS_CLIENT, to, "getinfo xxx" );
}
----------------------------QUERY-------------------------------
get length of UCS2 string
########################rank 1#############################
static char *
data_get_string(
		uint8_t **o,
		char term )
{
	uint8_t * p = *o;
	while (*p && *p != term)
		p++;
	if (*p) {
		*p = 0; p++;
	}
	uint8_t * res = *o;
	*o = p;
	return (char*)res;
}
########################rank 2#############################
int der_length_boolean(unsigned long *outlen) {
    LTC_ARGCHK(outlen != NULL);
    *outlen = 3;
    return CRYPT_OK;
}
########################rank 3#############################
int der_length_short_integer(unsigned long num, unsigned long *outlen) {
    unsigned long z, y, len;
    LTC_ARGCHK(outlen != NULL);
    num &= 0xFFFFFFFFUL;
    z = 0;
    y = num;
    while (y) {
        ++z;
        y >>= 8;
    }
    if (z == 0) {
        z = 1;
    }
    len = 1;
    ++len;
    len += z;
    len += (num & (1UL << ((z << 3) - 1))) ? 1 : 0;
    *outlen = len;
    return CRYPT_OK;
}
########################rank 4#############################
int len(char *s) {
    return strlen(s);
}
########################rank 5#############################
int len(char *s) {
    return strlen(s);
}
########################rank 6#############################
static int
_num_string_size(value v, type t, int quoted)
{
    return 8*SIZEOF_LONG + 1;
}
########################rank 7#############################
static int
_int_to_string(value v, type t, char *buf, int quoted_or_base)
{
    int base = quoted_or_base < 2 ? 10 : quoted_or_base;
    word number = v.nint;
    word aux = number;
    int	len, pos = 0;
    if (number < 0)
    {
	buf[pos++] = '-';
	number = -number;	
    }
    do	/* count digits */
    {
	++pos;
	aux /= base;
    } while(aux);
    len = pos;
    buf[pos--] = '\0';
    if (number < 0)		/* special case -2^(wordsize-1) */
    {
	int ch = (number-base) % base;
	buf[pos--] = (ch < 10) ? ch + '0' : ch + 'a' - 10;
	number = -(number/base);
    }
    do
    {
	int ch = number % base;
	buf[pos--] = (ch < 10) ? ch + '0' : ch + 'a' - 10;
	number /= base;
    } while(number);
    return len;
}
########################rank 8#############################
int der_length_utctime(ltc_utctime *utctime, unsigned long *outlen) {
    LTC_ARGCHK(outlen != NULL);
    LTC_ARGCHK(utctime != NULL);
    if ((utctime->off_hh == 0) && (utctime->off_mm == 0)) {
        *outlen = 2 + 13;
    } else {
        *outlen = 2 + 17;
    }
    return CRYPT_OK;
}
########################rank 9#############################
int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {
    const char *p = s;
    unsigned long plen = 0;
    int negative = 0;
    uint64_t v;
    if (plen == slen)
        return 0;
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }
    if (p[0] == '-') {
        negative = 1;
        p++; plen++;
        if (plen == slen)
            return 0;
    }
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else if (p[0] == '0' && slen == 1) {
        *value = 0;
        return 1;
    } else {
        return 0;
    }
    while (plen < slen && p[0] >= '0' && p[0] <= '9') {
        if (v > (UINT64_MAX / 10)) /* Overflow. */
            return 0;
        v *= 10;
        if (v > (UINT64_MAX - (p[0]-'0'))) /* Overflow. */
            return 0;
        v += p[0]-'0';
        p++; plen++;
    }
    if (plen < slen)
        return 0;
    if (negative) {
        if (v > ((uint64_t)(-(INT64_MIN+1))+1)) /* Overflow. */
            return 0;
        if (value != NULL) *value = -v;
    } else {
        if (v > INT64_MAX) /* Overflow. */
            return 0;
        if (value != NULL) *value = v;
    }
    return 1;
}
########################rank 10#############################
double fpconv_strtod(const char *nptr, char **endptr)
{
    char localbuf[FPCONV_G_FMT_BUFSIZE];
    char *buf, *endbuf, *dp;
    int buflen;
    double value;
    if (locale_decimal_point == '.')
        return strtod(nptr, endptr);
    buflen = strtod_buffer_size(nptr);
    if (!buflen) {
        *endptr = (char *)nptr;
        return 0;
    }
    if (buflen >= FPCONV_G_FMT_BUFSIZE) {
        buf = malloc(buflen + 1);
        if (!buf) {
            fprintf(stderr, "Out of memory");
            abort();
        }
    } else {
        buf = localbuf;
    }
    memcpy(buf, nptr, buflen);
    buf[buflen] = 0;
    dp = strchr(buf, '.');
    if (dp)
        *dp = locale_decimal_point;
    value = strtod(buf, &endbuf);
    *endptr = (char *)&nptr[endbuf - buf];
    if (buflen >= FPCONV_G_FMT_BUFSIZE)
        free(buf);
    return value;
}
----------------------------QUERY-------------------------------
contrain maximum of a range
########################rank 1#############################
static inline int
min(int a, int b)
{
	return (a < b) ? b : a;
}
########################rank 2#############################
int fun_b(unsigned x) {
    int val = 0;
    int i;
    for (i = 0; i < 32; i++) {
	val = (val << 1) | (x & 0x1);
	x >>= 1;
    }
    return val;
}
########################rank 3#############################
INLINE int Limit( int val, int max, int min ) {
	if ( val > max )
		val = max;
	else if ( val < min )
		val = min;
	return val;
}
########################rank 4#############################
q_t q_mul(q_t *q, q_t *r)
{
    q_t result;
    result.w = r->w*q->w - r->x*q->x - r->y*q->y - r->z*q->z;
    result.x = r->w*q->x + r->x*q->w - r->y*q->z + r->z*q->y;
    result.y = r->w*q->y + r->x*q->z + r->y*q->w - r->z*q->x;
    result.z = r->w*q->z - r->x*q->y + r->y*q->x + r->z*q->w;
    return result;
}
########################rank 5#############################
void ge_p1p1_to_p2(ge_p2 *r, const ge_p1p1 *p) {
    fe_mul(r->X, p->X, p->T);
    fe_mul(r->Y, p->Y, p->Z);
    fe_mul(r->Z, p->Z, p->T);
}
########################rank 6#############################
void ge_p1p1_to_p2(ge_p2 *r, const ge_p1p1 *p) {
    fe_mul(r->X, p->X, p->T);
    fe_mul(r->Y, p->Y, p->Z);
    fe_mul(r->Z, p->Z, p->T);
}
########################rank 7#############################
void ge_p1p1_to_p3(ge_p3 *r, const ge_p1p1 *p) {
    fe_mul(r->X, p->X, p->T);
    fe_mul(r->Y, p->Y, p->Z);
    fe_mul(r->Z, p->Z, p->T);
    fe_mul(r->T, p->X, p->Y);
}
########################rank 8#############################
void ge_p1p1_to_p3(ge_p3 *r, const ge_p1p1 *p) {
    fe_mul(r->X, p->X, p->T);
    fe_mul(r->Y, p->Y, p->Z);
    fe_mul(r->Z, p->Z, p->T);
    fe_mul(r->T, p->X, p->Y);
}
########################rank 9#############################
int bis(int x, int m) {
  int result = x | m;
#if 0
  int result = ___________;
#endif 
  return result;
}
########################rank 10#############################
long my_labs(x)
long x;
{
    return((x > 0) ? x : -x);
}
----------------------------QUERY-------------------------------
pad given buffer with len padding characters
########################rank 1#############################
void mystrscpy(char *dst, const char *src, int size)
{
	if (!size)
		return;
	while (--size) {
		char c = *src++;
		if (!c)
			break;
		*dst++ = c;
	}
	*dst = 0;
}
########################rank 2#############################
static void pad(unsigned char *buf, int len)
{
	for (int i = 0; i < len; i++)
		buf[i] = PADDING_CHAR;
}
########################rank 3#############################
uint32_t buffer_get_varlen(MOBIBuffer *buf, size_t *len) {
    return _buffer_get_varlen(buf, len, 1);
}
########################rank 4#############################
static uint32_t _buffer_get_varlen(MOBIBuffer *buf, size_t *len, const int direction) {
    uint32_t val = 0;
    uint8_t byte_count = 0;
    uint8_t byte;
    const uint8_t stop_flag = 0x80;
    const uint8_t mask = 0x7f;
    uint32_t shift = 0;
    do {
        if (direction == 1) {
            if (buf->offset + 1 > buf->maxlen) {
                debug_print("%s", "End of buffer\n");
                buf->error = MOBI_BUFFER_END;
                return val;
            }
            byte = buf->data[buf->offset++];
            val <<= 7;
            val |= (byte & mask);
        } else {
            if (buf->offset < 1) {
                debug_print("%s", "End of buffer\n");
                buf->error = MOBI_BUFFER_END;
                return val;
            }
            byte = buf->data[buf->offset--];
            val = val | (uint32_t)(byte & mask) << shift;
            shift += 7;
        }        
        (*len)++;
        byte_count++;
    } while (!(byte & stop_flag) && (byte_count < 4));
    return val;
}
########################rank 5#############################
size_t
openpam_strlcat(char *dst, const char *src, size_t size)
{
	size_t len;
	for (len = 0; *dst && size > 1; ++len, --size)
		dst++;
	for (; *src && size > 1; ++len, --size)
		*dst++ = *src++;
	*dst = '\0';
	while (*src)
		++len, ++src;
	return (len);
}
########################rank 6#############################
uint32_t buffer_get_varlen_dec(MOBIBuffer *buf, size_t *len) {
    return _buffer_get_varlen(buf, len, -1);
}
########################rank 7#############################
size_t
wcslcpy(wchar_t *dst, const wchar_t *src, size_t siz)
{
	wchar_t *d = dst;
	const wchar_t *s = src;
	size_t n = siz;
	if (n != 0 && --n != 0) {
		do {
			if ((*d++ = *s++) == 0)
				break;
		} while (--n != 0);
	}
	if (n == 0) {
		if (siz != 0)
			*d = '\0';		/* NUL-terminate dst */
		while (*s++)
			;
	}
	return(s - src - 1);	/* count does not include NUL */
}
########################rank 8#############################
char* _strset(char* szToFill, int szFill)
{
	char *t = szToFill;
	while (*szToFill != 0)
	{
		*szToFill = szFill;
		szToFill++;
	}
	return t;
}
########################rank 9#############################
char* _strset(char* szToFill, int szFill)
{
	char *t = szToFill;
	while (*szToFill != 0)
	{
		*szToFill = szFill;
		szToFill++;
	}
	return t;
}
########################rank 10#############################
static void b2w(unsigned int *out, const unsigned char *in, unsigned int len)
{
  const unsigned char *bpend = in + len;
  for (; in != bpend; in += 4, ++out)
  {
    *out = (unsigned int) (in[0] ) |
          (unsigned int) (in[3] << 24);
  }
}
----------------------------QUERY-------------------------------
write data in output buffers to client
########################rank 1#############################
int writeToClient(int fd, client *c, int handler_installed) {
    ssize_t nwritten = 0, totwritten = 0;
    size_t objlen;
    sds o;
    while(clientHasPendingReplies(c)) {
        if (c->bufpos > 0) {
            nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;
             * the remainder of the reply. */
            if (c->sentlen == c->bufpos) {
                c->bufpos = 0;
                c->sentlen = 0;
            }
        } else {
            o = listNodeValue(listFirst(c->reply));
            objlen = sdslen(o);
            if (objlen == 0) {
                listDelNode(c->reply,listFirst(c->reply));
                continue;
            }
            nwritten = write(fd, o + c->sentlen, objlen - c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;
            if (c->sentlen == objlen) {
                listDelNode(c->reply,listFirst(c->reply));
                c->sentlen = 0;
                c->reply_bytes -= objlen;
            }
        }
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver. */
        server.stat_net_output_bytes += totwritten;
        if (totwritten > NET_MAX_WRITES_PER_EVENT &&
            (server.maxmemory == 0 ||
             zmalloc_used_memory() < server.maxmemory)) break;
    }
    if (nwritten == -1) {
        if (errno == EAGAIN) {
            nwritten = 0;
        } else {
            serverLog(LL_VERBOSE,
                "Error writing to client: %s", strerror(errno));
            freeClient(c);
            return C_ERR;
        }
    }
    if (totwritten > 0) c->lastinteraction = server.unixtime;
    if (!clientHasPendingReplies(c)) {
        c->sentlen = 0;
        if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
            freeClient(c);
            return C_ERR;
        }
    }
    return C_OK;
}
########################rank 2#############################
void WriteClient( fileHandle_t f, gclient_t *cl ) {
	saveField_t *field;
	gclient_t temp;
	int length;
	// copy the structure across, then process the fields
	temp = *cl;
	// first, kill all events (assume they have been processed)
	memset( temp.ps.events, 0, sizeof( temp.ps.events ) );
	memset( temp.ps.eventParms, 0, sizeof( temp.ps.eventParms ) );
	temp.ps.eventSequence = 0;
	temp.ps.oldEventSequence = 0;
	temp.ps.entityEventSequence = 0;
	// change the pointers to lengths or indexes
	for ( field = gclientFields ; field->type ; field++ )
	{
		WriteField1( field, (byte *)&temp );
	}
	// write the block
	//if (!G_SaveWrite (&temp, sizeof(temp), f)) G_SaveWriteError();
	length = G_Save_Encode( (byte *)&temp, clientBuf, sizeof( temp ), sizeof( clientBuf ) );
	if ( !G_SaveWrite( &length, sizeof( length ), f ) ) {
		G_SaveWriteError();
	}
	if ( !G_SaveWrite( &clientBuf, length, f ) ) {
		G_SaveWriteError();
	}
	// now write any allocated data following the edict
	for ( field = gclientFields ; field->type ; field++ )
	{
		WriteField2( f, field, (byte *)cl );
	}
}
########################rank 3#############################
int anetWrite(int fd, char *buf, int count)
{
    int nwritten, totlen = 0;
    while(totlen != count) {
        nwritten = write(fd,buf,count-totlen);
        if (nwritten == 0) return totlen;
        if (nwritten == -1) return -1;
        totlen += nwritten;
        buf += nwritten;
    }
    return totlen;
}
########################rank 4#############################
void
write_stubs(void)
{
	list *l;
	definition *def;
	f_print(fout,
	    "\n\n");
	f_print(fout, "static struct timeval TIMEOUT = { %d, 0 };\n",
	    DEFAULT_TIMEOUT);
	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind == DEF_PROGRAM) {
			write_program(def);
		}
	}
}
########################rank 5#############################
void MSG_WriteDeltaUsercmd( msg_t *msg, usercmd_t *from, usercmd_t *to ) {
	if ( to->serverTime - from->serverTime < 256 ) {
		MSG_WriteBits( msg, 1, 1 );
		MSG_WriteBits( msg, to->serverTime - from->serverTime, 8 );
	} else {
		MSG_WriteBits( msg, 0, 1 );
		MSG_WriteBits( msg, to->serverTime, 32 );
	}
	MSG_WriteDelta( msg, from->angles[0], to->angles[0], 16 );
	MSG_WriteDelta( msg, from->angles[1], to->angles[1], 16 );
	MSG_WriteDelta( msg, from->angles[2], to->angles[2], 16 );
	MSG_WriteDelta( msg, from->forwardmove, to->forwardmove, 8 );
	MSG_WriteDelta( msg, from->rightmove, to->rightmove, 8 );
	MSG_WriteDelta( msg, from->upmove, to->upmove, 8 );
	MSG_WriteDelta( msg, from->buttons, to->buttons, 8 );
	MSG_WriteDelta( msg, from->wbuttons, to->wbuttons, 8 );
	MSG_WriteDelta( msg, from->weapon, to->weapon, 8 );
	MSG_WriteDelta( msg, from->flags, to->flags, 8 );
	MSG_WriteDelta( msg, from->doubleTap, to->doubleTap, 3 );
	MSG_WriteDelta( msg, from->identClient, to->identClient, 8 );           // NERVE - SMF
}
########################rank 6#############################
l_int32
pixaaWriteStream(FILE   *fp,
                 PIXAA  *pixaa)
{
l_int32  n, i;
PIXA    *pixa;
    PROCNAME("pixaaWriteStream");
#if !HAVE_LIBPNG     /* defined in environ.h and config_auto.h */
    return ERROR_INT("no libpng: can't read data", procName, 1);
#endif  /* !HAVE_LIBPNG */
    if (!fp)
        return ERROR_INT("stream not defined", procName, 1);
    if (!pixaa)
        return ERROR_INT("pixaa not defined", procName, 1);
    n = pixaaGetCount(pixaa);
    fprintf(fp, "\nPixaa Version %d\n", PIXAA_VERSION_NUMBER);
    fprintf(fp, "Number of pixa = %d\n", n);
    boxaWriteStream(fp, pixaa->boxa);
    for (i = 0; i < n; i++) {
        if ((pixa = pixaaGetPixa(pixaa, i, L_CLONE)) == NULL)
            return ERROR_INT("pixa not found", procName, 1);
        fprintf(fp, "\n\n --------------- pixa[%d] ---------------\n", i);
        pixaWriteStream(fp, pixa);
        pixaDestroy(&pixa);
    }
    return 0;
}
########################rank 7#############################
int tuntap_write(struct tuntap_dev *tuntap, unsigned char *buf, int len) {
  return(write(tuntap->fd, buf, len));
}
########################rank 8#############################
l_int32
pixaWrite(const char  *filename,
          PIXA        *pixa)
{
FILE  *fp;
    PROCNAME("pixaWrite");
#if !HAVE_LIBPNG     /* defined in environ.h and config_auto.h */
    return ERROR_INT("no libpng: can't write data", procName, 1);
#endif  /* !HAVE_LIBPNG */
    if (!filename)
        return ERROR_INT("filename not defined", procName, 1);
    if (!pixa)
        return ERROR_INT("pixa not defined", procName, 1);
    if ((fp = fopen(filename, "wb")) == NULL)
        return ERROR_INT("stream not opened", procName, 1);
    if (pixaWriteStream(fp, pixa))
        return ERROR_INT("pixa not written to stream", procName, 1);
    fclose(fp);
    return 0;
}
########################rank 9#############################
int output_prx(const char *prxfile)
{
	int size;
	unsigned char *data;
	FILE *fp;
	do
	{
		size = calculate_outsize();
		data = (unsigned char *) malloc(size);
		if(data == NULL)
		{
			fprintf(stderr, "Error, couldn't allocate output data\n");
			break;
		}
		memset(data, 0, size);
		output_header(data);
		output_ph(data + g_phbase);
		output_alloc(data + g_allocbase);
		output_sh(data + g_shbase);
		output_relocs(data + g_relocbase);
		output_shstrtab(data + g_shstrbase);
		fp = fopen(prxfile, "wb");
		if(fp != NULL)
		{
			fwrite(data, 1, size, fp);
			fclose(fp);
		}
		else
		{
			fprintf(stderr, "Error, could not open output file %s\n", prxfile);
		}
		free(data);
	}
	while(0);
	return 0;
}
########################rank 10#############################
static size_t amf_number_write(const amf_data * data, amf_write_proc write_proc, void * user_data) {
    number64 n = swap_number64(data->number_data);
    return write_proc(&n, sizeof(number64_be), user_data);
}
----------------------------QUERY-------------------------------
generate trace call to print
########################rank 1#############################
void TraceRay(Ray* ray, HitList* hitlist, float epsilon, float* dist) {
	// TODO
}
########################rank 2#############################
int aprs_mode = 0;
static void aprs_print_ax25call(unsigned char *call, int is_repeater)
{
	int i;
	for (i = 0; i < 6; i++)
		if ((call[i] &0xfe) != 0x40)
			verbprintf(0, "%c",call[i] >> 1);
	int ssid = (call[6] >> 1) & 0xf;
	if (ssid)
		verbprintf(0, "-%u",ssid);
	// hack: only display "*" on the last repeater, as opposed to all that already repeated
	if (is_repeater && (call[6] & 0x80))
			verbprintf(0, "*");
}
########################rank 3#############################
void KLTPrintTrackingContext(
  KLT_TrackingContext tc)
{
  fprintf(stderr, "\n\nTracking context:\n\n");
  fprintf(stderr, "\tmindist = %d\n", tc->mindist);
  fprintf(stderr, "\twindow_width = %d\n", tc->window_width);
  fprintf(stderr, "\twindow_height = %d\n", tc->window_height);
  fprintf(stderr, "\tsequentialMode = %s\n",
          tc->sequentialMode ? "TRUE" : "FALSE");
  fprintf(stderr, "\tsmoothBeforeSelecting = %s\n",
          tc->smoothBeforeSelecting ? "TRUE" : "FALSE");
  fprintf(stderr, "\tmin_eigenvalue = %d\n", tc->min_eigenvalue);
  fprintf(stderr, "\tmin_determinant = %f\n", tc->min_determinant);
  fprintf(stderr, "\tmin_displacement = %f\n", tc->min_displacement);
  fprintf(stderr, "\tmax_iterations = %d\n", tc->max_iterations);
  fprintf(stderr, "\tmax_residue = %f\n", tc->max_residue);
  fprintf(stderr, "\tgrad_sigma = %f\n", tc->grad_sigma);
  fprintf(stderr, "\tsmooth_sigma_fact = %f\n", tc->smooth_sigma_fact);
  fprintf(stderr, "\tpyramid_sigma_fact = %f\n", tc->pyramid_sigma_fact);
  fprintf(stderr, "\tnSkippedPixels = %d\n", tc->nSkippedPixels);
  fprintf(stderr, "\tborderx = %d\n", tc->borderx);
  fprintf(stderr, "\tbordery = %d\n", tc->bordery);
  fprintf(stderr, "\tnPyramidLevels = %d\n", tc->nPyramidLevels);
  fprintf(stderr, "\tsubsampling = %d\n", tc->subsampling);
  fprintf(stderr, "\n\tpyramid_last = %s\n", (tc->pyramid_last!=NULL) ?
          "points to old image" : "NULL");
  fprintf(stderr, "\tpyramid_last_gradx = %s\n", 
          (tc->pyramid_last_gradx!=NULL) ?
          "points to old image" : "NULL");
  fprintf(stderr, "\tpyramid_last_grady = %s\n",
          (tc->pyramid_last_grady!=NULL) ?
          "points to old image" : "NULL");
  fprintf(stderr, "\n\n");
}
########################rank 4#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NOJIT)) {  
    if (J->parent == 0 && J->exitno == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  J->retryrec = 0;
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    }
  );
  lj_record_setup(J);
}
########################rank 5#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NO_JIT)) {  
    if (J->parent == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_HAS_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    }
  );
  lj_record_setup(J);
}
########################rank 6#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NOJIT)) {  
    if (J->parent == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    }
  );
  lj_record_setup(J);
}
########################rank 7#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NOJIT)) {  
    if (J->parent == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    }
  );
  lj_record_setup(J);
}
########################rank 8#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NOJIT)) {  
    if (J->parent == 0 && J->exitno == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  J->retryrec = 0;
  J->ktrace = 0;
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    } else {
      BCOp op = bc_op(*J->pc);
      if (op == BC_CALLM || op == BC_CALL || op == BC_ITERC) {
	setintV(L->top++, J->exitno);  /* Parent of stitched trace. */
	setintV(L->top++, -1);
      }
    }
  );
  lj_record_setup(J);
}
########################rank 9#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NOJIT)) {  
    if (J->parent == 0 && J->exitno == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  J->retryrec = 0;
  J->ktrace = 0;
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    } else {
      BCOp op = bc_op(*J->pc);
      if (op == BC_CALLM || op == BC_CALL || op == BC_ITERC) {
	setintV(L->top++, J->exitno);  /* Parent of stitched trace. */
	setintV(L->top++, -1);
      }
    }
  );
  lj_record_setup(J);
}
########################rank 10#############################
static void trace_start(jit_State *J)
{
  lua_State *L;
  TraceNo traceno;
  if ((J->pt->flags & PROTO_NOJIT)) {  
    if (J->parent == 0 && J->exitno == 0) {
      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||
		 bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);
      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);
      J->pt->flags |= PROTO_ILOOP;
    }
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  traceno = trace_findfree(J);
  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);
    lj_trace_flushall(J->L);
    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
    return;
  }
  setgcrefp(J->trace[traceno], &J->cur);
  memset(&J->cur, 0, sizeof(GCtrace));
  J->cur.traceno = traceno;
  J->cur.nins = J->cur.nk = REF_BASE;
  J->cur.ir = J->irbuf;
  J->cur.snap = J->snapbuf;
  J->cur.snapmap = J->snapmapbuf;
  J->mergesnap = 0;
  J->needsnap = 0;
  J->bcskip = 0;
  J->guardemit.irt = 0;
  J->postproc = LJ_POST_NONE;
  lj_resetsplit(J);
  J->retryrec = 0;
  J->ktrace = 0;
  setgcref(J->cur.startpt, obj2gco(J->pt));
  L = J->L;
  lj_vmevent_send(L, TRACE,
    setstrV(L, L->top++, lj_str_newlit(L, "start"));
    setintV(L->top++, traceno);
    setfuncV(L, L->top++, J->fn);
    setintV(L->top++, proto_bcpos(J->pt, J->pc));
    if (J->parent) {
      setintV(L->top++, J->parent);
      setintV(L->top++, J->exitno);
    } else {
      BCOp op = bc_op(*J->pc);
      if (op == BC_CALLM || op == BC_CALL || op == BC_ITERC) {
	setintV(L->top++, J->exitno);  /* Parent of stitched trace. */
	setintV(L->top++, -1);
      }
    }
  );
  lj_record_setup(J);
}
----------------------------QUERY-------------------------------
get dimensions of given bmp file
########################rank 1#############################
cc_bool Drawer2D_Clamp(Bitmap* bmp, int* x, int* y, int* width, int* height) {
	if (*x >= bmp->Width || *y >= bmp->Height) return false;
	if (*x < 0) { *width  += *x; *x = 0; }
	if (*y < 0) { *height += *y; *y = 0; }
	*width  = min(*x + *width,  bmp->Width)  - *x;
	*height = min(*y + *height, bmp->Height) - *y;
	return *width > 0 && *height > 0;
}
########################rank 2#############################
uint16_t fetch(uint8_t var)
{
	if (var & 0xF0) {
		return read16low(global_table + ((var - 16) << 1));
	} else if (var) {
		return stack[frameptr->start + var - 1];
	} else {
		return stack[--stackptr];
	}
}
########################rank 3#############################
void RE_Draw_GetPicSize(int *w, int *h, char *pic)
{
  image_t *gl;
  gl = RE_Draw_FindPic(pic);
  if (!gl) {
    *w = *h = -1;
    return;
  }
  *w = gl->width;
  *h = gl->height;
}
########################rank 4#############################
bool lv_img_color_format_has_alpha(lv_img_cf_t cf)
{
    bool has_alpha = false;
    switch(cf) {
        case LV_IMG_CF_TRUE_COLOR_ALPHA:
        case LV_IMG_CF_RAW_ALPHA:
        case LV_IMG_CF_ALPHA_1BIT:
        case LV_IMG_CF_ALPHA_2BIT:
        case LV_IMG_CF_ALPHA_4BIT:
        case LV_IMG_CF_ALPHA_8BIT: has_alpha = true; break;
        default: has_alpha = false; break;
    }
    return has_alpha;
}
########################rank 5#############################
int	ROM_CHAR_HEIGHT = 14;	
FARADDR rom_char_addr;
void
pcrom_init(PSD psd)
{
	char *	p;
	rom_char_addr = int10(FNGETROMADDR, GETROM8x14);
#if 0
	 * as the returned font isn't always 14 high
	 */
	ROM_CHAR_HEIGHT = GETBYTE_FP(MK_FP(0x0040, 0x0085));
	if(ROM_CHAR_HEIGHT > MAX_ROM_HEIGHT)
		ROM_CHAR_HEIGHT = MAX_ROM_HEIGHT;
#endif
#if ELKS
	ROM_CHAR_HEIGHT = 14;
#endif
	p = getenv("CHARHEIGHT");
	if(p)
		ROM_CHAR_HEIGHT = atoi(p);
}
########################rank 6#############################
lv_coord_t lv_img_get_offset_y(lv_obj_t * img)
{
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
    return ext->offset.y;
}
########################rank 7#############################
void Draw_GetPalette(void)
{
  byte *pal, *out;
  int i;
  // get the palette and colormap
  LoadPCX("pics/colormap.pcx", &vid_colormap, &pal, NULL, NULL);
  if (!vid_colormap)
    Com_Error(ERR_FATAL, "Couldn't load pics/colormap.pcx");
  vid_alphamap = vid_colormap + 64 * 256;
  out = (byte *) d_8to24table;
  for (i = 0; i < 256; i++, out += 4) {
    int r, g, b;
    r = pal[i * 3 + 0];
    g = pal[i * 3 + 1];
    b = pal[i * 3 + 2];
    out[0] = r;
    out[1] = g;
    out[2] = b;
  }
  free(pal);
}
########################rank 8#############################
static
FT_Error  TT_Access_Glyph_Frame( TT_Loader*  loader,
								 FT_UInt glyph_index,
								 FT_ULong offset,
								 FT_UInt byte_count ) {
	FT_Error error;
	FT_Stream stream = loader->stream;
	(void)( FILE_Seek( offset ) || ACCESS_Frame( byte_count ) );
	FT_TRACE5( ( "Glyph %ld\n", glyph_index ) );
	return error;
}
########################rank 9#############################
struct shader_s *SCR_RegisterPic( const char *name ) {
	return re.RegisterPic( name );
}
########################rank 10#############################
int
DGifGetScreenDesc(GifFileType * GifFile) {
    int i, BitsPerPixel;
    GifByteType Buf[3];
    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
    if (!IS_READABLE(Private)) {
        _GifError = D_GIF_ERR_NOT_READABLE;
        return GIF_ERROR;
    }
    if (DGifGetWord(GifFile, &GifFile->SWidth) == GIF_ERROR ||
        DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR)
        return GIF_ERROR;
    if (READ(GifFile, Buf, 3) != 3) {
        _GifError = D_GIF_ERR_READ_FAILED;
        return GIF_ERROR;
    }
    GifFile->SColorResolution = (((Buf[0] & 0x70) + 1) >> 4) + 1;
    BitsPerPixel = (Buf[0] & 0x07) + 1;
    GifFile->SBackGroundColor = Buf[1];
    if (Buf[0] & 0x80) {    /* Do we have global color map? */
        GifFile->SColorMap = MakeMapObject(1 << BitsPerPixel, NULL);
        if (GifFile->SColorMap == NULL) {
            _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
            return GIF_ERROR;
        }
        for (i = 0; i < GifFile->SColorMap->ColorCount; i++) {
            if (READ(GifFile, Buf, 3) != 3) {
                FreeMapObject(GifFile->SColorMap);
                GifFile->SColorMap = NULL;
                _GifError = D_GIF_ERR_READ_FAILED;
                return GIF_ERROR;
            }
            GifFile->SColorMap->Colors[i].Red = Buf[0];
            GifFile->SColorMap->Colors[i].Green = Buf[1];
            GifFile->SColorMap->Colors[i].Blue = Buf[2];
        }
    } else {
        GifFile->SColorMap = NULL;
    }
    return GIF_OK;
}
----------------------------QUERY-------------------------------
add extension to filename
########################rank 1#############################
bool extension(int ext, unsigned long extensions) {
	return (extensions & ext);
}
########################rank 2#############################
int
mandel(double _Complex C)
{
  int py;
  C = (__extension__ 1.0iF) * (double)py;
  return cabs(C);  /* { dg-warning "incompatible" } */
}
########################rank 3#############################
const char *getExtension(const char *fname, size_t len)
{
	if (fname == NULL || len <= 0) return NULL;
	while (--len > 0 && fname[len] != '.' && fname[len] != '\0')
		;
	return fname + len + 1;
}
########################rank 4#############################
const char *COM_GetExtension( const char *name ) {
	int length, i;
	length = strlen(name)-1;
	i = length;
	while (name[i] != '.')
	{
		i--;
		if (name[i] == '/' || i == 0)
			return ""; // no extension
	}
	return &name[i+1];
}
########################rank 5#############################
char *
get_progname(char *argv0)
{
#ifdef HAVE___PROGNAME
        extern char *__progname;
        return __progname;
#else
        char *p;
        if (argv0 == NULL)
                return "unknown";       
        p = strrchr(argv0, '/');
        if (p == NULL)
                p = argv0;
        else
                p++;
        return p;
#endif
}
########################rank 6#############################
void get_file_extension(char *infile, char *ext)
{
   char *ptr;
   if ((ptr = strchr(infile, '.')) != NULL)
      strcpy(ext, ptr+1);
   else
      ext[0] = '\0';
}
########################rank 7#############################
void get_file_extension(char *infile, char *ext)
{
   char *ptr;
   if ((ptr = strchr(infile, '.')) != NULL)
      strcpy(ext, ptr+1);
   else
      ext[0] = '\0';
}
########################rank 8#############################
static char *fileNameToSymbol(const char *fileName)
{
    char *name;
    int i;
    name = malloc(strlen(fileName) + 1);
    check(name != 0, cantMalloc, "the symbol name");
    strcpy(name, fileName);
    for (i = 0; name[i]; ++i) {
        if (!((name[i] >= 'a' && name[i] <= 'z') || 
                (name[i] >= 'A' && name[i] <= 'Z') || 
                (name[i] >= '0' && name[i] <= '9'))) {
            name[i] = '_';
        }
    }
    if (name[0] >= '0' && name[0] <= '9') {
        name[0] = '_';
    }
    return name;
}
########################rank 9#############################
const char *private_get_extension(const char *filename) {
    const char *dot_pos = strrchr(filename, '.');
    return dot_pos == NULL ? "" : dot_pos + 1;
}
########################rank 10#############################
static char *S_FileExtension(const char *fni)
{
	// we should search from the ending to the last '/'
	char *fn = (char *) fni + strlen(fni) - 1;
	char *eptr = NULL;
	while(*fn != '/' && fn != fni)
	{
		if(*fn == '.')
		{
			eptr = fn;
			break;
		}
		fn--;
	}
	return eptr;
}
----------------------------QUERY-------------------------------
read one word from onboard RAM
########################rank 1#############################
static uint32_t debug_read_uleb128(const uint8_t **pp)
{
  const uint8_t *p = *pp;
  uint32_t v = *p++;
  if (LJ_UNLIKELY(v >= 0x80)) {
    int sh = 0;
    v &= 0x7f;
    do { v |= ((*p & 0x7f) << (sh += 7)); } while (*p++ >= 0x80);
  }
  *pp = p;
  return v;
}
########################rank 2#############################
static uint32_t debug_read_uleb128(const uint8_t **pp)
{
  const uint8_t *p = *pp;
  uint32_t v = *p++;
  if (LJ_UNLIKELY(v >= 0x80)) {
    int sh = 0;
    v &= 0x7f;
    do { v |= ((*p & 0x7f) << (sh += 7)); } while (*p++ >= 0x80);
  }
  *pp = p;
  return v;
}
########################rank 3#############################
static uint32_t debug_read_uleb128(const uint8_t **pp)
{
  const uint8_t *p = *pp;
  uint32_t v = *p++;
  if (LJ_UNLIKELY(v >= 0x80)) {
    int sh = 0;
    v &= 0x7f;
    do { v |= ((*p & 0x7f) << (sh += 7)); } while (*p++ >= 0x80);
  }
  *pp = p;
  return v;
}
########################rank 4#############################
static void RoQ_ReadAudio( cinematics_t *cin ) {
	unsigned int i;
	int snd_left, snd_right;
	uint8_t raw[RoQ_READ_BLOCK];
	short samples[RoQ_READ_BLOCK];
	roq_info_t *roq = cin->fdata;
	roq_chunk_t *chunk = &roq->chunk;
	unsigned int remaining, read;
	if( chunk->id == RoQ_SOUND_MONO ) {
		snd_left = chunk->argument;
		snd_right = 0;
	} else {
		snd_left = chunk->argument & 0xff00;
		snd_right = ( chunk->argument & 0xff ) << 8;
	}
	for( remaining = chunk->size; remaining > 0; remaining -= read ) {
		read = min( sizeof( raw ), remaining );
		trap_FS_Read( raw, read, cin->file );
		if( chunk->id == RoQ_SOUND_MONO ) {
			for( i = 0; i < read; i++ ) {
				snd_left += snd_sqr_arr[raw[i]];
				samples[i] = (short)snd_left;
				snd_left = (short)snd_left;
			}
			CIN_RawSamplesToListeners( cin, read, cin->s_rate, 2, 1, (uint8_t *)samples );
		} else if( chunk->id == RoQ_SOUND_STEREO ) {
			for( i = 0; i < read; i += 2 ) {
				snd_left += snd_sqr_arr[raw[i]];
				samples[i + 0] = (short)snd_left;
				snd_left = (short)snd_left;
				snd_right += snd_sqr_arr[raw[i + 1]];
				samples[i + 1] = (short)snd_right;
				snd_right = (short)snd_right;
			}
			CIN_RawSamplesToListeners( cin, read / 2, cin->s_rate, 2, 2, (uint8_t *)samples );
		}
	}
}
########################rank 5#############################
static uint16_t
ram_readw(uint32_t addr, void *priv)
{
    mem_mapping_t *map = (mem_mapping_t *)priv;
    memdev_t *dev = (memdev_t *)map->dev;
    uint16_t ret = 0xffff;
    ret = *(uint16_t *)(dev->ram + (addr - map->base));
    return(ret);
}
########################rank 6#############################
static int read_uint16(int fd, uint16_t* x)
{
    unsigned char tmp[2];
    int n;
    n = read(fd,tmp,2);
    if (n != 2)
        return -1;
    *x = tmp[0] | (tmp[1] << 8);
    return 0;
}
########################rank 7#############################
unsigned long Read16(unsigned char* pByte)
{
    unsigned short value = 0;
    value |= (unsigned short)pByte[0];
    value |= (unsigned short)pByte[1] << 8;
    return value;
}
########################rank 8#############################
cc_result Stream_Read(struct Stream* s, cc_uint8* buffer, cc_uint32 count) {
	cc_uint32 read;
	cc_result res;
	while (count) {
		if ((res = s->Read(s, buffer, count, &read))) return res;
		if (!read) return ERR_END_OF_STREAM;
		buffer += read;
		count  -= read;
	}
	return 0;
}
########################rank 9#############################
static void io_read_0042() {
    io_read_004x(2);
}
########################rank 10#############################
int read_dataflash(unsigned long addr, unsigned long size, char *result)
{
	unsigned int AddrToRead = addr;
	AT91PS_DataFlash pFlash = &DataFlashInst;
	pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
	if (pFlash == 0)
		return -1;
	return (AT91F_DataFlashRead(pFlash, AddrToRead, size, result));
}
----------------------------QUERY-------------------------------
encode ucs2 string into utf8 string
########################rank 1#############################
int Xcode_puny_encodeString( const DWORD *  pdwzInputString,
                             const int      iInputSize,
                             UCHAR8 *       pzOutputString,
                             int *          piOutputSize )
{
  int status;
  int offset        = 0;
  int output_offset = 0;
  unsigned int punycode_input_length;
  DWORD punycode_input[MAX_LABEL_SIZE_32];
  unsigned int encoded_string_length;
  char encoded_string[MAX_LABEL_SIZE_8];
  if ( iInputSize < 1 || pzOutputString == 0 ) 
  {
    return XCODE_BAD_ARGUMENT_ERROR;
  }
  memset( pzOutputString, 0, *piOutputSize );
  if (iInputSize > MAX_LABEL_SIZE_32) 
  {
    return XCODE_BUFFER_OVERFLOW_ERROR;
  }
  punycode_input_length = 0;
  for( offset = 0; offset < iInputSize; offset++ ) 
  {
    punycode_input[offset] = pdwzInputString[offset];
    punycode_input_length++;
  }
  if so just copy the input to output. no need to encode
  otherwise try to encode it */
  if( is_all_basic(punycode_input_length, punycode_input) == 1 ) 
  {
    for (offset = 0; offset < punycode_input_length; offset++) 
    {
	    *(pzOutputString + offset) = (char)*(punycode_input + offset);
    }
    *piOutputSize = punycode_input_length;
    return XCODE_SUCCESS;
  }
  encoded_string_length = MAX_LABEL_SIZE_8;
  status = punycode_encode(
    punycode_input_length,
    punycode_input,
    &encoded_string_length,
    encoded_string );
  if (status != XCODE_SUCCESS) 
  {
    return status;
  }
  if( ( strlen( ACE_PREFIX ) + encoded_string_length ) > MAX_LABEL_SIZE_8 ) 
  {
    return XCODE_BUFFER_OVERFLOW_ERROR;
  }
  output_offset = strlen(ACE_PREFIX);
  strncat( (char*)pzOutputString, ACE_PREFIX, strlen(ACE_PREFIX) );
  for ( offset = 0; offset < encoded_string_length; offset++ ) 
  {
    *(pzOutputString + output_offset++) = *(encoded_string + offset);
  }
  *piOutputSize = strlen(ACE_PREFIX) + encoded_string_length;
  *(pzOutputString + output_offset) = '\0';
  return XCODE_SUCCESS;
}
########################rank 2#############################
json_encode_string(
    char **buf, size_t buf_len,
    const char *str, size_t str_len,
    bool escape_solidus)
{
    if (!buf || !buf_len)
        return "json_encode_string: invalid arguments";
    char hex_buf[7];
    hex_buf_init(hex_buf);
    if (!append_ch(buf, &buf_len, '\"'))
        goto oom;
    if (str) {
        for (;str_len != 0; --str_len, ++str) {
            const char ch = *str;
            const char *escaped = NULL;
            switch (ch) {
            case '\r': escaped = "\\r"; break;
            case '\n': escaped = "\\n"; break;
            case '\\': escaped = "\\\\"; break;
            case '/': if (escape_solidus) escaped = "\\/"; break;
            case '"': escaped = "\\\""; break;
            case '\f': escaped = "\\f"; break;
            case '\b': escaped = "\\b"; break;
            case '\t': escaped = "\\t"; break;
            default:
                if ((unsigned char) ch < 32) {
                    char_to_hex(hex_buf + 4, ch);
                    escaped = hex_buf;
                }
                break;
            } /* switch */
            if (escaped) {
                if (!append_str(buf, &buf_len, escaped, strlen(escaped)))
                    goto oom;
            } else {
                if (!append_ch(buf, &buf_len, ch))
                    goto oom;
            }
        } /* for */
    } /* if */
    if (!append_ch(buf, &buf_len, '\"'))
        goto oom;
    return NULL;
oom:
    return "json_encode_string: out of memory";
}
########################rank 3#############################
static void bt_bencode_str(torrent_ctx* ctx, const char* name, const char* str)
{
	size_t len = strlen(str);
	int num_len;
	char* p;
	if (name) bt_str_append(ctx, name);
	if (!bt_str_ensure_length(ctx, ctx->content.length + len + 21)) return;
	p = ctx->content.str + ctx->content.length;
	p += (num_len = rhash_sprintI64(p, len));
	ctx->content.length += len + num_len + 1;
	*(p++) = ':';
	memcpy(p, str, len + 1); /* copy with trailing '\0' */
}
########################rank 4#############################
void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
    if (len < 64) {
        buf[0] = len | LP_ENCODING_6BIT_STR;
        memcpy(buf+1,s,len);
    } else if (len < 4096) {
        buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
        buf[1] = len & 0xff;
        memcpy(buf+2,s,len);
    } else {
        buf[0] = LP_ENCODING_32BIT_STR;
        buf[1] = len & 0xff;
        buf[2] = (len >> 8) & 0xff;
        buf[3] = (len >> 16) & 0xff;
        buf[4] = (len >> 24) & 0xff;
        memcpy(buf+5,s,len);
    }
}
########################rank 5#############################
void printf_encode(char *txt, size_t maxlen, const u8 *data, size_t len)
{
	char *end = txt + maxlen;
	size_t i;
	for (i = 0; i < len; i++) {
		if (txt + 4 > end)
			break;
		switch (data[i]) {
		case '\"':
			*txt++ = '\\';
			*txt++ = '\"';
			break;
		case '\\':
			*txt++ = '\\';
			*txt++ = '\\';
			break;
		case '\e':
			*txt++ = '\\';
			*txt++ = 'e';
			break;
		case '\n':
			*txt++ = '\\';
			*txt++ = 'n';
			break;
		case '\r':
			*txt++ = '\\';
			*txt++ = 'r';
			break;
		case '\t':
			*txt++ = '\\';
			*txt++ = 't';
			break;
		default:
			if (data[i] >= 32 && data[i] <= 127) {
				*txt++ = data[i];
			} else {
				txt += os_snprintf(txt, end - txt, "\\x%02x",
						   data[i]);
			}
			break;
		}
	}
	*txt = '\0';
}
########################rank 6#############################
static int encode_msm_phrng(rtcm_t *rtcm, int i, const double *phrng, int ncell)
{
    int j,phrng_val;
    for (j=0;j<ncell;j++) {
        if (phrng[j]==0.0) {
            phrng_val=-2097152;
        }
        else if (fabs(phrng[j])>1171.0) {
            trace(2,"msm fine phase-range overflow %s phrng=%.3f\n",
                 time_str(rtcm->time,0),phrng[j]);
            phrng_val=-2097152;
        }
        else {
            phrng_val=ROUND(phrng[j]/RANGE_MS/P2_29);
        }
        setbits(rtcm->buff,i,22,phrng_val); i+=22;
    }
    return i;
}
########################rank 7#############################
asn_enc_rval_t
der_encode(const asn_TYPE_descriptor_t *type_descriptor, const void *struct_ptr,
           asn_app_consume_bytes_f *consume_bytes, void *app_key) {
    ASN_DEBUG("DER encoder invoked for %s",
		type_descriptor->name);
	 * Invoke type-specific encoder.
	 */
    return type_descriptor->op->der_encoder(
        type_descriptor, struct_ptr, /* Pointer to the destination structure */
        0, 0, consume_bytes, app_key);
}
########################rank 8#############################
u8g_uint_t u8g_GetStrWidth(u8g_t *u8g, const char *s)
{
  u8g_uint_t  w;
  uint8_t encoding;
  w = 0;
  for(;;)
  {
    encoding = *s;
    if ( encoding == 0 )
      break;
    u8g_GetGlyph(u8g, encoding);
    w += u8g->glyph_dx;    
    s++;
  }
  return w;  
}
########################rank 9#############################
u8g_uint_t u8g_GetStrWidth(u8g_t *u8g, const char *s)
{
  u8g_uint_t  w;
  uint8_t encoding;
  w = 0;
  for(;;)
  {
    encoding = *s;
    if ( encoding == 0 )
      break;
    u8g_GetGlyph(u8g, encoding);
    w += u8g->glyph_dx;    
    s++;
  }
  return w;  
}
########################rank 10#############################
DUK_EXTERNAL const char *duk_hex_encode(duk_hthread *thr, duk_idx_t idx) {
	DUK_UNREF(idx);
	DUK_ERROR_UNSUPPORTED(thr);
	DUK_WO_NORETURN(return;);
}
----------------------------QUERY-------------------------------
check pointer is in the heap
########################rank 1#############################
void gen_push(int reg) {
    if (reg & DE_REG) {
        output_line ("pshx");
        stkp = stkp - INTSIZE;
    } else {
        output_line ("psha");	/* Check order */
        output_line ("pshb");
        stkp = stkp - INTSIZE;
    }
}
########################rank 2#############################
void gen_equal(void) {
    output_line ("popeq r1 r2");
    stkp = stkp + INTSIZE;
}
########################rank 3#############################
void gen_equal(void) {
    gen_call("__eq");
    stkp += INTSIZE;
}
########################rank 4#############################
struct segment *private1find(char *name, struct module *module)
{
	struct segment *seg;
	for (seg = segmentfind(name); seg != NULL; seg = seg->next)
		if (!strcmp(name, seg->name) && module == seg->module)
			return seg;
	return 0;
}
########################rank 5#############################
static Res allocAsSeg(AllocInfoStruct *aiReturn, LocusPref pref,
                      Size size, Pool pool)
{
  Res res;
  Seg seg;
  res = SegAlloc(&seg, CLASS(Seg), pref, size, pool, argsNone);
  if (res == ResOK) {
    aiReturn->the.segData.seg = seg;
  }
  return res;
}
########################rank 6#############################
LUA_API void lua_pushnil(lua_State *L)
{
  setnilV(L->top);
  incr_top(L);
}
########################rank 7#############################
gen_pop()
{
    output_line ("lw\t$v1, 16($sp)");
    output_line ("addiu\t$sp, 4");
    stkp = stkp + INTSIZE;
}
########################rank 8#############################
gen_push()
{
    output_line ("addiu\t$sp, -4");
    output_line ("sw\t$v0, 16($sp)");
    stkp = stkp - INTSIZE;
}
########################rank 9#############################
static char * xstrdup(char * s)
{
    char * t ;
    if (!s)
        return NULL ;
    t = malloc(strlen(s)+1) ;
    if (t) {
        strcpy(t,s);
    }
    return t ;
}
########################rank 10#############################
static char * xstrdup(const char * s)
{
    char * t ;
    if (!s)
        return NULL ;
    t = (char*)malloc(strlen(s)+1) ;
    if (t) {
        strcpy(t,s);
    }
    return t ;
}
----------------------------QUERY-------------------------------
search a file in directory recursively
########################rank 1#############################
bool dir_create(const char *path) { return false; }
#endif 
 * ------------------------------------------------------------------------
 * Directory scanning API
 * ------------------------------------------------------------------------ */
 * For information on what these are meant to do, please read the header file.
 */
#ifdef WINDOWS
struct ang_dir
{
	HANDLE h;
	char *first_file;
};
ang_dir *my_dopen(const char *dirname)
{
	WIN32_FIND_DATA fd;
	HANDLE h;
   	ang_dir *dir;
	h = FindFirstFile(format("%s\\*", dirname), &fd);
	if (h == INVALID_HANDLE_VALUE)
		return NULL;
	dir = mem_zalloc(sizeof(ang_dir));
	dir->h = h;
	dir->first_file = string_make(fd.cFileName);
	return dir;
}
########################rank 2#############################
char *
filename_get_directory(const char *filename)
{
    char *filename2;
    size_t len = strlen(filename);
    char *result;
    while (len && filename[len] != '/' && filename[len] != '\\')
        len--;
    filename2 = malloc(len+1);
    if (filename2 == NULL)
        exit(1);
    memcpy(filename2, filename, len+1);
    filename2[len] = '\0';
    if (filename_is_absolute(filename2))
        result = filename_combine(filename2, "");
    else {
        char buf[512];
        if (getcwd(buf, sizeof(buf)) == NULL)
            exit(1);
        result = filename_combine(buf, filename2);
    }
    free(filename2);
    return result;
}
########################rank 3#############################
int file_exists(char* name)
{
  struct stat buf;
  if(!name)
    return(0);
#if defined(MULTINET) && defined(__alpha)
  if(!decc$stat(name, &buf)) {
#else
  if(!stat(name, &buf)) {
#endif
    return(1);
  }
  return(0);
}
########################rank 4#############################
static void
make_directory_records(PDIR_RECORD d)
{
    PDIR_RECORD new_d;
    DIR *dirp;
    struct dirent *entry;
    char *old_end_source;
    struct stat stbuf;
    char buf[MAX_PATH];
    d->first_record = NULL;
#ifdef HAVE_D_TYPE
    dirp = opendir(source);
    if (dirp != NULL)
    {
        while ((entry = readdir(dirp)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue; // skip self and parent
            if (entry->d_type == DT_REG) // normal file
            {
                // Check for an absolute path
                if (source[0] == DIR_SEPARATOR_CHAR)
                {
                    strcpy(buf, source);
                    strcat(buf, DIR_SEPARATOR_STRING);
                    strcat(buf, entry->d_name);
                }
                else
                {
                    if (!getcwd(buf, sizeof(buf)))
                        error_exit("Cannot get CWD: %s\n", strerror(errno));
                    strcat(buf, DIR_SEPARATOR_STRING);
                    strcat(buf, source);
                    strcat(buf, entry->d_name);
                }
                if (stat(buf, &stbuf) == -1)
                {
                    error_exit("Cannot access '%s' (%s)\n", buf, strerror(errno));
                    return;
                }
                if (strcmp(entry->d_name, DIRECTORY_TIMESTAMP) == 0)
                {
                    convert_date_and_time(&d->date_and_time, &stbuf.st_ctime);
                }
                else
                {
                    if (verbosity == VERBOSE)
                    {
                        printf("%d: file %s\n", d->level, buf);
                    }
                    (void) new_directory_record(entry, &stbuf, d);
                }
            }
        }
        closedir(dirp);
    }
    else
    {
        error_exit("Cannot open '%s'\n", source);
        return;
    }
    dirp = opendir(source);
    if (dirp != NULL)
    {
        while ((entry = readdir(dirp)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue; // skip self and parent
            if (entry->d_type == DT_DIR) // directory
            {
                old_end_source = end_source;
                append_string_to_source(entry->d_name);
                *end_source++ = DIR_SEPARATOR_CHAR;
                *end_source = 0;
                if (verbosity == VERBOSE)
                {
                    printf("%d: directory %s\n", d->level + 1, source);
                }
                if (d->level < MAX_LEVEL)
                {
                    // Check for an absolute path
                    if (source[0] == DIR_SEPARATOR_CHAR)
                    {
                        strcpy(buf, source);
                    }
                    else
                    {
                        if (!getcwd(buf, sizeof(buf)))
                            error_exit("Cannot get CWD: %s\n", strerror(errno));
                        strcat(buf, DIR_SEPARATOR_STRING);
                        strcat(buf, source);
                    }
                    if (stat(buf, &stbuf) == -1)
                    {
                        error_exit("Cannot access '%s' (%s)\n", buf, strerror(errno));
                        return;
                    }
                    new_d = new_directory_record(entry, &stbuf, d);
                    new_d->next_in_path_table = root.next_in_path_table;
                    root.next_in_path_table = new_d;
                    new_d->level = d->level + 1;
                    make_directory_records(new_d);
                }
                else
                {
                    error_exit("Directory is nested too deep");
                }
                end_source = old_end_source;
                *end_source = 0;
            }
        }
        closedir(dirp);
    }
    else
    {
        error_exit("Cannot open '%s'\n", source);
        return;
    }
#else
    dirp = opendir(source);
    if (dirp != NULL)
    {
        while ((entry = readdir(dirp)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue; // skip self and parent
            // Check for an absolute path
            if (source[0] == DIR_SEPARATOR_CHAR)
            {
                strcpy(buf, source);
                strcat(buf, DIR_SEPARATOR_STRING);
                strcat(buf, entry->d_name);
            }
            else
            {
                if (!getcwd(buf, sizeof(buf)))
                    error_exit("Cannot get CWD: %s\n", strerror(errno));
                strcat(buf, DIR_SEPARATOR_STRING);
                strcat(buf, source);
                strcat(buf, entry->d_name);
            }
            if (stat(buf, &stbuf) == -1)
            {
                error_exit("Cannot access '%s' (%s)\n", buf, strerror(errno));
                return;
            }
            if (S_ISDIR(stbuf.st_mode))
            {
                old_end_source = end_source;
                append_string_to_source(entry->d_name);
                *end_source++ = DIR_SEPARATOR_CHAR;
                *end_source = 0;
                if (verbosity == VERBOSE)
                {
                    printf("%d: directory %s\n", d->level + 1, source);
                }
                if (d->level < MAX_LEVEL)
                {
                    new_d = new_directory_record(entry, &stbuf, d);
                    new_d->next_in_path_table = root.next_in_path_table;
                    root.next_in_path_table = new_d;
                    new_d->level = d->level + 1;
                    make_directory_records(new_d);
                }
                else
                {
                    error_exit("Directory is nested too deep");
                }
                end_source = old_end_source;
                *end_source = 0;
            }
            else if (S_ISREG(stbuf.st_mode))
            {
                if (strcmp(entry->d_name, DIRECTORY_TIMESTAMP) == 0)
                {
                    convert_date_and_time(&d->date_and_time, &stbuf.st_ctime);
                }
                else
                {
                    if (verbosity == VERBOSE)
                    {
                        printf("%d: file %s\n", d->level, buf);
                    }
                    (void) new_directory_record(entry, &stbuf, d);
                }
            }
        }
        closedir(dirp);
    }
    else
    {
        error_exit("Cannot open '%s'\n", source);
        return;
    }
#endif
    // sort directory
    d->first_record = sort_linked_list(d->first_record, 0, compare_directory_order);
}
########################rank 5#############################
char *
basename(char *path)
{
    char *p, *b;
    static char base[256];
    b = path;
    for (p=path; *p; ++p) {
        if (*p == '/')
            b = p + 1;
    }
    strcpy(base, b);
    for (p=base; *p; ++p) {
        if (*p == '.') {
            *p = 0;
            break;
        }
    }
    return base;
}
########################rank 6#############################
char *
filename_combine(const char *dirname, const char *filename)
{
	char *result;
	unsigned dirname_length;
	unsigned filename_length;
	unsigned dirname_offset = 0;
	unsigned result_offset = 0;
	unsigned result_max;
	static const struct Keyword slash = {"/", 1};
	struct Keyword prefix;
	unsigned prefix_length;
	filename_length = (unsigned)strlen(filename);
	if (dirname == NULL || dirname[0] == '\0') {
		result = (char*)malloc(filename_length+1);
        if (result == NULL)
            exit(1);
		memcpy(result, filename, filename_length+1);
		return result;
	}
	dirname_length = (unsigned)strlen(dirname);
	while (filename_length && (filename[0] == '/' || filename[0] == '\\')) {
		filename_length--;
		filename++;
	}
	while (dirname_length && (dirname[dirname_length-1] == '/' || filename[0] == '\\'))
		dirname_length--;
	result_max = dirname_length + filename_length + 2;
	result = (char*)malloc(result_max + 1);
    if (result == NULL)
        exit(1);
	 * Get the prefix, which is something like "C:\" on Windows,
	 * or "\\" or "//" also on Windows, or "/" on Unix 
	 */
	prefix = keyword_get_file_prefix(dirname, &dirname_offset, dirname_length);
	keyword_append(result, &result_offset, result_max, prefix);
	if (result_offset && result[result_offset - 1] != '/' && result[result_offset - 1] != '\\')
		keyword_append(result, &result_offset, result_max, slash);
	prefix_length = result_offset;
	combine_elements(result, &result_offset, result_max, prefix_length, dirname, dirname_offset, dirname_length);
	combine_elements(result, &result_offset, result_max, prefix_length, filename, 0, filename_length);
	return result;
}
########################rank 7#############################
int make_valid_path(char *dir, mode_t mode)
{
    struct stat st;
    char *tmp = NULL, *path = stripslash(strdup(dir));
    int retval;
    if (stat(path, &st) == 0) { /* file exists */
        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
        else { retval = 0; goto end; } /* not a directory.  Oops. */
    }
    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
    retval = 1;
end:
    if (tmp != NULL) free(tmp);
    if (path != NULL) free(path);
    return retval;
}
########################rank 8#############################
char * file_basename(char * file) {
	char * c = strrchr(file, '/');
	if (!c) return file;
	return (c+1);
}
########################rank 9#############################
void inlib(const char *file)
{
	const char *p, *cp;
	if ((p = getenv("LIBPATH")) == NULL)
		p = "/lib:/usr/lib";
	cp = path(p, file, R_OK);
	input(cp ? cp : file);
}
########################rank 10#############################
int
filename_is_absolute(const char *filename)
{
    if (filename == NULL || filename[0] == '\0')
        return 0;
    if (filename[0] == '/')
        return 1;
#if WIN32
    if (filename[0] == '\\')
        return 1;
    if (strlen(filename) >= 3) {
        if (my_isalpha(filename[0]) && filename[1] == ':') {
            if (filename[2] == '\\' || filename[2] == '/')
                return 1;
        }
    }
#endif
    return 0;
}
----------------------------QUERY-------------------------------
compress block of raw data
########################rank 1#############################
static
int fx_compress_block(const FX_STATE state, const u8* ibuf,
                      const uint32_t ilen){
    static u8* obuf;
    static size_t obuf_len;
    unsigned int compressed_len;
    int rc;
    if(ilen<=4){
        rc = fx_write_block(state, KIND_UNCOMPRESSED, ilen, ibuf);
        return rc<0 ? -1 : 0;
    }
    rc = mem_resize(&obuf, &obuf_len, ilen);
    if(rc<0) return -1;
    compressed_len = ilen - 4; 
    rc = lzfx_compress(ibuf, ilen, obuf+4, &compressed_len);
    if(rc<0 && rc != LZFX_ESIZE){
        fprintf(stderr, "Compression error (code %d)\n", rc);
        return -1;
    }
    if(rc == LZFX_ESIZE || !compressed_len){
        rc = fx_write_block(state, KIND_UNCOMPRESSED, ilen, ibuf);
        if(rc<0) return -1;
    } else {
        obuf[0] = ilen >> 24;
        obuf[1] = ilen >> 16;
        obuf[2] = ilen >> 8;
        obuf[3] = ilen;
        rc = fx_write_block(state, KIND_COMPRESSED, compressed_len+4, obuf);
        if(rc<0) return -1;
    }
    return 0;
}
########################rank 2#############################
void
block_flush(struct ZoneFileParser *parser)
{
    while (rte_ring_count(parser->free_queue) != 63) {
        pixie_usleep(100);
    }
}
########################rank 3#############################
int
deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
	deflate_state *s;
	compress_func func;
	int err = Z_OK;
	if (strm == Z_NULL || strm->state == Z_NULL)
		return (Z_STREAM_ERROR);
	s = (deflate_state *) strm->state;
	if (level == Z_DEFAULT_COMPRESSION) {
		level = 6;
	}
	if (level < 0 || level > 9 || strategy < 0 ||
	    strategy > Z_HUFFMAN_ONLY) {
		return (Z_STREAM_ERROR);
	}
	func = configuration_table[s->level].func;
	if (func != configuration_table[level].func && strm->total_in != 0) {
		err = deflate(strm, Z_PARTIAL_FLUSH);
	}
	if (s->level != level) {
		s->level = level;
		s->max_lazy_match   = configuration_table[level].max_lazy;
		s->good_match	= configuration_table[level].good_length;
		s->nice_match	= configuration_table[level].nice_length;
		s->max_chain_length = configuration_table[level].max_chain;
	}
	s->strategy = strategy;
	return (err);
}
########################rank 4#############################
int deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = (deflate_state *) strm->state;
    if (level == Z_DEFAULT_COMPRESSION) {
	level = 6;
    }
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
	return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if (func != configuration_table[level].func && strm->total_in != 0) {
	err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
	s->level = level;
	s->max_lazy_match   = configuration_table[level].max_lazy;
	s->good_match       = configuration_table[level].good_length;
	s->nice_match       = configuration_table[level].nice_length;
	s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}
########################rank 5#############################
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        strm->total_in != 0) {
        err = deflate(strm, Z_BLOCK);
        if (err == Z_BUF_ERROR && s->pending == 0)
            err = Z_OK;
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}
########################rank 6#############################
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        strm->total_in != 0) {
        err = deflate(strm, Z_BLOCK);
        if (err == Z_BUF_ERROR && s->pending == 0)
            err = Z_OK;
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}
########################rank 7#############################
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        strm->total_in != 0) {
        err = deflate(strm, Z_BLOCK);
        if (err == Z_BUF_ERROR && s->pending == 0)
            err = Z_OK;
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}
########################rank 8#############################
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
    s = strm->state;
#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        s->high_water) {
        int err = deflate(strm, Z_BLOCK);
        if (err == Z_STREAM_ERROR)
            return err;
        if (strm->avail_out == 0)
            return Z_BUF_ERROR;
    }
    if (s->level != level) {
        if (s->level == 0 && s->matches != 0) {
            if (s->matches == 1)
                slide_hash(s);
            else
                CLEAR_HASH(s);
            s->matches = 0;
        }
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return Z_OK;
}
########################rank 9#############################
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
    s = strm->state;
#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        s->high_water) {
        int err = deflate(strm, Z_BLOCK);
        if (err == Z_STREAM_ERROR)
            return err;
        if (strm->avail_out == 0)
            return Z_BUF_ERROR;
    }
    if (s->level != level) {
        if (s->level == 0 && s->matches != 0) {
            if (s->matches == 1)
                slide_hash(s);
            else
                CLEAR_HASH(s);
            s->matches = 0;
        }
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return Z_OK;
}
########################rank 10#############################
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;
    if (func != configuration_table[level].func && strm->total_in != 0) {
        err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}
----------------------------QUERY-------------------------------
allocate and clean buffer
########################rank 1#############################
void * SC68calloc(unsigned int n)
{
  void * buffer = SC68alloc(n);
  if (buffer) {
    char * b = buffer;
    while (n--) {
      *b++ = 0;
    }
  }
  return buffer;
}
########################rank 2#############################
void *Z_Malloc( int size ) {
	void *buf = malloc( size );
	Com_Memset( buf, 0, size );
	return buf;
}
########################rank 3#############################
void *rpl_malloc(size_t n)
{
    if(n == 0)
        n = 1;
    return malloc(n);
}
########################rank 4#############################
static void *my_malloc(size_t size)
{
    return malloc(size);
}
########################rank 5#############################
static
void *myMalloc(Int32 n) {
    void *p;
    p = malloc((size_t) n);
    if (p == NULL) outOfMemory();
    return p;
}
########################rank 6#############################
static void* XXH_malloc(size_t s) { return malloc(s); }
static void  XXH_free  (void* p)  { free(p); }
#include <string.h>
static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
#ifndef XXH_STATIC_LINKING_ONLY
#  define XXH_STATIC_LINKING_ONLY
#endif
#include "xxhash.h"
*  Compiler Specific Options
***************************************/
#if defined (__GNUC__) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#  define INLINE_KEYWORD inline
#else
#  define INLINE_KEYWORD
#endif
#if defined(__GNUC__)
#  define FORCE_INLINE_ATTR __attribute__((always_inline))
#elif defined(_MSC_VER)
#  define FORCE_INLINE_ATTR __forceinline
#else
#  define FORCE_INLINE_ATTR
#endif
#define FORCE_INLINE_TEMPLATE static INLINE_KEYWORD FORCE_INLINE_ATTR
#ifdef _MSC_VER
#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
#endif
*  Basic Types
***************************************/
#ifndef MEM_MODULE
# define MEM_MODULE
# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint8_t  BYTE;
    typedef uint16_t U16;
    typedef uint32_t U32;
    typedef  int32_t S32;
    typedef uint64_t U64;
#  else
    typedef unsigned char      BYTE;
    typedef unsigned short     U16;
    typedef unsigned int       U32;
    typedef   signed int       S32;
    typedef unsigned long long U64;   /* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
#  endif
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign;
static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static U64 XXH_read64(const void* ptr) { return ((const unalign*)ptr)->u64; }
#else
 * see : http://stackoverflow.com/a/32095106/646947
 */
static U32 XXH_read32(const void* memPtr)
{
    U32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
########################rank 7#############################
static void* XXH_malloc(size_t s) { return malloc(s); }
static void  XXH_free  (void* p)  { free(p); }
#include <string.h>
static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
#ifndef XXH_STATIC_LINKING_ONLY
#  define XXH_STATIC_LINKING_ONLY
#endif
#include "xxhash.h"
*  Compiler Specific Options
***************************************/
#if defined (__GNUC__) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#  define INLINE_KEYWORD inline
#else
#  define INLINE_KEYWORD
#endif
#if defined(__GNUC__) || defined(__ICCARM__)
#  define FORCE_INLINE_ATTR __attribute__((always_inline))
#elif defined(_MSC_VER)
#  define FORCE_INLINE_ATTR __forceinline
#else
#  define FORCE_INLINE_ATTR
#endif
#define FORCE_INLINE_TEMPLATE static INLINE_KEYWORD FORCE_INLINE_ATTR
#ifdef _MSC_VER
#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
#endif
*  Basic Types
***************************************/
#ifndef MEM_MODULE
# define MEM_MODULE
# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint8_t  BYTE;
    typedef uint16_t U16;
    typedef uint32_t U32;
    typedef  int32_t S32;
    typedef uint64_t U64;
#  else
    typedef unsigned char      BYTE;
    typedef unsigned short     U16;
    typedef unsigned int       U32;
    typedef   signed int       S32;
    typedef unsigned long long U64;   /* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
#  endif
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign;
static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static U64 XXH_read64(const void* ptr) { return ((const unalign*)ptr)->u64; }
#else
 * see : http://stackoverflow.com/a/32095106/646947
 */
static U32 XXH_read32(const void* memPtr)
{
    U32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
########################rank 8#############################
static void* XXH_malloc(size_t s) { return malloc(s); }
static void  XXH_free  (void* p)  { free(p); }
#include <string.h>
static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
#ifndef XXH_STATIC_LINKING_ONLY
#  define XXH_STATIC_LINKING_ONLY
#endif
#include "xxhash.h"
*  Compiler Specific Options
***************************************/
#if defined (__GNUC__) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#  define INLINE_KEYWORD inline
#else
#  define INLINE_KEYWORD
#endif
#if defined(__GNUC__) || defined(__ICCARM__)
#  define FORCE_INLINE_ATTR __attribute__((always_inline))
#elif defined(_MSC_VER)
#  define FORCE_INLINE_ATTR __forceinline
#else
#  define FORCE_INLINE_ATTR
#endif
#define FORCE_INLINE_TEMPLATE static INLINE_KEYWORD FORCE_INLINE_ATTR
#ifdef _MSC_VER
#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
#endif
*  Basic Types
***************************************/
#ifndef MEM_MODULE
# define MEM_MODULE
# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint8_t  BYTE;
    typedef uint16_t U16;
    typedef uint32_t U32;
    typedef  int32_t S32;
    typedef uint64_t U64;
#  else
    typedef unsigned char      BYTE;
    typedef unsigned short     U16;
    typedef unsigned int       U32;
    typedef   signed int       S32;
    typedef unsigned long long U64;   /* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
#  endif
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign;
static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static U64 XXH_read64(const void* ptr) { return ((const unalign*)ptr)->u64; }
#else
 * see : http://stackoverflow.com/a/32095106/646947
 */
static U32 XXH_read32(const void* memPtr)
{
    U32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
########################rank 9#############################
static void* XXH_malloc(size_t s) { return malloc(s); }
static void  XXH_free  (void* p)  { free(p); }
#include <string.h>
static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
#ifndef XXH_STATIC_LINKING_ONLY
#  define XXH_STATIC_LINKING_ONLY
#endif
#include "xxhash.h"
*  Compiler Specific Options
***************************************/
#if defined (__GNUC__) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#  define INLINE_KEYWORD inline
#else
#  define INLINE_KEYWORD
#endif
#if defined(__GNUC__) || defined(__ICCARM__)
#  define FORCE_INLINE_ATTR __attribute__((always_inline))
#elif defined(_MSC_VER)
#  define FORCE_INLINE_ATTR __forceinline
#else
#  define FORCE_INLINE_ATTR
#endif
#define FORCE_INLINE_TEMPLATE static INLINE_KEYWORD FORCE_INLINE_ATTR
#ifdef _MSC_VER
#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
#endif
*  Basic Types
***************************************/
#ifndef MEM_MODULE
# define MEM_MODULE
# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint8_t  BYTE;
    typedef uint16_t U16;
    typedef uint32_t U32;
    typedef  int32_t S32;
    typedef uint64_t U64;
#  else
    typedef unsigned char      BYTE;
    typedef unsigned short     U16;
    typedef unsigned int       U32;
    typedef   signed int       S32;
    typedef unsigned long long U64;   /* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
#  endif
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign;
static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static U64 XXH_read64(const void* ptr) { return ((const unalign*)ptr)->u64; }
#else
 * see : http://stackoverflow.com/a/32095106/646947
 */
static U32 XXH_read32(const void* memPtr)
{
    U32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
########################rank 10#############################
static void* XXH_malloc(size_t s) { return malloc(s); }
static void  XXH_free  (void* p)  { free(p); }
#include <string.h>
static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
#ifndef XXH_STATIC_LINKING_ONLY
#  define XXH_STATIC_LINKING_ONLY
#endif
#include "xxhash.h"
*  Compiler Specific Options
***************************************/
#if defined (__GNUC__) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#  define INLINE_KEYWORD inline
#else
#  define INLINE_KEYWORD
#endif
#if defined(__GNUC__) || defined(__ICCARM__)
#  define FORCE_INLINE_ATTR __attribute__((always_inline))
#elif defined(_MSC_VER)
#  define FORCE_INLINE_ATTR __forceinline
#else
#  define FORCE_INLINE_ATTR
#endif
#define FORCE_INLINE_TEMPLATE static INLINE_KEYWORD FORCE_INLINE_ATTR
#ifdef _MSC_VER
#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
#endif
*  Basic Types
***************************************/
#ifndef MEM_MODULE
# define MEM_MODULE
# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint8_t  BYTE;
    typedef uint16_t U16;
    typedef uint32_t U32;
    typedef  int32_t S32;
    typedef uint64_t U64;
#  else
    typedef unsigned char      BYTE;
    typedef unsigned short     U16;
    typedef unsigned int       U32;
    typedef   signed int       S32;
    typedef unsigned long long U64;   /* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
#  endif
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign;
static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static U64 XXH_read64(const void* ptr) { return ((const unalign*)ptr)->u64; }
#else
 * see : http://stackoverflow.com/a/32095106/646947
 */
static U32 XXH_read32(const void* memPtr)
{
    U32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
----------------------------QUERY-------------------------------
receive N byte from socket
########################rank 1#############################
int sock_recv(socket_t *sock, socket_t *from, char *data, int len)
{
    int bytes_recv = 0;
    socket_t tmp;
    switch(sock->type)
    {
        case SOCK_STREAM:
            bytes_recv = recv(sock->fd, data, len, 0);
            break;
        case SOCK_DGRAM:
            if(!from)
                from = &tmp; /* In case caller wants to ignore from socket */
            from->fd = sock->fd;
            from->addr_len = sock->addr_len;
            bytes_recv = recvfrom(from->fd, data, len, 0,
                                  SOCK_ADDR(from), &from->addr_len);
            break;
    }
    PERROR_GOTO(bytes_recv < 0, "recv", error);
    ERROR_GOTO(bytes_recv == 0, "disconnect", disconnect);
    if(debug_level >= DEBUG_LEVEL3)
    {
        printf("sock_recv: type=%d, fd=%d, bytes=%d\n",
               sock->type, sock->fd, bytes_recv);
        print_hexdump(data, bytes_recv);
    }
    return bytes_recv;
  disconnect:
    return 0;
  error:
    return -1;
}
########################rank 2#############################
static int recv_nb(socket_t sock, unsigned char *buff, int n)
{
    struct timeval tv={0};
    fd_set rs;
    FD_ZERO(&rs); FD_SET(sock,&rs);
    if (!select(sock+1,&rs,NULL,NULL,&tv)) return 0;
    return recv(sock,(char *)buff,n,0);
}
########################rank 3#############################
int tcp_receive_buffer(int newSocket, char *return_buffer)
{
	static int bytes_received = 0;
	static char message_received[MAX_MSG_LEN];
	static int count = 0;
	int offset;
	offset = 0;
	while (1) {
		if (bytes_received == 0) {
			memset(message_received, 0x0, MAX_MSG_LEN);	/* init buffer */
			count =
			    recvfrom(newSocket, message_received, MAX_MSG_LEN,
				     0, (struct sockaddr *)&tcpClientAddr,
				     &tcpClientLen);
			if (count < 0) {
				perror(" cannot receive data ");
				return ERROR;
			} else if (count == 0) {
				printf(" connection closed by client\n");
				close(newSocket);
				if (count) {
				}
				return ERROR;
			}
		}
		while (*(message_received + bytes_received) != END_LINE
		       && bytes_received < count) {
			memcpy(return_buffer + offset,
			       message_received + bytes_received, 1);
			offset++;
			bytes_received++;
		}
		if (bytes_received == count - 1) {
			*(return_buffer + offset) = END_LINE;
			bytes_received = 0;
			return ++offset;
		}
		if (bytes_received < count - 1) {
			*(return_buffer + offset) = END_LINE;
			bytes_received++;
			return ++offset;
		}
		if (bytes_received == count) {
			bytes_received = 0;
			return offset;
		}
	}			/* while */
}
########################rank 4#############################
void Sys_SendPacket( int length, const void *data, netadr_t to ) {
	int				ret = SOCKET_ERROR;
	struct sockaddr_storage	addr;
	if( to.type != NA_BROADCAST && to.type != NA_IP && to.type != NA_IP6 && to.type != NA_MULTICAST6)
	{
		Com_Error( ERR_FATAL, "Sys_SendPacket: bad address type" );
		return;
	}
	if( (ip_socket == INVALID_SOCKET && to.type == NA_IP) ||
		(ip6_socket == INVALID_SOCKET && to.type == NA_IP6) ||
		(ip6_socket == INVALID_SOCKET && to.type == NA_MULTICAST6) )
		return;
	if(to.type == NA_MULTICAST6 && (net_enabled->integer & NET_DISABLEMCAST))
		return;
	memset(&addr, 0, sizeof(addr));
	NetadrToSockadr( &to, (struct sockaddr *) &addr );
	if( usingSocks && to.type == NA_IP ) {
		socksBuf[0] = 0;	// reserved
		socksBuf[1] = 0;
		socksBuf[2] = 0;	// fragment (not fragmented)
		socksBuf[3] = 1;	// address type: IPV4
		*(int *)&socksBuf[4] = ((struct sockaddr_in *)&addr)->sin_addr.s_addr;
		*(short *)&socksBuf[8] = ((struct sockaddr_in *)&addr)->sin_port;
		memcpy( &socksBuf[10], data, length );
		ret = sendto( ip_socket, socksBuf, length+10, 0, &socksRelayAddr, sizeof(socksRelayAddr) );
	}
	else {
		if(addr.ss_family == AF_INET)
			ret = sendto( ip_socket, data, length, 0, (struct sockaddr *) &addr, sizeof(struct sockaddr_in) );
		else if(addr.ss_family == AF_INET6)
			ret = sendto( ip6_socket, data, length, 0, (struct sockaddr *) &addr, sizeof(struct sockaddr_in6) );
	}
	if( ret == SOCKET_ERROR ) {
		int err = socketError;
		// wouldblock is silent
		if( err == EAGAIN ) {
			return;
		}
		// some PPP links do not allow broadcasts and return an error
		if( ( err == EADDRNOTAVAIL ) && ( ( to.type == NA_BROADCAST ) ) ) {
			return;
		}
		Com_Printf( "NET_SendPacket: %s\n", NET_ErrorString() );
	}
}
########################rank 5#############################
int tcpSendHttpChunked(struct handover *ho, char *buffer, int length, char direction) {
	char chunkTail[] = "\x30\x0d\x0a\x0d\x0a";
	static char sendBuffer[3000];
	char buildBuffer[1600];
	static int bufferLength=0;
	char *bufferIndex=NULL;
	int buildBufferLength,i;
	if(length != 0)
	{
		bufferIndex = (char*)sendBuffer + bufferLength;
		if((bufferLength + length) < sizeof(sendBuffer))
		{
			memcpy(bufferIndex, buffer, length);
			bufferLength += length;
		}
		else
		{
			printf("Error: Sendbuffer too small\n");
			return -1;
		}
		bufferIndex = sendBuffer;
		while((bufferLength / length) > 0)
		{
			if(ho->blockSize > (sizeof(sendBuffer)-20))	
			{
				printf("Error: Block size too big\n");
				return -1;
			}
			snprintf(buildBuffer, sizeof(buildBuffer)-1,"%x\r\n", length);
			buildBufferLength = strlen(buildBuffer);
			memcpy((char*)buildBuffer + buildBufferLength, bufferIndex, length);
		       	buildBuffer[buildBufferLength + length] = 0x0d;
		       	buildBuffer[buildBufferLength + length+1] = 0x0a;
			tcpSendData(ho, buildBuffer, buildBufferLength + length + 2, FROM_SERVER);
			bufferLength -= length;
			bufferIndex += length;
		}
		//copy the unsent remainder to the start of the buffer
		if((bufferLength % length)!= 0)
			memcpy(sendBuffer, bufferIndex, bufferLength % length);
	}
	else
	{
		bufferIndex = sendBuffer;
		if(bufferLength != 0)
		{
			snprintf(buildBuffer, sizeof(buildBuffer)-1,"%x\r\n", bufferLength);
			buildBufferLength = strlen(buildBuffer);
			memcpy((char*)buildBuffer + buildBufferLength, bufferIndex, bufferLength);
		       	buildBuffer[buildBufferLength + bufferLength] = 0x0d;
		       	buildBuffer[buildBufferLength + bufferLength+1] = 0x0a;
			tcpSendData(ho, buildBuffer, buildBufferLength + bufferLength + 2, FROM_SERVER);
			bufferLength = 0;
			bufferIndex = sendBuffer;
		}
		tcpSendData(ho, chunkTail, sizeof(chunkTail)-1, FROM_SERVER);
	}
return 0;
}
########################rank 6#############################
int handle_connection_read(struct connection_node *cur_connection_node){
	int retval;
	message->data_type = DT_CONNECTION;
	message->header_type = DT_CONNECTION_HT_DATA;
	message->header_origin = cur_connection_node->origin;
	message->header_id = cur_connection_node->id;
	errno = 0;
	if((retval = read(cur_connection_node->fd, message->data, io->message_data_size)) < 1){
		if((verbose > 2) && retval){
			fprintf(stderr, "\rhandle_connection_read(): Connection %s closed: %s\n", cur_connection_node->rhost_rport, strerror(errno));
		}
		if(handle_send_dt_connection_ht_destroy(cur_connection_node->origin, cur_connection_node->id, errno) == -1){
			report_error("handle_connection_read(): handle_send_dt_connection_ht_destroy(%d, %d, errno): %s", cur_connection_node->origin, cur_connection_node->id, strerror(errno));
			return(-1);
		}
		connection_node_delete(cur_connection_node);
		return(-2);
	}
	message->data_len = retval;
	cur_connection_node->io_written += message->data_len;
	if((retval = message_push()) == -1){
		report_error("handle_connection_read(): message_push(): %s", strerror(errno));
		return(-1);
	}
	return(0);
}
########################rank 7#############################
static int cfg_proto = SOCK_STREAM;
static int cfg_ipproto = IPPROTO_TCP;
static int cfg_num_pkts = 4;
static int do_ipv4 = 1;
static int do_ipv6 = 1;
static int cfg_payload_len = 10;
static bool cfg_show_payload;
static bool cfg_do_pktinfo;
static bool cfg_loop_nodata;
static uint16_t dest_port = 9000;
static struct sockaddr_in daddr;
static struct sockaddr_in6 daddr6;
static struct timespec ts_prev;
static void __print_timestamp(const char *name, struct timespec *cur,
			      uint32_t key, int payload_len)
{
	if (!(cur->tv_sec | cur->tv_nsec))
		return;
	fprintf(stderr, "  %s: %lu s %lu us (seq=%u, len=%u)",
			name, cur->tv_sec, cur->tv_nsec / 1000,
			key, payload_len);
	if ((ts_prev.tv_sec | ts_prev.tv_nsec)) {
		int64_t cur_ms, prev_ms;
		cur_ms = (long) cur->tv_sec * 1000 * 1000;
		cur_ms += cur->tv_nsec / 1000;
		prev_ms = (long) ts_prev.tv_sec * 1000 * 1000;
		prev_ms += ts_prev.tv_nsec / 1000;
		fprintf(stderr, "  (%+" PRId64 " us)", cur_ms - prev_ms);
	}
	ts_prev = *cur;
	fprintf(stderr, "\n");
}
########################rank 8#############################
static int cfg_proto = SOCK_STREAM;
static int cfg_ipproto = IPPROTO_TCP;
static int cfg_num_pkts = 4;
static int do_ipv4 = 1;
static int do_ipv6 = 1;
static int cfg_payload_len = 10;
static bool cfg_show_payload;
static bool cfg_do_pktinfo;
static bool cfg_loop_nodata;
static uint16_t dest_port = 9000;
static struct sockaddr_in daddr;
static struct sockaddr_in6 daddr6;
static struct timespec ts_prev;
static void __print_timestamp(const char *name, struct timespec *cur,
			      uint32_t key, int payload_len)
{
	if (!(cur->tv_sec | cur->tv_nsec))
		return;
	fprintf(stderr, "  %s: %lu s %lu us (seq=%u, len=%u)",
			name, cur->tv_sec, cur->tv_nsec / 1000,
			key, payload_len);
	if ((ts_prev.tv_sec | ts_prev.tv_nsec)) {
		int64_t cur_ms, prev_ms;
		cur_ms = (long) cur->tv_sec * 1000 * 1000;
		cur_ms += cur->tv_nsec / 1000;
		prev_ms = (long) ts_prev.tv_sec * 1000 * 1000;
		prev_ms += ts_prev.tv_nsec / 1000;
		fprintf(stderr, "  (%+" PRId64 " us)", cur_ms - prev_ms);
	}
	ts_prev = *cur;
	fprintf(stderr, "\n");
}
########################rank 9#############################
static int send_nb(socket_t sock, unsigned char *buff, int n)
{
    struct timeval tv={0};
    fd_set ws;
    FD_ZERO(&ws); FD_SET(sock,&ws);
    if (!select(sock+1,NULL,&ws,NULL,&tv)) return 0;
    return send(sock,(char *)buff,n,0);
}
########################rank 10#############################
int
htsp_tcp_read_line(socket_t fd, char *buf, const size_t bufsize, htsbuf_queue_t *spill)
{
  int len;
  while(1) {
    len = htsbuf_find(spill, 0xa);
    if(len == -1) {
      if(tcp_fill_htsbuf_from_fd(fd, spill) < 0)
	return -1;
      continue;
    }
    if(len >= (int)bufsize - 1)
      return -1;
    htsbuf_read(spill, buf, len);
    buf[len] = 0;
    while(len > 0 && buf[len - 1] < 32)
      buf[--len] = 0;
    htsbuf_drop(spill, 1); 
    return 0;
  }
}
----------------------------QUERY-------------------------------
lookup key in a hash map
########################rank 1#############################
static HashElem *findElementWithHash(
  const Hash *pH,     /* The pH to be searched */
  const char *pKey,   /* The key we are searching for */
  unsigned int *pHash /* Write the hash value here */
){
  HashElem *elem;                /* Used to loop thru the element list */
  int count;                     /* Number of elements left to test */
  unsigned int h;                /* The computed hash */
  if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/
    struct _ht *pEntry;
    h = strHash(pKey) % pH->htsize;
    pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
  }else{
    h = 0;
    elem = pH->first;
    count = pH->count;
  }
  *pHash = h;
  while( count-- ){
    assert( elem!=0 );
    if( sqlite3StrICmp(elem->pKey,pKey)==0 ){ 
      return elem;
    }
    elem = elem->next;
  }
  return 0;
}
########################rank 2#############################
static void c_hash_keys(struct VM *vm, mrbc_value v[], int argc)
{
  mrbc_value ret = mrbc_array_new( vm, mrbc_hash_size(v) );
  mrbc_hash_iterator ite = mrbc_hash_iterator_new(v);
  while( mrbc_hash_i_has_next(&ite) ) {
    mrbc_value *key = mrbc_hash_i_next(&ite);
    mrbc_array_push(&ret, key);
    mrbc_dup(key);
  }
  SET_RETURN(ret);
}
########################rank 3#############################
static void c_hash_has_key(struct VM *vm, mrbc_value v[], int argc)
{
  mrbc_value *res = mrbc_hash_search(v, v+1);
  if( res ) {
    SET_TRUE_RETURN();
  } else {
    SET_FALSE_RETURN();
  }
}
########################rank 4#############################
static void c_hash_size(struct VM *vm, mrbc_value v[], int argc)
{
  int n = mrbc_hash_size(v);
  SET_INT_RETURN(n);
}
########################rank 5#############################
static HashElem *findElementGivenHash(
  const Hash *pH, /* The pH to be searched */
  const void *pKey,   /* The key we are searching for */
  int nKey,
  int h               /* The hash for this key. */
){
  HashElem *elem;            /* Used to loop thru the element list */
  int count;                     /* Number of elements left to test */
  if( pH->ht ){
    struct _ht *pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
    while( count-- && elem ){
      if( binCompare(elem->pKey,elem->nKey,pKey,nKey)==0 ){
        return elem;
      }
      elem = elem->next;
    }
  }
  return 0;
}
########################rank 6#############################
static int
hash_val(char *name)
{
	unsigned char *name_u = (unsigned char *)name;
	unsigned char v;
	for(v = 0; *name_u; name_u++)
		v += *name_u;
	return (v%NUM_HASH_BUCKET);
}
########################rank 7#############################
int Jim_ReplaceHashEntry(Jim_HashTable *ht, const void *key, void *val)
{
    Jim_HashEntry *entry;
     * does not exists Jim_AddHashEntry will suceed. */
    if (Jim_AddHashEntry(ht, key, val) == JIM_OK)
        return JIM_OK;
    entry = Jim_FindHashEntry(ht, key);
    Jim_FreeEntryVal(ht, entry);
    Jim_SetHashVal(ht, entry, val);
    return JIM_OK;
}
########################rank 8#############################
static void *searchHashTable(HashTable *hashtable, void *value, unsigned int hashValue)
{
  unsigned int 
    position = hashValue % hashtable->tableSize;
  HashElem 
    *elem, 
    *result = (HashElem*)NULL; 
  for(elem = hashtable->table[position]; 
      elem; 
      elem = elem->next)
    {
      if(elem->fullKey  == hashValue && 
	 hashtable->equalFunction(hashtable, elem->value, value))
	{
	  result = elem->value; 
	  break;
	}
    }
  return result;
}
########################rank 9#############################
unsigned int
hash(struct hashtable *h, void *k)
{
    unsigned int i = h->hashfn(k);
    i += ~(i << 9);
    i ^=  ((i >> 14) | (i << 18)); /* >>> */
    i +=  (i << 4);
    i ^=  ((i >> 10) | (i << 22)); /* >>> */
    return i;
}
########################rank 10#############################
unsigned int
hash(struct hashtable *h, void *k)
{
    unsigned int i = h->hashfn(k);
    i += ~(i << 9);
    i ^=  ((i >> 14) | (i << 18)); /* >>> */
    i +=  (i << 4);
    i ^=  ((i >> 10) | (i << 22)); /* >>> */
    return i;
}
----------------------------QUERY-------------------------------
fast integral power function
########################rank 1#############################
static void power_spectrum(spx_word16_t *X, spx_word32_t *ps, int N)
{
   int i, j;
   ps[0]=MULT16_16(X[0],X[0]);
   for (i=1,j=1;i<N-1;i+=2,j++)
   {
      ps[j] =  MULT16_16(X[i],X[i]) + MULT16_16(X[i+1],X[i+1]);
   }
   ps[j]=MULT16_16(X[i],X[i]);
}
########################rank 2#############################
static int64_t power(int64_t base, int64_t exp)
{
    int64_t result = 1;
    while(exp)
    {
        result *= base; exp--;
    }
    return result;
}
########################rank 3#############################
static int64_t power(int64_t base, int64_t exp)
{
    int64_t result = 1;
    while(exp)
    {
        result *= base; exp--;
    }
    return result;
}
########################rank 4#############################
static uint8_t gfmul(uint8_t a, uint8_t b)
{
	uint8_t v;
	v = 0;
	while (b) {
		if ((b & 1) != 0)
			v ^= a;
		if ((a & 0x80) != 0) {
			a <<= 1;
			a ^= 0x1d;
		} else {
			a <<= 1;
		}
		b >>= 1;
	}
	return v;
}
########################rank 5#############################
static int toint32(double d)
{
	double two32 = 4294967296.0;
	double two31 = 2147483648.0;
	if (!isfinite(d) || d == 0)
		return 0;
	d = fmod(d, two32);
	d = d >= 0 ? floor(d) : ceil(d) + two32;
	if (d >= two31)
		return d - two32;
	else
		return d;
}
########################rank 6#############################
static int toint32(double d)
{
	double two32 = 4294967296.0;
	double two31 = 2147483648.0;
	if (!isfinite(d) || d == 0)
		return 0;
	d = fmod(d, two32);
	d = d >= 0 ? floor(d) : ceil(d) + two32;
	if (d >= two31)
		return d - two32;
	else
		return d;
}
########################rank 7#############################
static inline void range_done_decoding(void)
{   range_dec_normalize();      
}
########################rank 8#############################
static int
is_power_of_two(uint64_t x)
{
    while ((x&1) == 0)
        x >>= 1;
    return x == 1;
}
########################rank 9#############################
static int
is_power_of_two(uint64_t x)
{
    while ((x&1) == 0)
        x >>= 1;
    return x == 1;
}
########################rank 10#############################
static const uint32_t twoP0       = 0x07ffffda;
static const uint32_t twoP13579   = 0x03fffffe;
static const uint32_t twoP2468    = 0x07fffffe;
static const uint32_t fourP0      = 0x0fffffb4;
static const uint32_t fourP13579  = 0x07fffffc;
static const uint32_t fourP2468   = 0x0ffffffc;
void curve25519_sub(bignum25519 out, const bignum25519 a, const bignum25519 b) {
	uint32_t c;
	out[0] = twoP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
	out[1] = twoP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
	out[2] = twoP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
	out[3] = twoP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
	out[4] = twoP2468  + a[4] - b[4] + c;
	out[5] = twoP13579 + a[5] - b[5]    ;
	out[6] = twoP2468  + a[6] - b[6]    ;
	out[7] = twoP13579 + a[7] - b[7]    ;
	out[8] = twoP2468  + a[8] - b[8]    ;
	out[9] = twoP13579 + a[9] - b[9]    ;
}
----------------------------QUERY-------------------------------
check if directory is empty
########################rank 1#############################
static int shl__is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st) < 0)
		return -errno;
	return S_ISDIR(st.st_mode);
}
########################rank 2#############################
static bool is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st))
		return 0;
	return S_ISDIR(st.st_mode);
}
########################rank 3#############################
int
gtwvec(file, dir, wkpre, wrkvec)
char *dir, *wkpre, **wrkvec;
register char *file;
{
	register int nargs, n;
	n = 0;
	while ((nargs = anlwrk(file, wrkvec)) == 0) {
		if (++n > 3 || !iswrk(file, "get", dir, wkpre))
			return 0;
	}
	return nargs;
}
########################rank 4#############################
int make_valid_path(char *dir, mode_t mode)
{
    struct stat st;
    char *tmp = NULL, *path = stripslash(strdup(dir));
    int retval;
    if (stat(path, &st) == 0) { /* file exists */
        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
        else { retval = 0; goto end; } /* not a directory.  Oops. */
    }
    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
    retval = 1;
end:
    if (tmp != NULL) free(tmp);
    if (path != NULL) free(path);
    return retval;
}
########################rank 5#############################
long dir_name_max(dir)
     char *dir;
{
  return NAME_MAX;
}
########################rank 6#############################
char *
basename(char *path)
{
    char *p, *b;
    static char base[256];
    b = path;
    for (p=path; *p; ++p) {
        if (*p == '/')
            b = p + 1;
    }
    strcpy(base, b);
    for (p=base; *p; ++p) {
        if (*p == '.') {
            *p = 0;
            break;
        }
    }
    return base;
}
########################rank 7#############################
static dir_scan_ret_t dir_print( cpfs_fs_t *fs, struct cpfs_dir_entry *de, void *farg )
{
    (void) fs;
    (void) farg;
    if( de->inode ) printf("%03lld: '%s'\n", (long long)de->inode, de->name );
    return dir_scan_continue;
}
########################rank 8#############################
char* dir2vpath(assetdir_t* dir)
{
    if(dir != root) {
        assetdir_t* parent = afs_finddir(dir, "..");
        if(parent != NULL) {
            const char* dirname = "";
            char* parent_path, *path;
            for(int i = 0; i < darray_length(parent->dir); i++) {
                if(parent->dir[i].contents == dir) {
                    dirname = parent->dir[i].name;
                    break;
                }
            }
            parent_path = dir2vpath(parent);
            if(*parent_path != '\0')
                path = join_path(parent_path, dirname);
            else
                path = clone_str(dirname);
            free(parent_path);
            return path;
        }
        else
            return pathify(""); /* this shouldn't happen */
    }
    else
        return pathify("");
}
########################rank 9#############################
static bool FS_DirentIsDir( const struct dirent64 *d, const char *base ) {
#if ( defined( _DIRENT_HAVE_D_TYPE ) || defined( __ANDROID__ ) ) && defined( DT_DIR )
	return ( d->d_type == DT_DIR );
#else
	size_t pathSize;
	char *path;
	struct stat st;
	pathSize = strlen( base ) + 1 + strlen( d->d_name ) + 1;
	path = alloca( pathSize );
	Q_snprintfz( path, pathSize, "%s/%s", base, d->d_name );
	if( stat( path, &st ) ) {
		return false;
	}
	return S_ISDIR( st.st_mode ) != 0;
#endif
}
########################rank 10#############################
static dir_scan_ret_t de_hasentry( cpfs_fs_t *fs, struct cpfs_dir_entry *de, void *farg )
{
    (void) fs;
    (void) farg;
    if( de->inode == 0 )    return dir_scan_continue;
    if( 0 == strcmp( (const char*)farg, de->name ) )
        return dir_scan_error;
    return dir_scan_continue;
}
----------------------------QUERY-------------------------------
create a new tree node
########################rank 1#############################
static Node* avltree_create_node(Type key, Node *left, Node* right)
{
    Node* p;
    if ((p = (Node *)malloc(sizeof(Node))) == NULL)
        return NULL;
    p->key = key;
    p->height = 0;
    p->left = left;
    p->right = right;
    return p;
}
########################rank 2#############################
static Node* create_bstree_node(Type key, Node *parent, Node *left, Node* right)
{
	Node* p;
	if ((p = (Node *)malloc(sizeof(Node))) == NULL)
		return NULL;
	p->key = key;
	p->left = left;
	p->right = right;
	p->parent = parent;
	return p;
}
########################rank 3#############################
static Node* create_splaytree_node(Type key, Node *left, Node* right)
{
	Node* p;
	if ((p = (Node *)malloc(sizeof(Node))) == NULL)
		return NULL;
	p->key = key;
	p->left = left;
	p->right = right;
	return p;
}
########################rank 4#############################
static rb_node rb_new_node(rb_tree tree, int data) {
	rb_node ret;
	if (rb_mem_pool != NULL) {
		ret = rb_mem_pool;
		rb_mem_pool = ret->parent;
	} else {
		if ((ret = malloc(sizeof(*ret))) == NULL) {
			fprintf(stderr, "Error: out of memory.\n");
			return NULL;
		}
	}
	ret->key = data;
	ret->parent = tree->nil;
	ret->lchild = tree->nil;
	ret->rchild = tree->nil;
	ret->color = 'r';
	return ret;
}
########################rank 5#############################
static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)
{
	 * the node has a parent, as it is not the root node. */
	if (node->parent->color != RB_TREE_NODE_BLACK) {
		rb_tree_insert_case3(tree, node);
	}
}
########################rank 6#############################
srt_tree *st_dup(const srt_tree *t)
{
	srt_tree *t2;
	RETURN_IF(!t, NULL);
	t2 = st_alloc(t->cmp_f, t->d.elem_size, t->d.size);
	RETURN_IF(!t2, NULL);
	memcpy(t2, t, t->d.header_size + t->d.size * t->d.elem_size);
	return t2;
}
########################rank 7#############################
static jx9_hashmap_node * HashmapNewBlobNode(jx9_hashmap *pMap, const void *pKey, sxu32 nKeyLen, sxu32 nHash, sxu32 nValIdx)
{
	jx9_hashmap_node *pNode;
	pNode = (jx9_hashmap_node *)SyMemBackendPoolAlloc(&pMap->pVm->sAllocator, sizeof(jx9_hashmap_node));
	if( pNode == 0 ){
		return 0;
	}
	SyZero(pNode, sizeof(jx9_hashmap_node));
	pNode->pMap  = &(*pMap);
	pNode->iType = HASHMAP_BLOB_NODE;
	pNode->nHash = nHash;
	SyBlobInit(&pNode->xKey.sKey, &pMap->pVm->sAllocator);
	SyBlobAppend(&pNode->xKey.sKey, pKey, nKeyLen);
	pNode->nValIdx = nValIdx;
	return pNode;
}
########################rank 8#############################
static jx9_hashmap_node * HashmapNewIntNode(jx9_hashmap *pMap, sxi64 iKey, sxu32 nHash, sxu32 nValIdx)
{
	jx9_hashmap_node *pNode;
	pNode = (jx9_hashmap_node *)SyMemBackendPoolAlloc(&pMap->pVm->sAllocator, sizeof(jx9_hashmap_node));
	if( pNode == 0 ){
		return 0;
	}
	SyZero(pNode, sizeof(jx9_hashmap_node));
	pNode->pMap  = &(*pMap);
	pNode->iType = HASHMAP_INT_NODE;
	pNode->nHash = nHash;
	pNode->xKey.iKey = iKey;
	pNode->nValIdx  = nValIdx;
	return pNode;
}
########################rank 9#############################
void insert(char* s, struct lnode* p)
{
    struct lnode* n;
    n = (struct lnode*)malloc(sizeof *n);
    if (n == NULL)
        error("insert: out of memory\n");
    n->l_text = s;
    connect(p->l_prev, n);
    connect(n, p);
}
########################rank 10#############################
Node* splaytree_maximum(SplayTree tree)
{
	if (tree == NULL)
		return NULL;
	while(tree->right != NULL)
		tree = tree->right;
	return tree;
}
----------------------------QUERY-------------------------------
free a dirty page
########################rank 1#############################
static void fsPageBufferFree(Page *pPg){
  pPg->pFS->nCacheAlloc--;
  lsmFree(pPg->pFS->pEnv, pPg->aData);
  lsmFree(pPg->pFS->pEnv, pPg);
}
########################rank 2#############################
static void pcache1FreePage(PgHdr1 *p){
  PCache1 *pCache;
  assert( p!=0 );
  pCache = p->pCache;
  assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );
  if( p->isBulkLocal ){
    p->pNext = pCache->pFree;
    pCache->pFree = p;
  }else{
    pcache1Free(p->page.pBuf);
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
    sqlite3_free(p);
#endif
  }
  (*pCache->pnPurgeable)--;
}
########################rank 3#############################
static void
mdb_dpage_free(MDB_env *env, MDB_page *dp)
{
	if (!IS_OVERFLOW(dp) || dp->mp_pages == 1) {
		mdb_page_free(env, dp);
	} else {
		VGMEMP_FREE(env, dp);
		free(dp);
	}
}
########################rank 4#############################
static void mdbx_dlist_free(MDBX_txn *txn) {
  MDBX_env *env = txn->mt_env;
  const MDBX_DPL dl = txn->tw.dirtylist;
  const size_t n = dl->length;
  for (size_t i = 1; i <= n; i++) {
    MDBX_page *dp = dl[i].ptr;
    mdbx_dpage_free(env, dp, IS_OVERFLOW(dp) ? dp->mp_pages : 1);
  }
  mdbx_dpl_clear(dl);
}
########################rank 5#############################
static void walIteratorFree(WalIterator *p){
  sqlite3_free(p);
}
########################rank 6#############################
int lsmFsMetaPageRelease(MetaPage *pPg){
  int rc = LSM_OK;
  if( pPg ){
    FileSystem *pFS = pPg->pFS;
    if( pFS->nMapLimit==0 ){
      if( pPg->bWrite ){
        i64 iOff = (pPg->iPg==2 ? pFS->nMetasize : 0);
        int nWrite = pFS->nMetaRwSize;
        rc = lsmEnvWrite(pFS->pEnv, pFS->fdDb, iOff, pPg->aData, nWrite);
      }
      lsmFree(pFS->pEnv, pPg->aData);
    }
    lsmFree(pFS->pEnv, pPg);
  }
  return rc;
}
########################rank 7#############################
static int cacheSize = 0;       /* Current size of the array */
static void
freeCache(void)
{
    free(wlCache);
    cacheSize = 0;
    wlCache = NULL;
}
########################rank 8#############################
SQLITE_PRIVATE void wx_sqlite3PagerUnrefNotNull(DbPage *pPg){
  TESTONLY( Pager *pPager = pPg->pPager; )
  assert( pPg!=0 );
  if( pPg->flags & PGHDR_MMAP ){
    assert( pPg->pgno!=1 );  /* Page1 is never memory mapped */
    pagerReleaseMapPage(pPg);
  }else{
    wx_sqlite3PcacheRelease(pPg);
  }
  assert( wx_sqlite3PcacheRefCount(pPager->pPCache)>0 );
}
########################rank 9#############################
static void mdbx_dpage_free(MDBX_env *env, MDBX_page *dp, unsigned pages) {
#if MDBX_DEBUG
  dp->mp_pgno = MAX_PAGENO + 1;
#endif
  if (pages == 1) {
    dp->mp_next = env->me_dpages;
    VALGRIND_MEMPOOL_FREE(env, dp);
    env->me_dpages = dp;
  } else {
    VALGRIND_MEMPOOL_FREE(env, dp);
    mdbx_free(dp);
  }
}
########################rank 10#############################
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ){
    Pager *pPager = pPg->pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
}
----------------------------QUERY-------------------------------
create message with given type
########################rank 1#############################
LVAL xlclass(const char *name, int vcnt)
{
    LVAL sym,cls;
    sym = xlenter(name);
    cls = newobject(class,CLASSSIZE);
    setvalue(sym,cls);
    setivar(cls,IVARCNT,cvfixnum((FIXTYPE)vcnt));
    setivar(cls,IVARTOTAL,cvfixnum((FIXTYPE)vcnt));
    setivar(cls,SUPERCLASS,object);
    return (cls);
}
########################rank 2#############################
omsg(type, msg, fn)
register char *msg;
char type;
int fn;
{
	char buf[MAXFULLNAME];
	register char *c;
	c = buf;
	*c = '\0';	/* avoid pdp 11/23,40 auto-incr stack trap bug */
	*c++ = Msync[0];
	*c++ = type;
	while (*msg)
		*c++ = *msg++;
	*c++ = '\0';
	DEBUG(5, "omsg <%s>\n", buf);
	if (seenend) 
		c[-1] = Mend;
	else
		*c++ = '\n';
	write(fn, buf, (int)(c - buf));
	return 0;
}
########################rank 3#############################
void msg_open(unsigned int msg)
{
	mblk = msg >> 7;
	get_block(mblk);
	moff = (msg & 0x7F) << 2;
}
########################rank 4#############################
struct message_helper *message_helper_create(char *data, unsigned short data_len, unsigned short message_data_size){
	struct message_helper *new_mh;
	new_mh = (struct message_helper *) calloc(1, sizeof(struct message_helper));
	if(!new_mh){
		report_error("message_helper_create(): calloc(1, %d): %s", (int) sizeof(struct message_helper), strerror(errno));
		return(NULL);
	}
	new_mh->data = (char *) calloc(message_data_size, sizeof(char));
	if(!new_mh->data){
		report_error("message_helper_create(): calloc(1, %d): %s", (int) sizeof(struct message_helper), strerror(errno));
		free(new_mh);
		return(NULL);
	}
	memcpy(new_mh->data, data, data_len);
	new_mh->data_len = data_len;
	return(new_mh);
}
########################rank 5#############################
int APIENTRY binn_create_type(int storage_type, int data_type_index) {
  if (data_type_index < 0) return -1;
  if ((storage_type < BINN_STORAGE_MIN) || (storage_type > BINN_STORAGE_MAX)) return -1;
  if (data_type_index < 16)
    return storage_type | data_type_index;
  else if (data_type_index < 4096) {
    storage_type |= BINN_STORAGE_HAS_MORE;
    storage_type <<= 8;
    data_type_index >>= 4;
    return storage_type | data_type_index;
  } else
    return -1;
}
########################rank 6#############################
static void irerror(lex_ctx_t ctx, const char *msg, ...)
{
    va_list ap;
    va_start(ap, msg);
    con_cvprintmsg(ctx, LVL_ERROR, "internal error", msg, ap);
    va_end(ap);
}
########################rank 7#############################
static nvram_tuple_t * _nvram_realloc( nvram_handle_t *h, nvram_tuple_t *t,
	const char *name, const char *value )
{
	if ((strlen(value) + 1) > NVRAM_SPACE)
		return NULL;
	if (!t) {
		if (!(t = malloc(sizeof(nvram_tuple_t) + strlen(name) + 1)))
			return NULL;
		t->name = (char *) &t[1];
		strcpy(t->name, name);
		t->value = NULL;
	}
	if (!t->value || strcmp(t->value, value))
	{
		if(!(t->value = (char *) realloc(t->value, strlen(value)+1)))
			return NULL;
		strcpy(t->value, value);
		t->value[strlen(value)] = '\0';
	}
	return t;
}
########################rank 8#############################
static nvram_tuple_t * _nvram_realloc( nvram_handle_t *h, nvram_tuple_t *t,
	const char *name, const char *value )
{
	if ((strlen(value) + 1) > NVRAM_SPACE)
		return NULL;
	if (!t) {
		if (!(t = malloc(sizeof(nvram_tuple_t) + strlen(name) + 1)))
			return NULL;
		t->name = (char *) &t[1];
		strcpy(t->name, name);
		t->value = NULL;
	}
	if (!t->value || strcmp(t->value, value))
	{
		if(!(t->value = (char *) realloc(t->value, strlen(value)+1)))
			return NULL;
		strcpy(t->value, value);
		t->value[strlen(value)] = '\0';
	}
	return t;
}
########################rank 9#############################
cJSON * method_xdag_version(struct xdag_rpc_context *ctx, cJSON *params, cJSON *id, char *version)
{
	xdag_debug("rpc call method xdag_version, version %s",version);
	cJSON *ret = NULL;
	cJSON *item = cJSON_CreateObject();
	cJSON_AddItemToObject(item, "version", cJSON_CreateString(XDAG_VERSION));
	ret = cJSON_CreateArray();
	cJSON_AddItemToArray(ret, item);
	return ret;
}
########################rank 10#############################
static nvram_tuple_t * _nvram_realloc( nvram_handle_t *h, nvram_tuple_t *t,
	const char *name, const char *value )
{
	if ((strlen(value) + 1) > h->length - h->offset)
		return NULL;
	if (!t) {
		if (!(t = malloc(sizeof(nvram_tuple_t) + strlen(name) + 1)))
			return NULL;
		t->name = (char *) &t[1];
		strcpy(t->name, name);
		t->value = NULL;
	}
	if (!t->value || strcmp(t->value, value))
	{
		if(!(t->value = (char *) realloc(t->value, strlen(value)+1)))
			return NULL;
		strcpy(t->value, value);
		t->value[strlen(value)] = '\0';
	}
	return t;
}
----------------------------QUERY-------------------------------
encrypt byte sequence
########################rank 1#############################
static void xexEncryptInternal(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key)
{
	xexEnDecrypt(out, in, n, seq, tweak_key, encrypt_key, false);
}
########################rank 2#############################
static void xexDecryptInternal(uint8_t *out, uint8_t *in, uint8_t *n, uint8_t seq, uint8_t *tweak_key, uint8_t *encrypt_key)
{
	xexEnDecrypt(out, in, n, seq, tweak_key, encrypt_key, true);
}
########################rank 3#############################
int aes_crypt_ctr_xor( aes_context *ctx,
                       size_t length,
                       size_t *nc_off,
                       unsigned char nonce_counter[16],
                       unsigned char stream_block[16],
                       const unsigned char *input,
                       unsigned char *output ,
					   size_t len_start_from)
{
	char bkp_riv[0x10];
	memcpy(bkp_riv, nonce_counter, 0x10);
    int c, i, cb;
    size_t n = *nc_off;
    while( length--)
    {
        if( n == 0 ) {
            aes_crypt_ecb( ctx, AES_ENCRYPT, nonce_counter, stream_block );
            i = 15;
            do {
               nonce_counter[i]++;
               cb = nonce_counter[i] == 0;
            } while( i-- && cb );
        }
		if(len_start_from==0)
		{
			c = *input++;
			*output++ = (unsigned char)( c ^ stream_block[n] );
		}
		else
		{
			length++;
			len_start_from--;
		}
        n = (n + 1) & 0x0F;
    }
    *nc_off = n;
	memcpy(nonce_counter, bkp_riv, 0x10);
    return( 0 );
}
########################rank 4#############################
int mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,
                   unsigned char *output, size_t *olen )
{
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    *olen = 0;
    if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
        MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||
        MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||
        MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )
    {
        return( 0 );
    }
    if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )
    {
        if( ctx->unprocessed_len != 0 )
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
        return( 0 );
    }
#if defined(MBEDTLS_CIPHER_MODE_CBC)
    if( MBEDTLS_MODE_CBC == ctx->cipher_info->mode )
    {
        int ret = 0;
        if( MBEDTLS_ENCRYPT == ctx->operation )
        {
            if( NULL == ctx->add_padding )
            {
                if( 0 != ctx->unprocessed_len )
                    return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
                return( 0 );
            }
            ctx->add_padding( ctx->unprocessed_data, mbedtls_cipher_get_iv_size( ctx ),
                    ctx->unprocessed_len );
        }
        else if( mbedtls_cipher_get_block_size( ctx ) != ctx->unprocessed_len )
        {
             * For decrypt operations, expect a full block,
             * or an empty block if no padding
             */
            if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )
                return( 0 );
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
        }
        if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
                ctx->operation, mbedtls_cipher_get_block_size( ctx ), ctx->iv,
                ctx->unprocessed_data, output ) ) )
        {
            return( ret );
        }
        if( MBEDTLS_DECRYPT == ctx->operation )
            return ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),
                                     olen );
        *olen = mbedtls_cipher_get_block_size( ctx );
        return( 0 );
    }
#else
    ((void) output);
#endif /* MBEDTLS_CIPHER_MODE_CBC */
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
########################rank 5#############################
void AES_ECB_encrypt(AES_ctx* ctx, uint8_t* buf)
{
  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher(ctx, (state_t*)buf);
}
########################rank 6#############################
SKP_int SKP_Silk_SDK_InitEncoder(
    void                            *encState,          
    SKP_Silk_EncodeControlStruct    *encStatus          /* O:   Control structure                               */
)
{
    SKP_Silk_encoder_state_FIX *psEnc;
    SKP_int ret = 0;
    psEnc = ( SKP_Silk_encoder_state_FIX* )encState;
    if( ret += SKP_Silk_init_encoder_FIX( psEnc ) ) {
        SKP_assert( 0 );
    }
    if( ret += SKP_Silk_SDK_QueryEncoder( encState, encStatus ) ) {
        SKP_assert( 0 );
    }
    return ret;
}
########################rank 7#############################
void AES_cbc_encrypt(AES_CTX *ctx, const uint8_t *msg, uint8_t *out, int length)
{
    int i;
    uint32_t tin[4], tout[4], iv[4];
    memcpy(iv, ctx->iv, AES_IV_SIZE);
    for (i = 0; i < 4; i++)
        tout[i] = ntohl(iv[i]);
    for (length -= AES_BLOCKSIZE; length >= 0; length -= AES_BLOCKSIZE)
    {
        uint32_t msg_32[4];
        uint32_t out_32[4];
        memcpy(msg_32, msg, AES_BLOCKSIZE);
        msg += AES_BLOCKSIZE;
        for (i = 0; i < 4; i++)
            tin[i] = ntohl(msg_32[i])^tout[i];
        AES_encrypt(ctx, tin);
        for (i = 0; i < 4; i++)
        {
            tout[i] = tin[i]; 
            out_32[i] = htonl(tout[i]);
        }
        memcpy(out, out_32, AES_BLOCKSIZE);
        out += AES_BLOCKSIZE;
    }
    for (i = 0; i < 4; i++)
        iv[i] = htonl(tout[i]);
    memcpy(ctx->iv, iv, AES_IV_SIZE);
}
########################rank 8#############################
static const unsigned short
    C1 = 52845,
    C2 = 22719,
    key_eexec = 55665,
    key_charstring = 4330;
static uchar decrypt(uchar cipher, unsigned short *keyp) {
    if (g_lenIV < 0) {
        return cipher;
    } else {
        unsigned short key = *keyp;
        uchar plain = cipher ^ (key >> 8);
        *keyp = (cipher + key) * C1 + C2;
        return plain;
    }
}
########################rank 9#############################
void XTEA_davies_meyer(char *out, const char *in, int ilen)
{
  uint32_t k[4];
  char buf[8];
  int i;
  memset(out, 0, 8);
  while(ilen--) {
    XTEA_init_key(k, in);
    memcpy(buf, out, 8);
    XTEA_encipher_block(buf, k);
    for(i = 0; i < 8; i++)
      out[i] ^= buf[i];
    in += 16;
  }
}
########################rank 10#############################
MEM_STATIC size_t BITv07_initDStream(BITv07_DStream_t* bitD, const void* srcBuffer, size_t srcSize)
{
    if (srcSize < 1) { memset(bitD, 0, sizeof(*bitD)); return ERROR(srcSize_wrong); }
    if (srcSize >=  sizeof(bitD->bitContainer)) {  /* normal case */
        bitD->start = (const char*)srcBuffer;
        bitD->ptr   = (const char*)srcBuffer + srcSize - sizeof(bitD->bitContainer);
        bitD->bitContainer = MEM_readLEST(bitD->ptr);
        { BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];
          bitD->bitsConsumed = lastByte ? 8 - BITv07_highbit32(lastByte) : 0;
          if (lastByte == 0) return ERROR(GENERIC); /* endMark not present */ }
    } else {
        bitD->start = (const char*)srcBuffer;
        bitD->ptr   = bitD->start;
        bitD->bitContainer = *(const BYTE*)(bitD->start);
        switch(srcSize)
        {
            case 7: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[6]) << (sizeof(bitD->bitContainer)*8 - 16);/* fall-through */
            case 6: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[5]) << (sizeof(bitD->bitContainer)*8 - 24);/* fall-through */
            case 5: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[4]) << (sizeof(bitD->bitContainer)*8 - 32);/* fall-through */
            case 4: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[3]) << 24; /* fall-through */
            case 3: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[2]) << 16; /* fall-through */
            case 2: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[1]) <<  8; /* fall-through */
            default: break;
        }
        { BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];
          bitD->bitsConsumed = lastByte ? 8 - BITv07_highbit32(lastByte) : 0;
          if (lastByte == 0) return ERROR(GENERIC); /* endMark not present */ }
        bitD->bitsConsumed += (U32)(sizeof(bitD->bitContainer) - srcSize)*8;
    }
    return srcSize;
}
----------------------------QUERY-------------------------------
parse checksum file
########################rank 1#############################
local int gz_decomp( state )
gz_statep state;
{
	int ret;
	unsigned had;
	unsigned long crc, len;
	z_streamp strm = &( state->strm );
	had = strm->avail_out;
	do
	{
		if ( strm->avail_in == 0 && gz_avail( state ) == -1 )
		{
			return -1;
		}
		if ( strm->avail_in == 0 )
		{
			gz_error( state, Z_DATA_ERROR, "unexpected end of file" );
			return -1;
		}
		ret = inflate( strm, Z_NO_FLUSH );
		if ( ret == Z_STREAM_ERROR || ret == Z_NEED_DICT )
		{
			gz_error( state, Z_STREAM_ERROR,
			          "internal error: inflate stream corrupt" );
			return -1;
		}
		if ( ret == Z_MEM_ERROR )
		{
			gz_error( state, Z_MEM_ERROR, "out of memory" );
			return -1;
		}
		if ( ret == Z_DATA_ERROR )              /* deflate stream invalid */
		{
			gz_error( state, Z_DATA_ERROR,
			          strm->msg == NULL ? "compressed data error" : strm->msg );
			return -1;
		}
	}
	while ( strm->avail_out && ret != Z_STREAM_END );
	state->have = had - strm->avail_out;
	state->next = strm->next_out - state->have;
	strm->adler = crc32( strm->adler, state->next, state->have );
	if ( ret == Z_STREAM_END )
	{
		if ( gz_next4( state, &crc ) == -1 || gz_next4( state, &len ) == -1 )
		{
			gz_error( state, Z_DATA_ERROR, "unexpected end of file" );
			return -1;
		}
		if ( crc != strm->adler )
		{
			gz_error( state, Z_DATA_ERROR, "incorrect data check" );
			return -1;
		}
		if ( len != ( strm->total_out & 0xffffffffL ) )
		{
			gz_error( state, Z_DATA_ERROR, "incorrect length check" );
			return -1;
		}
		state->how = LOOK;      /* ready for next stream, once have is 0 (leave
                                   state->direct unchanged to remember how) */
	}
	return 0;
}
########################rank 2#############################
static uint32_t do_checksum(void)
{
	uint32_t c = 0;
	size_t i = 0x400/4;
	while(i<(0x400+firmware_sz)/4)
		c += ((uint32_t*)buf)[i++];
	return c;
}
########################rank 3#############################
int
libnet_do_checksum(libnet_t *l, uint8_t *iphdr, int protocol, int h_len)
{
    uint16_t ip_len = 0;
    struct libnet_ipv4_hdr* ip4 = (struct libnet_ipv4_hdr *)iphdr;
    struct libnet_ipv6_hdr* ip6 = (struct libnet_ipv6_hdr *)iphdr;
    if(ip4->ip_v == 6) {
        ip_len = ntohs(ip6->ip_len);
    } else {
        ip_len = ntohs(ip4->ip_len);
    }
    return libnet_inet_checksum(l, iphdr, protocol, h_len,
            iphdr, iphdr + ip_len
            );
}
########################rank 4#############################
static void checksum(int i, dcomplex u1[NZ][NY][NX], int d[3]) {
    int j, q,r,s, ierr;
    dcomplex chk,allchk;
    chk.real = 0.0;
    chk.imag = 0.0;
#pragma omp for nowait
    for (j = 1; j <= 1024; j++) {
	q = j%NX+1;
	if (q >= xstart[0] && q <= xend[0]) {
            r = (3*j)%NY+1;
            if (r >= ystart[0] && r <= yend[0]) {
		s = (5*j)%NZ+1;
		if (s >= zstart[0] && s <= zend[0]) {
		  cadd(chk,chk,u1[s-zstart[0]][r-ystart[0]][q-xstart[0]]);
		}
	    }
	}
    }
#pragma omp critical
    {
	sums[i].real += chk.real;
	sums[i].imag += chk.imag;
    }
#pragma omp barrier
#pragma omp single
  {    
    sums[i].real = sums[i].real/(double)(NTOTAL);
    sums[i].imag = sums[i].imag/(double)(NTOTAL);
  }
}
########################rank 5#############################
static inline unsigned int yac_crc32(char *data, unsigned int size)  {
	if (size < YAC_FULL_CRC_THRESHOLD) {
		return crc32(data, size);
	} else {
		int i = 0;
		char crc_contents[YAC_FULL_CRC_THRESHOLD];
		int head = YAC_FULL_CRC_THRESHOLD >> 2;
		int tail = YAC_FULL_CRC_THRESHOLD >> 4;
		int body = YAC_FULL_CRC_THRESHOLD - head - tail;
		char *p = data + head;
		char *q = crc_contents + head;
		int step = (size - tail - head) / body;
		memcpy(crc_contents, data, head);
		for (; i < body; i++, q++, p+= step) {
			*q = *p;
		}
		memcpy(q, p, tail);
		return crc32(crc_contents, YAC_FULL_CRC_THRESHOLD);
	}
}
########################rank 6#############################
static void gen_crc24(FILE *fp)
{
    unsigned int crcs[256]={0};
    int i,j;
    for (i=0;i<256;i++) {
        crcs[i]=(unsigned int)i<<16;
        for (j=0;j<8;j++) if ((crcs[i]<<=1)&0x1000000) crcs[i]^=POLYCRC24Q;
    }
    fprintf(fp,"static const unsigned int tbl_CRC24Q[]={\n");
    for (i=0;i<32;i++) {
        fprintf(fp,"    ");
        for (j=0;j<8;j++) {
            fprintf(fp,"0x%06X%s",crcs[j+i*8],i==31&&j==7?"":",");
        }
        fprintf(fp,"\n");
    }
    fprintf(fp,"};\n");
}
########################rank 7#############################
int
inflate_packet_flush(s)
    inflate_blocks_statef *s;
{
	if (s->mode != LENS)
		return (Z_DATA_ERROR);
	s->mode = TYPE;
	return (Z_OK);
}
########################rank 8#############################
static
void
coap_merge_multi_option(uint8_t **dst, size_t *dst_len, uint8_t *option, size_t option_len, char separator)
{
  if (*dst_len > 0)
  {
    (*dst)[*dst_len] = separator;
    *dst_len += 1;
    memmove((*dst)+(*dst_len), option, option_len);
    *dst_len += option_len;
  }
  else
  {
    *dst = option;
    *dst_len = option_len;
  }
}
########################rank 9#############################
static
void
coap_merge_multi_option(uint8_t **dst, size_t *dst_len, uint8_t *option, size_t option_len, char separator)
{
  if (*dst_len > 0)
  {
    (*dst)[*dst_len] = separator;
    *dst_len += 1;
    memmove((*dst)+(*dst_len), option, option_len);
    *dst_len += option_len;
  }
  else
  {
    *dst = option;
    *dst_len = option_len;
  }
}
########################rank 10#############################
int
inflateSyncPoint(z)
z_streamp z;
{
	if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
		return (Z_STREAM_ERROR);
	return (inflate_blocks_sync_point(z->state->blocks));
}
----------------------------QUERY-------------------------------
remove trailing blanks, tabs and newlines
########################rank 1#############################
int removeComments_execute(unsigned char *input, long int input_len, unsigned char *changed) {
    long int i, j, incomment;
    changed[0] = '0';
    i = j = incomment = 0;
    while(i < input_len) {
        if (incomment == 0) {
            if ((input[i] == '/')&&(i + 1 < input_len)&&(input[i + 1] == '*')) {
                changed[0] = '1';
                incomment = 1;
                i += 2;
            } else if ((input[i] == '<')&&(i + 1 < input_len)&&(input[i + 1] == '!')&&
                    (i + 2 < input_len)&&(input[i+2] == '-')&&(i + 3 < input_len)&&
                    (input[i + 3] == '-') && (incomment == 0)) {
                incomment = 1;
                changed[0] = '1';
                i += 4;
            } else if ((input[i] == '-')&&(i + 1 < input_len)&&(input[i + 1] == '-')
                        && (incomment == 0)) {
                changed[0] = '1';
                input[i] = ' ';
                break;
            } else if (input[i] == '#' && (incomment == 0)) {
                changed[0] = '1';
                input[i] = ' ';
               break;
            } else {
                input[j] = input[i];
                i++;
                j++;
            }
        } else {
            if ((input[i] == '*')&&(i + 1 < input_len)&&(input[i + 1] == '/')) {
                incomment = 0;
                i += 2;
                input[j] = input[i];
                i++;
                j++;
            } else if ((input[i] == '-')&&(i + 1 < input_len)&&(input[i + 1] == '-')&&
                    (i + 2 < input_len)&&(input[i+2] == '>'))   {
                incomment = 0;
                i += 3;
                input[j] = input[i];
                i++;
                j++;
            } else {
                i++;
            }
        }
    }
    if (incomment) {
        input[j++] = ' ';
    }
    return j;
}
########################rank 2#############################
int sqlite3UnixDelete(const char *zFilename){
  unlink(zFilename);
  return SQLITE_OK;
}
########################rank 3#############################
void shellDeleteByte(Shell *shell, signed char direction)
{
    char offset = (direction == -1) ? 1 : 0;
    if ((shell->parser.cursor == 0 && direction == 1)
        || (shell->parser.cursor == shell->parser.length && direction == -1))
    {
        return;
    }
    if (shell->parser.cursor == shell->parser.length && direction == 1)
    {
        shell->parser.cursor--;
        shell->parser.length--;
        shell->parser.buffer[shell->parser.length] = 0;
        shellDeleteCommandLine(shell, 1);
    }
    else
    {
        for (short i = offset; i < shell->parser.length - shell->parser.cursor; i++)
        {
            shell->parser.buffer[shell->parser.cursor + i - 1] = 
                shell->parser.buffer[shell->parser.cursor + i];
        }
        shell->parser.length--;
        if (!offset)
        {
            shell->parser.cursor--;
            shellWriteByte(shell, '\b');
        }
        shell->parser.buffer[shell->parser.length] = 0;
        for (short i = shell->parser.cursor; i < shell->parser.length; i++)
        {
            shellWriteByte(shell, shell->parser.buffer[i]);
        }
        shellWriteByte(shell, ' ');
        for (short i = shell->parser.length - shell->parser.cursor + 1; i > 0; i--)
        {
            shellWriteByte(shell, '\b');
        }
    }
}
########################rank 4#############################
static void zlog_file_del(zlog_file_t * a_file)
{
	zc_debug("del onefile[%p]", a_file);
	zc_debug("a_file->path[%s]", a_file->path);
	free(a_file);
}
########################rank 5#############################
int
d_expunge(int f, int n)
{
	struct line	*lp, *nlp;
	char		 fname[NFILEN];
	for (lp = bfirstlp(curbp); lp != curbp->b_headp; lp = nlp) {
		nlp = lforw(lp);
		if (llength(lp) && lgetc(lp, 0) == 'D') {
			switch (d_makename(lp, fname, sizeof(fname))) {
			case ABORT:
				ewprintf("Bad line in dired buffer");
				return (FALSE);
			case FALSE:
				if (unlink(fname) < 0) {
					ewprintf("Could not delete '%s'",
					    basename(fname));
					return (FALSE);
				}
				break;
			case TRUE:
				if (rmdir(fname) < 0) {
					ewprintf("Could not delete directory '%s'",
					    basename(fname));
					return (FALSE);
				}
				break;
			}
			lfree(lp);
			curwp->w_bufp->b_lines--;
			curwp->w_flag |= WFFULL;
		}
	}
	return (TRUE);
}
########################rank 6#############################
void d_close_input(void)
{
   if (d_file) {
      fclose(d_file);
   }
   d_file = NULL;
   d_assign(d_filename, "");
}
########################rank 7#############################
int
d_del(int f, int n)
{
	if (n < 0)
		return (FALSE);
	while (n--) {
		if (llength(curwp->w_dotp) > 0)
			lputc(curwp->w_dotp, 0, 'D');
		if (lforw(curwp->w_dotp) != curbp->b_headp)
			curwp->w_dotp = lforw(curwp->w_dotp);
	}
	curwp->w_flag |= WFEDIT | WFMOVE;
	curwp->w_doto = 0;
	return (TRUE);
}
########################rank 8#############################
static void closefile_(file_t *file)
{
    tracet(3,"closefile_: path=%s\n",file->path);
    if (file->fp) fclose(file->fp);
    if (file->fp_tag) fclose(file->fp_tag);
    if (file->fp_tmp) fclose(file->fp_tmp);
    if (file->fp_tag_tmp) fclose(file->fp_tag_tmp);
    file->fp=file->fp_tag=file->fp_tmp=file->fp_tag_tmp=NULL;
}
########################rank 9#############################
void
_icv_close(_iconv_st *st)
{
	if (st == NULL)
		errno = EBADF;
	else
		free(st);
}
########################rank 10#############################
static void closefile(file_t *file)
{
    tracet(3,"closefile: fp=%d\n",file->fp);
    if (!file) return;
    closefile_(file);
    free(file);
}
----------------------------QUERY-------------------------------
search last occurrence of char in string
########################rank 1#############################
int strlen(char s[]) {
    int i = 0;
    while (s[i] != '\0') ++i;
    return i;
}
########################rank 2#############################
static int strlen30(const char *z){
  const char *z2 = z;
  while( *z2 ){ z2++; }
  return 0x3fffffff & (int)(z2 - z);
}
########################rank 3#############################
BINN_PRIVATE size_t strlen2(char *str) {
  if (str == NULL) return 0;
  return strlen(str);
}
########################rank 4#############################
extern int streq(const char *s1, const char *s2)
{
	while (*s1 != '\0' && *s2 != '\0') {
		if (*s1 != *s2) return 1;
		s1++; s2++;
	}
	if (*s1 != *s2) return 1;
	return 0;
}
########################rank 5#############################
int my_stricmp(const char *s1, const char *s2)
{
	char ch1 = 0;
	char ch2 = 0;
	while (true) {
		if ((*s1 == 0) && (*s2 == 0)) {
			return (0);
		}
		ch1 = toupper((unsigned char) *s1);
		ch2 = toupper((unsigned char) *s2);
		if (ch1 != ch2) {
			return ((int)(ch1 - ch2));
		}
		s1++;
		s2++;
	}
}
########################rank 6#############################
int concatCharRepeat(char* str, char c, int n)
{
	int i = strlen(str);
	int max = i + n;
	for (; i < max; ++i)
	{
		str[i] = c;
	}
	str[i] = '\0';
	return 1;
}
########################rank 7#############################
static void replace_char(char *string, char from, char to, int maxlen)
{
	char *lastchar = string + maxlen;
	while (string) {
		string = strchr(string, from);
		if (string) {
			*string = to;
			if (string >= lastchar)
				return;
		}
	}
}
########################rank 8#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 9#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 10#############################
size_t strspn(const char* str, const char* chrs) {
	size_t ret = 0;
	while (*str && strchr(chrs, *str++)) {
		ret++;
	}
	return ret;
}
----------------------------QUERY-------------------------------
binary search in sorted array of size
########################rank 1#############################
int64_t find_next(int **array, int64_t start, int64_t last, int value) {
  int64_t i;
  for (i = start; i < last; i++) {
    if (*(array[i]) == value) {
      break;
    }
  }
  return i;
}
########################rank 2#############################
size_t strnlen(const char *s, size_t count)
{
	const char *sc;
	for (sc = s; count-- && *sc != '\0'; ++sc)
	return sc - s;
}
########################rank 3#############################
int are_entry_offsets_valid(unsigned char *data, uint32_t size)
{
	int retval = 0;
	struct entry_info *first = NULL;
	first = next_entry(data, size);
	if(first)
	{
		if(first->offset == 0 && (first->size < first->name_ptr))
		{
			retval = 1;
		}
		free(first);
	}
	next_entry(NULL, 0);
	return retval;
}
########################rank 4#############################
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
########################rank 5#############################
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
########################rank 6#############################
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
########################rank 7#############################
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
########################rank 8#############################
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
########################rank 9#############################
long int local_array(int i)
{
    long int a[4] = {2L, 3L, 5L, 7l};
    int idx = i & 3;
    return a[idx];
}
########################rank 10#############################
static int
casort(struct kw *a, struct kw *b)
{
    if ( a->size != b->size )
	return a->size - b->size;
    return strncasecmp(a->id, b->id, b->size);
}
----------------------------QUERY-------------------------------
calculate checksum of checkpoint
########################rank 1#############################
static uint8_t
rtc_checksum(uint8_t *ptr)
{
    uint8_t sum;
    int i;
    sum = 0x00;
    for (i=MRTC_CONF_A; i<=MRTC_CONF_E; i++)
	sum += ptr[i];
    return(sum);
}
########################rank 2#############################
static void checksum(int i, dcomplex u1[NZ][NY][NX], int d[3]) {
    int j, q,r,s, ierr;
    dcomplex chk,allchk;
    chk.real = 0.0;
    chk.imag = 0.0;
#pragma omp for nowait
    for (j = 1; j <= 1024; j++) {
	q = j%NX+1;
	if (q >= xstart[0] && q <= xend[0]) {
            r = (3*j)%NY+1;
            if (r >= ystart[0] && r <= yend[0]) {
		s = (5*j)%NZ+1;
		if (s >= zstart[0] && s <= zend[0]) {
		  cadd(chk,chk,u1[s-zstart[0]][r-ystart[0]][q-xstart[0]]);
		}
	    }
	}
    }
#pragma omp critical
    {
	sums[i].real += chk.real;
	sums[i].imag += chk.imag;
    }
#pragma omp barrier
#pragma omp single
  {    
    sums[i].real = sums[i].real/(double)(NTOTAL);
    sums[i].imag = sums[i].imag/(double)(NTOTAL);
  }
}
########################rank 3#############################
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;
    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 
    return (unsigned short)(~cksum); 
}
########################rank 4#############################
static uint32_t do_checksum(void)
{
	uint32_t c = 0;
	size_t i = 0x400/4;
	while(i<(0x400+firmware_sz)/4)
		c += ((uint32_t*)buf)[i++];
	return c;
}
########################rank 5#############################
int
libnet_do_checksum(libnet_t *l, uint8_t *iphdr, int protocol, int h_len)
{
    uint16_t ip_len = 0;
    struct libnet_ipv4_hdr* ip4 = (struct libnet_ipv4_hdr *)iphdr;
    struct libnet_ipv6_hdr* ip6 = (struct libnet_ipv6_hdr *)iphdr;
    if(ip4->ip_v == 6) {
        ip_len = ntohs(ip6->ip_len);
    } else {
        ip_len = ntohs(ip4->ip_len);
    }
    return libnet_inet_checksum(l, iphdr, protocol, h_len,
            iphdr, iphdr + ip_len
            );
}
########################rank 6#############################
static inline unsigned int yac_crc32(char *data, unsigned int size)  {
	if (size < YAC_FULL_CRC_THRESHOLD) {
		return crc32(data, size);
	} else {
		int i = 0;
		char crc_contents[YAC_FULL_CRC_THRESHOLD];
		int head = YAC_FULL_CRC_THRESHOLD >> 2;
		int tail = YAC_FULL_CRC_THRESHOLD >> 4;
		int body = YAC_FULL_CRC_THRESHOLD - head - tail;
		char *p = data + head;
		char *q = crc_contents + head;
		int step = (size - tail - head) / body;
		memcpy(crc_contents, data, head);
		for (; i < body; i++, q++, p+= step) {
			*q = *p;
		}
		memcpy(q, p, tail);
		return crc32(crc_contents, YAC_FULL_CRC_THRESHOLD);
	}
}
########################rank 7#############################
uint32_t
libnet_compute_crc(uint8_t *buf, uint32_t len)
{
    uint32_t val;
    val = ~0;
    while (len--)
    {
        val = crc_table[(val ^ *buf) & 0xff] ^ (val >> 0x08);
        buf++;
    }
    return (~val);
}
########################rank 8#############################
static void gen_crc24(FILE *fp)
{
    unsigned int crcs[256]={0};
    int i,j;
    for (i=0;i<256;i++) {
        crcs[i]=(unsigned int)i<<16;
        for (j=0;j<8;j++) if ((crcs[i]<<=1)&0x1000000) crcs[i]^=POLYCRC24Q;
    }
    fprintf(fp,"static const unsigned int tbl_CRC24Q[]={\n");
    for (i=0;i<32;i++) {
        fprintf(fp,"    ");
        for (j=0;j<8;j++) {
            fprintf(fp,"0x%06X%s",crcs[j+i*8],i==31&&j==7?"":",");
        }
        fprintf(fp,"\n");
    }
    fprintf(fp,"};\n");
}
########################rank 9#############################
static cc_result Stream_Crc32Write(struct Stream* stream, const cc_uint8* data, cc_uint32 count, cc_uint32* modified) {
	struct Stream* source;
	cc_uint32 i, crc32 = stream->Meta.CRC32.CRC32;
	for (i = 0; i < count; i++) {
		crc32 = Utils_Crc32Table[(crc32 ^ data[i]) & 0xFF] ^ (crc32 >> 8);
	}
	stream->Meta.CRC32.CRC32 = crc32;
	source = stream->Meta.CRC32.Source;
	return source->Write(source, data, count, modified);
}
########################rank 10#############################
uint16_t cksum( char *b, int len ){
    uint16_t sum = 0;
    uint16_t t;
    char *e = b + len;
    b[len] = 0;
    while(b < e){
	t = (b[0] << 8) + b[1];
	sum += t;
	if(sum < t) sum++;
	b += 2;
    }
    return ~sum;
}
----------------------------QUERY-------------------------------
judge whether two strings are equal
########################rank 1#############################
extern int streq(const char *s1, const char *s2)
{
	while (*s1 != '\0' && *s2 != '\0') {
		if (*s1 != *s2) return 1;
		s1++; s2++;
	}
	if (*s1 != *s2) return 1;
	return 0;
}
########################rank 2#############################
int astreq(char str1[], char str2[], int len) {
    int k;
    k = 0;
    while (k < len) {
        if ((str1[k] != str2[k]))
            break;
        if (str1[k] == 0)
            break;
        if (str2[k] == 0)
            break;
        k++;
    }
    if (alphanumeric (str1[k]))
        return (0);
    if (alphanumeric (str2[k]))
        return (0);
    return (k);
}
########################rank 3#############################
int lj_ir_strcmp(GCstr *a, GCstr *b, IROp op)
{
  int res = lj_str_cmp(a, b);
  switch (op) {
  case IR_LT: return (res < 0);
  case IR_GE: return (res >= 0);
  case IR_LE: return (res <= 0);
  case IR_GT: return (res > 0);
  default: lua_assert(0); return 0;
  }
}
########################rank 4#############################
int lj_ir_strcmp(GCstr *a, GCstr *b, IROp op)
{
  int res = lj_str_cmp(a, b);
  switch (op) {
  case IR_LT: return (res < 0);
  case IR_GE: return (res >= 0);
  case IR_LE: return (res <= 0);
  case IR_GT: return (res > 0);
  default: lua_assert(0); return 0;
  }
}
########################rank 5#############################
int lj_ir_strcmp(GCstr *a, GCstr *b, IROp op)
{
  int res = lj_str_cmp(a, b);
  switch (op) {
  case IR_LT: return (res < 0);
  case IR_GE: return (res >= 0);
  case IR_LE: return (res <= 0);
  case IR_GT: return (res > 0);
  default: lua_assert(0); return 0;
  }
}
########################rank 6#############################
int lj_ir_strcmp(GCstr *a, GCstr *b, IROp op)
{
  int res = lj_str_cmp(a, b);
  switch (op) {
  case IR_LT: return (res < 0);
  case IR_GE: return (res >= 0);
  case IR_LE: return (res <= 0);
  case IR_GT: return (res > 0);
  default: lua_assert(0); return 0;
  }
}
########################rank 7#############################
int lj_ir_strcmp(GCstr *a, GCstr *b, IROp op)
{
  int res = lj_str_cmp(a, b);
  switch (op) {
  case IR_LT: return (res < 0);
  case IR_GE: return (res >= 0);
  case IR_LE: return (res <= 0);
  case IR_GT: return (res > 0);
  default: lua_assert(0); return 0;
  }
}
########################rank 8#############################
int lj_ir_strcmp(GCstr *a, GCstr *b, IROp op)
{
  int res = lj_str_cmp(a, b);
  switch (op) {
  case IR_LT: return (res < 0);
  case IR_GE: return (res >= 0);
  case IR_LE: return (res <= 0);
  case IR_GT: return (res > 0);
  default: lua_assert(0); return 0;
  }
}
########################rank 9#############################
unsigned char
strncasecmp(const char *s1, const char *s2, unsigned char n)
{
  unsigned char len;
  return strncmp(s1, s2, n);
}
########################rank 10#############################
unsigned char
strncasecmp(const char *s1, const char *s2, unsigned char n)
{
  unsigned char len;
  return strncmp(s1, s2, n);
}
----------------------------QUERY-------------------------------
return random integer value between min and max
########################rank 1#############################
static
float *vector(int nl, int nh)
{
  float *v;
  v=(float *)malloc((unsigned) (nh-nl+1)*sizeof(float));
  if (!v) fail("allocation failure in vector()");
  return v-nl;
}
########################rank 2#############################
void Normalize(vector_t * v)
{
    v->x /= v->w;
    v->y /= v->w;
    v->z /= v->w;
}
########################rank 3#############################
static int random_val(int min, int max)
{
    double weight = rand()/(double) RAND_MAX;
    int result = min * (1-weight) + max * weight;
    return result;
}
########################rank 4#############################
CGLM_EXPORT
void
glmc_vec3_mulv(vec3 a, vec3 b, vec3 d) {
  glm_vec3_mulv(a, b, d);
}
########################rank 5#############################
CGLM_EXPORT
void
glmc_vec4_mulv(vec4 a, vec4 b, vec4 d) {
  glm_vec4_mulv(a, b, d);
}
########################rank 6#############################
float vec3_len2(const union vec3 *v)
{
	return v->v.x * v->v.x + v->v.y * v->v.y + v->v.z * v->v.z;
}
########################rank 7#############################
int rand_between(int low, int high)
{
    return low + rand() / (RAND_MAX / (high - low + 1) + 1);
}
########################rank 8#############################
unsigned srl(unsigned x, int k) { 
    unsigned xsra = (int) x >> k; 
    return xsra; /* keeps gcc from complaining */
} 
int sra(int x, int k) { 
    int xsrl = (unsigned) x >> k; 
    return xsrl; /* keeps gcc from complaining */
}
########################rank 9#############################
real32_T norm(const real32_T x[3])
{
  real32_T y;
  real32_T scale;
  int32_T k;
  real32_T absxk;
  real32_T t;
  y = 0.0F;
  scale = 1.17549435E-38F;
  for (k = 0; k < 3; k++) {
    absxk = (real32_T)fabs(x[k]);
    if (absxk > scale) {
      t = scale / absxk;
      y = 1.0F + y * t * t;
      scale = absxk;
    } else {
      t = absxk / scale;
      y += t * t;
    }
  }
  return scale * (real32_T)sqrt(y);
}
########################rank 10#############################
void Matrix6_Tran(float a[6][6], float b[6][6])
{
    uint8_t i,j;
    for (i=0; i<6; i++)
    {
        for (j=0; j<6; j++)
        {
            b[i][j] = a[j][i];
        }
    }
}
