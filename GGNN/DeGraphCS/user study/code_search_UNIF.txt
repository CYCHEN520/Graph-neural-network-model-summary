----------------------------QUERY-------------------------------
write a byte to output buffer of device
########################rank 1#############################
bool mainOutputStreamCallback(pb_ostream_t *stream, const uint8_t *buf, size_t count)
{
	writeBytesToStream(buf, count);
	return true;
}
########################rank 2#############################
USHORT WriteBytes(const UBYTE *buf,
                  const USHORT len,
                  OutputFile *fp)
{
   return io_WriteBytes(buf, len, fp);
}
########################rank 3#############################
uint8_t u8g_WriteByteBWTo16GrDevice(u8g_t *u8g, u8g_dev_t *dev, uint8_t b)
{
  static uint8_t buf[4];
  static uint8_t map[4] = { 0, 0x00f, 0x0f0, 0x0ff };
  buf [3] = map[b & 3];
  b>>=2;
  buf [2] = map[b & 3];
  b>>=2;
  buf [1] = map[b & 3];
  b>>=2;
  buf [0] = map[b & 3];
  return dev->com_fn(u8g, U8G_COM_MSG_WRITE_SEQ, 4, buf);
}
########################rank 4#############################
static void io_write_0042() {
    io_write_004x(2);
}
########################rank 5#############################
static void io_write_0040() {
    io_write_004x(0);
}
########################rank 6#############################
static void io_write_0041() {
    io_write_004x(1);
}
########################rank 7#############################
ssize_t writen(int fd, const void *ptr, size_t n)
{
	size_t	nleft;
	ssize_t	nwritten;
	nleft = n;
	while (nleft > 0) {
		if ((nwritten = write(fd, ptr, nleft)) < 0) {
			if (nleft == n)
				return -1;
			else
				break;
		} else if (nwritten == 0) {
			break;
		}
		nleft	-= nwritten;
		ptr	+= nwritten;
	}
	return (n - nleft);
}
########################rank 8#############################
l_int32
bbufferBytesToWrite(BBUFFER  *bb,
                    size_t   *pnbytes)
{
    PROCNAME("bbufferBytesToWrite");
    if (!bb)
        return ERROR_INT("bb not defined", procName, 1);
    if (!pnbytes)
        return ERROR_INT("&nbytes not defined", procName, 1);
    *pnbytes = bb->n - bb->nwritten;
    return 0;
}
########################rank 9#############################
void writeInt4(char** pptr, int anInt)
{
  **pptr = (char)(anInt / 16777216);
  (*pptr)++;
  anInt %= 16777216;
  **pptr = (char)(anInt / 65536);
  (*pptr)++;
  anInt %= 65536;
	**pptr = (char)(anInt / 256);
	(*pptr)++;
	**pptr = (char)(anInt % 256);
	(*pptr)++;
}
########################rank 10#############################
static void io_write_00A1() {
    io_write_00x1(&vpic2);
}
----------------------------QUERY-------------------------------
insert a new value into list
########################rank 1#############################
static void
add_all(columns_t *columns, add_column_cb ac, const column_info_t *list,
		size_t len)
{
	size_t i;
	for(i = 0U; i < len; ++i)
	{
		ac(columns, list[i]);
	}
}
########################rank 2#############################
quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
                                            unsigned char *zl) {
    unsigned char *value;
    unsigned int sz;
    long long longval;
    char longstr[32] = {0};
    unsigned char *p = ziplistIndex(zl, 0);
    while (ziplistGet(p, &value, &sz, &longval)) {
        if (!value) {
            sz = ll2string(longstr, sizeof(longstr), longval);
            value = (unsigned char *)longstr;
        }
        quicklistPushTail(quicklist, value, sz);
        p = ziplistNext(zl, p);
    }
    zfree(zl);
    return quicklist;
}
########################rank 3#############################
ListElement* ListPrevElement(List* aList, ListElement** pos)
{
	return *pos = (*pos == NULL) ? aList->last : (*pos)->prev;
}
########################rank 4#############################
l_int32
listInsertBefore(DLLIST  **phead,
                 DLLIST   *elem,
                 void     *data)
{
DLLIST  *cell, *head;
    PROCNAME("listInsertBefore");
    if (!phead)
        return ERROR_INT("&head not defined", procName, 1);
    head = *phead;
    if (!data)
        return ERROR_INT("data not defined", procName, 1);
    if ((!head && elem) || (head && !elem))
        return ERROR_INT("head and elem not consistent", procName, 1);
    if ((cell = (DLLIST *)CALLOC(1, sizeof(DLLIST))) == NULL)
        return ERROR_INT("cell not made", procName, 1);
    cell->data = data;
    if (!head) {  /* start the list; initialize the ptrs */
        cell->prev = NULL;
        cell->next = NULL;
        *phead = cell;
    }
    else if (head == elem) {  /* insert before head of list */
        cell->prev = NULL;
        cell->next = head;
        head->prev = cell;
        *phead = cell;
    }
    else  {   /* insert before elem and after head of list */
        cell->prev = elem->prev;
        cell->next = elem;
        elem->prev->next = cell;
        elem->prev = cell;
    }
    return 0;
}
########################rank 5#############################
void InsertNodeBeforeElement(Node *element, Node *node)
{
    Node *parent;
    parent = element->parent;
    node->parent = parent;
    node->next = element;
    node->prev = element->prev;
    element->prev = node;
    if (node->prev)
        node->prev->next = node;
    if (parent->content == element)
        parent->content = node;
}
########################rank 6#############################
l_int32
listInsertAfter(DLLIST  **phead,
                DLLIST   *elem,
                void     *data)
{
DLLIST  *cell, *head;
    PROCNAME("listInsertAfter");
    if (!phead)
        return ERROR_INT("&head not defined", procName, 1);
    head = *phead;
    if (!data)
        return ERROR_INT("data not defined", procName, 1);
    if ((!head && elem) || (head && !elem))
        return ERROR_INT("head and elem not consistent", procName, 1);
    if ((cell = (DLLIST *)CALLOC(1, sizeof(DLLIST))) == NULL)
        return ERROR_INT("cell not made", procName, 1);
    cell->data = data;
    if (!head) {  /* start the list; initialize the ptrs */
        cell->prev = NULL;
        cell->next = NULL;
        *phead = cell;
    }
    else if (elem->next == NULL) {  /* insert after last */
        cell->prev = elem;
        cell->next = NULL;
        elem->next = cell;
    }
    else  {  /* insert after elem and before the end */
        cell->prev = elem;
        cell->next = elem->next;
        elem->next->prev = cell;
        elem->next = cell;
    }
    return 0;
}
########################rank 7#############################
list_ptr new_ele(int val) {
    list_ptr ls = (list_ptr) malloc(sizeof(list_ele));
    ls->val = val;
    return ls;
}
########################rank 8#############################
list_ptr new_ele(int val) {
    list_ptr ls = (list_ptr) malloc(sizeof(list_ele));
    ls->val = val;
    return ls;
}
########################rank 9#############################
void insert(int data) {
    struct ListNode* newNode = (struct ListNode*) malloc(sizeof(struct ListNode));
    newNode->data  = data;
    newNode->next = head;
    head = newNode;
    printf("Inserted Element : %d\n", data);
}
########################rank 10#############################
void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
volatile xListItem * pxIndex;
	pxIndex = pxList->pxIndex;
	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pvContainer = ( void * ) pxList;
	( pxList->uxNumberOfItems )++;
}
----------------------------QUERY-------------------------------
check string is suffix of another string
########################rank 1#############################
int
str_prefix(char *prefix, char *str)
{
	return (!strncmp(prefix, str, strlen(prefix)));
}
########################rank 2#############################
int strlen(char s[]) {
    int i = 0;
    while (s[i] != '\0') ++i;
    return i;
}
########################rank 3#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 4#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 5#############################
char *homogenize(char *str)
{
    char *ans;
    char *fr;
    char *to;
    int ch;
    to = fr = ans = strdup(str);
    while ((ch = *fr++) != '\0')
    {
	if (isalnum(ch))
	{
	    *to++ = tolower(ch);
	}
    }
    *to = '\0';
    return ans;
}
########################rank 6#############################
char* strchr(const char* str, int c) {
	while (*str) {
		if (*str == c) {
			return (char*) str;
		}
		++str;
	}
	return NULL;
}
########################rank 7#############################
static void skip_quotes(const char **string) {
    SKIP_CHAR(string);
    while (**string != '\"') {
        if (**string == '\0')
            return;
        if (**string == '\\') {
            SKIP_CHAR(string);
            if (**string == '\0')
                return;
        }
        SKIP_CHAR(string);
    }
    SKIP_CHAR(string);
}
########################rank 8#############################
char *
strrchr(const char *s, int c)
{
	char *r = NULL;
	if( c != '\0') {
		while (*s != '\0') {
			if (*s++ == c)
				r = (char *)s - 1;
		}
	} else {
		r = (char *)s + strlen(s);
	}
	return r;
}
########################rank 9#############################
char* strcbrk(char* str, char c)
{
	char* p;
	for(p = str; *p && *p != c; p++)
		;
	return p;
}
########################rank 10#############################
unsigned char * _mbschr(const unsigned char *str, unsigned int c)
{
  return (unsigned char *)strchr((const char*)str, c);
}
----------------------------QUERY-------------------------------
remove all elements in list
########################rank 1#############################
void pvl_clear(pvl_list l)
{
    pvl_elem e = pvl_head(l);
    pvl_elem next;
    if (e == 0) {
        return;
    }
    while (e != 0) {
        next = pvl_next(e);
        (void)pvl_remove(l, e);
        e = next;
    }
}
########################rank 2#############################
int list_remove_item_at(List_t * list, int idx, list_item_remove_callback_func cb){
	ListItem_t * nextItem, * lastItem;
	if(!list->head) return(1);
	if(idx == 0 && !list->head->next) return list_remove_item_head(list, cb);
	nextItem = list->head;
	lastItem = NULL;
	// Move to index
	while(idx-1 > 0){
		// Index does not exist
		if(!nextItem->next){
			return(0);
		}else{
			// Move to next Item
			lastItem = nextItem;
			nextItem = nextItem->next;
		}
		idx--;
	}
	// Last Item
	if(!nextItem->next){
		free(nextItem);
		return(1);
	}else{ // Middle Item
		// Connect item before and after index
		lastItem->next = nextItem->next;
		// Free unconnected item index
		free(nextItem);
		return(1);
	}
}
########################rank 3#############################
void yac_storage_free_list(yac_item_list *list)  {
	yac_item_list *l;
	while (list) {
		l = list;
		list = list->next;
		USER_FREE(l);
	}
}
########################rank 4#############################
int list_remove(List_t * list, list_item_remove_callback_func cb){
	// Loop through entire list removing each item
	while(1){
		if( list_remove_item_head(list, cb) ){
			if(!list->head){
				break;
			}
		}else{
			return(0);
		}
	}
	return(1);
}
########################rank 5#############################
void list_remove(list_t list, void *item)
{
	struct list *l, *r;
	if (*list == NULL) {
		return;
	}
	r = NULL;
	for (l = *list; l != NULL; l = l->next) {
		if (l == item) {
			if (r == NULL) {
				*list = l->next;
			} else {
				r->next = l->next;
			}
			l->next = NULL;
			return;
		}
		r = l;
	}
}
########################rank 6#############################
alpm_list_t SYMEXPORT *alpm_list_remove_item(alpm_list_t *haystack,
		alpm_list_t *item)
{
	if(haystack == NULL || item == NULL) {
		return haystack;
	}
	if(item == haystack) {
		 * the tail node */
		haystack = item->next;
		if(haystack) {
			haystack->prev = item->prev;
		}
		item->prev = NULL;
	} else if(item == haystack->prev) {
		 * reference on the head node. We also know tail != head. */
		if(item->prev) {
			item->prev->next = item->next;
			haystack->prev = item->prev;
			item->prev = NULL;
		}
	} else {
		if(item->next) {
			item->next->prev = item->prev;
		}
		if(item->prev) {
			item->prev->next = item->next;
		}
	}
	return haystack;
}
########################rank 7#############################
void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
	pxList = ( xList * ) pxItemToRemove->pvContainer;
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}
	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
}
########################rank 8#############################
void *
listRemoveFromHead(DLLIST  **phead)
{
DLLIST  *head;
void    *data;
    PROCNAME("listRemoveFromHead");
    if (!phead)
        return (void *)ERROR_PTR("&head not defined", procName, NULL);
    if ((head = *phead) == NULL)
        return (void *)ERROR_PTR("head not defined", procName, NULL);
    if (head->next == NULL)  /* only one */
        *phead = NULL;
    else {
        head->next->prev = NULL;
        *phead = head->next;
    }
    data = head->data;
    FREE(head);
    return data;
}
########################rank 9#############################
void *
listRemoveElement(DLLIST  **phead,
                  DLLIST   *elem)
{
void    *data;
DLLIST  *head;
    PROCNAME("listRemoveElement");
    if (!phead)
        return (void *)ERROR_PTR("&head not defined", procName, NULL);
    head = *phead;
    if (!head)
        return (void *)ERROR_PTR("head not defined", procName, NULL);
    if (!elem)
        return (void *)ERROR_PTR("elem not defined", procName, NULL);
    data = elem->data;
    if (head->next == NULL) {  /* only one */
        if (elem != head)
            return (void *)ERROR_PTR("elem must be head", procName, NULL);
        *phead = NULL;
    }
    else if (head == elem) {   /* first one */
        elem->next->prev = NULL;
        *phead = elem->next;
    }
    else if (elem->next == NULL) {   /* last one */
        elem->prev->next = NULL;
    }
    else {  /* neither the first nor the last one */
        elem->next->prev = elem->prev;
        elem->prev->next = elem->next;
    }
    FREE(elem);
    return data;
}
########################rank 10#############################
static void
todo_remove_at(struct RangeList *task, unsigned index)
{
    memmove(&task->list[index],
            &task->list[index+1],
            (task->count - index) * sizeof(task->list[index])
            );
    task->count--;
}
----------------------------QUERY-------------------------------
stop logging messages to syslog
########################rank 1#############################
int OS_CloseRead(int fd)
{
    if(asyncIoTable[AIO_RD_IX(fd)].inUse != 0) {
        asyncIoTable[AIO_RD_IX(fd)].inUse = 0;
        FD_CLR(fd, &readFdSet);
    }
    return shutdown(fd, 0);
}
########################rank 2#############################
int rozolauncher_stop(char * pid_file, int timer) {
  struct timespec ts;
  if (rozolauncher_send_signal(pid_file,SIGTERM) < 0) {
    return -1;
  }  
  while (timer) {
    ** pid file has been removed
    */      
    if (access(pid_file,R_OK)!=0) return 0;
    ** pid file not yet removed. 
    ** Let's wait...
    */
    timer--;
    ts.tv_sec  = 0;
    ts.tv_nsec = 1000000;
    nanosleep(&ts,NULL);      
  }  
#ifdef LAUNCHER_TRACE
  info("File %s not yet removed !!!",pid_file);
#endif   
  return 0;
}
########################rank 3#############################
void
restart_inactivity_timer(uint32_t timeout)
{
    struct timeval now;
    if (g_this_event.ssn == NULL  ||  g_this_event.ssn->ssn_is_valid != TRUE)   return;
    gettimeofday(&now, NULL);
    timeval_add_ms(&now, timeout);
    CANCEL(g_this_event.ssn->ssn_InactivityTimer);
    g_this_event.ssn->ssn_InactivityTimer = event_add(&now, state_inactivity_timeout, g_this_event.ssn);
}
########################rank 4#############################
l_float32
stopWallTimer(L_WALLTIMER  **ptimer)
{
l_int32       tsec, tusec;
L_WALLTIMER  *timer;
    PROCNAME("stopWallTimer");
    if (!ptimer)
        return (l_float32)ERROR_FLOAT("&timer not defined", procName, 0.0);
    timer = *ptimer;
    if (!timer)
        return (l_float32)ERROR_FLOAT("timer not defined", procName, 0.0);
    l_getCurrentTime(&timer->stop_sec, &timer->stop_usec);
    tsec = timer->stop_sec - timer->start_sec;
    tusec = timer->stop_usec - timer->start_usec;
    LEPT_FREE(timer);
    *ptimer = NULL;
    return (tsec + ((l_float32)tusec) / 1000000.0);
}
########################rank 5#############################
void FS_FCloseFile(fileHandle_t f)
{
  fsHandle_t *handle;
  handle = FS_GetFileByHandle(f);
  if (handle->file) {
    fclose(handle->file);
  }
  memset(handle, 0, sizeof(*handle));
}
########################rank 6#############################
static void dill_timer_cancel(struct dill_clause *cl) {
    struct dill_ctx_cr *ctx = &dill_getctx->cr;
    struct dill_tmclause *tmcl = dill_cont(cl, struct dill_tmclause, cl);
    dill_rbtree_erase(&ctx->timers, &tmcl->item);
    tmcl->cl.cr = NULL;
}
########################rank 7#############################
void
zed_log_syslog_close(void)
{
	if (_ctx.do_syslog) {
		_ctx.do_syslog = 0;
		closelog();
	}
}
########################rank 8#############################
int
d_shell_command(int f, int n)
{
#ifdef MONA
  ewprintf("shell command is not supported");
  return (FALSE);
#else
	char	 command[512], fname[MAXPATHLEN], buf[BUFSIZ], *bufp, *cp;
	int	 infd, fds[2];
	pid_t	 pid;
	struct	 sigaction olda, newa;
	struct buffer	*bp;
	struct mgwin	*wp;
	FILE	*fin;
	bp = bfind("*Shell Command Output*", TRUE);
	if (bclear(bp) != TRUE)
		return (ABORT);
	if (d_makename(curwp->w_dotp, fname, sizeof(fname)) != FALSE) {
		ewprintf("bad line");
		return (ABORT);
	}
	command[0] = '\0';
	if ((bufp = eread("! on %s: ", command, sizeof(command), EFNEW,
	    basename(fname))) == NULL)
		return (ABORT);
	infd = open(fname, O_RDONLY);
	if (infd == -1) {
		ewprintf("Can't open input file : %s", strerror(errno));
		return (FALSE);
	}
	if (pipe(fds) == -1) {
		ewprintf("Can't create pipe : %s", strerror(errno));
		close(infd);
		return (FALSE);
	}
	newa.sa_handler = reaper;
	newa.sa_flags = 0;
	if (sigaction(SIGCHLD, &newa, &olda) == -1) {
		close(infd);
		close(fds[0]);
		close(fds[1]);
		return (ABORT);
	}
	pid = fork();
	switch (pid) {
	case -1:
		ewprintf("Can't fork");
		return (ABORT);
	case 0:
		close(fds[0]);
		dup2(infd, STDIN_FILENO);
		dup2(fds[1], STDOUT_FILENO);
		dup2(fds[1], STDERR_FILENO);
		execl("/bin/sh", "sh", "-c", bufp, (char *)NULL);
		exit(1);
		break;
	default:
		close(infd);
		close(fds[1]);
		fin = fdopen(fds[0], "r");
		if (fin == NULL)	
			panic("can't happen");
		while (fgets(buf, sizeof(buf), fin) != NULL) {
			cp = strrchr(buf, '\n');
			if (cp == NULL && !feof(fin)) {	/* too long a line */
				int c;
				addlinef(bp, "%s...", buf);
				while ((c = getc(fin)) != EOF && c != '\n')
					;
				continue;
			} else if (cp)
				*cp = '\0';
			addline(bp, buf);
		}
		fclose(fin);
		close(fds[0]);
		break;
	}
	wp = popbuf(bp);
	if (wp == NULL)
		return (ABORT);	/* XXX - free the buffer?? */
	curwp = wp;
	curbp = wp->w_bufp;
	if (sigaction(SIGCHLD, &olda, NULL) == -1)
		ewprintf("Warning, couldn't reset previous signal handler");
	return (TRUE);
#endif
}
########################rank 9#############################
void CL_StopVideo_f( void )
{
  CL_CloseAVI( );
}
########################rank 10#############################
static void OPLSetTimerHandler(FM_OPL *OPL,OPL_TIMERHANDLER timer_handler,void *param)
{
	OPL->timer_handler   = timer_handler;
	OPL->TimerParam = param;
}
----------------------------QUERY-------------------------------
render bignum into decimal
########################rank 1#############################
static void mp_mul_add_simple(mp_int *r, mp_int *a, mp_int *b)
{
    BignumInt *aend = a->w + a->nw, *bend = b->w + b->nw, *rend = r->w + r->nw;
    for (BignumInt *ap = a->w, *rp = r->w;
         ap < aend && rp < rend; ap++, rp++) {
        BignumInt adata = *ap, carry = 0, *rq = rp;
        for (BignumInt *bp = b->w; bp < bend && rq < rend; bp++, rq++) {
            BignumInt bdata = bp < bend ? *bp : 0;
            BignumMULADD2(carry, *rq, adata, bdata, *rq, carry);
        }
        for (; rq < rend; rq++)
            BignumADC(*rq, carry, carry, *rq, 0);
    }
}
########################rank 2#############################
int32_t mpz_cmp_si(mpz_ptr a, int32_t s)
{
	mpz_t mpz;
	u_int32_t u = (s > 0) ? s : -s;
	u32tompz(t,u,l);
	u32pack(mpz,t,l);
	mpz->s = s < 0;
	return mpz_cmp(a, mpz);
}
########################rank 3#############################
int mpz_neg(mpz_ptr d, mpz_ptr s)
{
	int err;
	if ((d != s) && ((err = mpz_set(d, s)) != SBN_OK))
		return err;
	_mpz_neg(d);
	return SBN_OK;
}
########################rank 4#############################
int mpz_abs(mpz_ptr d, mpz_ptr s)
{
	int err;
	if ((d != s) && ((err = mpz_set(d, s)) != SBN_OK))
		return err;
	_mpz_abs(d);
	return SBN_OK;
}
########################rank 5#############################
int mpz_gcd(mpz_ptr g, mpz_ptr a, mpz_ptr b)
{
	int err;
	if (_mpz_iszero(a)) {
		if ((err = mpz_set(g, b)) != SBN_OK)
			return err;
		_mpz_abs(g);
		return SBN_OK;
	}
	if (_mpz_iszero(b)) {
		if ((err = mpz_set(g, a)) != SBN_OK)
			return err;
		_mpz_abs(g);
		return SBN_OK;
	}
	return mpz_gcd_raw(g, a, b->d, b->l);
}
########################rank 6#############################
int32_t mpz_cmpabs(mpz_ptr a, mpz_ptr b)
{
	int32_t i;
	if (a->l > b->l) return 1;
	if (a->l < b->l) return -1;
	i = a->l;
	while(i--) {
		if (a->d[i] > b->d[i]) return 1;
		if (a->d[i] < b->d[i]) return -1;
	}
	return 0;
}
########################rank 7#############################
int mpz_fac_ui(mpz_ptr r, u_int32_t i)
{
	u_int32_t j;
	int err;
	if (!i) {
		mpz_setzero(r);
		return SBN_OK;
	}
	if ((err = mpz_set_ui(r, 1)) != SBN_OK)
		return err;
	for (j = 2; j <= i; j++)
		if ((err = mpz_mul_ui(r, r, j)) != SBN_OK)
			return err;
	return SBN_OK;
}
########################rank 8#############################
int mpz_setzero(mpz_ptr z)
{
	z->s = 0;
	return mpz_zero_realloc(z, 0);
}
########################rank 9#############################
typedef bitstr_t exp_t;
exp_t base_order;
void point_mult(elem_t x, elem_t y, const exp_t exp)
{
  elem_t X, Y;
  int i;
  point_set_zero(X, Y);
  for(i = bitstr_sizeinbits(exp) - 1; i >= 0; i--) {
    point_double(X, Y);
    if (bitstr_getbit(exp, i))
      point_add(X, Y, x, y);
  }
  point_copy(x, y, X, Y);
}
########################rank 10#############################
mp_err mp_sub_d(const mp_int *a, mp_digit b, mp_int *c)
{
   mp_digit *tmpa, *tmpc;
   mp_err    err;
   int       ix, oldused;
   if (c->alloc < (a->used + 1)) {
      if ((err = mp_grow(c, a->used + 1)) != MP_OKAY) {
         return err;
      }
   }
    * addition [with fudged signs]
    */
   if (a->sign == MP_NEG) {
      mp_int a_ = *a;
      a_.sign = MP_ZPOS;
      err     = mp_add_d(&a_, b, c);
      c->sign = MP_NEG;
      mp_clamp(c);
      return err;
   }
   oldused = c->used;
   tmpa    = a->dp;
   tmpc    = c->dp;
   if (((a->used == 1) && (a->dp[0] <= b)) || (a->used == 0)) {
      if (a->used == 1) {
         *tmpc++ = b - *tmpa;
      } else {
         *tmpc++ = b;
      }
      ix      = 1;
      c->sign = MP_NEG;
      c->used = 1;
   } else {
      mp_digit mu = b;
      c->sign = MP_ZPOS;
      c->used = a->used;
      for (ix = 0; ix < a->used; ix++) {
         *tmpc    = *tmpa++ - mu;
         mu       = *tmpc >> (MP_SIZEOF_BITS(mp_digit) - 1u);
         *tmpc++ &= MP_MASK;
      }
   }
   MP_ZERO_DIGITS(tmpc, oldused - ix);
   mp_clamp(c);
   return MP_OKAY;
}
----------------------------QUERY-------------------------------
look for match name in system dictionary
########################rank 1#############################
int iniparser_find_entry(
    dictionary  *   ini,
    const char  *   entry
)
{
    int found=0 ;
    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {
        found = 1 ;
    }
    return found ;
}
########################rank 2#############################
int iniparser_find_entry(const dictionary * ini, const char * entry)
{
    int found=0 ;
    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {
        found = 1 ;
    }
    return found ;
}
########################rank 3#############################
int iniparser_find_entry(
    dictionary  *   ini,
    const char  *   entry
)
{
    int found=0 ;
    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {
        found = 1 ;
    }
    return found ;
}
########################rank 4#############################
cell_t ffFindC( const char *WordName, ExecToken *pXT )
{
DBUG(("ffFindC: %s\n", WordName ));
    CStringToForth( gScratch, WordName, sizeof(gScratch) );
    return ffFind( gScratch, pXT );
}
########################rank 5#############################
int iniparser_getsecnkeys(dictionary * d, char * s)
{
    int     seclen, nkeys ;
    char    keym[ASCIILINESZ+1];
    int j ;
    nkeys = 0;
    if (d==NULL) return nkeys;
    if (! iniparser_find_entry(d, s)) return nkeys;
    seclen  = (int)strlen(s);
    snprintf(keym, ASCIILINESZ, "%s:", s);
    for (j=0 ; j<d->size ; j++) {
        if (d->key[j]==NULL)
            continue ;
        if (!strncmp(d->key[j], keym, seclen+1))
            nkeys++;
    }
    return nkeys;
}
########################rank 6#############################
static
int by_name(const void *a, const void *b)
{
	return strcmp(SYM(a)->name, SYM(b)->name);
}
########################rank 7#############################
cell_t ffTokenToName( ExecToken XT, const ForthString **NFAPtr )
{
    const ForthString *NameField;
    cell_t Searching = TRUE;
    cell_t Result = 0;
    ExecToken TempXT;
    NameField = (ForthString *) gVarContext;
DBUGX(("\ffCodeToName: gVarContext = 0x%x\n", gVarContext));
    do
    {
        TempXT = NameToToken( NameField );
        if( TempXT == XT )
        {
DBUGX(("ffCodeToName: NFA = 0x%x\n", NameField));
            *NFAPtr = NameField ;
            Result = 1;
            Searching = FALSE;
        }
        else
        {
            NameField = NameToPrevious( NameField );
            if( NameField == NULL )
            {
                *NFAPtr = 0;
                Searching = FALSE;
            }
        }
    } while ( Searching);
    return Result;
}
########################rank 8#############################
int iniparser_getsecnkeys(const dictionary * d, const char * s)
{
    int     seclen, nkeys ;
    char    keym[ASCIILINESZ+1];
    int j ;
    nkeys = 0;
    if (d==NULL) return nkeys;
    if (! iniparser_find_entry(d, s)) return nkeys;
    seclen  = (int)strlen(s);
    strlwc(s, keym, sizeof(keym));
    keym[seclen] = ':';
    for (j=0 ; j<d->size ; j++) {
        if (d->key[j]==NULL)
            continue ;
        if (!strncmp(d->key[j], keym, seclen+1))
            nkeys++;
    }
    return nkeys;
}
########################rank 9#############################
int iniparser_getsecnkeys(dictionary * d, char * s)
{
    int     seclen, nkeys ;
    char    keym[ASCIILINESZ+1];
    int j ;
    nkeys = 0;
    if (d==NULL) return nkeys;
    if (! iniparser_find_entry(d, s)) return nkeys;
    seclen  = (int)strlen(s);
    sprintf(keym, "%s:", s);
    for (j=0 ; j<d->size ; j++) {
        if (d->key[j]==NULL)
            continue ;
        if (!strncmp(d->key[j], keym, seclen+1)) 
            nkeys++;
    }
    return nkeys;
}
########################rank 10#############################
char *getParam(struct uriparams *params, char *name)
{
	int32_t i;
	for(i = (*params).paramcount - 1; i >= 0; --i)
	{
		if(strcmp((*params).params[i], name) == 0) { return (*params).values[i]; }
	}
	return "";
}
----------------------------QUERY-------------------------------
remove an element from a row vector
########################rank 1#############################
void
sm_row_remove(prow, col)
register sm_row *prow;
register int col;
{
    register sm_element *p;
    for(p = prow->first_col; p != 0 && p->col_num < col; p = p->next_col)
	;
    if (p != 0 && p->col_num == col) {
	dll_unlink(p, prow->first_col, prow->last_col, 
			    next_col, prev_col, prow->length);
	sm_element_free(p);
    }
}
########################rank 2#############################
void setmgr_vacuum(hlld_setmgr *mgr) {
    unsigned long long vsn = mgr->vsn;
    merge_old_versions(mgr, mgr->delta, vsn);
    swap_set_maps(mgr, vsn);
    merge_old_versions(mgr, mgr->delta, vsn);
    delete_old_versions(mgr, vsn);
}
########################rank 3#############################
void list_remove(list_t list, void *item)
{
	struct list *l, *r;
	if (*list == NULL) {
		return;
	}
	r = NULL;
	for (l = *list; l != NULL; l = l->next) {
		if (l == item) {
			if (r == NULL) {
				*list = l->next;
			} else {
				r->next = l->next;
			}
			l->next = NULL;
			return;
		}
		r = l;
	}
}
########################rank 4#############################
alpm_list_t SYMEXPORT *alpm_list_remove_item(alpm_list_t *haystack,
		alpm_list_t *item)
{
	if(haystack == NULL || item == NULL) {
		return haystack;
	}
	if(item == haystack) {
		 * the tail node */
		haystack = item->next;
		if(haystack) {
			haystack->prev = item->prev;
		}
		item->prev = NULL;
	} else if(item == haystack->prev) {
		 * reference on the head node. We also know tail != head. */
		if(item->prev) {
			item->prev->next = item->next;
			haystack->prev = item->prev;
			item->prev = NULL;
		}
	} else {
		if(item->next) {
			item->next->prev = item->prev;
		}
		if(item->prev) {
			item->prev->next = item->next;
		}
	}
	return haystack;
}
########################rank 5#############################
alpm_list_t SYMEXPORT *alpm_list_diff(const alpm_list_t *lhs,
		const alpm_list_t *rhs, alpm_list_fn_cmp fn)
{
	alpm_list_t *left, *right;
	alpm_list_t *ret = NULL;
	left = alpm_list_copy(lhs);
	left = alpm_list_msort(left, alpm_list_count(left), fn);
	right = alpm_list_copy(rhs);
	right = alpm_list_msort(right, alpm_list_count(right), fn);
	alpm_list_diff_sorted(left, right, fn, &ret, NULL);
	alpm_list_free(left);
	alpm_list_free(right);
	return ret;
}
########################rank 6#############################
static int list_drop_elem(list_t *simclist_restrict l, struct list_entry_s *tmp, unsigned int pos) {
    if (tmp == NULL) return -1;
    if (l->numels % 2) {    /* now odd */
        if (l->numels == 1) l->mid = NULL;
        else if (pos >= l->numels/2) l->mid = l->mid->prev;
    } else {                /* now even */
        if (pos < l->numels/2) l->mid = l->mid->next;
    }
    tmp->prev->next = tmp->next;
    tmp->next->prev = tmp->prev;
    if (l->attrs.copy_data && tmp->data != NULL)
        free(tmp->data);
    if (l->spareels != NULL && l->spareelsnum < SIMCLIST_MAX_SPARE_ELEMS) {
        l->spareels[l->spareelsnum++] = tmp;
    } else {
        free(tmp);
    }
    return 0;
}
########################rank 7#############################
int length(cell n) {
	int	k;
	for (k = 0; n != NIL; n = cdr(n))
		k++;
	return k;
}
########################rank 8#############################
char *
stringReplaceEachSubstr(const char  *src,
                        const char  *sub1,
                        const char  *sub2,
                        l_int32     *pcount)
{
char    *currstr, *newstr;
l_int32  loc;
    PROCNAME("stringReplaceEachSubstr");
    if (!src)
        return (char *)ERROR_PTR("src not defined", procName, NULL);
    if (!sub1)
        return (char *)ERROR_PTR("sub1 not defined", procName, NULL);
    if (!sub2)
        return (char *)ERROR_PTR("sub2 not defined", procName, NULL);
    if (pcount)
        *pcount = 0;
    loc = 0;
    if ((newstr = stringReplaceSubstr(src, sub1, sub2, NULL, &loc)) == NULL)
        return NULL;
    if (pcount)
        (*pcount)++;
    while (1) {
        currstr = newstr;
        newstr = stringReplaceSubstr(currstr, sub1, sub2, NULL, &loc);
        if (!newstr)
            return currstr;
        FREE(currstr);
        if (pcount)
            (*pcount)++;
    }
}
########################rank 9#############################
static
void  translate_array( FT_UInt n,
					   FT_Vector*  coords,
					   FT_Pos delta_x,
					   FT_Pos delta_y ) {
	FT_UInt k;
	if ( delta_x ) {
		for ( k = 0; k < n; k++ )
			coords[k].x += delta_x;
	}
	if ( delta_y ) {
		for ( k = 0; k < n; k++ )
			coords[k].y += delta_y;
	}
}
########################rank 10#############################
SQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid){
  assert( p!=0 );
  assert( p->pForest==0 );  /* Cannot be used with sqlite3RowSetText() */
  if( (p->rsFlags & ROWSET_NEXT)==0 ){  /*OPTIMIZATION-IF-FALSE*/
    if( (p->rsFlags & ROWSET_SORTED)==0 ){  /*OPTIMIZATION-IF-FALSE*/
      p->pEntry = rowSetEntrySort(p->pEntry);
    }
    p->rsFlags |= ROWSET_SORTED|ROWSET_NEXT;
  }
  if( p->pEntry ){
    *pRowid = p->pEntry->v;
    p->pEntry = p->pEntry->pRight;
    if( p->pEntry==0 ){ /*OPTIMIZATION-IF-TRUE*/
      sqlite3RowSetClear(p);
    }
    return 1;
  }else{
    return 0;
  }
}
----------------------------QUERY-------------------------------
load a bignum from int
########################rank 1#############################
void bignum_fromint(bignum* b, unsigned int num) {
	b->length = 1;
	if(b->capacity < b->length) {
		b->capacity = b->length;
		b->data = realloc(b->data, b->capacity * sizeof(word));
	}
	b->data[0] = num;
}
########################rank 2#############################
int mpz_setzero(mpz_ptr z)
{
	z->s = 0;
	return mpz_zero_realloc(z, 0);
}
########################rank 3#############################
int mpz_gcd(mpz_ptr g, mpz_ptr a, mpz_ptr b)
{
	int err;
	if (_mpz_iszero(a)) {
		if ((err = mpz_set(g, b)) != SBN_OK)
			return err;
		_mpz_abs(g);
		return SBN_OK;
	}
	if (_mpz_iszero(b)) {
		if ((err = mpz_set(g, a)) != SBN_OK)
			return err;
		_mpz_abs(g);
		return SBN_OK;
	}
	return mpz_gcd_raw(g, a, b->d, b->l);
}
########################rank 4#############################
int mpz_neg(mpz_ptr d, mpz_ptr s)
{
	int err;
	if ((d != s) && ((err = mpz_set(d, s)) != SBN_OK))
		return err;
	_mpz_neg(d);
	return SBN_OK;
}
########################rank 5#############################
int read_int4_array(int f, int *iarray, int n)
{
#ifdef _CRAY
    int j, nread;
    int *buffer;
    buffer = (int *)G_malloc((n + 1) * 4);
    if (!buffer)
	return 0;
    nread = read(f, buffer, 4 * n);
    if (nread <= 0) {
	return 0;
    }
    nread /= 4;
    for (j = 0; j < nread; j++) {
	if ((j & 1) == 0) {
	    iarray[j] = buffer[j / 2] >> 32;
	}
	else {
	    iarray[j] = buffer[j / 2] & 0xffffffff;
	}
    }
    G_free(buffer);
    return nread;
#else
    int nread = read(f, iarray, 4 * n);
    if (nread <= 0)
	return 0;
#  ifdef LITTLE
    flip4((const unsigned int *)iarray, (unsigned int *)iarray, nread / 4);
#  endif
    return nread / 4;
#endif
}
########################rank 6#############################
int ssh2_bignum_length(Bignum bn)
{
  return 4 + (bignum_bitcount(bn) + 8) / 8;
}
########################rank 7#############################
typedef bitstr_t exp_t;
exp_t base_order;
void point_mult(elem_t x, elem_t y, const exp_t exp)
{
  elem_t X, Y;
  int i;
  point_set_zero(X, Y);
  for(i = bitstr_sizeinbits(exp) - 1; i >= 0; i--) {
    point_double(X, Y);
    if (bitstr_getbit(exp, i))
      point_add(X, Y, x, y);
  }
  point_copy(x, y, X, Y);
}
########################rank 8#############################
int32_t mpz_cmpabs(mpz_ptr a, mpz_ptr b)
{
	int32_t i;
	if (a->l > b->l) return 1;
	if (a->l < b->l) return -1;
	i = a->l;
	while(i--) {
		if (a->d[i] > b->d[i]) return 1;
		if (a->d[i] < b->d[i]) return -1;
	}
	return 0;
}
########################rank 9#############################
int mpz_abs(mpz_ptr d, mpz_ptr s)
{
	int err;
	if ((d != s) && ((err = mpz_set(d, s)) != SBN_OK))
		return err;
	_mpz_abs(d);
	return SBN_OK;
}
########################rank 10#############################
int
bnAddQ_16(struct BigNum *dest, unsigned src)
{
	BNWORD16 t;
	if (!dest->size)
		return bnSetQ(dest, src);
	t = lbnAdd1_16((BNWORD16 *)dest->ptr, dest->size, (BNWORD16)src);
	MALLOCDB;
	if (t) {
		src = dest->size;
		bnSizeCheck(dest, src+1);
		((BNWORD16 *)dest->ptr)[BIGLITTLE(-1-src,src)] = t;
		dest->size = src+1;
	}
	return 0;
}
----------------------------QUERY-------------------------------
grab a lock on a mutex
########################rank 1#############################
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;                              /* Return code */
  ** already held), or one of the transitions that the busy-handler
  ** may be invoked during, according to the comment above
  ** wx_sqlite3PagerSetBusyhandler().
  */
  assert( (pPager->eLock>=locktype)
       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)
       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)
  );
  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
########################rank 2#############################
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;                              /* Return code */
  ** already held), or one of the transitions that the busy-handler
  ** may be invoked during, according to the comment above
  ** sqlite3PagerSetBusyhandler().
  */
  assert( (pPager->eLock>=locktype)
       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)
       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)
  );
  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
########################rank 3#############################
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;                              /* Return code */
  ** already held), or one of the transitions that the busy-handler
  ** may be invoked during, according to the comment above
  ** systemdata_sqlite3PagerSetBusyhandler().
  */
  assert( (pPager->eLock>=locktype)
       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)
       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)
  );
  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
########################rank 4#############################
static void pthreadMutexEnter(keen_io_sqlite3_mutex *p){
  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
  ** our own.  This implementation assumes that pthread_equal()
  ** is atomic - that it cannot be deceived into thinking self
  ** and p->owner are equal if p->owner changes between two values
  ** that are not equal to self while the comparison is taking place.
  ** This implementation also assumes a coherent cache - that 
  ** separate processes cannot read different values from the same
  ** address at the same time.  If either of these two conditions
  ** are not met, then the mutexes will fail and problems will result.
  */
  {
    pthread_t self = pthread_self();
    if( p->nRef>0 && pthread_equal(p->owner, self) ){
      p->nRef++;
    }else{
      pthread_mutex_lock(&p->mutex);
      assert( p->nRef==0 );
      p->owner = self;
      p->nRef = 1;
    }
  }
#else
  */
  pthread_mutex_lock(&p->mutex);
#if SQLITE_MUTEX_NREF
  assert( p->nRef>0 || p->owner==0 );
  p->owner = pthread_self();
  p->nRef++;
#endif
#endif
#ifdef SQLITE_DEBUG
  if( p->trace ){
    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
  }
#endif
}
########################rank 5#############################
SQLITE_PRIVATE int sqlite3PagerNosync(Pager *pPager){
  return pPager->noSync;
}
########################rank 6#############################
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;                              /* Return code */
  do {
    rc = pager_lock_db(pPager,locktype);
  }while( rc==UNQLITE_BUSY && pPager->xBusyHandler && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
########################rank 7#############################
static int
lockBtreeWithRetry(Btree * pRef)
{
	int rc = SQLITE_OK;
	assert(sqlite3BtreeHoldsMutex(pRef));
	if(pRef->inTrans == TRANS_NONE)
	{
		u8 inTransaction = pRef->pBt->inTransaction;
		btreeIntegrity(pRef);
		rc = sqlite3BtreeBeginTrans(pRef, 0);
		pRef->pBt->inTransaction = inTransaction;
		pRef->inTrans = TRANS_NONE;
		if(rc == SQLITE_OK)
		{
			pRef->pBt->nTransaction--;
		}
		btreeIntegrity(pRef);
	}
	return rc;
}
########################rank 8#############################
static int pagerLockDb(Pager *pPager, int eLock){
  int rc = SQLITE_OK;
  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );
  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){
    rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);
    if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){
      pPager->eLock = (u8)eLock;
      IOTRACE(("LOCK %p %d\n", pPager, eLock))
    }
  }
  return rc;
}
########################rank 9#############################
SQLITE_PRIVATE int systemdata_sqlite3WalBeginWriteTransaction(Wal *pWal){
  int rc;
  ** transaction. */
  assert( pWal->readLock>=0 );
  assert( pWal->writeLock==0 && pWal->iReCksum==0 );
  if( pWal->readOnly ){
    return SQLITE_READONLY;
  }
  ** SQLITE_BUSY if unable.
  */
  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);
  if( rc ){
    return rc;
  }
  pWal->writeLock = 1;
  ** time the read transaction on this connection was started, then
  ** the write is disallowed.
  */
  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){
    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
    pWal->writeLock = 0;
    rc = SQLITE_BUSY_SNAPSHOT;
  }
  return rc;
}
########################rank 10#############################
SQLITE_PRIVATE int wx_sqlite3WalBeginWriteTransaction(Wal *pWal){
  int rc;
  ** transaction. */
  assert( pWal->readLock>=0 );
  assert( pWal->writeLock==0 && pWal->iReCksum==0 );
  if( pWal->readOnly ){
    return SQLITE_READONLY;
  }
  ** SQLITE_BUSY if unable.
  */
  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);
  if( rc ){
    return rc;
  }
  pWal->writeLock = 1;
  ** time the read transaction on this connection was started, then
  ** the write is disallowed.
  */
  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){
    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
    pWal->writeLock = 0;
    rc = SQLITE_BUSY_SNAPSHOT;
  }
  return rc;
}
----------------------------QUERY-------------------------------
advance a carray cursor to next row of output
########################rank 1#############################
static int carrayNext(sqlite3_vtab_cursor *cur){
  carray_cursor *pCur = (carray_cursor*)cur;
  pCur->iRowid++;
  return SQLITE_OK;
}
########################rank 2#############################
static int fsdirRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
  fsdir_cursor *pCur = (fsdir_cursor*)cur;
  *pRowid = pCur->iRowid;
  return SQLITE_OK;
}
########################rank 3#############################
static void fsdirResetCursor(fsdir_cursor *pCur){
  int i;
  for(i=0; i<=pCur->iLvl; i++){
    FsdirLevel *pLvl = &pCur->aLvl[i];
    if( pLvl->pDir ) closedir(pLvl->pDir);
    sqlite3_free(pLvl->zDir);
  }
  sqlite3_free(pCur->zPath);
  sqlite3_free(pCur->aLvl);
  pCur->aLvl = 0;
  pCur->zPath = 0;
  pCur->zBase = 0;
  pCur->nBase = 0;
  pCur->nLvl = 0;
  pCur->iLvl = -1;
  pCur->iRowid = 1;
}
########################rank 4#############################
static int fts3CursorSeekStmt(Fts3Cursor *pCsr){
  int rc = SQLITE_OK;
  if( pCsr->pStmt==0 ){
    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
    char *zSql;
    if( p->pSeekStmt ){
      pCsr->pStmt = p->pSeekStmt;
      p->pSeekStmt = 0;
    }else{
      zSql = sqlite3_mprintf("SELECT %s WHERE rowid = ?", p->zReadExprlist);
      if( !zSql ) return SQLITE_NOMEM;
      rc = sqlite3_prepare_v3(p->db, zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0);
      sqlite3_free(zSql);
    }
    if( rc==SQLITE_OK ) pCsr->bSeekStmt = 1;
  }
  return rc;
}
########################rank 5#############################
static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){
  BtCursor *p;
  assert( sqlite3_mutex_held(pBt->mutex) );
  assert( pExcept==0 || pExcept->pBt==pBt );
  for(p=pBt->pCursor; p; p=p->pNext){
    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ) break;
  }
  if( p ) return saveCursorsOnList(p, iRoot, pExcept);
  if( pExcept ) pExcept->curFlags &= ~BTCF_Multiple;
  return SQLITE_OK;
}
########################rank 6#############################
static int fts5VocabRowidMethod(
  sqlite3_vtab_cursor *pCursor, 
  sqlite_int64 *pRowid
){
  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
  *pRowid = pCsr->rowid;
  return SQLITE_OK;
}
########################rank 7#############################
SQLITE_PRIVATE int keen_io_sqlite3BtreeNext(BtCursor *pCur, int *pRes){
  int rc;
  int idx;
  MemPage *pPage;
  assert( cursorHoldsMutex(pCur) );
  assert( pRes!=0 );
  assert( *pRes==0 || *pRes==1 );
  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
  if( pCur->eState!=CURSOR_VALID ){
    invalidateOverflowCache(pCur);
    rc = restoreCursorPosition(pCur);
    if( rc!=SQLITE_OK ){
      *pRes = 0;
      return rc;
    }
    if( CURSOR_INVALID==pCur->eState ){
      *pRes = 1;
      return SQLITE_OK;
    }
    if( pCur->skipNext ){
      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
      pCur->eState = CURSOR_VALID;
      if( pCur->skipNext>0 ){
        pCur->skipNext = 0;
        *pRes = 0;
        return SQLITE_OK;
      }
      pCur->skipNext = 0;
    }
  }
  pPage = pCur->apPage[pCur->iPage];
  idx = ++pCur->aiIdx[pCur->iPage];
  assert( pPage->isInit );
  ** to be invalid here. This can only occur if a second cursor modifies
  ** the page while cursor pCur is holding a reference to it. Which can
  ** only happen if the database is corrupt in such a way as to link the
  ** page into more than one b-tree structure. */
  testcase( idx>pPage->nCell );
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
  if( idx>=pPage->nCell ){
    if( !pPage->leaf ){
      rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset+8]));
      if( rc ){
        *pRes = 0;
        return rc;
      }
      rc = moveToLeftmost(pCur);
      *pRes = 0;
      return rc;
    }
    do{
      if( pCur->iPage==0 ){
        *pRes = 1;
        pCur->eState = CURSOR_INVALID;
        return SQLITE_OK;
      }
      moveToParent(pCur);
      pPage = pCur->apPage[pCur->iPage];
    }while( pCur->aiIdx[pCur->iPage]>=pPage->nCell );
    *pRes = 0;
    if( pPage->intKey ){
      rc = keen_io_sqlite3BtreeNext(pCur, pRes);
    }else{
      rc = SQLITE_OK;
    }
    return rc;
  }
  *pRes = 0;
  if( pPage->leaf ){
    return SQLITE_OK;
  }
  rc = moveToLeftmost(pCur);
  return rc;
}
########################rank 8#############################
static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur){
  int rc;
  MemPage *pPage;
  assert( cursorOwnsBtShared(pCur) );
  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
  assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
  assert( pCur->info.nSize==0 );
  if( pCur->eState!=CURSOR_VALID ){
    rc = restoreCursorPosition(pCur);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( CURSOR_INVALID==pCur->eState ){
      return SQLITE_DONE;
    }
    if( pCur->skipNext ){
      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
      pCur->eState = CURSOR_VALID;
      if( pCur->skipNext<0 ){
        pCur->skipNext = 0;
        return SQLITE_OK;
      }
      pCur->skipNext = 0;
    }
  }
  pPage = pCur->pPage;
  assert( pPage->isInit );
  if( !pPage->leaf ){
    int idx = pCur->ix;
    rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));
    if( rc ) return rc;
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->ix==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = CURSOR_INVALID;
        return SQLITE_DONE;
      }
      moveToParent(pCur);
    }
    assert( pCur->info.nSize==0 );
    assert( (pCur->curFlags & (BTCF_ValidOvfl))==0 );
    pCur->ix--;
    pPage = pCur->pPage;
    if( pPage->intKey && !pPage->leaf ){
      rc = systemdata_sqlite3BtreePrevious(pCur, 0);
    }else{
      rc = SQLITE_OK;
    }
  }
  return rc;
}
########################rank 9#############################
static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes){
  int rc;
  MemPage *pPage;
  assert( cursorOwnsBtShared(pCur) );
  assert( pRes!=0 );
  assert( *pRes==0 );
  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
  assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
  assert( pCur->info.nSize==0 );
  if( pCur->eState!=CURSOR_VALID ){
    rc = restoreCursorPosition(pCur);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( CURSOR_INVALID==pCur->eState ){
      *pRes = 1;
      return SQLITE_OK;
    }
    if( pCur->skipNext ){
      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
      pCur->eState = CURSOR_VALID;
      if( pCur->skipNext<0 ){
        pCur->skipNext = 0;
        return SQLITE_OK;
      }
      pCur->skipNext = 0;
    }
  }
  pPage = pCur->apPage[pCur->iPage];
  assert( pPage->isInit );
  if( !pPage->leaf ){
    int idx = pCur->aiIdx[pCur->iPage];
    rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));
    if( rc ) return rc;
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->aiIdx[pCur->iPage]==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = CURSOR_INVALID;
        *pRes = 1;
        return SQLITE_OK;
      }
      moveToParent(pCur);
    }
    assert( pCur->info.nSize==0 );
    assert( (pCur->curFlags & (BTCF_ValidNKey|BTCF_ValidOvfl))==0 );
    pCur->aiIdx[pCur->iPage]--;
    pPage = pCur->apPage[pCur->iPage];
    if( pPage->intKey && !pPage->leaf ){
      rc = sqlite3BtreePrevious(pCur, pRes);
    }else{
      rc = SQLITE_OK;
    }
  }
  return rc;
}
########################rank 10#############################
static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur){
  int rc;
  MemPage *pPage;
  assert( cursorOwnsBtShared(pCur) );
  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
  assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
  assert( pCur->info.nSize==0 );
  if( pCur->eState!=CURSOR_VALID ){
    rc = restoreCursorPosition(pCur);
    if( rc!=SQLITE_OK ){
      return rc;
    }
    if( CURSOR_INVALID==pCur->eState ){
      return SQLITE_DONE;
    }
    if( pCur->skipNext ){
      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
      pCur->eState = CURSOR_VALID;
      if( pCur->skipNext<0 ){
        pCur->skipNext = 0;
        return SQLITE_OK;
      }
      pCur->skipNext = 0;
    }
  }
  pPage = pCur->pPage;
  assert( pPage->isInit );
  if( !pPage->leaf ){
    int idx = pCur->ix;
    rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));
    if( rc ) return rc;
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->ix==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = CURSOR_INVALID;
        return SQLITE_DONE;
      }
      moveToParent(pCur);
    }
    assert( pCur->info.nSize==0 );
    assert( (pCur->curFlags & (BTCF_ValidOvfl))==0 );
    pCur->ix--;
    pPage = pCur->pPage;
    if( pPage->intKey && !pPage->leaf ){
      rc = wx_sqlite3BtreePrevious(pCur, 0);
    }else{
      rc = SQLITE_OK;
    }
  }
  return rc;
}
----------------------------QUERY-------------------------------
split string into args respecting backwhack and quote
########################rank 1#############################
void
dochq(argv, argc)
register char *argv[];
register int argc;
{
	if (argc > 2) {
		if (*argv[2])
			lquote = *argv[2];
		if (argc > 3) {
			if (*argv[3])
				rquote = *argv[3];
		}
		else
			rquote = lquote;
	}
	else {
		lquote = LQUOTE;
		rquote = RQUOTE;
	}
}
########################rank 2#############################
static void write_declare(struct generator * g,
                          char * declaration,
                          struct node * p) {
    struct str * temp = g->outbuf;
    g->outbuf = g->declarations;
    write_string(g, "    ");
    writef(g, declaration, p);
    write_string(g, ";");
    write_newline(g);
    g->outbuf = temp;
}
########################rank 3#############################
static void set_table_name( ShellState *p, const char *zName )
{
  int i, n;
  int needQuote;
  char *z;
  if ( p->zDestTable )
  {
    free( p->zDestTable );
    p->zDestTable = 0;
  }
  if( zName == 0 ) return;
  needQuote = !isalpha( ( unsigned char )*zName ) && *zName!='_';
  for ( i = n = 0; zName[ i ]; i++, n++ )
  {
    if( !isalnum( ( unsigned char )zName[ i ] ) && zName[ i ] != '_' )
    {
      needQuote = 1;
      if ( zName[ i ] == '\'' ) n++;
    }
  }
  if ( needQuote ) n += 2;
  z = p->zDestTable = malloc( n + 1 );
  if ( z == 0 )
  {
    raw_printf( stderr, "Error: out of memory\n" );
    exit( 1 );
  }
  n = 0;
  if ( needQuote ) z[ n++ ] = '\'';
  for ( i = 0; zName[ i ]; i++ )
  {
    z[ n++ ] = zName[ i ];
    if ( zName[ i ] == '\'' ) z[ n++ ] = '\'';
  }
  if ( needQuote ) z[ n++ ] = '\'';
  z[ n ] = 0;
}
########################rank 4#############################
SQLITE_PRIVATE void sqlite3Dequote(char *z){
  char quote;
  int i, j;
  if( z==0 ) return;
  quote = z[0];
  if( !sqlite3Isquote(quote) ) return;
  if( quote=='[' ) quote = ']';
  for(i=1, j=0;; i++){
    assert( z[i] );
    if( z[i]==quote ){
      if( z[i+1]==quote ){
        z[j++] = quote;
        i++;
      }else{
        break;
      }
    }else{
      z[j++] = z[i];
    }
  }
  z[j] = 0;
}
########################rank 5#############################
int
tmp()
{
	extern char *envtmp;
	sigset_t set, oset;
	static int first;
	int fd;
	char path[MAXPATHLEN];
	if (!first && !envtmp) {
		envtmp = getenv("TMPDIR");
		first = 1;
	}
	if (envtmp)
		(void)sprintf(path, "%s/%s", envtmp, _NAME_ARTMP);
	else
		strcpy(path, _PATH_ARTMP);
	sigfillset(&set);
	(void)sigprocmask(SIG_BLOCK, &set, &oset);
	if ((fd = mkstemp(path)) == -1)
		error(tname);
        (void)unlink(path);
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
	return (fd);
}
########################rank 6#############################
static void
parse_argname(const char *str, char *flag, char *arg) {
  int buffer = 0;
  size_t flagpos = 0;
  size_t argpos = 0;
  size_t len = strlen(str);
  size_t i;
  for (i = 0; i < len; ++i) {
    if (buffer || '[' == str[i] || '<' == str[i]) {
      buffer = 1;
      arg[argpos++] = str[i];
    } else {
      if (' ' == str[i]) continue;
      flag[flagpos++] = str[i];
    }
  }
  arg[argpos] = '\0';
  flag[flagpos] = '\0';
}
########################rank 7#############################
static void set_table_name(struct callback_data *p, const char *zName){
  int i, n;
  int needQuote;
  char *z;
  if( p->zDestTable ){
    free(p->zDestTable);
    p->zDestTable = 0;
  }
  if( zName==0 ) return;
  needQuote = !isalpha((unsigned char)*zName) && *zName!='_';
  for(i=n=0; zName[i]; i++, n++){
    if( !isalnum((unsigned char)zName[i]) && zName[i]!='_' ){
      needQuote = 1;
      if( zName[i]=='\'' ) n++;
    }
  }
  if( needQuote ) n += 2;
  z = p->zDestTable = malloc( n+1 );
  if( z==0 ){
    fprintf(stderr,"Error: out of memory\n");
    exit(1);
  }
  n = 0;
  if( needQuote ) z[n++] = '\'';
  for(i=0; zName[i]; i++){
    z[n++] = zName[i];
    if( zName[i]=='\'' ) z[n++] = '\'';
  }
  if( needQuote ) z[n++] = '\'';
  z[n] = 0;
}
########################rank 8#############################
extern void str_assign(struct str * str, const char * s) {
    str_clear(str);
    str_append_string(str, s);
}
########################rank 9#############################
extern void str_assign(struct str * str, const char * s) {
    str_clear(str);
    str_append_string(str, s);
}
########################rank 10#############################
void glob_initfromgui(void *dummy, t_symbol *s, int argc, t_atom *argv)
{
    char *cwd = atom_getsymbolarg(0, argc, argv)->s_name;
    t_namelist *nl;
    unsigned int i;
    int j;
    int nhostfont = (argc-2)/3;
    sys_oldtclversion = atom_getfloatarg(1, argc, argv);
    if (argc != 2 + 3 * nhostfont) bug("glob_initfromgui");
    for (i = 0; i < NFONT; i++)
    {
        int best = 0;
        int wantheight = sys_fontlist[i].fi_maxheight;
        int wantwidth = sys_fontlist[i].fi_maxwidth;
        for (j = 1; j < nhostfont; j++)
        {
            if (atom_getintarg(3 * j + 4, argc, argv) <= wantheight &&
                atom_getintarg(3 * j + 3, argc, argv) <= wantwidth)
                    best = j;
        }
        sys_fontlist[i].fi_hostfontsize =
            atom_getintarg(3 * best + 2, argc, argv);
        sys_fontlist[i].fi_width = atom_getintarg(3 * best + 3, argc, argv);
        sys_fontlist[i].fi_height = atom_getintarg(3 * best + 4, argc, argv);
    }
#if 0
    for (i = 0; i < 6; i++)
        fprintf(stderr, "font (%d %d %d) -> (%d %d %d)\n",
            sys_fontlist[i].fi_fontsize,
            sys_fontlist[i].fi_maxwidth,
            sys_fontlist[i].fi_maxheight,
            sys_fontlist[i].fi_hostfontsize,
            sys_fontlist[i].fi_width,
            sys_fontlist[i].fi_height);
#endif
    for  (nl = sys_externlist; nl; nl = nl->nl_next)
        if (!sys_load_lib(0, nl->nl_string))
            post("%s: can't load library", nl->nl_string);
    for  (nl = sys_openlist; nl; nl = nl->nl_next)
        openit(cwd, nl->nl_string);
    namelist_free(sys_openlist);
    sys_openlist = 0;
    for  (nl = sys_messagelist; nl; nl = nl->nl_next)
    {
        t_binbuf *b = binbuf_new();
        binbuf_text(b, nl->nl_string, strlen(nl->nl_string));
        binbuf_eval(b, 0, 0, 0);
        binbuf_free(b);
    }
    namelist_free(sys_messagelist);
    sys_messagelist = 0;
}
----------------------------QUERY-------------------------------
retrieve page from the pager cache
########################rank 1#############################
static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){
  int nPage = get4byte(&pPage1->aData[28]);
  testcase( nPage==0 );
  if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);
  testcase( pBt->nPage!=nPage );
  pBt->nPage = nPage;
}
########################rank 2#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( sqlite3_mutex_held(pBt->mutex) );
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 3#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( wx_sqlite3_mutex_held(pBt->mutex) );
  rc = wx_sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 4#############################
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ){
    Pager *pPager = pPg->pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
}
########################rank 5#############################
SQLITE_PRIVATE void systemdata_sqlite3PagerUnrefNotNull(DbPage *pPg){
  TESTONLY( Pager *pPager = pPg->pPager; )
  assert( pPg!=0 );
  if( pPg->flags & PGHDR_MMAP ){
    assert( pPg->pgno!=1 );  /* Page1 is never memory mapped */
    pagerReleaseMapPage(pPg);
  }else{
    systemdata_sqlite3PcacheRelease(pPg);
  }
  assert( systemdata_sqlite3PcacheRefCount(pPager->pPCache)>0 );
}
########################rank 6#############################
static int btreeGetPage(
  BtShared *pBt,       /* The btree */
  Pgno pgno,           /* Number of the page to fetch */
  MemPage **ppPage,    /* Return the page in this parameter */
  int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
){
  int rc;
  DbPage *pDbPage;
  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
  assert( systemdata_sqlite3_mutex_held(pBt->mutex) );
  rc = systemdata_sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return SQLITE_OK;
}
########################rank 7#############################
static int pager_write_dirty_pages(Pager *pPager,Page *pDirty)
{
	int rc = VEDIS_OK;
	Page *pNext;
	for(;;){
		if( pDirty == 0 ){
			break;
		}
		pNext = pDirty->pDirtyPrev; /* Not a bug: Reverse link */
		if( (pDirty->flags & PAGE_DONT_WRITE) == 0 ){
			rc = vedisOsWrite(pPager->pfd,pDirty->zData,pPager->iPageSize,pDirty->pgno * pPager->iPageSize);
			if( rc != VEDIS_OK ){
				break;
			}
		}
		pDirty->flags &= ~(PAGE_DIRTY|PAGE_DONT_WRITE|PAGE_NEED_SYNC|PAGE_IN_JOURNAL|PAGE_HOT_DIRTY);
		if( pDirty->nRef < 1 ){
			pager_unlink_page(pPager,pDirty);
			pager_release_page(pPager,pDirty);
		}
		pDirty = pNext;
	}
	pPager->pDirty = pPager->pFirstDirty = 0;
	pPager->pHotDirty = pPager->pFirstHot = 0;
	pPager->nHot = 0;
	return rc;
}
########################rank 8#############################
static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){
  DbPage *pDbPage;
  assert( sqlite3_mutex_held(pBt->mutex) );
  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
  if( pDbPage ){
    return btreePageFromDbPage(pDbPage, pgno, pBt);
  }
  return 0;
}
########################rank 9#############################
SQLITE_PRIVATE int
sqlite3BtreeGetPage(BtShared * pBt,	/* The btree */
		    Pgno pgno,	/* Number of the page to fetch */
		    MemPage ** ppPage,	/* Return the page in this parameter */
		    int noContent	/* Do not load page content if true */
	)
{
	int rc;
	MemPage *pPage;
	DbPage *pDbPage;
	assert(sqlite3_mutex_held(pBt->mutex));
	rc = sqlite3PagerAcquire(pBt->pPager, pgno, (DbPage **) & pDbPage, noContent);
	if(rc)
		return rc;
	pPage = (MemPage *) sqlite3PagerGetExtra(pDbPage);
	pPage->aData = sqlite3PagerGetData(pDbPage);
	pPage->pDbPage = pDbPage;
	pPage->pBt = pBt;
	pPage->pgno = pgno;
	pPage->hdrOffset = pPage->pgno == 1 ? 100 : 0;
	*ppPage = pPage;
	return SQLITE_OK;
}
########################rank 10#############################
SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}
----------------------------QUERY-------------------------------
round up to nearest integer
########################rank 1#############################
static void vli_mult(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
{
    uint128_t r01 = 0;
    uint64_t r2 = 0;
    uint i, k;
    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
    {
        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
        for(i=l_min; i<=k && i<NUM_ECC_DIGITS; ++i)
        {
            uint128_t l_product = (uint128_t)p_left[i] * p_right[k-i];
            r01 += l_product;
            r2 += (r01 < l_product);
        }
        p_result[k] = (uint64_t)r01;
        r01 = (r01 >> 64) | (((uint128_t)r2) << 64);
        r2 = 0;
    }
    p_result[NUM_ECC_DIGITS*2 - 1] = (uint64_t)r01;
}
########################rank 2#############################
static void vli_modMult_n(uECC_word_t *result, const uECC_word_t *left, const uECC_word_t *right) {
    bitcount_t i;
    uECC_word_t product[2 * uECC_N_WORDS];
    uECC_word_t modMultiple[2 * uECC_N_WORDS];
    uECC_word_t tmp[2 * uECC_N_WORDS];
    uECC_word_t *v[2] = {tmp, product};
    uECC_word_t index = 1;
    vli_mult_n(product, left, right);
    vli_clear_n(modMultiple);
    vli_set(modMultiple + uECC_N_WORDS + 1, curve_n);
    vli_rshift1(modMultiple + uECC_N_WORDS + 1);
    modMultiple[2 * uECC_N_WORDS - 1] |= HIGH_BIT_SET;
    modMultiple[uECC_N_WORDS] = HIGH_BIT_SET;
    for (i = 0;
         i <= ((((bitcount_t)uECC_N_WORDS) << uECC_WORD_BITS_SHIFT) + (uECC_WORD_BITS - 1));
         ++i) {
        uECC_word_t borrow = vli2_sub_n(v[1 - index], v[index], modMultiple);
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        vli2_rshift1_n(modMultiple);
    }
    vli_set_n(result, v[index]);
}
########################rank 3#############################
long
mp_base_mul(BNS *rop, BNS *op1, BNS *op2, BNI len1, BNI len2)
{
    long i, j;			/* counters */
    BNI value;			/* intermediate result */
    BNS carry;			/* carry value */
    long size = len1 + len2;
    if (op1[0]) {
	value = (BNI)(op1[0]) * op2[0];
	rop[0] = value;
	carry = (BNS)(value >> BNSBITS);
	for (j = 1; j < len2; j++) {
	    value = (BNI)(op1[0]) * op2[j] + carry;
	    rop[j] = value;
	    carry = (BNS)(value >> BNSBITS);
	}
	rop[j] = carry;
    }
    for (i = 1; i < len1; i++) {
	if (op1[i]) {
	    value = (BNI)(op1[i]) * op2[0] + rop[i];
	    rop[i] = value;
	    carry = (BNS)(value >> BNSBITS);
	    for (j = 1; j < len2; j++) {
		value = (BNI)(op1[i]) * op2[j] + rop[i + j] + carry;
		rop[i + j] = value;
		carry = (BNS)(value >> BNSBITS);
	    }
	    rop[i + j] = carry;
	}
    }
    if (size > 1 && rop[size - 1] == 0)
	--size;
    return (size);
}
########################rank 4#############################
int multiply(int a, int b)
{
  return a * b;
}
########################rank 5#############################
static void vli_square(uint64_t *p_result, uint64_t *p_left)
{
    uint128_t r01 = 0;
    uint64_t r2 = 0;
    uint i, k;
    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
    {
        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
        for(i=l_min; i<=k && i<=k-i; ++i)
        {
            uint128_t l_product = (uint128_t)p_left[i] * p_left[k-i];
            if(i < k-i)
            {
                r2 += l_product >> 127;
                l_product *= 2;
            }
            r01 += l_product;
            r2 += (r01 < l_product);
        }
        p_result[k] = (uint64_t)r01;
        r01 = (r01 >> 64) | (((uint128_t)r2) << 64);
        r2 = 0;
    }
    p_result[NUM_ECC_DIGITS*2 - 1] = (uint64_t)r01;
}
########################rank 6#############################
static void vli_modMult_fast(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
{
    uint64_t l_product[2 * NUM_ECC_DIGITS];
    vli_mult(l_product, p_left, p_right);
    vli_mmod_fast(p_result, l_product);
}
########################rank 7#############################
static void vli_modSquare_fast(uint64_t *p_result, uint64_t *p_left)
{
    uint64_t l_product[2 * NUM_ECC_DIGITS];
    vli_square(l_product, p_left);
    vli_mmod_fast(p_result, l_product);
}
########################rank 8#############################
static void vli_mod_square_fast(uint64_t *result, const uint64_t *left)
{
	uint64_t product[2 * NUM_ECC_DIGITS];
	vli_square(product, left);
	vli_mmod_fast(result, product);
}
########################rank 9#############################
int bignum_jacobi(bignum* ac, bignum* nc) {
	bignum *remainder = bignum_init(), *twos = bignum_init();
	bignum *temp = bignum_init(), *a = bignum_init(), *n = bignum_init();
	int mult = 1, result = 0;
	bignum_copy(ac, a);
	bignum_copy(nc, n);
	while(bignum_greater(a, &NUMS[1]) && !bignum_equal(a, n)) {
		bignum_imodulate(a, n);
		if(bignum_leq(a, &NUMS[1]) || bignum_equal(a, n)) break;
		bignum_fromint(twos, 0);
		while(a->data[0] % 2 == 0) {
			bignum_iadd(twos, &NUMS[1]);
			bignum_idivide(a, &NUMS[2]);
		}
		if(bignum_greater(twos, &NUMS[0]) && twos->data[0] % 2 == 1) {
			bignum_remainder(n, &NUMS[8], remainder);
			if(!bignum_equal(remainder, &NUMS[1]) && !bignum_equal(remainder, &NUMS[7])) {
				mult *= -1;
			}
		}
		if(bignum_leq(a, &NUMS[1]) || bignum_equal(a, n)) break;
		bignum_remainder(n, &NUMS[4], remainder);
		bignum_remainder(a, &NUMS[4], temp);
		if(!bignum_equal(remainder, &NUMS[1]) && !bignum_equal(temp, &NUMS[1])) mult *= -1;
		bignum_copy(a, temp);
		bignum_copy(n, a);
		bignum_copy(temp, n);
	}
	if(bignum_equal(a, &NUMS[1])) result = mult;
	else result = 0;
	bignum_deinit(remainder);
	bignum_deinit(twos);
	bignum_deinit(temp);
	bignum_deinit(a);
	bignum_deinit(n);
	return result;
}
########################rank 10#############################
void ModExp(BYTE *A, BYTE *B, int LB, BYTE *C, int LC, BYTE *M, int LM)
{
	BYTE	wmask;
	int		bits;
	bits = LC*8;
	wmask = 0x80;
	A[LM-1] = 1;
	while ( !sniff_bit(C,wmask) ) {
		wmask >>= 1;
		bits--;
		if ( !wmask ) {
			wmask = 0x80;
			C++;
		}
	}
	while ( bits-- ) {
		memset(A+LM, 0x00, LM*2);
		ModSqr(A+LM, A,LM,  M,LM);
		memcpy(A, A+LM*2, LM);
		memset(A+LM, 0x00, 2*LM);
		if ( sniff_bit(C,wmask) ) {
			memset(A+LM, 0x00, (LM+LB));
			ModMult(A+LM, B,LB, A,LM,  M,LM);       /* temp = B * A (MOD M) */
			memcpy(A, A+LM+(LM+LB)-LM, LM);  /* A = lower LM bytes of temp */
			memset(A+LM, 0x00, 2*LM);
		}
		wmask >>= 1;
		if ( !wmask ) {
			wmask = 0x80;
			C++;
		}
	}
}
----------------------------QUERY-------------------------------
create a new thread safe queue of size siz
########################rank 1#############################
void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
  (void)tqp;
  (void)msg;
}
########################rank 2#############################
static void
thread_worker_start(struct Core *core)
{
    struct CoreWorkerThread *t;
    t = malloc(sizeof(*t));
    if (t == 0)
        return;
    memset(t, 0, sizeof(*t));
    t->core = core;
    t->index = core->workers_count;
    t->handle = pixie_begin_thread(thread_worker, 0, t);
    if (t->handle == 0) {
        LOG_ERR(C_GENERAL, "can't start worker thread %u\n", errno);
        free(t);
        return;
    }
    core->workers = REALLOC2(core->workers, core->workers_count + 1, sizeof(core->workers[0]));
    core->workers[core->workers_count] = t;
    core->workers_count++;
}
########################rank 3#############################
void add_worker(pthread_t tid, int sockfd)
{
	struct worker_thread *wtp;
	if ((wtp = malloc(sizeof(struct worker_thread))) == NULL) {
		log_ret("add_worker: can't malloc");
		pthread_exit((void *)1);
	}
	wtp->tid = tid;
	wtp->sockfd = sockfd;
	pthread_mutex_lock(&workerlock);
	wtp->prev = NULL;
	wtp->next = workers;
	if (workers != NULL)
		workers->prev = wtp;
	workers = wtp;
	pthread_mutex_unlock(&workerlock);
}
########################rank 4#############################
int
__objc_thread_set_priority(int priority)
{
  return -1;
}
########################rank 5#############################
tommy_inline void hashdyn_shrink_step(tommy_hashdyn* hashdyn)
{
	if (hashdyn->count <= hashdyn->bucket_max / 8 && hashdyn->bucket_bit > TOMMY_HASHDYN_BIT)
		tommy_hashdyn_resize(hashdyn, hashdyn->bucket_bit - 1);
}
########################rank 6#############################
struct mpscq *mpscq_create(struct mpscq *n, size_t capacity)
{
	if(!n) {
		n = calloc(1, sizeof(*n));
		n->flags |= MPSCQ_MALLOC;
	} else {
		n->flags = 0;
	}
	n->count = ATOMIC_VAR_INIT(0);
	n->head = ATOMIC_VAR_INIT(0);
	n->tail = 0;
	n->buffer = calloc(capacity, sizeof(void *));
	n->max = capacity;
	atomic_thread_fence(memory_order_release);
	return n;
}
########################rank 7#############################
const ThreadData *sqlite3ThreadDataReadOnly(){
  static const ThreadData zeroData = {0};  /* Initializer to silence warnings
                                           ** from broken compilers */
  const ThreadData *pTd = sqlite3OsThreadSpecificData(0);
  return pTd ? pTd : &zeroData;
}
########################rank 8#############################
static int jobqueue_init(jobqueue* jobqueue_p){
	jobqueue_p->len = 0;
	jobqueue_p->front = NULL;
	jobqueue_p->rear  = NULL;
	jobqueue_p->has_jobs = (struct bsem*)malloc(sizeof(struct bsem));
	if (jobqueue_p->has_jobs == NULL){
		return -1;
	}
	pthread_mutex_init(&(jobqueue_p->rwmutex), NULL);
	bsem_init(jobqueue_p->has_jobs, 0);
	return 0;
}
########################rank 9#############################
static int jobqueue_init(jobqueue* jobqueue_p){
	jobqueue_p->len = 0;
	jobqueue_p->front = NULL;
	jobqueue_p->rear  = NULL;
	jobqueue_p->has_jobs = (struct bsem*)malloc(sizeof(struct bsem));
	if (jobqueue_p->has_jobs == NULL){
		return -1;
	}
	pthread_mutex_init(&(jobqueue_p->rwmutex), NULL);
	bsem_init(jobqueue_p->has_jobs, 0);
	return 0;
}
########################rank 10#############################
static Res ClientArenaExtend(Arena arena, Addr base, Size size)
{
  ClientArena clientArena = MustBeA(ClientArena, arena);
  Chunk chunk;
  AVER(base != (Addr)0);
  AVER(size > 0);
  return clientChunkCreate(&chunk, clientArena, base, AddrAdd(base, size));
}
----------------------------QUERY-------------------------------
push integer to end of list
########################rank 1#############################
int list_add_item_before(List_t * list, int idx, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// Move to right before list index or return 1 if no such index
	while(idx-1 > 0){
		// Insert after last item in list
		if(!nextItem->next){ // Index doesn't exist
			return(0);
		}else{
			nextItem = nextItem->next;
			idx--;
		}
	}
	// Add item after current "nextItem" pointed too.
	if(nextItem->next){ // Middle of list
		if(!li->next){
			ListItem_t * tmpItem = list_item_initialize();
			// Save next item in list
			tmpItem = nextItem->next;
			// Attach new item to current item's next pointer
			nextItem->next = li;
			// Attach "old" next item pointer 
			li->next = tmpItem;
			return(1);
		}else{
			return(0);
		}
	}else if(!nextItem->next){ // End of list
		if(!li->next){
			nextItem->next = li;
			return(1);
		}else{
			return(0);
		}
	}
	return(0);
}
########################rank 2#############################
int mlt_deque_push_back_int( mlt_deque self, int item )
{
	int error = mlt_deque_allocate( self );
	if ( error == 0 )
		self->list[ self->count ++ ].value = item;
	return error;
}
########################rank 3#############################
void pvl_push(pvl_list L, void *d)
{
    struct pvl_elem_t *E = pvl_new_element(d, 0, L->tail);
       E->next = 0;
       E->prior = L->tail;
     */
    if (L->tail != 0) {
        L->tail->next = E;
    }
    if (L->head == 0) {
        L->head = E;
    }
    L->tail = E;
    L->count++;
}
########################rank 4#############################
int list_add_item_after(List_t * list, int idx, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// Move to list index or return 1 if no such index
	while(idx > 0){
		// Insert after last item in list
		if(!nextItem->next){ // Index doesn't exist
			return(0);
		}else{
			nextItem = nextItem->next;
			idx--;
		}
	}
	// Add item after current "nextItem" pointed too.
	if(nextItem->next){ // Middle of list
		if(!li->next){
			ListItem_t * tmpItem = list_item_initialize();
			// Save next item in list
			tmpItem = nextItem->next;
			// Attach new item to current item's next pointer
			nextItem->next = li;
			// Attach "old" next item pointer 
			li->next = tmpItem;
		}else{
			return(0);
		}
	}else if(!nextItem->next){ // End of list
		if(!li->next){
			nextItem->next = li;
		}else{
			return(0);
		}
	}
	return(1);
}
########################rank 5#############################
int max_list_tail(list_ptr ls, int sofar) {
    if (ls == NULL)
	return sofar;
    else
	return max_list_tail(ls->next,
			     max(sofar, ls->val));
}
########################rank 6#############################
int max_list_tail(list_ptr ls, int sofar) {
    if (ls == NULL)
	return sofar;
    else
	return max_list_tail(ls->next,
			     max(sofar, ls->val));
}
########################rank 7#############################
int list_add_item(List_t * list, ListItem_t * li){
	// Temporary "iterator" on the list
	ListItem_t * nextItem = list->head;
	// No head yet
	if(!list->head){
		list->head = li;
		return(1);
	}
	// Move to the end of the list
	while(nextItem->next){
		nextItem = nextItem->next;
	}
	// Made it to the end of the list
	// add the new item to the list.
	if(!li->next){
		nextItem->next = li;
	}else{
		return(0);
	}
	return(1);
}
########################rank 8#############################
int val(list_ptr ls) {
    if (ls == NULL)
	return 0;
    else
	return ls->val;
}
########################rank 9#############################
int val(list_ptr ls) {
    if (ls == NULL)
	return 0;
    else
	return ls->val;
}
########################rank 10#############################
static int sgsstd_va_get_args( SGS_CTX )
{
	uint8_t i, xac, pcnt;
	sgs_StackFrame* sf;
	SGSFN( "va_get_args" );
	if( !C->sf_last || !C->sf_last->prev )
		STDLIB_WARN( "not called from function" )
	sf = C->sf_last->prev;
	pcnt = SGS_MIN( sf->argcount, sf->inexp );
	for( i = 0; i < pcnt; ++i )
		sgs_PushVariable( C, C->stack_base[ sf->argend - pcnt + i ] );
	if( sf->argcount > sf->inexp )
	{
		sgs_Variable* tpv;
		xac = (uint8_t)( sf->argcount - sf->inexp );
		tpv = C->stack_base + sf->argbeg + xac - 1;
		for( i = 0; i < xac; ++i )
			sgs_PushVariable( C, *(tpv - i) );
	}
	sgs_CreateArray( C, NULL, sf->argcount );
	return 1;
}
----------------------------QUERY-------------------------------
restart timer from current point in time
########################rank 1#############################
void
uip_timer_restart(struct uip_timer *t)
{
  t->start = clock_time();
}
########################rank 2#############################
static void LWebTask_Reset(struct LWebTask* task) {
	task->completed = false;
	task->working   = true;
	task->success   = false;
	task->start     = DateTime_CurrentUTC_MS();
	task->res       = 0;
	task->status    = 0;
}
########################rank 3#############################
void
stimer_restart(struct stimer *t)
{
  t->start = clock_seconds();
}
########################rank 4#############################
void
uip_timer_reset(struct uip_timer *t)
{
  t->start += t->interval;
}
########################rank 5#############################
static struct rusage sBegin;  /* CPU time at start */
static sqlite3_int64 iBegin;  /* Wall-clock time at start */
** Begin timing an operation
*/
static void beginTimer( void )
{
  if ( enableTimer )
  {
    getrusage( RUSAGE_SELF, &sBegin );
    iBegin = timeOfDay();
  }
}
########################rank 6#############################
void __start_timer()
{
	gettimeofday(&start, NULL);
}
########################rank 7#############################
void yac_storage_shutdown(void)  {
	yac_allocator_shutdown();
}
########################rank 8#############################
static void CL_GameModule_AsyncStream_Shutdown( void ) {
	AsyncStream_ShutdownModule( cg_async_stream );
	cg_async_stream = NULL;
}
########################rank 9#############################
static void CL_ShutdownAsyncStream( void ) {
	if( !cl_async_stream ) {
		return;
	}
	AsyncStream_ShutdownModule( cl_async_stream );
	cl_async_stream = NULL;
}
########################rank 10#############################
INLINE void TimerBOver(FM_ST *ST)
{
	if(ST->mode & 0x08) FM_STATUS_SET(ST,0x02);
	ST->TBC = ( 256-ST->TB)<<4;
	if (ST->timer_handler) (ST->timer_handler)(ST->param,1,ST->TBC * ST->timer_prescaler,ST->clock);
}
----------------------------QUERY-------------------------------
return file name in path
########################rank 1#############################
char path_file_name[256];
char * getfilename(int idx) {
  sprintf(path_file_name,"%d", idx);
  return path_file_name;
}
########################rank 2#############################
char *find_file(char** path, char* suffix) {
  char *res;
#ifndef WIN32
  struct stat sb;
  int i = 0;
  while (path[i] != NULL) {
    res = concat(path[i], suffix);
    if ( stat(res, &sb) == 0 && S_ISREG(sb.st_mode) ) 
      return res;
    else
      free(res);
    ++i;
  }
#else
  return concat(path[0], suffix);
#endif
  return NULL;
}
########################rank 3#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 4#############################
char *
filename_combine(const char *dirname, const char *filename)
{
	char *result;
	unsigned dirname_length;
	unsigned filename_length;
	unsigned dirname_offset = 0;
	unsigned result_offset = 0;
	unsigned result_max;
	static const struct Keyword slash = {"/", 1};
	struct Keyword prefix;
	unsigned prefix_length;
	filename_length = (unsigned)strlen(filename);
	if (dirname == NULL || dirname[0] == '\0') {
		result = (char*)malloc(filename_length+1);
        if (result == NULL)
            exit(1);
		memcpy(result, filename, filename_length+1);
		return result;
	}
	dirname_length = (unsigned)strlen(dirname);
	while (filename_length && (filename[0] == '/' || filename[0] == '\\')) {
		filename_length--;
		filename++;
	}
	while (dirname_length && (dirname[dirname_length-1] == '/' || filename[0] == '\\'))
		dirname_length--;
	result_max = dirname_length + filename_length + 2;
	result = (char*)malloc(result_max + 1);
    if (result == NULL)
        exit(1);
	 * Get the prefix, which is something like "C:\" on Windows,
	 * or "\\" or "//" also on Windows, or "/" on Unix 
	 */
	prefix = keyword_get_file_prefix(dirname, &dirname_offset, dirname_length);
	keyword_append(result, &result_offset, result_max, prefix);
	if (result_offset && result[result_offset - 1] != '/' && result[result_offset - 1] != '\\')
		keyword_append(result, &result_offset, result_max, slash);
	prefix_length = result_offset;
	combine_elements(result, &result_offset, result_max, prefix_length, dirname, dirname_offset, dirname_length);
	combine_elements(result, &result_offset, result_max, prefix_length, filename, 0, filename_length);
	return result;
}
########################rank 5#############################
SARRAY *
getSortedPathnamesInDirectory(const char  *dirname,
                              const char  *substr,
                              l_int32      firstpage,
                              l_int32      npages)
{
char    *fname, *fullname;
l_int32  i, nfiles, lastpage;
SARRAY  *sa, *safiles, *saout;
    PROCNAME("getSortedPathnamesInDirectory");
    if (!dirname)
        return (SARRAY *)ERROR_PTR("dirname not defined", procName, NULL);
    if ((sa = getFilenamesInDirectory(dirname)) == NULL)
        return (SARRAY *)ERROR_PTR("sa not made", procName, NULL);
    safiles = sarraySelectBySubstring(sa, substr);
    sarrayDestroy(&sa);
    nfiles = sarrayGetCount(safiles);
    if (nfiles == 0) {
        L_WARNING("no files found", procName);
        return safiles;
    }
    sarraySort(safiles, safiles, L_SORT_INCREASING);
    firstpage = L_MIN(L_MAX(firstpage, 0), nfiles - 1);
    if (npages == 0)
        npages = nfiles - firstpage;
    lastpage = L_MIN(firstpage + npages - 1, nfiles - 1);
    saout = sarrayCreate(lastpage - firstpage + 1);
    for (i = firstpage; i <= lastpage; i++) {
        fname = sarrayGetString(safiles, i, L_NOCOPY);
        fullname = genPathname(dirname, fname);
        sarrayAddString(saout, fullname, L_INSERT);
    }
    sarrayDestroy(&safiles);
    return saout;
}
########################rank 6#############################
PRIVATE char *pathsearch(argv0,name,modemask)
char *argv0;
char *name;
int modemask;
{
  char *pathlist;
  char *path,*cp;
  char c;
  extern int access();
#ifdef __WIN32__
  cp = strrchr(argv0,'\\');
#else
  cp = strrchr(argv0,'/');
#endif
  if( cp ){
    c = *cp;
    *cp = 0;
    path = (char *)malloc( strlen(argv0) + strlen(name) + 2 );
    if( path ) sprintf(path,"%s/%s",argv0,name);
    *cp = c;
  }else{
    extern char *getenv();
    pathlist = getenv("PATH");
    if( pathlist==0 ) pathlist = ".:/bin:/usr/bin";
    path = (char *)malloc( strlen(pathlist)+strlen(name)+2 );
    if( path!=0 ){
      while( *pathlist ){
        cp = strchr(pathlist,':');
        if( cp==0 ) cp = &pathlist[strlen(pathlist)];
        c = *cp;
        *cp = 0;
        sprintf(path,"%s/%s",pathlist,name);
        *cp = c;
        if( c==0 ) pathlist = "";
        else pathlist = &cp[1];
        if( access(path,modemask)==0 ) break;
      }
    }
  }
  return path;
}
########################rank 7#############################
int
_open(const char *path, int flags, ...)
{
  return -1;
}
########################rank 8#############################
char* FStringGetDirname(FString* pFString)
{
	char* ptr = FStringGetString(pFString);
	if (ptr != NULL)
		return basename(ptr);
	return NULL;
}
########################rank 9#############################
int make_valid_path(char *dir, mode_t mode)
{
    struct stat st;
    char *tmp = NULL, *path = stripslash(strdup(dir));
    int retval;
    if (stat(path, &st) == 0) { /* file exists */
        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
        else { retval = 0; goto end; } /* not a directory.  Oops. */
    }
    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
    retval = 1;
end:
    if (tmp != NULL) free(tmp);
    if (path != NULL) free(path);
    return retval;
}
########################rank 10#############################
const char *Sys_Dirname( char *path )
{
	return dirname( path );
}
----------------------------QUERY-------------------------------
get name of current executable
########################rank 1#############################
char *tgetstr(bp, id, area)
    register char *bp;
    char *id, **area;
{
    for (;;) {
        bp = tskip(bp);
        if (!*bp)
            return (0);
        if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
            continue;
        if (*bp == '@')
            return(0);
        if (*bp != '=')
            continue;
        bp++;
        return tdecode(bp, area);
    }
}
########################rank 2#############################
char *
selGetName(SEL  *sel)
{
    PROCNAME("selGetName");
    if (!sel)
        return (char *)ERROR_PTR("sel not defined", procName, NULL);
    return sel->name;
}
########################rank 3#############################
static short FGetLittleShort( fileHandle_t f ) {
	short	v;
	FS_Read( &v, sizeof(v), f );
	return LittleShort( v);
}
########################rank 4#############################
const char *
HBF_GetProperty(HBF *handle, const char *propertyName)
{
	return hbfProperty(handle, propertyName);
}
########################rank 5#############################
char *
pixGetText(PIX  *pix)
{
    PROCNAME("pixGetText");
    if (!pix)
        return (char *)ERROR_PTR("pix not defined", procName, NULL);
    return pix->text;
}
########################rank 6#############################
void *fxp_get_userdata(struct sftp_request *req)
{
    return req->userdata;
}
########################rank 7#############################
L_RECOGA *
recogGetParent(L_RECOG  *recog)
{
    PROCNAME("recogGetParent");
    if (!recog)
        return (L_RECOGA *)ERROR_PTR("recog not defined", procName, NULL);
    return recog->parent;
}
########################rank 8#############################
l_int32
recogGetCount(L_RECOG  *recog)
{
    PROCNAME("recogGetCount");
    if (!recog)
        return ERROR_INT("recog not defined", procName, 0);
    return recog->setsize;
}
########################rank 9#############################
PIX *
pixaccGetPix(PIXACC  *pixacc)
{
    PROCNAME("pixaccGetPix");
    if (!pixacc)
        return (PIX *)ERROR_PTR("pixacc not defined", procName, NULL);
    return pixacc->pix;
}
########################rank 10#############################
signed char shellCheckPermission(Shell *shell, ShellCommand *command)
{
    return ((!command->attr.attrs.permission
                || command->attr.attrs.type == SHELL_TYPE_USER
                || (command->attr.attrs.permission 
                    & shell->info.user->attr.attrs.permission))
            && (shell->status.isChecked
                || command->attr.attrs.enableUnchecked))
            ? 0 : -1;
}
----------------------------QUERY-------------------------------
read machine uptime
########################rank 1#############################
HTS221_Error_et HTS221_Get_DeviceID(void *handle, uint8_t* deviceid)
{
  if(HTS221_ReadReg(handle, HTS221_WHO_AM_I_REG, 1, deviceid))
    return HTS221_ERROR;
  return HTS221_OK;
}
########################rank 2#############################
int32_t lis3dsh_bus_mode_set(stmdev_ctx_t *ctx, lis3dsh_bus_mode_t *val)
{
  lis3dsh_ctrl_reg5_t ctrl_reg5;
  int32_t ret;
  ret = lis3dsh_read_reg(ctx, LIS3DSH_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  if (ret == 0) {
    ctrl_reg5.sim = (uint8_t)*val;
    ret = lis3dsh_read_reg(ctx, LIS3DSH_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  }
  return ret;
}
########################rank 3#############################
HTS221_Error_et HTS221_Set_AvgHT(void *handle, HTS221_Avgh_et avgh, HTS221_Avgt_et avgt)
{
  uint8_t tmp;
  HTS221_assert_param(IS_HTS221_AVGH(avgh));
  HTS221_assert_param(IS_HTS221_AVGT(avgt));
  if(HTS221_ReadReg(handle, HTS221_AV_CONF_REG, 1, &tmp))
    return HTS221_ERROR;
  tmp &= ~(HTS221_AVGH_MASK | HTS221_AVGT_MASK);
  tmp |= (uint8_t)avgh;
  tmp |= (uint8_t)avgt;
  if(HTS221_WriteReg(handle, HTS221_AV_CONF_REG, 1, &tmp))
    return HTS221_ERROR;
  return HTS221_OK;
}
########################rank 4#############################
static void init(ambit_object_t *object, uint32_t driver_param)
{
    struct ambit_device_driver_data_s *data;
    if ((data = calloc(1, sizeof(struct ambit_device_driver_data_s))) != NULL) {
        object->driver_data = data;
        libambit_pmem20_init(&object->driver_data->pmem20, object, driver_param);
    }
}
########################rank 5#############################
int32_t lis3dsh_bus_mode_get(stmdev_ctx_t *ctx, lis3dsh_bus_mode_t *val)
{
  lis3dsh_ctrl_reg5_t ctrl_reg5;
  int32_t ret;
  ret = lis3dsh_read_reg(ctx, LIS3DSH_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  switch ( ctrl_reg5.sim ) {
    case LIS3DSH_SEL_BY_HW:
      *val = LIS3DSH_SEL_BY_HW;
      break;
    case LIS3DSH_SPI_3W:
      *val = LIS3DSH_SPI_3W;
      break;
    default:
      *val = LIS3DSH_SEL_BY_HW;
      break;
  }
  return ret;
}
########################rank 6#############################
uint16_t ft6x06_ReadID(uint16_t DeviceAddr)
{
  TS_IO_Init();
  return (TS_IO_Read(DeviceAddr, FT6206_CHIP_ID_REG));
}
########################rank 7#############################
void eldexp( x, pwr2, y )
unsigned short x[];
long pwr2;
unsigned short y[];
{
unsigned short xi[NI];
long li;
int i;
emovi( x, xi );
li = xi[1];
li += pwr2;
i = 0;
emdnorm( xi, i, i, li, 64 );
emovo( xi, y );
}
########################rank 8#############################
void stmpe811_IO_SetEdgeMode(uint16_t DeviceAddr, uint32_t IO_Pin, uint8_t Edge)
{
  uint8_t tmp1 = 0, tmp2 = 0;   
  tmp1 = IOE_Read(DeviceAddr, STMPE811_REG_IO_FE);
  tmp2 = IOE_Read(DeviceAddr, STMPE811_REG_IO_RE);
  tmp1 &= ~(uint8_t)IO_Pin;
  tmp2 &= ~(uint8_t)IO_Pin;
  if (Edge & STMPE811_EDGE_FALLING)
  {
    tmp1 |= (uint8_t)IO_Pin;
  }
  if (Edge & STMPE811_EDGE_RISING)
  {
    tmp2 |= (uint8_t)IO_Pin;
  }
  IOE_Write(DeviceAddr, STMPE811_REG_IO_FE, tmp1);
  IOE_Write(DeviceAddr, STMPE811_REG_IO_RE, tmp2);
}
########################rank 9#############################
int32_t lis3dsh_id_get(stmdev_ctx_t *ctx, lis3dsh_id_t *val)
{
  uint8_t reg[3];
  int32_t ret;
  ret = lis3dsh_read_reg(ctx, LIS3DSH_INFO1,reg, 3);
  val->info1  = reg[0];
  val->info2  = reg[1];
  val->whoami = reg[2];
  return ret;
}
########################rank 10#############################
int32_t lis3dsh_mode_get(stmdev_ctx_t *ctx, lis3dsh_md_t *val)
{
  lis3dsh_ctrl_reg4_t ctrl_reg4;
  lis3dsh_ctrl_reg5_t ctrl_reg5;
  int32_t ret;
  ret = lis3dsh_read_reg(ctx, LIS3DSH_CTRL_REG4, (uint8_t*)&ctrl_reg4, 1);
  if (ret == 0) {
    ret = lis3dsh_read_reg(ctx, LIS3DSH_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  }
  switch (ctrl_reg4.odr) {
    case LIS3DSH_OFF:
      val->odr = LIS3DSH_OFF;
      break;
    case LIS3DSH_3Hz125:
      val->odr = LIS3DSH_3Hz125;
      break;
    case LIS3DSH_6Hz25:
      val->odr = LIS3DSH_6Hz25;
      break;
    case LIS3DSH_12Hz5:
      val->odr = LIS3DSH_12Hz5;
      break;
    case LIS3DSH_25Hz:
      val->odr = LIS3DSH_25Hz;
      break;
    case LIS3DSH_50Hz:
      val->odr = LIS3DSH_50Hz;
      break;
    case LIS3DSH_100Hz:
      val->odr = LIS3DSH_100Hz;
      break;
    case LIS3DSH_400Hz:
      val->odr = LIS3DSH_400Hz;
      break;
    case LIS3DSH_800Hz:
      val->odr = LIS3DSH_800Hz;
      break;
    case LIS3DSH_1kHz6:
      val->odr = LIS3DSH_1kHz6;
      break;
    default:
      val->odr = LIS3DSH_OFF;
      break;
  }
  switch (ctrl_reg5.fscale) {
    case LIS3DSH_2g:
      val->fs = LIS3DSH_2g;
      break;
    case LIS3DSH_4g:
      val->fs = LIS3DSH_4g;
      break;
    case LIS3DSH_6g:
      val->fs = LIS3DSH_6g;
      break;
    case LIS3DSH_8g:
      val->fs = LIS3DSH_8g;
      break;
    case LIS3DSH_16g:
      val->fs = LIS3DSH_16g;
      break;
    default:
      val->fs = LIS3DSH_2g;
      break;
  }
  return ret;
}
----------------------------QUERY-------------------------------
store integer into register
########################rank 1#############################
void op_int_store(struct svm *svm)
{
    unsigned int reg = next_byte(svm);
    BOUNDS_TEST_REGISTER(reg);
    unsigned int val1 = next_byte(svm);
    unsigned int val2 = next_byte(svm);
    int value = BYTES_TO_ADDR(val1, val2);
    if (getenv("DEBUG") != NULL)
        printf("STORE_INT(Reg:%02x) => %04d [Hex:%04x]\n", reg, value, value);
    if ((svm->registers[reg].type == STRING) && (svm->registers[reg].content.string))
        free(svm->registers[reg].content.string);
    svm->registers[reg].content.integer = value;
    svm->registers[reg].type = INTEGER;
    svm->ip += 1;
}
########################rank 2#############################
void nrf24_configRegister(uint8_t reg, uint8_t value)
{
    nrf24_csn_digitalWrite(LOW);
    spi_transfer(W_REGISTER | (REGISTER_MASK & reg));
    spi_transfer(value);
    nrf24_csn_digitalWrite(HIGH);
}
########################rank 3#############################
int32_t LAN8742_EnableIT(lan8742_Object_t *pObj, uint32_t Interrupt)
{
    uint32_t readval = 0;
    int32_t status = LAN8742_STATUS_OK;
    if (pObj->IO.ReadReg(pObj->DevAddr, LAN8742_IMR, &readval) >= 0) {
        readval |= Interrupt;
        if (pObj->IO.WriteReg(pObj->DevAddr, LAN8742_IMR, readval) < 0) {
            status =  LAN8742_STATUS_WRITE_ERROR;
        }
    } else {
        status = LAN8742_STATUS_READ_ERROR;
    }
    return status;
}
########################rank 4#############################
static void do_o_set_property(lily_vm_state *vm, uint16_t *code, int code_pos)
{
    lily_value **vm_regs = vm->vm_regs;
    lily_value *rhs_reg;
    int index;
    lily_instance_val *ival;
    ival = vm_regs[code[code_pos + 2]]->value.instance;
    index = code[code_pos + 3];
    rhs_reg = vm_regs[code[code_pos + 4]];
    lily_assign_value(vm, ival->values[index], rhs_reg);
}
########################rank 5#############################
qboolean LAN_UpdateVisiblePings( int source ) {
	return CL_UpdateVisiblePings_f( source );
}
########################rank 6#############################
qboolean LAN_UpdateVisiblePings( int source ) {
	return CL_UpdateVisiblePings_f( source );
}
########################rank 7#############################
static void myGpioSetMode(unsigned gpio, unsigned mode)
{
   int reg, shift;
   reg   =  gpio/10;
   shift = (gpio%10) * 3;
   gpioReg[reg] = (gpioReg[reg] & ~(7<<shift)) | (mode<<shift);
}
########################rank 8#############################
BMP280_RETURN_FUNCTION_TYPE bmp280_set_spi3(uint8_t v_enable_disable_u8)
{
	BMP280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	uint8_t v_data_u8 = BMP280_INIT_VALUE;
	if (p_bmp280 == BMP280_NULL) {
		return  E_BMP280_NULL_PTR;
	} else {
		com_rslt = p_bmp280->bus_read(p_bmp280->dev_addr,
				BMP280_CONFIG_REG_SPI3_ENABLE__REG, &v_data_u8,
				BMP280_GEN_READ_WRITE_DATA_LENGTH);
		if (com_rslt == SUCCESS) {
			v_data_u8 = BMP280_SET_BITSLICE(v_data_u8,
					BMP280_CONFIG_REG_SPI3_ENABLE,
					v_enable_disable_u8);
			com_rslt += p_bmp280->bus_write(
					p_bmp280->dev_addr,
					BMP280_CONFIG_REG_SPI3_ENABLE__REG,
					&v_data_u8,
					BMP280_GEN_READ_WRITE_DATA_LENGTH);
		}
	}
	return com_rslt;
}
########################rank 9#############################
BMP280_RETURN_FUNCTION_TYPE bmp280_get_spi3(uint8_t *v_enable_disable_u8)
{
	BMP280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	uint8_t v_data_u8 = BMP280_INIT_VALUE;
	if (p_bmp280 == BMP280_NULL) {
		return  E_BMP280_NULL_PTR;
	} else {
		com_rslt = p_bmp280->bus_read(p_bmp280->dev_addr,
				BMP280_CONFIG_REG_SPI3_ENABLE__REG, &v_data_u8,
				BMP280_GEN_READ_WRITE_DATA_LENGTH);
		*v_enable_disable_u8 = BMP280_GET_BITSLICE(v_data_u8,
				BMP280_CONFIG_REG_SPI3_ENABLE);
	}
	return com_rslt;
}
########################rank 10#############################
uint8_t si5351c_read_single(si5351c_driver_t* const drv, uint8_t reg)
{
	const uint8_t data_tx[] = { reg };
	uint8_t data_rx[] = { 0x00 };
	i2c_bus_transfer(drv->bus, drv->i2c_address, data_tx, 1, data_rx, 1);
	return data_rx[0];
}
----------------------------QUERY-------------------------------
stop stream server
########################rank 1#############################
static int
_local_io_close(stream_id nst)
{
    int err;
    Check_Stream_Owner(nst);
    if (IsSocket(nst))
    {
	if (SocketUnix(nst) != D_UNKNOWN)
	    (void) ec_unlink(DidName(SocketUnix(nst)));
	(void) ec_stream_reset_sigio(nst, SWRITE);
	if (SocketInputStream(nst))
	    (void) ec_stream_reset_sigio(nst, SREAD);
    }
#if defined(HAVE_READLINE)
    if (IsReadlineStream(nst)) {
	if (fclose(StreamFILE(nst)) < 0)
	{
	    Set_Errno
	    return(SYS_ERROR);
	}
    }
#endif
    if ((err = StreamMethods(nst).close(StreamUnit(nst))) != PSUCCEED)
    {
	return err;
    }
#if _WIN32
    if (IsSocket(nst))
    {
	int dummy;
	stream_id inst;
	if (nst->signal_thread)
	{
	    ec_thread_wait(nst->signal_thread, &dummy, THREAD_TIMEOUT);
	    if (ec_thread_terminate(nst->signal_thread, THREAD_TIMEOUT) < 0)
		return SYS_ERROR;
	    nst->signal_thread = 0;
	}
	if ((inst = SocketInputStream(nst)) && inst->signal_thread)
	{
	    ec_thread_wait(inst->signal_thread, &dummy, THREAD_TIMEOUT);
	    if (ec_thread_terminate(inst->signal_thread, THREAD_TIMEOUT) < 0)
		return SYS_ERROR;
	    inst->signal_thread = 0;
	}
    }
#endif
    return(PSUCCEED);
}
########################rank 2#############################
static void SV_Web_ResetResponse( sv_http_response_t *response ) {
	if( response->filename ) {
		Mem_Free( response->filename );
		response->filename = NULL;
	}
	if( response->file ) {
		FS_FCloseFile( response->file );
		response->file = 0;
	}
	response->fileno = -1;
	response->file_data_offset = 0;
	response->file_send_pos = 0;
	response->content_state = CONTENT_STATE_DEFAULT;
	if( response->content ) {
		Mem_Free( response->content );
		response->content = NULL;
	}
	response->content_length = 0;
	SV_Web_ResetStream( &response->stream );
	response->code = HTTP_RESP_NONE;
}
########################rank 3#############################
int rtnl_receive(struct rtnl_handle *rtnl_handle)
{
	int status;
	char buf[8192];
	struct sockaddr_nl nladdr;
	struct iovec iov = { buf, sizeof(buf) };
	struct nlmsghdr *h;
	struct msghdr msg = {
		.msg_name    = &nladdr,
		.msg_namelen = sizeof(nladdr),
		.msg_iov     = &iov,
		.msg_iovlen  = 1,
	};
	status = recvmsg(rtnl_handle->rtnl_fd, &msg, 0);
	if (status < 0) {
		if (errno == EINTR)
			return 0;
		rtnl_log(LOG_NOTICE, "OVERRUN on rtnl socket");
		return -1;
	}
	if (status == 0) {
		rtnl_log(LOG_ERROR, "EOF on rtnl socket");
		return -1;
	}
	if (msg.msg_namelen != sizeof(nladdr)) {
		rtnl_log(LOG_ERROR, "invalid address size");
		return -1;
	}
	h = (struct nlmsghdr *) buf;
	while (NLMSG_OK(h, status)) {
#if 0
		if (h->nlmsg_pid != rtnl_local.nl_pid ||
		    h->nlmsg_seq != rtnl_dump) {
			goto skip;
		}
#endif
		if (h->nlmsg_type == NLMSG_DONE) {
			rtnl_log(LOG_NOTICE, "NLMSG_DONE");
			return 0;
		}
		if (h->nlmsg_type == NLMSG_ERROR) { 
			struct nlmsgerr *err = NLMSG_DATA(h);
			if (h->nlmsg_len>=NLMSG_LENGTH(sizeof(struct nlmsgerr)))
				errno = -err->error;
			rtnl_log(LOG_ERROR, "NLMSG_ERROR, errnp=%d",
				 errno);
			return -1;
		}
		if (call_handler(rtnl_handle, h->nlmsg_type, h) == 0) 
			rtnl_log(LOG_NOTICE, "unhandled nlmsg_type %u",
				 h->nlmsg_type);
		h = NLMSG_NEXT(h, status);
	}
	return 1;
}
########################rank 4#############################
static void *consumer_get(size_t *sz)
{
    pthread_mutex_lock(&g_producer.mutex);
    while(true)
    {
        if(g_producer.stop)
        {
            pthread_mutex_unlock(&g_producer.mutex);
            return NULL;
        }
        if(g_producer.chunk)
            break;
        pthread_cond_signal(&g_producer.req_cond);
        pthread_cond_wait(&g_producer.avail_cond, &g_producer.mutex);
    }
    void *c = g_producer.chunk;
    if(sz)
        *sz = g_producer.chunk_sz;
    g_producer.chunk = NULL;
    pthread_mutex_unlock(&g_producer.mutex);
     * will also wake them up */
    pthread_cond_signal(&g_producer.req_cond);
    return c;
}
########################rank 5#############################
static void close_connection(struct xdag_rpc_connection* conn)
{
	shutdown(conn->fd.fd, SHUT_WR);
	recv(conn->fd.fd, NULL, 0, 0);
	close(conn->fd.fd);
	free(conn);
}
########################rank 6#############################
extern void strsvrstop(strsvr_t *svr, const char *cmd)
{
    tracet(3,"strsvrstop:\n");
    if (cmd) strsendcmd(svr->stream,cmd);
    svr->state=0;
#ifdef WIN32
    WaitForSingleObject(svr->thread,10000);
    CloseHandle(svr->thread);
#else
    pthread_join(svr->thread,NULL);
#endif
}
########################rank 7#############################
void freeBlockedClientData(RedisModuleCtx *ctx, BlockedClientData *bcd) {
    for (int j = 0; j < bcd->numqueues; j++)
        RedisModule_FreeString(ctx,bcd->queues[j]);
    RedisModule_Free(bcd->queues);
    RedisModule_Free(bcd);
}
########################rank 8#############################
static int TS_program_packet_hdr(uint32_t pid,
                                 int      data_len,
                                 byte     TS_hdr[TS_PACKET_SIZE],
                                 int     *TS_hdr_len)
{
  uint32_t controls = 0;
  int     pointer, ii;
  if (data_len > (TS_PACKET_SIZE - 5))  // i.e., 183
  {
    fprint_err("### PMT/PAT data for PID %02x is too long (%d > 183)",
               pid,data_len);
    return 1;
  }
  // We always start with a sync_byte to identify this as a
  // Transport Stream packet
  TS_hdr[0] = 0x47;
  // We want the "payload_unit_start_indicator" bit set
  TS_hdr[1] = (byte)(0x40 | ((pid & 0x1f00) >> 8));
  TS_hdr[2] = (byte)(pid & 0xff);
  // We don't need any adaptation field controls
  controls = 0x10;
  TS_hdr[3] = (byte)(controls | next_continuity_count(pid));
  // Next comes a pointer to the actual payload data
  // (i.e., 0 if the data is 183 bytes long)
  // followed by pad bytes until we *get* to the data
  pointer = (byte)(TS_PACKET_SIZE - 5 - data_len);
  TS_hdr[4] = pointer;
  for (ii=0; ii<pointer; ii++)
    TS_hdr[5+ii] = 0xff;
  *TS_hdr_len = 5+pointer;
  return 0;
}
########################rank 9#############################
static bool CL_MM_LoginSteam( void ) {
	int64_t start_time;
	if( cl_mm_loginState >= LOGIN_STATE_WAITING || cl_mm_enabled ) {
		// already authed or in process
		return false;
	}
	cl_mm_login_steam_complete = false;
	cl_mm_login_steam_ok = false;
	if( cl_mm_steam_token != NULL ) {
		Mem_Free( cl_mm_steam_token );
		cl_mm_steam_token = NULL;
	}
	if( Steam_GetAuthSessionTicket( &CL_MM_LoginSteamCb ) == 0 ) {
		return false;
	}
	// wait for GetAuthSessionTicket callback but not for too long
	start_time = Sys_Milliseconds();
	while( !cl_mm_login_steam_complete ) {
		if( Sys_Milliseconds() > start_time + MM_STEAM_TICKET_AUTH_TIMEOUT ) {
			break;
		}
		Steam_RunFrame();
	}
	return cl_mm_login_steam_ok;
}
########################rank 10#############################
static int ProcessHeader(FCGI_Header header, FCGX_Stream *stream)
{
    FCGX_Stream_Data *data = (FCGX_Stream_Data *)stream->data;
    int requestId;
    if(header.version != FCGI_VERSION_1) {
        return FCGX_UNSUPPORTED_VERSION;
    }
    requestId =        (header.requestIdB1 << 8)
                         + header.requestIdB0;
    data->contentLen = (header.contentLengthB1 << 8)
                         + header.contentLengthB0;
    data->paddingLen = header.paddingLength;
    if(header.type == FCGI_BEGIN_REQUEST) {
        return ProcessBeginRecord(requestId, stream);
    }
    if(requestId  == FCGI_NULL_REQUEST_ID) {
        return ProcessManagementRecord(header.type, stream);
    }
    if(requestId != data->reqDataPtr->requestId) {
        return SKIP;
    }
    if(header.type != data->type) {
        return FCGX_PROTOCOL_ERROR;
    }
    return STREAM_RECORD;
}
----------------------------QUERY-------------------------------
get length of UCS2 string
########################rank 1#############################
int u8_wc_toutf8_nul(char *dest, uint32_t ch)
{
  int sz = u8_wc_toutf8(dest,ch);
  dest[sz] = '\0';
  return sz;
}
########################rank 2#############################
int u8_wc_toutf8_nul(char *dest, uint32_t ch)
{
  int sz = u8_wc_toutf8(dest,ch);
  dest[sz] = '\0';
  return sz;
}
########################rank 3#############################
int u8_wc_toutf8_nul(char *dest, uint32_t ch)
{
  int sz = u8_wc_toutf8(dest,ch);
  dest[sz] = '\0';
  return sz;
}
########################rank 4#############################
long double atold(const char *str)
{
	return strtold(str, NULL);
}
########################rank 5#############################
static int tonum(char *buff, const char *sep, double *v)
{
    int n,len=(int)strlen(sep);
    char *p,*q;
    for (p=buff,n=0;n<MAXFIELD;p=q+len) {
        if ((q=strstr(p,sep))) *q='\0'; 
        if (*p) v[n++]=atof(p);
        if (!q) break;
    }
    return n;
}
########################rank 6#############################
static size_t
chrsw(const char str[], size_t char_width)
{
	const wchar_t wide = utf8_char_to_wchar(str, char_width);
	const size_t result = vifm_wcwidth(wide);
	return (result == (size_t)-1) ? 1 : result;
}
########################rank 7#############################
static int get_lang(char *b)
{
	char *s;
	s = getenv("LANG");
	if (!s || strlen(s) < 2)
		return -1;
	b[0] = s[0];
	b[1] = s[1];
	b[2] = '\0';
	return 0;
}
########################rank 8#############################
int len(char *s) {
    return strlen(s);
}
########################rank 9#############################
int len(char *s) {
    return strlen(s);
}
########################rank 10#############################
struct bwstring *
ignore_case(struct bwstring *str)
{
	if (MB_CUR_MAX == 1) {
		unsigned char *end, *s;
		s = str->data.cstr;
		end = s + str->len;
		while (s < end) {
			*s = toupper(*s);
			++s;
		}
	} else {
		wchar_t *end, *s;
		s = str->data.wstr;
		end = s + str->len;
		while (s < end) {
			*s = towupper(*s);
			++s;
		}
	}
	return (str);
}
----------------------------QUERY-------------------------------
contrain maximum of a range
########################rank 1#############################
bool vec2_is_zero(mfloat_t *a)
{
	return nearly_equal(a[0], MFLOAT_C(0.0), MFLT_EPSILON) && nearly_equal(a[1], MFLOAT_C(0.0), MFLT_EPSILON);
}
########################rank 2#############################
char upc_check(char source[])
{ /* Calculate the correct check digit for a UPC barcode */
	unsigned int i, count, check_digit;
	count = 0;
	for (i = 0; i < strlen(source); i++) {
		count += ctoi(source[i]);
		if (!(i & 1)) {
			count += 2 * (ctoi(source[i]));
		}
	}
	check_digit = 10 - (count%10);
	if (check_digit == 10) { check_digit = 0; }
	return itoc(check_digit);
}
########################rank 3#############################
static
FT_UInt  code_to_index4( TT_CMapTable*  cmap,
						 FT_ULong charCode ) {
	FT_UInt result, index1, segCount;
	TT_CMap4*        cmap4;
	TT_CMap4Segment  *seg4, *limit;
	cmap4    = &cmap->c.cmap4;
	result   = 0;
	segCount = cmap4->segCountX2 / 2;
	seg4     = cmap4->segments;
	limit    = seg4 + segCount;
	seg4 = cmap4->last_segment;
	if ( (FT_ULong)( charCode       - seg4->startCount ) <
		 (FT_ULong)( seg4->endCount - seg4->startCount ) ) {
		goto Found;
	}
	for ( seg4 = cmap4->segments; seg4 < limit; seg4++ )
	{
		if ( charCode > seg4->endCount ) {
			continue;
		}
		if ( charCode >= seg4->startCount ) {
			goto Found;
		}
	}
	return 0;
Found:
	cmap4->last_segment = seg4;
	if ( seg4->idRangeOffset == 0 ) {
		result = ( charCode + seg4->idDelta ) & 0xFFFF;
	} else
	{
		index1 = seg4->idRangeOffset / 2
				 + ( charCode - seg4->startCount )
				 + ( seg4 - cmap4->segments )
				 - segCount;
		if ( index1 < cmap4->numGlyphId       &&
			 cmap4->glyphIdArray[index1] != 0 ) {
			result = ( cmap4->glyphIdArray[index1] + seg4->idDelta ) & 0xFFFF;
		}
	}
	return result;
}
########################rank 4#############################
mfloat_t quadratic_ease_in(mfloat_t p)
{
	return p * p;
}
########################rank 5#############################
bool vec4_is_zero(mfloat_t *a)
{
	return nearly_equal(a[0], MFLOAT_C(0.0), MFLT_EPSILON) && nearly_equal(a[1], MFLOAT_C(0.0), MFLT_EPSILON) && nearly_equal(a[2], MFLOAT_C(0.0), MFLT_EPSILON) && nearly_equal(a[3], MFLOAT_C(0.0), MFLT_EPSILON);
}
########################rank 6#############################
int write_jedec_1(struct flashctx *flash, const uint8_t *src, unsigned int start,
		  unsigned int len)
{
	unsigned int i;
	int failed = 0;
	chipaddr dst = flash->virtual_memory + start;
	chipaddr olddst;
	unsigned int mask;
	mask = getaddrmask(flash->chip);
	olddst = dst;
	for (i = 0; i < len; i++) {
		if (write_byte_program_jedec_common(flash, src, dst, mask))
			failed = 1;
		dst++, src++;
	}
	if (failed)
		msg_cerr(" writing sector at 0x%" PRIxPTR " failed!\n", olddst);
	return failed;
}
########################rank 7#############################
int vorbis_book_errorv(codebook *book,float *a){
  int dim=book->dim,k;
  int best=_best(book,a,1);
  for(k=0;k<dim;k++)
    a[k]=(book->valuelist+best*dim)[k];
  return(best);
}
########################rank 8#############################
int lcount = 0;
int se_max(int x, int y) {
    return (x < y) ? (lcount++, y) : x;
}
########################rank 9#############################
int lcount = 0;
int se_max(int x, int y)
{
    return (x < y) ? (lcount++, y) : x;
}
########################rank 10#############################
int __bound_delete_region(void *p)
{
    unsigned long start, end, addr, size, empty_size;
    BoundEntry *page, *e, *e2;
    int t1_start, t1_end, t2_start, t2_end, i;
    start = (unsigned long)p;
    t1_start = start >> (BOUND_T2_BITS + BOUND_T3_BITS);
    t2_start = (start >> (BOUND_T3_BITS - BOUND_E_BITS)) & 
        ((BOUND_T2_SIZE - 1) << BOUND_E_BITS);
    page = __bound_t1[t1_start];
    e = (BoundEntry *)((char *)page + t2_start);
    addr = start - e->start;
    if (addr > e->size)
        e = __bound_find_region(e, p);
    if (e->size == EMPTY_SIZE || (unsigned long)p != e->start) 
        return -1;
    if (e->is_invalid)
        empty_size = INVALID_SIZE;
    else
        empty_size = EMPTY_SIZE;
    size = e->size;
    end = start + size;
    t1_end = end >> (BOUND_T2_BITS + BOUND_T3_BITS);
    t2_end = (end >> (BOUND_T3_BITS - BOUND_E_BITS)) & 
        ((BOUND_T2_SIZE - 1) << BOUND_E_BITS);
    delete_region(e, p, empty_size);
    if (t1_end == t1_start) {
        e2 = (BoundEntry *)((char *)page + t2_end);
        if (e2 > e) {
            e++;
            for(;e<e2;e++) {
                e->start = 0;
                e->size = empty_size;
            }
            delete_region(e, p, empty_size);
        }
    } else {
        e2 = page + BOUND_T2_SIZE;
        e++;
        for(;e<e2;e++) {
            e->start = 0;
            e->size = empty_size;
        }
        for(i=t1_start+1;i<t1_end;i++) {
            page = get_page(i);
            e2 = page + BOUND_T2_SIZE;
            for(e=page;e<e2;e++) {
                e->start = 0;
                e->size = empty_size;
            }
        }
        page = get_page(t1_end);
        e2 = (BoundEntry *)((char *)page + t2_end);
        for(e=page;e<e2;e++) {
            e->start = 0;
            e->size = empty_size;
        }
        delete_region(e, p, empty_size);
    }
    return 0;
}
----------------------------QUERY-------------------------------
pad given buffer with len padding characters
########################rank 1#############################
static void pad(unsigned char *buf, int len)
{
	for (int i = 0; i < len; i++)
		buf[i] = PADDING_CHAR;
}
########################rank 2#############################
static void ZeroU8( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    unsigned char *dest = (unsigned char*)destinationBuffer;
    while( count-- )
    {
        *dest = 128;
        dest += destinationStride;
    }
}
########################rank 3#############################
static void
append_byte(unsigned char *buf, size_t *buf_length, size_t buf_max, unsigned c)
{
    if (*buf_length < buf_max)
        buf[(*buf_length)++] = (unsigned char)c;
}
########################rank 4#############################
static void
append_byte(unsigned char *buf, size_t *buf_length, size_t buf_max, unsigned c)
{
    if (*buf_length < buf_max)
        buf[(*buf_length)++] = (unsigned char)c;
}
########################rank 5#############################
static void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
########################rank 6#############################
static int addFloatSamplesToInputBuffer(
    sonicStream stream,
    float *samples,
    int numSamples)
{
    short *buffer;
    int count = numSamples*stream->numChannels;
    if(numSamples == 0) {
	return 1;
    }
    if(!enlargeInputBufferIfNeeded(stream, numSamples)) {
	return 0;
    }
    buffer = stream->inputBuffer + stream->numInputSamples*stream->numChannels;
    while(count--) {
        *buffer++ = (*samples++)*32767.0f;
    }
    stream->numInputSamples += numSamples;
    return 1;
}
########################rank 7#############################
unsigned char *cuEnc64(const unsigned char *inbuf,
	unsigned inlen,
	unsigned *outlen)		// RETURNED
{
	return cuEnc64WithLines(inbuf, inlen, 0, outlen);
}
########################rank 8#############################
static void Zero16( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    PaUint16 *dest = (PaUint16 *)destinationBuffer;
    while( count-- )
    {
        *dest = 0;
        dest += destinationStride;
    }
}
########################rank 9#############################
static void Zero32( void *destinationBuffer, signed int destinationStride,
        unsigned int count )
{
    PaUint32 *dest = (PaUint32 *)destinationBuffer;
    while( count-- )
    {
        *dest = 0;
        dest += destinationStride;
    }
}
########################rank 10#############################
void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
    if (len < 64) {
        buf[0] = len | LP_ENCODING_6BIT_STR;
        memcpy(buf+1,s,len);
    } else if (len < 4096) {
        buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
        buf[1] = len & 0xff;
        memcpy(buf+2,s,len);
    } else {
        buf[0] = LP_ENCODING_32BIT_STR;
        buf[1] = len & 0xff;
        buf[2] = (len >> 8) & 0xff;
        buf[3] = (len >> 16) & 0xff;
        buf[4] = (len >> 24) & 0xff;
        memcpy(buf+5,s,len);
    }
}
----------------------------QUERY-------------------------------
write data in output buffers to client
########################rank 1#############################
static int write_EOF_to_buffered_TS_output(buffered_TS_output_p  writer)
{
  int  err;
  // Make sure anything we were working on beforehand has been output
  internal_flush_buffered_TS_output(writer);
  if (global_parent_debug)
    print_msg("--> writing EOF\n");
  err = add_eof_entry(writer);
  if (err)
  {
    print_err("### Error adding EOF indicator\n");
    return 1;
  }
  return 0;
}
########################rank 2#############################
int writeToClient(int fd, client *c, int handler_installed) {
    ssize_t nwritten = 0, totwritten = 0;
    size_t objlen;
    sds o;
    while(clientHasPendingReplies(c)) {
        if (c->bufpos > 0) {
            nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;
             * the remainder of the reply. */
            if (c->sentlen == c->bufpos) {
                c->bufpos = 0;
                c->sentlen = 0;
            }
        } else {
            o = listNodeValue(listFirst(c->reply));
            objlen = sdslen(o);
            if (objlen == 0) {
                listDelNode(c->reply,listFirst(c->reply));
                continue;
            }
            nwritten = write(fd, o + c->sentlen, objlen - c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;
            if (c->sentlen == objlen) {
                listDelNode(c->reply,listFirst(c->reply));
                c->sentlen = 0;
                c->reply_bytes -= objlen;
            }
        }
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver. */
        server.stat_net_output_bytes += totwritten;
        if (totwritten > NET_MAX_WRITES_PER_EVENT &&
            (server.maxmemory == 0 ||
             zmalloc_used_memory() < server.maxmemory)) break;
    }
    if (nwritten == -1) {
        if (errno == EAGAIN) {
            nwritten = 0;
        } else {
            serverLog(LL_VERBOSE,
                "Error writing to client: %s", strerror(errno));
            freeClient(c);
            return C_ERR;
        }
    }
    if (totwritten > 0) c->lastinteraction = server.unixtime;
    if (!clientHasPendingReplies(c)) {
        c->sentlen = 0;
        if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
            freeClient(c);
            return C_ERR;
        }
    }
    return C_OK;
}
########################rank 3#############################
local void
flush_pending(strm)
    z_streamp strm;
{
	deflate_state *s = (deflate_state *) strm->state;
	unsigned len = s->pending;
	if (len > strm->avail_out) len = strm->avail_out;
	if (len == 0)
		return;
	if (strm->next_out != Z_NULL) {		/* PPP */
		zmemcpy(strm->next_out, s->pending_out, len);
		strm->next_out += len;
	}					/* PPP */
	s->pending_out += len;
	strm->total_out += len;
	strm->avail_out  -= len;
	s->pending -= len;
	if (s->pending == 0) {
		s->pending_out = s->pending_buf;
	}
}
########################rank 4#############################
static void SNAP_DemoMetaDataMessage( msg_t *msg, const char *meta_data, size_t meta_data_realsize ) {
	int demoinfo_len, demoinfo_len_pos, demoinfo_end;
	int meta_data_ofs, meta_data_ofs_pos;
	// demoinfo message
	MSG_WriteUint8( msg, svc_demoinfo );
	demoinfo_len_pos = msg->cursize;
	MSG_WriteInt32( msg, 0 );    // svc_demoinfo length
	demoinfo_len = msg->cursize;
	meta_data_ofs_pos = msg->cursize;
	MSG_WriteInt32( msg, 0 );    // meta data start offset
	meta_data_ofs = msg->cursize;
	if( meta_data_realsize > SNAP_MAX_DEMO_META_DATA_SIZE ) {
		meta_data_realsize = SNAP_MAX_DEMO_META_DATA_SIZE;
	}
	if( meta_data_realsize > 0 ) {
		meta_data_realsize--;
	}
	meta_data_ofs = msg->cursize - meta_data_ofs;
	MSG_WriteInt32( msg, meta_data_realsize );       // real size
	MSG_WriteInt32( msg, SNAP_MAX_DEMO_META_DATA_SIZE ); // max size
	MSG_WriteData( msg, meta_data, meta_data_realsize );
	MSG_WriteData( msg, dummy_meta_data, SNAP_MAX_DEMO_META_DATA_SIZE - meta_data_realsize );
	demoinfo_end = msg->cursize;
	demoinfo_len = msg->cursize - demoinfo_len;
	msg->cursize = demoinfo_len_pos;
	MSG_WriteInt32( msg, demoinfo_len ); // svc_demoinfo length
	msg->cursize = meta_data_ofs_pos;
	MSG_WriteInt32( msg, meta_data_ofs );    // meta data start offset
	msg->cursize = demoinfo_end;
}
########################rank 5#############################
int anetWrite(int fd, char *buf, int count)
{
    int nwritten, totlen = 0;
    while(totlen != count) {
        nwritten = write(fd,buf,count-totlen);
        if (nwritten == 0) return totlen;
        if (nwritten == -1) return -1;
        totlen += nwritten;
        buf += nwritten;
    }
    return totlen;
}
########################rank 6#############################
static bool scsi_inquiry(VDev *vdev, uint8_t evpd, uint8_t page,
                         void *data, uint32_t data_size)
{
    ScsiCdbInquiry cdb = {
        .command = 0x12,
        .b1 = evpd,
        .b2 = page,
        .alloc_len = data_size < 65535 ? data_size : 65535,
    };
    VirtioCmd inquiry[] = {
        { &req, sizeof(req), VRING_DESC_F_NEXT },
        { &resp, sizeof(resp), VRING_DESC_F_WRITE | VRING_DESC_F_NEXT },
        { data, data_size, VRING_DESC_F_WRITE },
    };
    vs_run("inquiry", inquiry, vdev, &cdb, sizeof(cdb), data, data_size);
    return virtio_scsi_response_ok(&resp);
}
########################rank 7#############################
static void bold_on(void)
{
    write(1, "\033[1m", 4);
}
########################rank 8#############################
void printLastPacketInfo(int count) {
    ASSERT(count >= 0);
     * ---------|------- 
     * <---1----- <---2--
    */
    int i = G_pos - 1;
    char buffer[PAYLOAD_SNAPSHOT_LEN * 5 + 1];
    while(i >= 0) {
        memset(buffer, 0, PAYLOAD_SNAPSHOT_LEN + 5 + 1);
        printPacketArray(buffer, (uchar*)G_packet[i].payload);
        dump(L_OK, "datalen:%u seq:%u dport:%u sport:%u incoming:%c packet:\n\n%s\n",
            G_packet[i].datalen,
            G_packet[i].tcp_seq,
            G_packet[i].dport,
            G_packet[i].sport,
            G_packet[i].incoming, 
            buffer);
        i--;
        count--;
        if (count == 0) {
            return; 
        }
    }
    for (i = LAST_PACKETS_NUM - 1; i > G_pos - 1 ; i--, count--) {
        if (count == 0) {
            return; 
        }
        memset(buffer, 0, PAYLOAD_SNAPSHOT_LEN + 4 + 1);
        printPacketArray(buffer, (uchar*)G_packet[i].payload);
        dump(L_OK, "datalen:%u seq:%u dport:%u sport:%u incoming:%c\npacket:\n%s\n",
            G_packet[i].datalen,
            G_packet[i].tcp_seq,
            G_packet[i].dport,
            G_packet[i].sport,
            G_packet[i].incoming, 
            buffer);
    }
}
########################rank 9#############################
static void fds_write(uint32 address, uint8 value)
{
}
########################rank 10#############################
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len;
    deflate_state *s = strm->state;
    _tr_flush_bits(s);
    len = s->pending;
    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;
    zmemcpy(strm->next_out, s->pending_out, len);
    strm->next_out  += len;
    s->pending_out  += len;
    strm->total_out += len;
    strm->avail_out -= len;
    s->pending      -= len;
    if (s->pending == 0) {
        s->pending_out = s->pending_buf;
    }
}
----------------------------QUERY-------------------------------
generate trace call to print
########################rank 1#############################
void msock_print_error(void)
{
    if (s_logfp == NULL)
    {
        s_logfp = stderr;
    }
#ifdef WINNT
    msock_print_winsock_error();
#else
    (void) fprintf(s_logfp,"Socket Error: [%d]: %s\n",
            errno,
            strerror(errno));
#endif 
}
########################rank 2#############################
cell pp_apply(cell x) {
	cell	m, p, q, last;
	m = x;
	p = cdr(m);
	last = p;
	while (p != NIL) {
		last = p;
		p = cdr(p);
	}
	p = car(last);
	while (p != NIL) {
		if (atom_p(p))
			return error("apply: improper argument list",
					car(last));
		p = cdr(p);
	}
	if (cddr(m) == NIL) {
		p = cadr(m);
	}
	else {
		p = flat_copy(cdr(m), &q);
		q = p;
		while (cddr(q) != NIL)
			q = cdr(q);
		cdr(q) = car(last);
	}
	return cons(car(m), p);
}
########################rank 3#############################
static void visitmsg(const upb_refcounted *r, upb_refcounted_visit *visit,
                     void *closure) {
  upb_msg_oneof_iter o;
  const upb_msgdef *m = (const upb_msgdef*)r;
  const upb_def *def = upb_msgdef_upcast(m);
  upb_msg_field_iter i;
  for(upb_msg_field_begin(&i, m);
      !upb_msg_field_done(&i);
      upb_msg_field_next(&i)) {
    upb_fielddef *f = upb_msg_iter_field(&i);
    visit(r, upb_fielddef_upcast2(f), closure);
  }
  for(upb_msg_oneof_begin(&o, m);
      !upb_msg_oneof_done(&o);
      upb_msg_oneof_next(&o)) {
    upb_oneofdef *f = upb_msg_iter_oneof(&o);
    visit(r, upb_oneofdef_upcast(f), closure);
  }
  if (upb_def_file(def)) {
    visit(r, upb_filedef_upcast(upb_def_file(def)), closure);
  }
}
########################rank 4#############################
void print_valid_escapes(){
	printf("\n\n");
	printf("\rSupported revsh escape sequences:\n");
	printf("\n");
	printf("\r~.\tExit. (Good for killing an unresponsive session.)\n");
	printf("\r~#\tList active connections with usage statistics.\n");
	printf("\r~?\tList the supported revsh escape sequences.\n");
	printf("\r\n");
}
########################rank 5#############################
static void cswitch(JF, js_Ast *ref, js_Ast *head)
{
	js_Ast *node, *clause, *def = NULL;
	int end;
	cexp(J, F, ref);
	for (node = head; node; node = node->b) {
		clause = node->a;
		if (clause->type == STM_DEFAULT) {
			if (def)
				jsC_error(J, clause, "more than one default label in switch");
			def = clause;
		} else {
			cexp(J, F, clause->a);
			clause->casejump = emitjump(J, F, OP_JCASE);
		}
	}
	emit(J, F, OP_POP);
	if (def) {
		def->casejump = emitjump(J, F, OP_JUMP);
		end = 0;
	} else {
		end = emitjump(J, F, OP_JUMP);
	}
	for (node = head; node; node = node->b) {
		clause = node->a;
		label(J, F, clause->casejump);
		if (clause->type == STM_DEFAULT)
			cstmlist(J, F, clause->a);
		else
			cstmlist(J, F, clause->b);
	}
	if (end)
		label(J, F, end);
}
########################rank 6#############################
static void cswitch(JF, js_Ast *ref, js_Ast *head)
{
	js_Ast *node, *clause, *def = NULL;
	int end;
	cexp(J, F, ref);
	for (node = head; node; node = node->b) {
		clause = node->a;
		if (clause->type == STM_DEFAULT) {
			if (def)
				jsC_error(J, clause, "more than one default label in switch");
			def = clause;
		} else {
			cexp(J, F, clause->a);
			emitline(J, F, clause);
			clause->casejump = emitjump(J, F, OP_JCASE);
		}
	}
	emit(J, F, OP_POP);
	if (def) {
		emitline(J, F, def);
		def->casejump = emitjump(J, F, OP_JUMP);
		end = 0;
	} else {
		end = emitjump(J, F, OP_JUMP);
	}
	for (node = head; node; node = node->b) {
		clause = node->a;
		label(J, F, clause->casejump);
		if (clause->type == STM_DEFAULT)
			cstmlist(J, F, clause->a);
		else
			cstmlist(J, F, clause->b);
	}
	if (end)
		label(J, F, end);
}
########################rank 7#############################
process(FILE *fid) {
	char line[MAXLINE+3], *s;
	for (;;) {
		++emess_dat.File_line;
		if (!(s = fgets(line, MAXLINE, fid)))
			break;
		if (!strchr(s, '\n')) { 
			int c;
			strcat(s, "\n");
			while ((c = fgetc(fid)) != EOF && c != '\n') ;
		}
		if (*s == tag) {
			fputs(line, stdout);
			continue;
		}
		phi1 = dmstor(s, &s);
		lam1 = dmstor(s, &s);
		if (inverse) {
			phi2 = dmstor(s, &s);
			lam2 = dmstor(s, &s);
			geod_inv();
		} else {
			al12 = dmstor(s, &s);
			geod_S = strtod(s, &s) * to_meter;
			geod_pre();
			geod_for();
		}
		if (!*s && (s > line)) --s; /* assumed we gobbled \n */
		if (pos_azi) {
			if (al12 < 0.) al12 += TWOPI;
			if (al21 < 0.) al21 += TWOPI;
		}
		if (fullout) {
			printLL(phi1, lam1); TAB;
			printLL(phi2, lam2); TAB;
			if (oform) {
				(void)printf(oform, al12 * RAD_TO_DEG); TAB;
				(void)printf(oform, al21 * RAD_TO_DEG); TAB;
				(void)printf(osform, geod_S * fr_meter);
			}  else {
				(void)fputs(rtodms(pline, al12, 0, 0), stdout); TAB;
				(void)fputs(rtodms(pline, al21, 0, 0), stdout); TAB;
				(void)printf(osform, geod_S * fr_meter);
			}
		} else if (inverse)
			if (oform) {
				(void)printf(oform, al12 * RAD_TO_DEG); TAB;
				(void)printf(oform, al21 * RAD_TO_DEG); TAB;
				(void)printf(osform, geod_S * fr_meter);
			} else {
				(void)fputs(rtodms(pline, al12, 0, 0), stdout); TAB;
				(void)fputs(rtodms(pline, al21, 0, 0), stdout); TAB;
				(void)printf(osform, geod_S * fr_meter);
			}
		else {
			printLL(phi2, lam2); TAB;
			if (oform)
				(void)printf(oform, al21 * RAD_TO_DEG);
			else
				(void)fputs(rtodms(pline, al21, 0, 0), stdout);
		}
		(void)fputs(s, stdout);
	}
}
########################rank 8#############################
static int ParseCmdLine(int argc, char *argv[])
{
	int i;
	for (i = 0; i < argc; ++i)
	{
		//PRINT_DEBUG_INFO(("%s",argv[i]));
		if (strcmp(argv[i], "--dump-ast") == 0 ||
			strcmp(argv[i], "--dump-IR") == 0)
		{
			Option.cflags = ListAppend(Option.cflags, argv[i]);
		}
		else if (strcmp(argv[i], "-E") == 0)
		{
			Option.oftype = PP_FILE;
		}
		else if (strcmp(argv[i], "-S") == 0)
		{
			Option.oftype = ASM_FILE;
		}
		else if (strcmp(argv[i], "-c") == 0)
		{
			Option.oftype = OBJ_FILE;
		}
		else if (strcmp(argv[i], "-o") == 0)
		{
			Option.out = argv[++i];
		}
		else if (strncmp(argv[i], "-D", 2) == 0 ||
			strncmp(argv[i], "-U", 2) == 0 ||
			strncmp(argv[i], "-I", 2) == 0)
		{
			Option.pflags = ListAppend(Option.pflags, argv[i]);
		}
		else if (strcmp(argv[i], "-h") == 0)
		{
			ShowHelp();
		}
		else if (strcmp(argv[i], "-v") == 0)
		{
			Option.verbose = 1;
		}
		else if (strncmp(argv[i], "-Wl,", 4) == 0)
		{
			Option.lflags = ListAppend(Option.lflags, argv[i]);
		}
		else if (strncmp(argv[i], "-Wa,", 4) == 0)
		{
			Option.aflags = ListAppend(Option.aflags, argv[i]);
		}
		else if (argv[i][0] == '-')
		{			
			Option.linput = ListAppend(Option.linput, argv[i]);
		}
		else{
			AddFile(argv[i]);	
		}
	}
	return i;
}
########################rank 9#############################
static void bcemit_comp(FuncState *fs, BinOpr opr, ExpDesc *e1, ExpDesc *e2)
{
	ExpDesc *eret = e1;
	BCIns ins;
	expr_toval(fs, e1);
	if (opr == OPR_EQ || opr == OPR_NE) {
		BCOp op = opr == OPR_EQ ? BC_ISEQV : BC_ISNEV;
		BCReg ra;
		if (expr_isk(e1)) { 
			e1 = e2;
			e2 = eret;
		}
		ra = expr_toanyreg(fs, e1);  /* First arg must be in a reg. */
		expr_toval(fs, e2);
		switch (e2->k) {
		case VKNIL: case VKFALSE: case VKTRUE:
			ins = BCINS_AD(op+(BC_ISEQP-BC_ISEQV), ra,
					const_pri(e2));
			break;
		case VKSTR:
			ins = BCINS_AD(op+(BC_ISEQS-BC_ISEQV), ra,
					const_str(fs, e2));
			break;
		case VKNUM:
			ins = BCINS_AD(op+(BC_ISEQN-BC_ISEQV), ra,
					const_num(fs, e2));
			break;
		default:
			ins = BCINS_AD(op, ra, expr_toanyreg(fs, e2));
			break;
		}
	} else {
		uint32_t op = opr-OPR_LT+BC_ISLT;
		BCReg ra, rd;
		if ((op-BC_ISLT) & 1) {  /* GT -> LT, GE -> LE */
			e1 = e2; e2 = eret;  /* Swap operands. */
			op = ((op-BC_ISLT)^3)+BC_ISLT;
			expr_toval(fs, e1);
		}
		rd = expr_toanyreg(fs, e2);
		ra = expr_toanyreg(fs, e1);
		ins = BCINS_AD(op, ra, rd);
	}
	if (e1->k == VNONRELOC && e1->u.s.info >= fs->nactvar)
		fs->freereg--;
	if (e2->k == VNONRELOC && e2->u.s.info >= fs->nactvar)
		fs->freereg--;
	bcemit_INS(fs, ins);
	eret->u.s.info = bcemit_jmp(fs);
	eret->k = VJMP;
}
########################rank 10#############################
static void bcemit_comp(FuncState *fs, BinOpr opr, ExpDesc *e1, ExpDesc *e2)
{
  ExpDesc *eret = e1;
  BCIns ins;
  expr_toval(fs, e1);
  if (opr == OPR_EQ || opr == OPR_NE) {
    BCOp op = opr == OPR_EQ ? BC_ISEQV : BC_ISNEV;
    BCReg ra;
    if (expr_isk(e1)) { e1 = e2; e2 = eret; }  
    ra = expr_toanyreg(fs, e1);  /* First arg must be in a reg. */
    expr_toval(fs, e2);
    switch (e2->k) {
    case VKNIL: case VKFALSE: case VKTRUE:
      ins = BCINS_AD(op+(BC_ISEQP-BC_ISEQV), ra, const_pri(e2));
      break;
    case VKSTR:
      ins = BCINS_AD(op+(BC_ISEQS-BC_ISEQV), ra, const_str(fs, e2));
      break;
    case VKNUM:
      ins = BCINS_AD(op+(BC_ISEQN-BC_ISEQV), ra, const_num(fs, e2));
      break;
    default:
      ins = BCINS_AD(op, ra, expr_toanyreg(fs, e2));
      break;
    }
  } else {
    uint32_t op = opr-OPR_LT+BC_ISLT;
    BCReg ra;
    if ((op-BC_ISLT) & 1) {  /* GT -> LT, GE -> LE */
      e1 = e2; e2 = eret;  /* Swap operands. */
      op = ((op-BC_ISLT)^3)+BC_ISLT;
    }
    ra = expr_toanyreg(fs, e1);
    ins = BCINS_AD(op, ra, expr_toanyreg(fs, e2));
  }
  if (e1->k == VNONRELOC && e1->u.s.info >= fs->nactvar) fs->freereg--;
  if (e2->k == VNONRELOC && e2->u.s.info >= fs->nactvar) fs->freereg--;
  bcemit_INS(fs, ins);
  eret->u.s.info = bcemit_jmp(fs);
  eret->k = VJMP;
}
----------------------------QUERY-------------------------------
get dimensions of given bmp file
########################rank 1#############################
int bmp_file_get_dimensions(char *filename, int *w, int *h) 
{
    FILE *f = fopen(filename, "rb");
    bmp_t b;
    if (f == NULL)
	return -1;
    if (read_bmp_file_header(f, &(b.file_header)) != 0) {
	fclose(f);
        return -1;
    }
    if (read_bmp_info_header(f, &(b.info_header)) != 0) {
	fclose(f);
        return -1;
    }    
    *w = b.info_header.width;
    *h = b.info_header.height;
    fclose(f);
    return 0;
}
########################rank 2#############################
PIX *
pixRead(const char  *filename)
{
FILE  *fp;
PIX   *pix;
    PROCNAME("pixRead");
    if (!filename)
        return (PIX *)ERROR_PTR("filename not defined", procName, NULL);
    if ((fp = fopenReadStream(filename)) == NULL)
        return (PIX *)ERROR_PTR("image file not found", procName, NULL);
    if ((pix = pixReadStream(fp, 0)) == NULL) {
        fclose(fp);
        return (PIX *)ERROR_PTR("pix not read", procName, NULL);
    }
         * DGifCloseFile() closes the windows file stream! */
    if (pixGetInputFormat(pix) != IFF_GIF)
        fclose(fp);
#ifndef _WIN32
    else  /* gif file */
        fclose(fp);
#endif  /* ! _WIN32 */
    return pix;
}
########################rank 3#############################
Jbig2Image *
jbig2_image_read_pbm_file(Jbig2Ctx *ctx, char *filename)
{
    FILE *in;
    Jbig2Image *image;
    if ((in = fopen(filename, "rb")) == NULL) {
        fprintf(stderr, "unable to open '%s' for reading\n", filename);
        return NULL;
    }
    image = jbig2_image_read_pbm(ctx, in);
    fclose(in);
    return (image);
}
########################rank 4#############################
PIX *
pixReadStream(FILE    *fp,
              l_int32  hint)
{
l_int32  format;
PIX     *pix;
    PROCNAME("pixReadStream");
    if (!fp)
        return (PIX *)ERROR_PTR("stream not defined", procName, NULL);
    pix = NULL;
    findFileFormatStream(fp, &format);
    switch (format)
    {
    case IFF_BMP:
        if ((pix = pixReadStreamBmp(fp)) == NULL )
            return (PIX *)ERROR_PTR( "bmp: no pix returned", procName, NULL);
        break;
    case IFF_JFIF_JPEG:
        if ((pix = pixReadStreamJpeg(fp, READ_24_BIT_COLOR, 1, NULL, hint))
                == NULL)
            return (PIX *)ERROR_PTR( "jpeg: no pix returned", procName, NULL);
        break;
    case IFF_PNG:
        if ((pix = pixReadStreamPng(fp)) == NULL)
            return (PIX *)ERROR_PTR("png: no pix returned", procName, NULL);
        break;
    case IFF_TIFF:
    case IFF_TIFF_PACKBITS:
    case IFF_TIFF_RLE:
    case IFF_TIFF_G3:
    case IFF_TIFF_G4:
    case IFF_TIFF_LZW:
    case IFF_TIFF_ZIP:
        if ((pix = pixReadStreamTiff(fp, 0)) == NULL)  /* page 0 by default */
            return (PIX *)ERROR_PTR("tiff: no pix returned", procName, NULL);
        break;
    case IFF_PNM:
        if ((pix = pixReadStreamPnm(fp)) == NULL)
            return (PIX *)ERROR_PTR("pnm: no pix returned", procName, NULL);
        break;
    case IFF_GIF:
        if ((pix = pixReadStreamGif(fp)) == NULL)
            return (PIX *)ERROR_PTR("gif: no pix returned", procName, NULL);
        break;
    case IFF_JP2:
        return (PIX *)ERROR_PTR("jp2: format not supported", procName, NULL);
        break;
    case IFF_WEBP:
        if ((pix = pixReadStreamWebP(fp)) == NULL)
            return (PIX *)ERROR_PTR("webp: no pix returned", procName, NULL);
        break;
    case IFF_SPIX:
        if ((pix = pixReadStreamSpix(fp)) == NULL)
            return (PIX *)ERROR_PTR("spix: no pix returned", procName, NULL);
        break;
    case IFF_UNKNOWN:
        return (PIX *)ERROR_PTR( "Unknown format: no pix returned",
                procName, NULL);
        break;
    }
    if (pix)
        pixSetInputFormat(pix, format);
    return pix;
}
########################rank 5#############################
Image *
load_image_tga(f)		
FILE *f;
{
	Image* image = NULL;
	boolean bTopDown;
	boolean bOK = FALSE;
	TGAheader	header;
	int	width, height, c, x, y, yy;
	ASSERT(sizeof(Pixel) == 1);
	if(fread(&header, sizeof(header), 1, f) == 1 && header.bpp == 8)
	{
		bTopDown = (header.descriptor & 0x20);
		width = DB_TO_INT(header.Width);
		height = DB_TO_INT(header.Height);
		image = new_image(width, height);
		if(image != NULL)
		{
			bOK = 0 == fseek(f, DB_TO_INT(header.ColorMapLen) * header.ColorMapEntrySize/8, SEEK_CUR);
			for(y = 0; y < height && bOK; y++)
			{
				yy = bTopDown ? y : (height-1) - y;
				for(x = 0; x < width && bOK; x++)
				{
					bOK = ((c = fgetc(f)) != EOF);
					if(bOK)
						put_pixel(image, x, yy, (Pixel)c);
				}
			}
		}
	}
	if(!bOK && image != NULL)
	{
		free_image(image);
		image = NULL;
	}
	return image;
}
########################rank 6#############################
int
DGifCloseFile(GifFileType * GifFile) {
    GifFilePrivateType *Private;
    FILE *File;
    if (GifFile == NULL)
        return GIF_ERROR;
    Private = (GifFilePrivateType *) GifFile->Private;
    if (!IS_READABLE(Private)) {
        _GifError = D_GIF_ERR_NOT_READABLE;
        return GIF_ERROR;
    }
    File = Private->File;
    if (GifFile->Image.ColorMap) {
        FreeMapObject(GifFile->Image.ColorMap);
        GifFile->Image.ColorMap = NULL;
    }
    if (GifFile->SColorMap) {
        FreeMapObject(GifFile->SColorMap);
        GifFile->SColorMap = NULL;
    }
    if (Private) {
        free((char *)Private);
        Private = NULL;
    }
    if (GifFile->SavedImages) {
        FreeSavedImages(GifFile);
        GifFile->SavedImages = NULL;
    }
    free(GifFile);
    if (File && (fclose(File) != 0)) {
        _GifError = D_GIF_ERR_CLOSE_FAILED;
        return GIF_ERROR;
    }
    return GIF_OK;
}
########################rank 7#############################
PIX *
pixReadMem(const l_uint8  *data,
           size_t          size)
{
l_int32  format;
PIX     *pix;
    PROCNAME("pixReadMem");
    if (!data)
        return (PIX *)ERROR_PTR("data not defined", procName, NULL);
    if (size < 8)
        return (PIX *)ERROR_PTR("size < 8", procName, NULL);
    pix = NULL;
    findFileFormatBuffer(data, &format);
    switch (format)
    {
    case IFF_BMP:
        if ((pix = pixReadMemBmp(data, size)) == NULL )
            return (PIX *)ERROR_PTR( "bmp: no pix returned", procName, NULL);
        break;
    case IFF_JFIF_JPEG:
        if ((pix = pixReadMemJpeg(data, size, READ_24_BIT_COLOR, 1, NULL, 0))
                == NULL)
            return (PIX *)ERROR_PTR( "jpeg: no pix returned", procName, NULL);
        break;
    case IFF_PNG:
        if ((pix = pixReadMemPng(data, size)) == NULL)
            return (PIX *)ERROR_PTR("png: no pix returned", procName, NULL);
        break;
    case IFF_TIFF:
    case IFF_TIFF_PACKBITS:
    case IFF_TIFF_RLE:
    case IFF_TIFF_G3:
    case IFF_TIFF_G4:
    case IFF_TIFF_LZW:
    case IFF_TIFF_ZIP:
        if ((pix = pixReadMemTiff(data, size, 0)) == NULL)
            return (PIX *)ERROR_PTR("tiff: no pix returned", procName, NULL);
        break;
    case IFF_PNM:
        if ((pix = pixReadMemPnm(data, size)) == NULL)
            return (PIX *)ERROR_PTR("pnm: no pix returned", procName, NULL);
        break;
    case IFF_GIF:
        if ((pix = pixReadMemGif(data, size)) == NULL)
            return (PIX *)ERROR_PTR("gif: no pix returned", procName, NULL);
        break;
    case IFF_JP2:
        return (PIX *)ERROR_PTR("jp2: format not supported", procName, NULL);
        break;
    case IFF_SPIX:
        if ((pix = pixReadMemSpix(data, size)) == NULL)
            return (PIX *)ERROR_PTR("spix: no pix returned", procName, NULL);
        break;
    case IFF_UNKNOWN:
        return (PIX *)ERROR_PTR("Unknown format: no pix returned",
                procName, NULL);
        break;
    }
         * the actual input format; for 1 bpp, default to G4.  */
    if (pix) {
        if (format == IFF_TIFF && pixGetDepth(pix) == 1)
            format = IFF_TIFF_G4;
        pixSetInputFormat(pix, format);
    }
    return pix;
}
########################rank 8#############################
PIX *
pixReadWithHint(const char  *filename,
                l_int32      hint)
{
FILE  *fp;
PIX   *pix;
    PROCNAME("pixReadWithHint");
    if (!filename)
        return (PIX *)ERROR_PTR("filename not defined", procName, NULL);
    if ((fp = fopenReadStream(filename)) == NULL)
        return (PIX *)ERROR_PTR("image file not found", procName, NULL);
    pix = pixReadStream(fp, hint);
    fclose(fp);
    if (!pix)
        return (PIX *)ERROR_PTR("image not returned", procName, NULL);
    return pix;
}
########################rank 9#############################
l_int32
pixWritePSEmbed(const char  *filein,
                const char  *fileout)
{
l_int32    w, h;
l_float32  scale;
FILE      *fp;
PIX       *pix;
    PROCNAME("pixWritePSEmbed");
    if (!filein)
        return ERROR_INT("filein not defined", procName, 1);
    if (!fileout)
        return ERROR_INT("fileout not defined", procName, 1);
    if ((pix = pixRead(filein)) == NULL)
        return ERROR_INT("image not read from file", procName, 1);
    w = pixGetWidth(pix);
    h = pixGetHeight(pix);
    if (w * 11.0 > h * 8.5)
        scale = 8.5 * 300. / (l_float32)w;
    else
        scale = 11.0 * 300. / (l_float32)h;
    if ((fp = fopenWriteStream(fileout, "wb")) == NULL)
        return ERROR_INT("file not opened for write", procName, 1);
    pixWriteStreamPS(fp, pix, NULL, 0, scale);
    fclose(fp);
    pixDestroy(&pix);
    return 0;
}
########################rank 10#############################
lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
{
    if(br != NULL) *br = 0;
    if(file_p->drv == NULL) return LV_FS_RES_INV_PARAM;
    if(file_p->drv->read_cb == NULL) return LV_FS_RES_NOT_IMP;
    uint32_t br_tmp = 0;
    lv_fs_res_t res = file_p->drv->read_cb(file_p->drv, file_p->file_d, buf, btr, &br_tmp);
    if(br != NULL) *br = br_tmp;
    return res;
}
----------------------------QUERY-------------------------------
add extension to filename
########################rank 1#############################
const char *COM_FileExtension( const char *filename ) {
	const char *src, *last;
	last = strrchr( filename, '/' );
	src = strrchr( last ? last : filename, '.' );
	if( src && *( src + 1 ) ) {
		return src;
	}
	return NULL;
}
########################rank 2#############################
FILE* CreateOutput(char *filename, char *ext)
{
	char tmp[256];
	char *p = tmp;
	// hello.c  --->  hello.s / hello.ast  /hello.uil
	while (*filename && *filename != '.')
		*p++ = *filename++;
	strcpy(p, ext);
	return fopen(tmp, "w");
}
########################rank 3#############################
char* FileName(char *name, char *ext)
{
	char *str;
	int len;
	int i;
	if(ext == EMPTY_EXT){
		return name;
	}
	i = len = strlen(name);
	while (i > 0 && name[i - 1] != '.'){
		i--;
	}
	if(i > 0){
		len = i - 1;
	}
	str = Alloc(len + strlen(ext)+1);
	strncpy(str,name,len);
	str[len] = '\0';
	strcat(str,ext);	
	return str;		
}
########################rank 4#############################
void COM_StripExtension( char *filename ) {
	char *src, *last = NULL;
	last = strrchr( filename, '/' );
	src = strrchr( last ? last : filename, '.' );
	if( src && *( src + 1 ) ) {
		*src = 0;
	}
}
########################rank 5#############################
static POST *_create_post_section(const char *filename)
{
   int num;
   POST *p;
   p = m_xmalloc(sizeof(POST));
   p->token = m_xmalloc(sizeof(char*));
   p->num = 0;
   strcpy(p->filename, filename);
   if (!_post) {
      _post = m_xmalloc(sizeof(POST*));
      _post[0] = 0;
   }
   for(num = 0; _post[num]; num++)
      ;
   _post = m_xrealloc(_post, sizeof(POST*) * (2 + num));
   _post[num++] = p;
   _post[num] = 0;
   return p;
}
########################rank 6#############################
void CL_DemoFilename( int number, char *fileName ) {
	if ( number < 0 || number > 9999 ) {
		Com_sprintf( fileName, MAX_OSPATH, "demo9999" ); // fretn - removed .tga
		return;
	}
	Com_sprintf( fileName, MAX_OSPATH, "demo%04i", number );
}
########################rank 7#############################
void CL_DemoFilename( int number, char *fileName ) {
	int a,b,c,d;
	if ( number < 0 || number > 9999 ) {
		Com_sprintf( fileName, MAX_OSPATH, "demo9999.tga" );
		return;
	}
	a = number / 1000;
	number -= a * 1000;
	b = number / 100;
	number -= b * 100;
	c = number / 10;
	number -= c * 10;
	d = number;
	Com_sprintf( fileName, MAX_OSPATH, "demo%i%i%i%i"
				 , a, b, c, d );
}
########################rank 8#############################
void get_file_extension(char *infile, char *ext)
{
   char *ptr;
   if ((ptr = strchr(infile, '.')) != NULL)
      strcpy(ext, ptr+1);
   else
      ext[0] = '\0';
}
########################rank 9#############################
void get_file_extension(char *infile, char *ext)
{
   char *ptr;
   if ((ptr = strchr(infile, '.')) != NULL)
      strcpy(ext, ptr+1);
   else
      ext[0] = '\0';
}
########################rank 10#############################
snd_stream_t *S_CodecOpenStream(const char *filename)
{
	snd_codec_t *codec;
	char fn[MAX_QPATH];
	codec = S_FindCodecForFile(filename);
	if(!codec)
	{
		Com_Printf("Unknown extension for %s\n", filename);
		return NULL;
	}
	strncpy(fn, filename, sizeof(fn));
	COM_DefaultExtension(fn, sizeof(fn), codec->ext);
	return codec->open(fn);
}
----------------------------QUERY-------------------------------
read one word from onboard RAM
########################rank 1#############################
static uint16_t
ram_readw(uint32_t addr, void *priv)
{
    mem_mapping_t *map = (mem_mapping_t *)priv;
    memdev_t *dev = (memdev_t *)map->dev;
    uint16_t ret = 0xffff;
    ret = *(uint16_t *)(dev->ram + (addr - map->base));
    return(ret);
}
########################rank 2#############################
IoError *IoError_newWithMessageFormat_(void *state, const char *format, ...)
{
	IoSymbol *message;
	va_list ap;
	va_start(ap, format);
	message = IoState_symbolWithUArray_copy_(state, UArray_newWithVargs_(format, ap), 0);
	va_end(ap);
	{
		IoError *error = IoError_new(state);
		IoObject_setSlot_to_(error, IoState_symbolWithCString_((IoState*)state, (char *)("message")), message);
		return error;
	}
}
########################rank 3#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan5_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  12);
}
########################rank 4#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan3_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  8);
}
########################rank 5#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan2_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  6);
}
########################rank 6#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan4_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  10);
}
########################rank 7#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan8_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  18);
}
########################rank 8#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan7_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  16);
}
########################rank 9#############################
int16_t mavlink_msg_rc_channels_scaled_get_chan6_scaled(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  14);
}
########################rank 10#############################
uint16_t mavlink_msg_rc_channels_raw_get_chan4_raw(const mavlink_message_t* msg)
{
	return _MAV_RETURN_uint16_t(msg,  10);
}
----------------------------QUERY-------------------------------
encode ucs2 string into utf8 string
########################rank 1#############################
char *encode_base64(int size, char *src)
{
    int i;
    char *out, *p;
    if (!src) {
        return NULL;
    }
    if (!size) {
        size = strlen((char *)src);
    }
    out = (char *)calloc(sizeof(char), size * 4 / 3 + 4);
    if (!out) {
        return NULL;
    }
    p = out;
    for (i = 0; i < size; i += 3) {
        unsigned char b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0, b7 = 0;
        b1 = src[i];
        if (i + 1 < size) {
            b2 = src[i + 1];
        }
        if (i + 2 < size) {
            b3 = src[i + 2];
        }
        b4 = b1 >> 2;
        b5 = ((b1 & 0x3) << 4) | (b2 >> 4);
        b6 = ((b2 & 0xf) << 2) | (b3 >> 6);
        b7 = b3 & 0x3f;
        *p++ = encode(b4);
        *p++ = encode(b5);
        if (i + 1 < size) {
            *p++ = encode(b6);
        } else {
            *p++ = '=';
        }
        if (i + 2 < size) {
            *p++ = encode(b7);
        } else {
            *p++ = '=';
        }
    }
    return out;
}
########################rank 2#############################
void G_Save_Decode( byte *in, int insize, byte *out, int outsize ) {
	int incount, outcount;
	byte count;     //DAJ was in but caused endian bugs
	//
	incount = 0;
	outcount = 0;
	while ( incount < insize ) {
		// read the count
		count = 0;
		memcpy( &count, in + incount, SAVE_ENCODE_COUNT_BYTES );
		incount += SAVE_ENCODE_COUNT_BYTES;
		// if it's negative, zero it out
		if ( count & ( 1 << ( ( SAVE_ENCODE_COUNT_BYTES * 8 ) - 1 ) ) ) {
			count &= ~( 1 << ( ( SAVE_ENCODE_COUNT_BYTES * 8 ) - 1 ) );
			memset( out + outcount, 0, count );
			outcount += count;
		} else {
			// copy the data from "in"
			memcpy( out + outcount, in + incount, count );
			outcount += count;
			incount += count;
		}
	}
}
########################rank 3#############################
uint16_t mavlink_msg_statustext_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, mavlink_statustext_t* statustext)
{
	return mavlink_msg_statustext_pack(system_id, component_id, msg, statustext->severity, statustext->text);
}
########################rank 4#############################
static int encode_msm3(rtcm_t *rtcm, int sys, int sync)
{
    double rrng[64],rrate[64],psrng[64],phrng[64],lock[64];
    unsigned char half[64];
    int i,nsat,ncell;
    trace(3,"encode_msm3: sys=%d sync=%d\n",sys,sync);
    if (!(i=encode_msm_head(3,rtcm,sys,sync,&nsat,&ncell,rrng,rrate,NULL,psrng,
                            phrng,NULL,lock,half,NULL))) {
        return 0;
    }
    i=encode_msm_mod_rrng(rtcm,i,rrng ,nsat ); /* rough range modulo 1 ms */
    i=encode_msm_psrng   (rtcm,i,psrng,ncell); /* fine pseudorange */
    i=encode_msm_phrng   (rtcm,i,phrng,ncell); /* fine phase-range */
    i=encode_msm_lock    (rtcm,i,lock ,ncell); /* lock-time indicator */
    i=encode_msm_half_amb(rtcm,i,half ,ncell); /* half-cycle-amb indicator */
    rtcm->nbit=i;
    return 1;
}
########################rank 5#############################
void base64_encode(unsigned char *out,const unsigned char *in,int inlen)
{
   for (; inlen >= 3; inlen -= 3) {
      *out++ = base64digits[in[0] >> 2];
      *out++ = base64digits[((in[0] << 4) & 0x30) | (in[1] >> 4)];
      *out++ = base64digits[((in[1] << 2) & 0x3c) | (in[2] >> 6)];
      *out++ = base64digits[in[2] & 0x3f];
      in += 3;
   }
   if (inlen > 0) {
      unsigned char fragment;
      *out++ = base64digits[in[0] >> 2];
      fragment = (in[0] << 4) & 0x30;
      if (inlen > 1)
         fragment |= in[1] >> 4;
      *out++ = base64digits[fragment];
      *out++ = (inlen < 2) ? '=' : base64digits[(in[1] << 2) & 0x3c];
      *out++ = '=';
   }
   *out = '\0';
}
########################rank 6#############################
static int encode_msm_phrng(rtcm_t *rtcm, int i, const double *phrng, int ncell)
{
    int j,phrng_val;
    for (j=0;j<ncell;j++) {
        if (phrng[j]==0.0) {
            phrng_val=-2097152;
        }
        else if (fabs(phrng[j])>1171.0) {
            trace(2,"msm fine phase-range overflow %s phrng=%.3f\n",
                 time_str(rtcm->time,0),phrng[j]);
            phrng_val=-2097152;
        }
        else {
            phrng_val=ROUND(phrng[j]/RANGE_MS/P2_29);
        }
        setbits(rtcm->buff,i,22,phrng_val); i+=22;
    }
    return i;
}
########################rank 7#############################
static void bt_bencode_str(torrent_ctx* ctx, const char* name, const char* str)
{
	size_t len = strlen(str);
	int num_len;
	char* p;
	if (name) bt_str_append(ctx, name);
	if (!bt_str_ensure_length(ctx, ctx->content.length + len + 21)) return;
	p = ctx->content.str + ctx->content.length;
	p += (num_len = rhash_sprintI64(p, len));
	ctx->content.length += len + num_len + 1;
	*(p++) = ':';
	memcpy(p, str, len + 1); /* copy with trailing '\0' */
}
########################rank 8#############################
size_t
base64_decode(void *vdst, size_t sizeof_dst, 
              const void *vsrc, size_t sizeof_src)
{
	static const unsigned char rstr[] = {
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,	62,		0xFF,   0xFF,   0xFF,	63,
		52,		53,		54,		55,		56,		57,		58,		59,		
        60,		61,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0,		1,		2,		3,		4,		5,		6,		
        7,		8,		9,		10,		11,		12,		13,		14,
		15,		16,		17,		18,		19,		20,		21,		22,		
        23,		24,		25,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,	26,		27,		28,		29,		30,		31,		32,		
        33,		34,		35,		36,		37,		38,		39,		40,
		41,		42,		43,		44,		45,		46,		47,		48,		
        49,		50,		51,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
	};
    size_t i = 0;
    size_t d = 0;
    unsigned char *dst = (unsigned char *)vdst;
    const unsigned char *src = (const unsigned char *)vsrc;
	while (i < sizeof_src) {
        unsigned b;
		unsigned c=0;
		while (i<sizeof_src && (c = rstr[src[i]]) > 64)
			i++;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b = (c << 2) & 0xfc;
		while (i<sizeof_src && (c = rstr[src[i]]) > 64)
			i++;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= (c>>4) & 0x03;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
		b = (c<<4) & 0xF0;
		while (i<sizeof_src && src[i] != '=' && (c = rstr[src[i]]) > 64)
			;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= (c>>2) & 0x0F;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
		b = (c<<6) & 0xC0;
		while (i<sizeof_src && src[i] != '=' && (c = rstr[src[i]]) > 64)
			;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= c;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
	}
	if (d<sizeof_dst)
		dst[d] = '\0';
	return d;
}
########################rank 9#############################
size_t
base64_decode(void *vdst, size_t sizeof_dst, 
              const void *vsrc, size_t sizeof_src)
{
	static const unsigned char rstr[] = {
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,	62,		0xFF,   0xFF,   0xFF,	63,
		52,		53,		54,		55,		56,		57,		58,		59,		
        60,		61,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0,		1,		2,		3,		4,		5,		6,		
        7,		8,		9,		10,		11,		12,		13,		14,
		15,		16,		17,		18,		19,		20,		21,		22,		
        23,		24,		25,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,	26,		27,		28,		29,		30,		31,		32,		
        33,		34,		35,		36,		37,		38,		39,		40,
		41,		42,		43,		44,		45,		46,		47,		48,		
        49,		50,		51,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
	};
    size_t i = 0;
    size_t d = 0;
    unsigned char *dst = (unsigned char *)vdst;
    const unsigned char *src = (const unsigned char *)vsrc;
	while (i < sizeof_src) {
        unsigned b;
		unsigned c=0;
		while (i<sizeof_src && (c = rstr[src[i]]) > 64)
			i++;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b = (c << 2) & 0xfc;
		while (i<sizeof_src && (c = rstr[src[i]]) > 64)
			i++;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= (c>>4) & 0x03;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
		b = (c<<4) & 0xF0;
		while (i<sizeof_src && src[i] != '=' && (c = rstr[src[i]]) > 64)
			;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= (c>>2) & 0x0F;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
		b = (c<<6) & 0xC0;
		while (i<sizeof_src && src[i] != '=' && (c = rstr[src[i]]) > 64)
			;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= c;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
	}
	if (d<sizeof_dst)
		dst[d] = '\0';
	return d;
}
########################rank 10#############################
size_t
base64_decode(void *vdst, size_t sizeof_dst, 
              const void *vsrc, size_t sizeof_src)
{
	static const unsigned char rstr[] = {
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,	62,		0xFF,   0xFF,   0xFF,	63,
		52,		53,		54,		55,		56,		57,		58,		59,		
        60,		61,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0,		1,		2,		3,		4,		5,		6,		
        7,		8,		9,		10,		11,		12,		13,		14,
		15,		16,		17,		18,		19,		20,		21,		22,		
        23,		24,		25,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,	26,		27,		28,		29,		30,		31,		32,		
        33,		34,		35,		36,		37,		38,		39,		40,
		41,		42,		43,		44,		45,		46,		47,		48,		
        49,		50,		51,		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
		0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   
        0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,
	};
    size_t i = 0;
    size_t d = 0;
    unsigned char *dst = (unsigned char *)vdst;
    const unsigned char *src = (const unsigned char *)vsrc;
	while (i < sizeof_src) {
        unsigned b;
		unsigned c=0;
		while (i<sizeof_src && (c = rstr[src[i]]) > 64)
			i++;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b = (c << 2) & 0xfc;
		while (i<sizeof_src && (c = rstr[src[i]]) > 64)
			i++;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= (c>>4) & 0x03;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
		b = (c<<4) & 0xF0;
		while (i<sizeof_src && src[i] != '=' && (c = rstr[src[i]]) > 64)
			;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= (c>>2) & 0x0F;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
		b = (c<<6) & 0xC0;
		while (i<sizeof_src && src[i] != '=' && (c = rstr[src[i]]) > 64)
			;
		if (src[i] == '=' || i++ >= sizeof_src)
			break;
		b |= c;
		if (d<sizeof_dst)
			dst[d++] = (unsigned char)b;
		if (i>=sizeof_src)
			break;
	}
	if (d<sizeof_dst)
		dst[d] = '\0';
	return d;
}
----------------------------QUERY-------------------------------
check pointer is in the heap
########################rank 1#############################
int pqIsEmpty( PriorityQ *pq )
{
	return (pq->size == 0) && pqHeapIsEmpty( pq->heap );
}
########################rank 2#############################
int pqIsEmpty( PriorityQ *pq )
{
	return (pq->size == 0) && pqHeapIsEmpty( pq->heap );
}
########################rank 3#############################
int pqIsEmpty( PriorityQ *pq )
{
	return (pq->size == 0) && pqHeapIsEmpty( pq->heap );
}
########################rank 4#############################
Bool PoolDebugOptionsCheck(PoolDebugOptions opt)
{
  CHECKL(opt != NULL);
  if (opt->fenceSize != 0) {
    CHECKL(opt->fenceTemplate != NULL);
  }
  if (opt->freeSize != 0) {
    CHECKL(opt->freeTemplate != NULL);
  }
  return TRUE;
}
########################rank 5#############################
static pword *
_copy_heap_big(value v1, type t1, pword *top, pword *dest)
{
    int arity;
    pword *pw;
    dest->val.ptr = top;
    dest->tag.kernel = Tag(t1.kernel);
    arity = BufferPwords(v1.ptr);
    pw = v1.ptr;
    do                          
	*top++ = *pw++;
    while(--arity > 0);
    return(top);
}
########################rank 6#############################
void cmd_read(frommark, tomark, cmd, bang, extra)
	MARK	frommark;
	MARK	tomark;
	CMD	cmd;
	int	bang;
	char	*extra;
{
	int	fd, rc;	
	REG char	*scan;	/* used for finding NUL characters */
	int	hadnul;	/* boolean: any NULs found? */
	int	addnl;	/* boolean: forced to add newlines? */
	int	len;	/* number of chars in current line */
	long	lines;	/* number of lines in current block */
	struct stat statb;
	if (extra[0] == '!')
	{
		filter(frommark, MARK_UNSET, extra + 1);
		return;
	}
	fd = open(extra, O_RDONLY);
	if (fd < 0)
	{
		msg("Can't open \"%s\"", extra);
		return;
	}
#ifndef CRUNCH
	if (stat(extra, &statb) < 0)
	{
		msg("Can't stat \"%s\"", extra);
	}
# if TOS
	if (statb.st_mode & S_IJDIR)
# else
#  if OSK
	if (statb.st_mode & S_IFDIR)
#  else
	if ((statb.st_mode & S_IFMT) != S_IFREG)
#  endif
# endif
	{
		msg("\"%s\" is not a regular file", extra);
		return;
	}
#endif /* not CRUNCH */
	ChangeText
	{
		tomark = frommark = (frommark | (BLKSIZE - 1L)) + 1L;
		len = 0;
		hadnul = addnl = FALSE;
		 * the file don't trip us up
		 */
		add(tomark, "\n");
		while ((rc = tread(fd, tmpblk.c, BLKSIZE - 1)) > 0)
		{
			for (lines = 0, scan = tmpblk.c; rc > 0; rc--, scan++)
			{
				if (*scan != '\n' && len + 2 > BLKSIZE)
				{
					*scan = '\n';
					addnl = TRUE;
				}
				if (!*scan)
				{
					*scan = 0x80;
					hadnul = TRUE;
				}
				if (*scan == '\n')
				{
					len = 0;
					lines++;
				}
				else
				{
					len++;
				}
			}
			*scan = '\0';
			add(tomark, tmpblk.c);
			tomark += MARK_AT_LINE(lines) + len - markidx(tomark);
		}
		if (len > 0)
		{
			msg("Last line had no newline");
			tomark += BLKSIZE; /* <- for the rptlines calc */
		}
		else /* delete that first newline */
		{
			delete(tomark, (tomark | (BLKSIZE - 1L)) + 1L);
		}
	}
	close(fd);
	rptlines = markline(tomark) - markline(frommark);
	rptlabel = "read";
	if (addnl)
		msg("Newlines were added to break up long lines");
	if (hadnul)
		msg("NULs were converted to 0x80");
}
########################rank 7#############################
size_t mem_heapsize()
{
  return (size_t)((void *)mem_brk - (void *)mem_heap);
}
########################rank 8#############################
void *myrealloc(char* file, int line, void* p, size_t size)
{
	void* rc = NULL;
	storageElement* s = NULL;
	Thread_lock_mutex(heap_mutex);
	s = TreeRemoveKey(&heap, ((int*)p)-1);
	if (s == NULL)
		Log(LOG_ERROR, 13, "Failed to reallocate heap item at file %s line %d", file, line);
	else
	{
		size_t space = sizeof(storageElement);
		size_t filenamelen = strlen(file)+1;
		checkEyecatchers(file, line, p, s->size);
		size = Heap_roundup(size);
		state.current_size += size - s->size;
		if (state.current_size > state.max_size)
			state.max_size = state.current_size;
		if ((s->ptr = realloc(s->ptr, size + 2*sizeof(int))) == NULL)
		{
			Log(LOG_ERROR, 13, errmsg);
			return NULL;
		}
		space += size + 2*sizeof(int) - s->size;
		*(int*)(s->ptr) = eyecatcher; /* start eyecatcher */
		*(int*)(((char*)(s->ptr)) + (sizeof(int) + size)) = eyecatcher; /* end eyecatcher */
		s->size = size;
		space -= strlen(s->file);
		s->file = realloc(s->file, filenamelen);
		space += filenamelen;
		strcpy(s->file, file);
		s->line = line;
		rc = s->ptr;
		TreeAdd(&heap, s, space);
	}
	Thread_unlock_mutex(heap_mutex);
	return (rc == NULL) ? NULL : ((int*)(rc)) + 1;	/* skip start eyecatcher */
}
########################rank 9#############################
static void fib_heap_cascading_cut(FibHeap *heap, FibNode *node) 
{
    FibNode *parent = node->parent;
    if (parent != NULL)
        return ;
    if (node->marked == 0) 
        node->marked = 1;
    else
    {
        fib_heap_cut(heap, node, parent);
        fib_heap_cascading_cut(heap, parent);
    }
}
########################rank 10#############################
static int in_heap(const void *p)
{
    return p < mem_get_brk() && p >= mem_heap_lo();
}
----------------------------QUERY-------------------------------
search a file in directory recursively
########################rank 1#############################
int
_lseek(int file,
       int ptr,
       int dir)
{
  return 0;
}
########################rank 2#############################
static char const *file_name(char const *path)
{
	char const *name;
	name = strrchr(path, '/');
	if (!name) {
		name = strrchr(path, '\\'); 	/* eww windows? */
	}
	if (!name) {
		name = path;
	} else {
		name++;
	}
	return name;
}
########################rank 3#############################
bool afs_empty(assetdir_t* base)
{
    int i;
    if(darray_length(base->file) > 0)
        return false;
    if(darray_length(base->dir) > 2) /* skip "." and ".." */
        return false;
    for(i = 0; i < darray_length(base->dir); i++) { /* just in case... */
        if(0 != strcmp(base->dir[i].name, ".") && 0 != strcmp(base->dir[i].name, ".."))
            return false;
    }
    return true;
}
########################rank 4#############################
int
ffropen(const char *fn, struct buffer *bp)
{
  // On Mona, we can't assume fopen succeed on directory.
#ifdef MONA
  if (fisdir(fn) == TRUE) {
		return (FIODIR);
  }
	if ((ffp = fopen(fn, "r")) == NULL) {
		if (errno == ENOENT) {
			return (FIOFNF);
        }
		return (FIOERR);
	}
	ffstat(bp);
	return (FIOSUC);
#else
	if ((ffp = fopen(fn, "r")) == NULL) {
		if (errno == ENOENT)
			return (FIOFNF);
		return (FIOERR);
	}
	if (fisdir(fn) == TRUE)
		return (FIODIR);
	ffstat(bp);
	return (FIOSUC);
#endif
}
########################rank 5#############################
char path_file_name[256];
char * getfilename(int idx) {
  sprintf(path_file_name,"%d", idx);
  return path_file_name;
}
########################rank 6#############################
int make_valid_path(char *dir, mode_t mode)
{
    struct stat st;
    char *tmp = NULL, *path = stripslash(strdup(dir));
    int retval;
    if (stat(path, &st) == 0) { /* file exists */
        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
        else { retval = 0; goto end; } /* not a directory.  Oops. */
    }
    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
    retval = 1;
end:
    if (tmp != NULL) free(tmp);
    if (path != NULL) free(path);
    return retval;
}
########################rank 7#############################
static pofile_t *L10n_FindPOFile( podomain_t *podomain, const char *filepath ) {
	pofile_t *pofile;
	if( !podomain ) {
		return NULL;
	}
	for( pofile = podomain->pofiles_head; pofile != NULL; pofile = pofile->next ) {
		if( !Q_stricmp( pofile->path, filepath ) ) {
			return pofile;
		}
	}
	return NULL;
}
########################rank 8#############################
char * file_basename(char * file) {
	char * c = strrchr(file, '/');
	if (!c) return file;
	return (c+1);
}
########################rank 9#############################
char *find_file(char** path, char* suffix) {
  char *res;
#ifndef WIN32
  struct stat sb;
  int i = 0;
  while (path[i] != NULL) {
    res = concat(path[i], suffix);
    if ( stat(res, &sb) == 0 && S_ISREG(sb.st_mode) ) 
      return res;
    else
      free(res);
    ++i;
  }
#else
  return concat(path[0], suffix);
#endif
  return NULL;
}
########################rank 10#############################
PIXAC *
pixacompCreateFromFiles(const char  *dirname,
                        const char  *substr,
                        l_int32      comptype)
{
PIXAC    *pixac;
SARRAY   *sa;
    PROCNAME("pixacompCreateFromFiles");
    if (!dirname)
        return (PIXAC *)ERROR_PTR("dirname not defined", procName, NULL);
    if (comptype != IFF_DEFAULT && comptype != IFF_TIFF_G4 &&
        comptype != IFF_PNG && comptype != IFF_JFIF_JPEG)
        return (PIXAC *)ERROR_PTR("invalid comptype", procName, NULL);
    if ((sa = getSortedPathnamesInDirectory(dirname, substr, 0, 0)) == NULL)
        return (PIXAC *)ERROR_PTR("sa not made", procName, NULL);
    pixac = pixacompCreateFromSA(sa, comptype);
    sarrayDestroy(&sa);
    return pixac;
}
----------------------------QUERY-------------------------------
compress block of raw data
########################rank 1#############################
local void
copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;	/* the input data */
    unsigned len;	/* its length */
    int	header;	/* true if block header must be written */
{
	bi_windup(s);	/* align on byte boundary */
	s->last_eob_len = 8;	/* enough lookahead for inflate */
	if (header) {
		put_short(s, (ush)len);
		put_short(s, (ush)~len);
#ifdef DEBUG_ZLIB
		s->bits_sent += 2*16;
#endif
	}
#ifdef DEBUG_ZLIB
	s->bits_sent += (ulg)len<<3;
#endif
	Assert(s->pending + len < s->pending_buf_size, "pending_buf overrun");
	zmemcpy(&s->pending_buf[s->pending], buf, len);	/* PPP */
	s->pending += len;				/* PPP */
}
########################rank 2#############################
static int inflate_stored(__G)
     __GDEF
{
  UINT_D64 w;           /* current window position (deflate64: up to 64k!) */
  unsigned n;           /* number of bytes in block */
  register ulg b;       /* bit buffer */
  register unsigned k;  /* number of bits in bit buffer */
  int retval = 0;       /* error code returned: initialized to "no error" */
  Trace((stderr, "\nstored block"));
  b = G.bb;                       /* initialize bit buffer */
  k = G.bk;
  w = G.wp;                       /* initialize window position */
  n = k & 7;
  DUMPBITS(n);
  NEEDBITS(16)
  n = ((unsigned)b & 0xffff);
  DUMPBITS(16)
  NEEDBITS(16)
  if (n != (unsigned)((~b) & 0xffff))
    return 1;                   /* error in compressed data */
  DUMPBITS(16)
  while (n--)
  {
    NEEDBITS(8)
    redirSlide[w++] = (uch)b;
    if (w == wsize)
    {
      if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
      w = 0;
    }
    DUMPBITS(8)
  }
  G.wp = (unsigned)w;             /* restore global window pointer */
  G.bb = b;                       /* restore global bit buffer */
  G.bk = k;
cleanup_and_exit:
  return retval;
}
########################rank 3#############################
static inline unsigned short *block_header(void *header)
{
    //assert(header < mem_get_brk());
    return half_word(header);
}
########################rank 4#############################
static void blake2s_update(blake2s_state *S, const uchar *input,
  uint input_size) {
    uint left, fill;
    while(input_size > 0) {
        left = S->buflen;
        fill = 2 * BLOCK_SIZE - left;
        if(input_size > fill) {
            neoscrypt_copy(S->buf + left, input, fill);
            S->buflen += fill;
            S->t[0] += BLOCK_SIZE;
            blake2s_compress(S);
            neoscrypt_copy(S->buf, S->buf + BLOCK_SIZE, BLOCK_SIZE);
            S->buflen -= BLOCK_SIZE;
            input += fill;
            input_size -= fill;
        } else {
            neoscrypt_copy(S->buf + left, input, input_size);
            S->buflen += input_size;
            input += input_size;
            input_size = 0;
        }
    }
}
########################rank 5#############################
static int _unmarshal_lzxc_reset_table(unsigned char **pData,
                                       unsigned int *pDataLen,
                                       struct chmLzxcResetTable *dest)
{
    if (*pDataLen != _CHM_LZXC_RESETTABLE_V1_LEN)
        return 0;
    _unmarshal_uint32    (pData, pDataLen, &dest->version);
    _unmarshal_uint32    (pData, pDataLen, &dest->block_count);
    _unmarshal_uint32    (pData, pDataLen, &dest->unknown);
    _unmarshal_uint32    (pData, pDataLen, &dest->table_offset);
    _unmarshal_uint64    (pData, pDataLen, &dest->uncompressed_len);
    _unmarshal_uint64    (pData, pDataLen, &dest->compressed_len);
    _unmarshal_uint64    (pData, pDataLen, &dest->block_len);
    if (dest->version != 2)
        return 0;
    return 1;
}
########################rank 6#############################
int
inflateSyncPoint(z)
z_streamp z;
{
	if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
		return (Z_STREAM_ERROR);
	return (inflate_blocks_sync_point(z->state->blocks));
}
########################rank 7#############################
local int gz_decomp( state )
gz_statep state;
{
	int ret;
	unsigned had;
	unsigned long crc, len;
	z_streamp strm = &( state->strm );
	had = strm->avail_out;
	do
	{
		if ( strm->avail_in == 0 && gz_avail( state ) == -1 )
		{
			return -1;
		}
		if ( strm->avail_in == 0 )
		{
			gz_error( state, Z_DATA_ERROR, "unexpected end of file" );
			return -1;
		}
		ret = inflate( strm, Z_NO_FLUSH );
		if ( ret == Z_STREAM_ERROR || ret == Z_NEED_DICT )
		{
			gz_error( state, Z_STREAM_ERROR,
			          "internal error: inflate stream corrupt" );
			return -1;
		}
		if ( ret == Z_MEM_ERROR )
		{
			gz_error( state, Z_MEM_ERROR, "out of memory" );
			return -1;
		}
		if ( ret == Z_DATA_ERROR )              /* deflate stream invalid */
		{
			gz_error( state, Z_DATA_ERROR,
			          strm->msg == NULL ? "compressed data error" : strm->msg );
			return -1;
		}
	}
	while ( strm->avail_out && ret != Z_STREAM_END );
	state->have = had - strm->avail_out;
	state->next = strm->next_out - state->have;
	strm->adler = crc32( strm->adler, state->next, state->have );
	if ( ret == Z_STREAM_END )
	{
		if ( gz_next4( state, &crc ) == -1 || gz_next4( state, &len ) == -1 )
		{
			gz_error( state, Z_DATA_ERROR, "unexpected end of file" );
			return -1;
		}
		if ( crc != strm->adler )
		{
			gz_error( state, Z_DATA_ERROR, "incorrect data check" );
			return -1;
		}
		if ( len != ( strm->total_out & 0xffffffffL ) )
		{
			gz_error( state, Z_DATA_ERROR, "incorrect length check" );
			return -1;
		}
		state->how = LOOK;      /* ready for next stream, once have is 0 (leave
                                   state->direct unchanged to remember how) */
	}
	return 0;
}
########################rank 8#############################
int deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
    version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
	deflate_state *s;
	int noheader = 0;
	static const char *my_version = ZLIB_VERSION;
	ushf *overlay;
	if (version == Z_NULL || version[0] != my_version[0] ||
	    stream_size != sizeof (z_stream)) {
		return (Z_VERSION_ERROR);
	}
	if (strm == Z_NULL)
		return (Z_STREAM_ERROR);
	strm->msg = Z_NULL;
#ifndef NO_ZCFUNCS
	if (strm->zalloc == Z_NULL) {
		strm->zalloc = zcalloc;
		strm->opaque = (voidpf)0;
	}
	if (strm->zfree == Z_NULL) strm->zfree = zcfree;
#endif
	if (level == Z_DEFAULT_COMPRESSION) level = 6;
#ifdef FASTEST
	level = 1;
#endif
	if (windowBits < 0) { /* undocumented feature: suppress zlib header */
		noheader = 1;
		windowBits = -windowBits;
	}
	if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
	    windowBits <= 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
		return (Z_STREAM_ERROR);
	}
	s = (deflate_state *) ZALLOC(strm, 1, sizeof (deflate_state));
	if (s == Z_NULL)
		return (Z_MEM_ERROR);
	strm->state = (struct internal_state FAR *)s;
	s->strm = strm;
	s->noheader = noheader;
	s->w_bits = windowBits;
	s->w_size = 1 << s->w_bits;
	s->w_mask = s->w_size - 1;
	s->hash_bits = memLevel + 7;
	s->hash_size = 1 << s->hash_bits;
	s->hash_mask = s->hash_size - 1;
	s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
	s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof (Byte));
	s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof (Pos));
	s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof (Pos));
	s->lit_bufsize = 1 << (memLevel + 6);	/* 16K elements by default */
	overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof (ush)+2);
	s->pending_buf = (uchf *) overlay;
	s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof (ush)+2L);
	if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
	    s->pending_buf == Z_NULL) {
		strm->msg = ERR_MSG(Z_MEM_ERROR);
		s->status = INIT_STATE;
		(void) deflateEnd(strm);
		return (Z_MEM_ERROR);
	}
	s->d_buf = overlay + s->lit_bufsize/sizeof (ush);
	s->l_buf = s->pending_buf + (1+sizeof (ush))*s->lit_bufsize;
	s->level = level;
	s->strategy = strategy;
	s->method = (Byte)method;
	return (deflateReset(strm));
}
########################rank 9#############################
lzg_uint32_t LZG_MaxEncodedSize(lzg_uint32_t insize)
{
    return LZG_HEADER_SIZE + insize;
}
########################rank 10#############################
lzg_uint32_t LZG_MaxEncodedSize(lzg_uint32_t insize)
{
    return LZG_HEADER_SIZE + insize;
}
----------------------------QUERY-------------------------------
allocate and clean buffer
########################rank 1#############################
Fsignal mw_change_fsignal(Fsignal signal, int N)
{
    int mem_size;
    if (signal == NULL)
        signal = mw_new_fsignal();
    if (signal == NULL)
        return (NULL);
    mem_size = N * sizeof(float);
    if (mem_size > signal->allocsize)
    {
        if (signal->values != NULL)
        {
            free(signal->values);
            signal->values = NULL;
        }
        if (mw_alloc_fsignal(signal, N) == NULL)
        {
            mw_delete_fsignal(signal);
            return (NULL);
        }
    }
    else
        signal->size = N;
    return (signal);
}
########################rank 2#############################
int memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
    memset( &heap, 0, sizeof(buffer_alloc_ctx) );
    memset( buf, 0, len );
#if defined(POLARSSL_THREADING_C)
    polarssl_mutex_init( &heap.mutex );
    platform_set_malloc_free( buffer_alloc_malloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    platform_set_malloc_free( buffer_alloc_malloc, buffer_alloc_free );
#endif
    if( (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE )
    {
        len -= POLARSSL_MEMORY_ALIGN_MULTIPLE
             - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
        buf += POLARSSL_MEMORY_ALIGN_MULTIPLE
             - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
    }
    heap.buf = buf;
    heap.len = len;
    heap.first = (memory_header *) buf;
    heap.first->size = len - sizeof(memory_header);
    heap.first->magic1 = MAGIC1;
    heap.first->magic2 = MAGIC2;
    heap.first_free = heap.first;
    return( 0 );
}
########################rank 3#############################
int sqlite3MemTraceDeactivate(void){
  int rc = SQLITE_OK;
  if( memtraceBase.xMalloc!=0 ){
    rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);
    if( rc==SQLITE_OK ){
      memset(&memtraceBase, 0, sizeof(memtraceBase));
    }
  }
  memtraceOut = 0;
  return rc;
}
########################rank 4#############################
int sqlite3MemTraceDeactivate(void){
  int rc = SQLITE_OK;
  if( memtraceBase.xMalloc!=0 ){
    rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);
    if( rc==SQLITE_OK ){
      memset(&memtraceBase, 0, sizeof(memtraceBase));
    }
  }
  memtraceOut = 0;
  return rc;
}
########################rank 5#############################
int sqlite3MemTraceDeactivate(void){
  int rc = SQLITE_OK;
  if( memtraceBase.xMalloc!=0 ){
    rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);
    if( rc==SQLITE_OK ){
      memset(&memtraceBase, 0, sizeof(memtraceBase));
    }
  }
  memtraceOut = 0;
  return rc;
}
########################rank 6#############################
void mm_free(void *bp)
{
  if (bp == 0)
    return;
  size_t size = GET_SIZE(HDRP(bp));
  if (heap_listp == 0){
    mm_init();
  }
  PUT(HDRP(bp), PACK(size, 0));
  PUT(FTRP(bp), PACK(size, 0));
  coalesce(bp);
}
########################rank 7#############################
void mm_free(void *bp)
{
  if (bp == 0)
    return;
  size_t size = GET_SIZE(HDRP(bp));
  if (heap_listp == 0){
    mm_init();
  }
  PUT(HDRP(bp), PACK(size, 0));
  PUT(FTRP(bp), PACK(size, 0));
  coalesce(bp);
}
########################rank 8#############################
Jbig2Image *
jbig2_image_new(Jbig2Ctx *ctx, uint32_t width, uint32_t height)
{
    Jbig2Image *image;
    uint32_t stride;
    if (width == 0 || height == 0) {
        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, "failed to create zero sized image");
        return NULL;
    }
    image = jbig2_new(ctx, Jbig2Image, 1);
    if (image == NULL) {
        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, "failed to allocate image");
        return NULL;
    }
    stride = ((width - 1) >> 3) + 1;    /* generate a byte-aligned stride */
    if (height > (INT32_MAX / stride)) {
        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, "integer multiplication overflow (stride=%u, height=%u)", stride, height);
        jbig2_free(ctx->allocator, image);
        return NULL;
    }
    image->data = jbig2_new(ctx, uint8_t, (size_t) height * stride);
    if (image->data == NULL) {
        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, "failed to allocate image data buffer (stride=%u, height=%u)", stride, height);
        jbig2_free(ctx->allocator, image);
        return NULL;
    }
    image->width = width;
    image->height = height;
    image->stride = stride;
    image->refcount = 1;
    return image;
}
########################rank 9#############################
static void cstr_realloc(CString *cstr, int new_size)
{
    int size;
    void *data;
    size = cstr->size_allocated;
    if (size == 0)
        size = 8; 
    while (size < new_size)
        size = size * 2;
    data = tcc_realloc(cstr->data_allocated, size);
    if (!data)
        error("memory full");
    cstr->data_allocated = data;
    cstr->size_allocated = size;
    cstr->data = data;
}
########################rank 10#############################
Fimage mw_change_fimage(Fimage image, int nrow, int ncol)
{
    int size;
    if (image == NULL)
        image = mw_new_fimage();
    if (image == NULL)
        return (NULL);
    size = nrow * ncol * sizeof(float);
    if (size > image->allocsize)
    {
        if (image->gray != NULL)
        {
            free(image->gray);
            image->gray = NULL;
        }
        if (mw_alloc_fimage(image, nrow, ncol) == NULL)
        {
            mw_delete_fimage(image);
            return (NULL);
        }
    }
    else
    {
        image->nrow = nrow;
        image->ncol = ncol;
    }
    return (image);
}
----------------------------QUERY-------------------------------
receive N byte from socket
########################rank 1#############################
int                          
Nread(SOCKET s, void* bufp, int count )
{
#if defined(__lynx__) || defined(__svr4__) || defined(_AIX) || defined(__NTVIS__) || defined(__FreeBSD__)
  struct sockaddr from;
#else
  struct sockaddr_in from;
#endif
  int len = sizeof(from);
  register int cnt;
  if (timeout > 0) {
    fd_set readfds, exceptfds;
    struct timeval tv_timeout;
    int n;
    tv_timeout.tv_sec = timeout/1000;
    tv_timeout.tv_usec = (timeout%1000)*1000;
    FD_ZERO(&readfds);
    FD_ZERO(&exceptfds);
    FD_SET(s, &readfds);
    FD_SET(s, &exceptfds);
    n =  select( s+1, &readfds, NULL, &exceptfds, &tv_timeout );
    if (n == SOCKET_ERROR) {
      sockets_err("select read");
    } else if (n == 0) {
      return (0);
    }
  }
  if( udp )  
    {cnt = recvfrom( s, bufp, count, 0, SOCKADDR_CAST &from, &len );
    numCalls++;
    } 
  else 
    {if( b_flag )  cnt = mread( s, bufp, count );        /* fill bufp */
    else 
      {
#if defined(__NTVIS__)
        cnt = recv( s, bufp, count, 0 );
#else
        cnt = read( s, bufp, count );
#endif /* __NTVIS__ */
        numCalls++;
      }
    if (touchdata && cnt > 0) 
      {register int c = cnt, sum = 0;
       register char *b = bufp;
       while (c--) sum += *b++;
      }
    }
  return(cnt);
}
########################rank 2#############################
int connect_socket(const int connect_port, const char *address) {
	struct sockaddr_in a;
	struct hostent *ha;
	int s;
	// get a fresh juicy socket
	if((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
		perror("ERROR: socket()");
		close(s);
		return -1;
	}
	// clear the sockaddr_in structure
	memset(&a, 0, sizeof(a));
	a.sin_port = htons(connect_port);
	a.sin_family = AF_INET;
	// get IP from host name, if appropriate
	if((ha = gethostbyname(address)) == NULL) {
		perror("ERROR: gethostbyname()");
		return -1;
	}
	if(ha->h_length == 0) {
		printf("ERROR: No addresses for %s. Aborting.\n", address);
		return -1;
	}
	memcpy(&a.sin_addr, ha->h_addr_list[0], ha->h_length);
	// connect to the remote host
	if(connect(s, (struct sockaddr *) &a, sizeof(a)) < 0) {
		perror("ERROR: connect()");
		shutdown(s, SHUT_RDWR);
		close(s);
		return -1;
	}
	// w00t, it worked.
	return s;
}
########################rank 3#############################
static void mg_sock_get_addr(sock_t sock, int remote,
                             union socket_address *sa) {
  socklen_t slen = sizeof(*sa);
  memset(sa, 0, slen);
  if (remote) {
    getpeername(sock, &sa->sa, &slen);
  } else {
    getsockname(sock, &sa->sa, &slen);
  }
}
########################rank 4#############################
static void mg_sock_get_addr(sock_t sock, int remote,
                             union socket_address *sa) {
  socklen_t slen = sizeof(*sa);
  memset(sa, 0, slen);
  if (remote) {
    getpeername(sock, &sa->sa, &slen);
  } else {
    getsockname(sock, &sa->sa, &slen);
  }
}
########################rank 5#############################
static void mg_sock_get_addr(sock_t sock, int remote,
                             union socket_address *sa) {
  socklen_t slen = sizeof(*sa);
  memset(sa, 0, slen);
  if (remote) {
    getpeername(sock, &sa->sa, &slen);
  } else {
    getsockname(sock, &sa->sa, &slen);
  }
}
########################rank 6#############################
static void mg_sock_get_addr(sock_t sock, int remote,
                             union socket_address *sa) {
  socklen_t slen = sizeof(*sa);
  memset(sa, 0, slen);
  if (remote) {
    getpeername(sock, &sa->sa, &slen);
  } else {
    getsockname(sock, &sa->sa, &slen);
  }
}
########################rank 7#############################
static void mg_sock_get_addr(sock_t sock, int remote,
                             union socket_address *sa) {
  socklen_t slen = sizeof(*sa);
  memset(sa, 0, slen);
  if (remote) {
    getpeername(sock, &sa->sa, &slen);
  } else {
    getsockname(sock, &sa->sa, &slen);
  }
}
########################rank 8#############################
SOCKET open_socket(int local_port, int bind_any) {
  SOCKET sock_fd;
  struct sockaddr_in local_address;
  int sockopt = 1;
  if((sock_fd = socket(PF_INET, SOCK_DGRAM, 0))  < 0) {
    traceEvent(TRACE_ERROR, "Unable to create socket [%s][%d]\n",
	       strerror(errno), sock_fd);
    return(-1);
  }
#ifndef WIN32
#endif
  setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR,(char *)&sockopt, sizeof(sockopt));
  memset(&local_address, 0, sizeof(local_address));
  local_address.sin_family = AF_INET;
  local_address.sin_port = htons(local_port);
  local_address.sin_addr.s_addr = htonl(bind_any ? INADDR_ANY : INADDR_LOOPBACK);
  if(bind(sock_fd,(struct sockaddr*) &local_address, sizeof(local_address)) == -1) {
    traceEvent(TRACE_ERROR, "Bind error on local port %u [%s]\n", local_port, strerror(errno));
    return(-1);
  }
  return(sock_fd);
}
########################rank 9#############################
int listen_socket(const int listen_port)
{
	struct sockaddr_in a;
	int s;
	int yes = 1;
	// get a fresh juicy socket
	if((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
		perror("ERROR: socket()");
		return -1;
	}
	// make sure it's quickly reusable
	if(setsockopt(s, SOL_SOCKET, SO_REUSEADDR,	(char *) &yes, sizeof(yes)) < 0) {
		perror("ERROR: setsockopt()");
		close(s);
		return -1;
	}
	// listen on all of the hosts interfaces/addresses (0.0.0.0)
	memset(&a, 0, sizeof(a));
	a.sin_port = htons(listen_port);
	a.sin_addr.s_addr = htonl(INADDR_ANY);
	a.sin_family = AF_INET;
	if(bind(s, (struct sockaddr *) &a, sizeof(a)) < 0) {
		perror("ERROR: bind()");
		close(s);
		return -1;
	}
	listen(s, 10);
	return s;
}
########################rank 10#############################
static int readntrip(ntrip_t *ntrip, unsigned char *buff, int n, char *msg)
{
    int nb;
    tracet(4,"readntrip: n=%d\n",n);
    if (!waitntrip(ntrip,msg)) return 0;
    if (ntrip->nb>0) { 
        nb=ntrip->nb<=n?ntrip->nb:n;
        memcpy(buff,ntrip->buff+ntrip->nb-nb,nb);
        ntrip->nb=0;
        return nb;
    }
    return readtcpcli(ntrip->tcp,buff,n,msg);
}
----------------------------QUERY-------------------------------
lookup key in a hash map
########################rank 1#############################
static void *searchHashTable(HashTable *hashtable, void *value, unsigned int hashValue)
{
  unsigned int 
    position = hashValue % hashtable->tableSize;
  HashElem 
    *elem, 
    *result = (HashElem*)NULL; 
  for(elem = hashtable->table[position]; 
      elem; 
      elem = elem->next)
    {
      if(elem->fullKey  == hashValue && 
	 hashtable->equalFunction(hashtable, elem->value, value))
	{
	  result = elem->value; 
	  break;
	}
    }
  return result;
}
########################rank 2#############################
int hash(int key, int capacity){
  return key % capacity;
}
########################rank 3#############################
static int binHash(const void *pKey, int nKey){
  int h = 0;
  const char *z = (const char *)pKey;
  while( nKey-- > 0 ){
    h = (h<<3) ^ h ^ *(z++);
  }
  return h & 0x7fffffff;
}
########################rank 4#############################
static int JimInsertHashEntry(Jim_HashTable *ht, const void *key)
{
    unsigned int h;
    Jim_HashEntry *he;
    if (JimExpandHashTableIfNeeded(ht) == JIM_ERR)
        return -1;
    h = Jim_HashKey(ht, key) & ht->sizemask;
    he = ht->table[h];
    while (he) {
        if (Jim_CompareHashKeys(ht, key, he->key))
            return -1;
        he = he->next;
    }
    return h;
}
########################rank 5#############################
int hash(char *name)
{
	register int hashval;
	for (hashval = 0; *name;)
		hashval += *name++;
	return(hashval % HASHSIZE);
}
########################rank 6#############################
uint32_t dalias_hash(char *s0) {
	unsigned char *s = (void *) s0;
	uint_fast32_t h = 0;
	while(*s) {
		h = 16 * h + *s++;
		h ^= h >> 24 & 0xf0;
	}
	return h & 0xfffffff;
}
########################rank 7#############################
long long sdbm(char s[])
{
    long long hash = 0;
    int i = 0;
    while (s[i] != '\0')
    {
        hash = s[i] + (hash << 6) + (hash << 16) - hash;
        i++;
    }
    return hash;
}
########################rank 8#############################
static uint32_t hash(const char *s)
{
	uint32_t hash = 0;
	while (*s)
		hash = 31 * hash + *s++;
	return hash;
}
########################rank 9#############################
const void *hashMapGet(HashMap *map, const char key[]) {
  HashMapEntry *e;
  uint32_t      hash  = doHash(key);
  size_t        index = indexFor(hash, map->capacity);
  for (e = map->table[index]; e != NULL; e = e->next) {
    if (isHit(e, key, hash))
      return e->value;
  }
  return NULL;
}
########################rank 10#############################
void * 
hashtable_search(struct hashtable *h, void *k)
{
    struct entry *e;
    unsigned int hashvalue, index;
    hashvalue = hash(h,k);
    index = indexFor(h->tablelength,hashvalue);
    e = h->table[index];
    while (NULL != e)
    {
        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) return e->v;
        e = e->next;
    }
    return NULL;
}
----------------------------QUERY-------------------------------
fast integral power function
########################rank 1#############################
static int64_t power(int64_t base, int64_t exp)
{
    int64_t result = 1;
    while(exp)
    {
        result *= base; exp--;
    }
    return result;
}
########################rank 2#############################
static int64_t power(int64_t base, int64_t exp)
{
    int64_t result = 1;
    while(exp)
    {
        result *= base; exp--;
    }
    return result;
}
########################rank 3#############################
float IwFreq2Float(struct iwreq *inreq) {
    return ((float) inreq->u.freq.m) * pow(10,inreq->u.freq.e);
}
########################rank 4#############################
l_uint32
convertGrayCodeToBinary(l_uint32 val)
{
l_uint32  shift;
    for (shift = 1; shift < 32; shift <<= 1)
        val ^= val >> shift;
    return val;
}
########################rank 5#############################
PaError Pa_GetSampleSize( PaSampleFormat format )
{
    int size;
    switch(format )
    {
    case paUInt8:
    case paInt8:
        size = 1;
        break;
    case paInt16:
        size = 2;
        break;
    case paPackedInt24:
        size = 3;
        break;
    case paFloat32:
    case paInt32:
    case paInt24:
        size = 4;
        break;
    default:
        size = paSampleFormatNotSupported;
        break;
    }
    return (PaError) size;
}
########################rank 6#############################
double lagrange(const double x[],
                const double y[],
                long n,
                double xval)
{
  long i, j;
  double yval = 0.;
  for( i=0; i < n; i++ )
    {
      double l = 1.;
      for( j=0; j < n; j++ )
	if( i != j )
	  l *= (xval-x[j])/(x[i]-x[j]);
      yval += y[i]*l;
    }
  return yval;
}
########################rank 7#############################
uint8_t u8g_com_arduino_st7920_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr)
{
  return 1;
}
########################rank 8#############################
uint8_t u8g_com_arduino_st7920_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr)
{
  return 1;
}
########################rank 9#############################
PaUtilZeroer* PaUtil_SelectZeroer( PaSampleFormat destinationFormat )
{
    switch( destinationFormat & ~paNonInterleaved ){
    case paFloat32:
        return paZeroers.Zero32;
    case paInt32:
        return paZeroers.Zero32;
    case paInt24:
        return paZeroers.Zero24;
    case paInt16:
        return paZeroers.Zero16;
    case paInt8:
        return paZeroers.Zero8;
    case paUInt8:
        return paZeroers.ZeroU8;
    default: return 0;
    }
}
########################rank 10#############################
extern double PI;
extern int sgngam;
static double jvs(n, x) double n, x;
{
  double t, u, y, z, k;
  int ex;
  z = -x * x / 4.0;
  u = 1.0;
  y = u;
  k = 1.0;
  t = 1.0;
  while (t > MACHEP) {
    u *= z / (k * (n + k));
    y += u;
    k += 1.0;
    if (y != 0)
      t = fabs(u / y);
  }
#if DEBUG
  printf("power series=%.5e ", y);
#endif
  t = frexp(0.5 * x, &ex);
  ex = ex * n;
  if ((ex > -1023) && (ex < 1023) && (n > 0.0) && (n < (MAXGAM - 1.0))) {
    t = pow(0.5 * x, n) / gamma(n + 1.0);
#if DEBUG
    printf("pow(.5*x, %.4e)/gamma(n+1)=%.5e\n", n, t);
#endif
    y *= t;
  } else {
#if DEBUG
    z = n * log(0.5 * x);
    k = lgam(n + 1.0);
    t = z - k;
    printf("log pow=%.5e, lgam(%.4e)=%.5e\n", z, n + 1.0, k);
#else
    t = n * log(0.5 * x) - lgam(n + 1.0);
#endif
    if (y < 0) {
      sgngam = -sgngam;
      y = -y;
    }
    t += log(y);
#if DEBUG
    printf("log y=%.5e\n", log(y));
#endif
    if (t < -MAXLOG) {
      return (0.0);
    }
    if (t > MAXLOG) {
      mtherr("Jv", OVERFLOW);
      return (MAXNUM);
    }
    y = sgngam * exp(t);
  }
  return (y);
}
----------------------------QUERY-------------------------------
check if directory is empty
########################rank 1#############################
bool afs_empty(assetdir_t* base)
{
    int i;
    if(darray_length(base->file) > 0)
        return false;
    if(darray_length(base->dir) > 2) /* skip "." and ".." */
        return false;
    for(i = 0; i < darray_length(base->dir); i++) { /* just in case... */
        if(0 != strcmp(base->dir[i].name, ".") && 0 != strcmp(base->dir[i].name, ".."))
            return false;
    }
    return true;
}
########################rank 2#############################
static bool is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st))
		return 0;
	return S_ISDIR(st.st_mode);
}
########################rank 3#############################
static int shl__is_dir(const char *path)
{
	struct stat st;
	if (stat(path, &st) < 0)
		return -errno;
	return S_ISDIR(st.st_mode);
}
########################rank 4#############################
static int
isRootDirPath(const char *path)
{
    return findRootDirPath(path) != NULL;
}
########################rank 5#############################
const char *Sys_Basename( char *path )
{
	return basename( path );
}
########################rank 6#############################
const char *fs_base_dir(void)
{
    return fs_dir_base;
}
########################rank 7#############################
static int dirCnt;      /* Count of directories added to watch list */
static int ifd;         /* Inotify file descriptor */
static int
traverseTree(const char *pathname, const struct stat *sb, int tflag,
             struct FTW *ftwbuf)
{
    int wd, slot, flags;
    if (! S_ISDIR(sb->st_mode))
        return 0;               /* Ignore nondirectory files */
    flags = IN_CREATE | IN_MOVED_FROM | IN_MOVED_TO | IN_DELETE_SELF;
    if (isRootDirPath(pathname))
        flags |= IN_MOVE_SELF;
    wd = inotify_add_watch(ifd, pathname, flags | IN_ONLYDIR);
    if (wd == -1) {
           already have been deleted or renamed, in which case we'll get
           an ENOENT error. In that case, we log the error, but
           carry on execution. Other errors are unexpected, and if we
           hit them, we give up. */
        logMessage(VB_BASIC, "inotify_add_watch: %s: %s\n",
                pathname, strerror(errno));
        if (errno == ENOENT)
            return 0;
        else
            exit(EXIT_FAILURE);
    }
    if (findWatch(wd) >= 0) {
           nothing more to do. */
        logMessage(VB_BASIC, "WD %d already in cache (%s)\n", wd, pathname);
        return 0;
    }
    dirCnt++;
    slot = addWatchToCache(wd, pathname);
    logMessage(VB_NOISY, "    watchDir: wd = %d [cache slot: %d]; %s\n",
                wd, slot, pathname);
    return 0;
}
########################rank 8#############################
int
showcwdir(int f, int n)
{
	ewprintf("Current directory: %s", mgcwd);
	return (TRUE);
}
########################rank 9#############################
const char *Sys_Dirname( char *path )
{
	return dirname( path );
}
########################rank 10#############################
int make_valid_path(char *dir, mode_t mode)
{
    struct stat st;
    char *tmp = NULL, *path = stripslash(strdup(dir));
    int retval;
    if (stat(path, &st) == 0) { /* file exists */
        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
        else { retval = 0; goto end; } /* not a directory.  Oops. */
    }
    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
    retval = 1;
end:
    if (tmp != NULL) free(tmp);
    if (path != NULL) free(path);
    return retval;
}
----------------------------QUERY-------------------------------
create a new tree node
########################rank 1#############################
static int* inorderTraversal(struct TreeNode* root, int* returnSize)
{
    if (root == NULL) {
        *returnSize = 0;
        return NULL;
    }
    int count = 0;
    int *result = malloc(5000 * sizeof(int));
    traverse(root, result, &count);
    *returnSize = count;
    return result;
}
########################rank 2#############################
static rb_node rb_new_node(rb_tree tree, int data) {
	rb_node ret;
	if (rb_mem_pool != NULL) {
		ret = rb_mem_pool;
		rb_mem_pool = ret->parent;
	} else {
		if ((ret = malloc(sizeof(*ret))) == NULL) {
			fprintf(stderr, "Error: out of memory.\n");
			return NULL;
		}
	}
	ret->key = data;
	ret->parent = tree->nil;
	ret->lchild = tree->nil;
	ret->rchild = tree->nil;
	ret->color = 'r';
	return ret;
}
########################rank 3#############################
RBRoot* create_rbtree()
{
	RBRoot *root = (RBRoot *)malloc(sizeof(RBRoot));
	root->node = NULL;
	return root;
}
########################rank 4#############################
BOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function) {
	BOSTree *new_tree = malloc(sizeof(BOSTree));
	new_tree->root_node = NULL;
	new_tree->cmp_function = cmp_function;
	new_tree->free_function = free_function;
	return new_tree;
}
########################rank 5#############################
void insert_r(struct TrieNode* root, char* word) {
    if (root == NULL || word == NULL) return;
    if (root->child != NULL) {
        if (root->child->val == *word) {
            if (*word == '\0') return;
            insert_r(root->child, word + 1);
        }
        else {
            struct TrieNode** p = &(root->child->sibling);
            while (*p) {
                if ((*p)->val == *word) {
                    if (*word == '\0') return;
                    insert_r(*p, word + 1);
                    return;
                }
                p = &((*p)->sibling);
            }
            struct TrieNode* new_node = trieCreate();
            new_node->val = *word;
            *p = new_node;
            if (*word == '\0') return;
            insert_r(*p, word + 1);
        }
    }
    else {
        struct TrieNode* new_node = trieCreate();
        new_node->val = *word;
        root->child = new_node;
        if (*word == '\0') return;
        insert_r(root->child, word + 1);
    }
}
########################rank 6#############################
static inline VisitedNodes VisitedNodesCreate(const ASPathNodeSource *source, void *context)
{
	VisitedNodes nodes;
	CCALLOC(nodes, sizeof(struct __VisitedNodes));
    nodes->source = source;
    nodes->context = context;
    return nodes;
}
########################rank 7#############################
static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1,
                                  AVLTreeNode *node2)
{
	int side;
	if (node2 != NULL) {
		node2->parent = node1->parent;
	}
	if (node1->parent == NULL) {
		tree->root_node = node2;
	} else {
		side = avl_tree_node_parent_side(node1);
		node1->parent->children[side] = node2;
		avl_tree_update_height(node1->parent);
	}
}
########################rank 8#############################
static srjson_t *srjson_New_Item(srjson_doc_t *doc)
{
	srjson_t *node = (srjson_t*)doc->malloc_fn(sizeof(srjson_t));
	if (node)
		memset(node, 0, sizeof(srjson_t));
	return node;
}
########################rank 9#############################
struct TreeNode* invertTree_r(struct TreeNode* root) {
    if (root == NULL) return NULL;
    struct TreeNode *t = root->left;
    root->left = root->right;;
    root->right = t;
    invertTree_r(root->left);
    invertTree_r(root->right);
    return root;
}
########################rank 10#############################
Node* avltree_minimum(AVLTree tree)
{
    if (tree == NULL)
        return NULL;
    while(tree->left != NULL)
        tree = tree->left;
    return tree;
}
----------------------------QUERY-------------------------------
free a dirty page
########################rank 1#############################
static int pager_write_hot_dirty_pages(Pager *pPager,Page *pDirty)
{
	int rc = VEDIS_OK;
	Page *pNext;
	for(;;){
		if( pDirty == 0 ){
			break;
		}
		pNext = pDirty->pPrevHot; /* Not a bug: Reverse link */
		if( (pDirty->flags & PAGE_DONT_WRITE) == 0 ){
			rc = vedisOsWrite(pPager->pfd,pDirty->zData,pPager->iPageSize,pDirty->pgno * pPager->iPageSize);
			if( rc != VEDIS_OK ){
				break;
			}
		}
		pDirty->flags &= ~(PAGE_DIRTY|PAGE_DONT_WRITE|PAGE_NEED_SYNC|PAGE_IN_JOURNAL|PAGE_HOT_DIRTY);
		if( pDirty->pDirtyPrev ){
			pDirty->pDirtyPrev->pDirtyNext = pDirty->pDirtyNext;
		}else{
			pPager->pDirty = pDirty->pDirtyNext;
		}
		if( pDirty->pDirtyNext ){
			pDirty->pDirtyNext->pDirtyPrev = pDirty->pDirtyPrev;
		}else{
			pPager->pFirstDirty = pDirty->pDirtyPrev;
		}
		pager_unlink_page(pPager,pDirty);
		pager_release_page(pPager,pDirty);
		pDirty = pNext;
	}
	return rc;
}
########################rank 2#############################
static int pager_write_dirty_pages(Pager *pPager,Page *pDirty)
{
	int rc = VEDIS_OK;
	Page *pNext;
	for(;;){
		if( pDirty == 0 ){
			break;
		}
		pNext = pDirty->pDirtyPrev; /* Not a bug: Reverse link */
		if( (pDirty->flags & PAGE_DONT_WRITE) == 0 ){
			rc = vedisOsWrite(pPager->pfd,pDirty->zData,pPager->iPageSize,pDirty->pgno * pPager->iPageSize);
			if( rc != VEDIS_OK ){
				break;
			}
		}
		pDirty->flags &= ~(PAGE_DIRTY|PAGE_DONT_WRITE|PAGE_NEED_SYNC|PAGE_IN_JOURNAL|PAGE_HOT_DIRTY);
		if( pDirty->nRef < 1 ){
			pager_unlink_page(pPager,pDirty);
			pager_release_page(pPager,pDirty);
		}
		pDirty = pNext;
	}
	pPager->pDirty = pPager->pFirstDirty = 0;
	pPager->pHotDirty = pPager->pFirstHot = 0;
	pPager->nHot = 0;
	return rc;
}
########################rank 3#############################
SQLITE_PRIVATE void
sqlite3BtreeGetTempCursor(BtCursor * pCur, BtCursor * pTempCur)
{
	assert(cursorHoldsMutex(pCur));
	memcpy(pTempCur, pCur, sizeof(*pCur));
	pTempCur->pNext = 0;
	pTempCur->pPrev = 0;
	if(pTempCur->pPage)
	{
		sqlite3PagerRef(pTempCur->pPage->pDbPage);
	}
}
########################rank 4#############################
static void fsPageBufferFree(Page *pPg){
  pPg->pFS->nCacheAlloc--;
  lsmFree(pPg->pFS->pEnv, pPg->aData);
  lsmFree(pPg->pFS->pEnv, pPg);
}
########################rank 5#############################
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ){
    Pager *pPager = pPg->pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
}
########################rank 6#############################
SQLITE_PRIVATE void
sqlite3BtreeReleaseTempCursor(BtCursor * pCur)
{
	assert(cursorHoldsMutex(pCur));
	if(pCur->pPage)
	{
		sqlite3PagerUnref(pCur->pPage->pDbPage);
	}
}
########################rank 7#############################
static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){
  assert( pPage!=0 );
  assert( PAGE_IS_UNPINNED(pPage) );
  assert( pPage->pLruNext );
  assert( pPage->pLruPrev );
  assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );
  pPage->pLruPrev->pLruNext = pPage->pLruNext;
  pPage->pLruNext->pLruPrev = pPage->pLruPrev;
  pPage->pLruNext = 0;
  pPage->pLruPrev = 0;
  assert( pPage->isAnchor==0 );
  assert( pPage->pCache->pGroup->lru.isAnchor==1 );
  pPage->pCache->nRecyclable--;
  return pPage;
}
########################rank 8#############################
SQLITE_PRIVATE int
sqlite3BtreeGetPage(BtShared * pBt,	/* The btree */
		    Pgno pgno,	/* Number of the page to fetch */
		    MemPage ** ppPage,	/* Return the page in this parameter */
		    int noContent	/* Do not load page content if true */
	)
{
	int rc;
	MemPage *pPage;
	DbPage *pDbPage;
	assert(sqlite3_mutex_held(pBt->mutex));
	rc = sqlite3PagerAcquire(pBt->pPager, pgno, (DbPage **) & pDbPage, noContent);
	if(rc)
		return rc;
	pPage = (MemPage *) sqlite3PagerGetExtra(pDbPage);
	pPage->aData = sqlite3PagerGetData(pDbPage);
	pPage->pDbPage = pDbPage;
	pPage->pBt = pBt;
	pPage->pgno = pgno;
	pPage->hdrOffset = pPage->pgno == 1 ? 100 : 0;
	*ppPage = pPage;
	return SQLITE_OK;
}
########################rank 9#############################
static void mdbx_dpage_free(MDBX_env *env, MDBX_page *dp, unsigned pages) {
#if MDBX_DEBUG
  dp->mp_pgno = MAX_PAGENO + 1;
#endif
  if (pages == 1) {
    dp->mp_next = env->me_dpages;
    VALGRIND_MEMPOOL_FREE(env, dp);
    env->me_dpages = dp;
  } else {
    VALGRIND_MEMPOOL_FREE(env, dp);
    mdbx_free(dp);
  }
}
########################rank 10#############################
SQLITE_PRIVATE void keen_io_sqlite3PcacheRelease(PgHdr *p){
  assert( p->nRef>0 );
  p->nRef--;
  if( p->nRef==0 ){
    PCache *pCache = p->pCache;
    pCache->nRef--;
    if( (p->flags&PGHDR_DIRTY)==0 ){
      pcacheUnpin(p);
    }else{
      pcacheRemoveFromDirtyList(p);
      pcacheAddToDirtyList(p);
    }
  }
}
----------------------------QUERY-------------------------------
create message with given type
########################rank 1#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 2#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 3#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 4#############################
void DNS_init(uint8_t s, uint8_t * buf)
{
	DNS_SOCKET = s; // SOCK_DNS
	pDNSMSG = buf; // User's shared buffer
	DNS_MSGID = DNS_MSG_ID;
}
########################rank 5#############################
void
error(a, b, c, d, e, f, g, h, i, j)
char *a;
{
	sprintf(err_msg, a, b, c, d, e, f, g, h, i, j);
	li_err_msg = err_msg;
}
########################rank 6#############################
void start_msg(char **msg, int type)
{
	put_integer(type, msg);
	(*msg) += 4;
}
########################rank 7#############################
void my_perror( char *msg ) {
	if (errno == 0) {
		message( "error: %s.\n", msg );
	} else {
		char *errstr = strerror( errno );
		message( "error: %s: [%d] %s\n", msg, errno, errstr );
	}
}
########################rank 8#############################
void upb_env_initonly(upb_env *e) {
  e->ok_ = true;
  e->error_func_ = &default_err;
  e->error_ud_ = NULL;
}
########################rank 9#############################
void upb_env_initonly(upb_env *e) {
  e->ok_ = true;
  e->error_func_ = &default_err;
  e->error_ud_ = NULL;
}
########################rank 10#############################
void msg(fmt, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	REG char	*fmt;
	long	arg1, arg2, arg3, arg4, arg5, arg6, arg7;
{
	if (mode != MODE_VI)
	{
		sprintf(pmsg, fmt, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
		qaddstr(pmsg);
		addch('\n');
		exrefresh();
	}
	else
	{
		if (manymsgs)
		{
			getkey(WHEN_MSG);
		}
		sprintf(pmsg, fmt, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
		manymsgs = TRUE;
	}
}
----------------------------QUERY-------------------------------
encrypt byte sequence
########################rank 1#############################
static const unsigned short
    C1 = 52845,
    C2 = 22719,
    key_eexec = 55665,
    key_charstring = 4330;
static uchar decrypt(uchar cipher, unsigned short *keyp) {
    if (g_lenIV < 0) {
        return cipher;
    } else {
        unsigned short key = *keyp;
        uchar plain = cipher ^ (key >> 8);
        *keyp = (cipher + key) * C1 + C2;
        return plain;
    }
}
########################rank 2#############################
int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,
                   size_t ilen, unsigned char *output, size_t *olen )
{
    int ret;
    size_t block_size = 0;
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }
    *olen = 0;
    block_size = mbedtls_cipher_get_block_size( ctx );
    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
    {
        if( ilen != block_size )
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
        *olen = ilen;
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
                    ctx->operation, input, output ) ) )
        {
            return( ret );
        }
        return( 0 );
    }
#if defined(MBEDTLS_GCM_C)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )
    {
        *olen = ilen;
        return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,
                           output );
    }
#endif
    if ( 0 == block_size )
    {
        return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
    }
    if( input == output &&
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }
#if defined(MBEDTLS_CIPHER_MODE_CBC)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )
    {
        size_t copy_len = 0;
        if( ( ctx->operation == MBEDTLS_DECRYPT &&
                ilen + ctx->unprocessed_len <= block_size ) ||
             ( ctx->operation == MBEDTLS_ENCRYPT &&
                ilen + ctx->unprocessed_len < block_size ) )
        {
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
                    ilen );
            ctx->unprocessed_len += ilen;
            return( 0 );
        }
         * Process cached data first
         */
        if( 0 != ctx->unprocessed_len )
        {
            copy_len = block_size - ctx->unprocessed_len;
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
                    copy_len );
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
                    ctx->operation, block_size, ctx->iv,
                    ctx->unprocessed_data, output ) ) )
            {
                return( ret );
            }
            *olen += block_size;
            output += block_size;
            ctx->unprocessed_len = 0;
            input += copy_len;
            ilen -= copy_len;
        }
         * Cache final, incomplete block
         */
        if( 0 != ilen )
        {
            if( 0 == block_size )
            {
                return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
            }
            copy_len = ilen % block_size;
            if( copy_len == 0 && ctx->operation == MBEDTLS_DECRYPT )
                copy_len = block_size;
            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),
                    copy_len );
            ctx->unprocessed_len += copy_len;
            ilen -= copy_len;
        }
         * Process remaining full blocks
         */
        if( ilen )
        {
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
                    ctx->operation, ilen, ctx->iv, input, output ) ) )
            {
                return( ret );
            }
            *olen += ilen;
        }
        return( 0 );
    }
#endif /* MBEDTLS_CIPHER_MODE_CBC */
#if defined(MBEDTLS_CIPHER_MODE_CFB)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CFB )
    {
        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,
                ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,
                input, output ) ) )
        {
            return( ret );
        }
        *olen = ilen;
        return( 0 );
    }
#endif /* MBEDTLS_CIPHER_MODE_CFB */
#if defined(MBEDTLS_CIPHER_MODE_CTR)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CTR )
    {
        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,
                ilen, &ctx->unprocessed_len, ctx->iv,
                ctx->unprocessed_data, input, output ) ) )
        {
            return( ret );
        }
        *olen = ilen;
        return( 0 );
    }
#endif /* MBEDTLS_CIPHER_MODE_CTR */
#if defined(MBEDTLS_CIPHER_MODE_STREAM)
    if( ctx->cipher_info->mode == MBEDTLS_MODE_STREAM )
    {
        if( 0 != ( ret = ctx->cipher_info->base->stream_func( ctx->cipher_ctx,
                                                    ilen, input, output ) ) )
        {
            return( ret );
        }
        *olen = ilen;
        return( 0 );
    }
#endif /* MBEDTLS_CIPHER_MODE_STREAM */
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
########################rank 3#############################
void hmacSha512(uint8_t *out, const uint8_t *key, const unsigned int key_length, const uint8_t *text, const unsigned int text_length)
{
	unsigned int i;
	uint8_t hash[SHA512_HASH_LENGTH];
	uint8_t padded_key[128];
	HashState64 hs64;
	// Determine key.
	memset(padded_key, 0, sizeof(padded_key));
	if (key_length <= sizeof(padded_key))
	{
		memcpy(padded_key, key, key_length);
	}
	else
	{
		sha512Begin(&hs64);
		for (i = 0; i < key_length; i++)
		{
			sha512WriteByte(&hs64, key[i]);
		}
		sha512Finish(padded_key, &hs64);
	}
	// Calculate hash = H((K_0 XOR ipad) || text).
	sha512Begin(&hs64);
	for (i = 0; i < sizeof(padded_key); i++)
	{
		sha512WriteByte(&hs64, (uint8_t)(padded_key[i] ^ 0x36));
	}
	for (i = 0; i < text_length; i++)
	{
		sha512WriteByte(&hs64, text[i]);
	}
	sha512Finish(hash, &hs64);
	// Calculate H((K_0 XOR opad) || hash).
	sha512Begin(&hs64);
	for (i = 0; i < sizeof(padded_key); i++)
	{
		sha512WriteByte(&hs64, (uint8_t)(padded_key[i] ^ 0x5c));
	}
	for (i = 0; i < sizeof(hash); i++)
	{
		sha512WriteByte(&hs64, hash[i]);
	}
	sha512Finish(out, &hs64);
}
########################rank 4#############################
uint64_t
blackrock2_shuffle(const struct BlackRock *br, uint64_t m)
{
    uint64_t c;
    c = ENCRYPT(br->rounds, br->a_bits, br->a_mask, br->b_bits, br->b_mask, m, br->seed);
    while (c >= br->range)
        c = ENCRYPT(br->rounds, br->a_bits, br->a_mask, br->b_bits, br->b_mask, c, br->seed);
    return c;
}
########################rank 5#############################
uint64_t
blackrock2_shuffle(const struct BlackRock *br, uint64_t m)
{
    uint64_t c;
    c = ENCRYPT(br->rounds, br->a_bits, br->a_mask, br->b_bits, br->b_mask, m, br->seed);
    while (c >= br->range)
        c = ENCRYPT(br->rounds, br->a_bits, br->a_mask, br->b_bits, br->b_mask, c, br->seed);
    return c;
}
########################rank 6#############################
void sha4_hmac_finish( sha4_context *ctx, unsigned char output[64] )
{
    int is384, hlen;
    unsigned char tmpbuf[64];
    is384 = ctx->is384;
    hlen = ( is384 == 0 ) ? 64 : 48;
    sha4_finish( ctx, tmpbuf );
    sha4_starts( ctx, is384 );
    sha4_update( ctx, ctx->opad, 128 );
    sha4_update( ctx, tmpbuf, hlen );
    sha4_finish( ctx, output );
    memset( tmpbuf, 0, sizeof( tmpbuf ) );
}
########################rank 7#############################
int mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,
                   unsigned char *output, size_t *olen )
{
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    *olen = 0;
    if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
        MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||
        MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||
        MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )
    {
        return( 0 );
    }
    if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )
    {
        if( ctx->unprocessed_len != 0 )
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
        return( 0 );
    }
#if defined(MBEDTLS_CIPHER_MODE_CBC)
    if( MBEDTLS_MODE_CBC == ctx->cipher_info->mode )
    {
        int ret = 0;
        if( MBEDTLS_ENCRYPT == ctx->operation )
        {
            if( NULL == ctx->add_padding )
            {
                if( 0 != ctx->unprocessed_len )
                    return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
                return( 0 );
            }
            ctx->add_padding( ctx->unprocessed_data, mbedtls_cipher_get_iv_size( ctx ),
                    ctx->unprocessed_len );
        }
        else if( mbedtls_cipher_get_block_size( ctx ) != ctx->unprocessed_len )
        {
             * For decrypt operations, expect a full block,
             * or an empty block if no padding
             */
            if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )
                return( 0 );
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
        }
        if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
                ctx->operation, mbedtls_cipher_get_block_size( ctx ), ctx->iv,
                ctx->unprocessed_data, output ) ) )
        {
            return( ret );
        }
        if( MBEDTLS_DECRYPT == ctx->operation )
            return ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),
                                     olen );
        *olen = mbedtls_cipher_get_block_size( ctx );
        return( 0 );
    }
#else
    ((void) output);
#endif /* MBEDTLS_CIPHER_MODE_CBC */
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
########################rank 8#############################
static void update_V(uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
    HMAC_init(hash_context, K);
    HMAC_update(hash_context, V, hash_context->result_size);
    HMAC_finish(hash_context, K, V);
}
########################rank 9#############################
static void update_V(const uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
    HMAC_init(hash_context, K);
    HMAC_update(hash_context, V, hash_context->result_size);
    HMAC_finish(hash_context, K, V);
}
########################rank 10#############################
static void update_V(const uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
    HMAC_init(hash_context, K);
    HMAC_update(hash_context, V, hash_context->result_size);
    HMAC_finish(hash_context, K, V);
}
----------------------------QUERY-------------------------------
parse checksum file
########################rank 1#############################
int getc_crc(FILE *ib)
{
	int c;
	c = getc(ib);
	if (c != EOF)
		crc += c;		/* checksum */
	return c;
}
########################rank 2#############################
int
wr_rdfile(ARCHD *arcn, int ifd, off_t *left)
{
	int cnt;
	int res = 0;
	off_t size = arcn->sb.st_size;
	struct stat sb;
	 * while there are more bytes to write
	 */
	while (size > 0L) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0)) {
			*left = size;
			return(-1);
		}
		cnt = MIN(cnt, size);
		if ((res = read(ifd, bufpt, cnt)) <= 0)
			break;
		size -= res;
		bufpt += res;
	}
	 * better check the file did not change during this operation
	 * or the file read failed.
	 */
	if (res < 0)
		syswarn(1, errno, "Read fault on %s", arcn->org_name);
	else if (size != 0L)
		paxwarn(1, "File changed size during read %s", arcn->org_name);
	else if (fstat(ifd, &sb) < 0)
		syswarn(1, errno, "Failed stat on %s", arcn->org_name);
	else if (arcn->sb.st_mtime != sb.st_mtime)
		paxwarn(1, "File %s was modified during copy to archive",
			arcn->org_name);
	*left = size;
	return(0);
}
########################rank 3#############################
static unsigned
tcp_checksum2(const unsigned char *px, unsigned offset_ip,
              unsigned offset_tcp, size_t tcp_length)
{
    uint64_t xsum = 0;
    unsigned i;
    xsum = 6;
    xsum += tcp_length;
    xsum += px[offset_ip + 12] << 8 | px[offset_ip + 13];
    xsum += px[offset_ip + 14] << 8 | px[offset_ip + 15];
    xsum += px[offset_ip + 16] << 8 | px[offset_ip + 17];
    xsum += px[offset_ip + 18] << 8 | px[offset_ip + 19];
    for (i=0; i<tcp_length; i += 2) {
        xsum += px[offset_tcp + i]<<8 | px[offset_tcp + i + 1];
    }
    xsum -= (tcp_length & 1) * px[offset_tcp + i - 1]; /* yea I know going off end of packet is bad so sue me */
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    return (unsigned)xsum;
}
########################rank 4#############################
static unsigned
tcp_checksum2(const unsigned char *px, unsigned offset_ip,
              unsigned offset_tcp, size_t tcp_length)
{
    uint64_t xsum = 0;
    unsigned i;
    xsum = 6;
    xsum += tcp_length;
    xsum += px[offset_ip + 12] << 8 | px[offset_ip + 13];
    xsum += px[offset_ip + 14] << 8 | px[offset_ip + 15];
    xsum += px[offset_ip + 16] << 8 | px[offset_ip + 17];
    xsum += px[offset_ip + 18] << 8 | px[offset_ip + 19];
    for (i=0; i<tcp_length; i += 2) {
        xsum += px[offset_tcp + i]<<8 | px[offset_tcp + i + 1];
    }
    xsum -= (tcp_length & 1) * px[offset_tcp + i - 1]; /* yea I know going off end of packet is bad so sue me */
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    return (unsigned)xsum;
}
########################rank 5#############################
const char *d_submatch(int i)
{
   return d_submatches[i];
}
########################rank 6#############################
void
masscan_load_database_files(struct Masscan *masscan)
{
    const char *filename;
    filename = masscan->payloads.pcap_payloads_filename;
    if (filename) {
        if (masscan->payloads.udp == NULL)
            masscan->payloads.udp = payloads_udp_create();
        if (masscan->payloads.oproto == NULL)
            masscan->payloads.oproto = payloads_udp_create();
        payloads_read_pcap(filename, masscan->payloads.udp, masscan->payloads.oproto);
    }
     * "nmap-payloads"
     */
    filename = masscan->payloads.nmap_payloads_filename;
    if (filename) {
        FILE *fp;
        int err;
        err = fopen_s(&fp, filename, "rt");
        if (err || fp == NULL) {
            perror(filename);
        } else {
            if (masscan->payloads.udp == NULL)
                masscan->payloads.udp = payloads_udp_create();
            payloads_udp_readfile(fp, filename, masscan->payloads.udp);
            fclose(fp);
        }
    }
     * "nmap-service-probes"
     */
    filename = masscan->payloads.nmap_service_probes_filename;
    if (filename) {
        if (masscan->payloads.probes)
            nmapserviceprobes_free(masscan->payloads.probes);
        masscan->payloads.probes = nmapserviceprobes_read_file(filename);
    }
}
########################rank 7#############################
unsigned
udp_checksum2(const unsigned char *px, unsigned offset_ip,
              unsigned offset_tcp, size_t tcp_length)
{
    uint64_t xsum = 0;
    unsigned i;
    xsum = 17;
    xsum += tcp_length;
    xsum += px[offset_ip + 12] << 8 | px[offset_ip + 13];
    xsum += px[offset_ip + 14] << 8 | px[offset_ip + 15];
    xsum += px[offset_ip + 16] << 8 | px[offset_ip + 17];
    xsum += px[offset_ip + 18] << 8 | px[offset_ip + 19];
    for (i=0; i<tcp_length; i += 2) {
        xsum += px[offset_tcp + i]<<8 | px[offset_tcp + i + 1];
    }
    xsum -= (tcp_length & 1) * px[offset_tcp + i - 1]; /* yea I know going off end of packet is bad so sue me */
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    return (unsigned)xsum;
}
########################rank 8#############################
unsigned
udp_checksum2(const unsigned char *px, unsigned offset_ip,
              unsigned offset_tcp, size_t tcp_length)
{
    uint64_t xsum = 0;
    unsigned i;
    xsum = 17;
    xsum += tcp_length;
    xsum += px[offset_ip + 12] << 8 | px[offset_ip + 13];
    xsum += px[offset_ip + 14] << 8 | px[offset_ip + 15];
    xsum += px[offset_ip + 16] << 8 | px[offset_ip + 17];
    xsum += px[offset_ip + 18] << 8 | px[offset_ip + 19];
    for (i=0; i<tcp_length; i += 2) {
        xsum += px[offset_tcp + i]<<8 | px[offset_tcp + i + 1];
    }
    xsum -= (tcp_length & 1) * px[offset_tcp + i - 1]; /* yea I know going off end of packet is bad so sue me */
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    xsum = (xsum & 0xFFFF) + (xsum >> 16);
    return (unsigned)xsum;
}
########################rank 9#############################
int cksum(char *buf, unsigned long count)
{
        unsigned len;
        unsigned char tot;
        unsigned char cksum;
        unsigned x;
        tot = 0;
        len = hextobin(buf + 2);
        for (x = 0; x != len; ++x) {
                tot += hextobin(buf + 2 + x * 2);
        }
        cksum = hextobin(buf + 2 + x * 2);
        tot = (255 & ~tot);
        if (tot != cksum) {
                fprintf(stderr, "Checksum mismatch on line %ld (got %x but calculated %x)\n", count, cksum, tot);
                return 1;
        } else {
                return 0;
        }
}
########################rank 10#############################
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;
    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 
    return (unsigned short)(~cksum); 
}
----------------------------QUERY-------------------------------
remove trailing blanks, tabs and newlines
########################rank 1#############################
static unsigned strstrip(char * s)
{
    char *last = NULL ;
    char *dest = s;
    if (s==NULL) return 0;
    last = s + strlen(s);
    while (isspace((int)*s) && *s) s++;
    while (last > s) {
        if (!isspace((int)*(last-1)))
            break ;
        last -- ;
    }
    *last = (char)0;
    memmove(dest,s,last - s + 1);
    return last - s;
}
########################rank 2#############################
int
delwhite(int f, int n)
{
	int	col, s;
	col = curwp->w_doto;
	while (col < llength(curwp->w_dotp) &&
	    (isspace(lgetc(curwp->w_dotp, col))))
		++col;
	do {
		if (curwp->w_doto == 0) {
			s = FALSE;
			break;
		}
		if ((s = backchar(FFRAND, 1)) != TRUE)
			break;
	} while (isspace(lgetc(curwp->w_dotp, curwp->w_doto)));
	if (s == TRUE)
		(void)forwchar(FFRAND, 1);
	(void)ldelete((RSIZE)(col - curwp->w_doto), KNONE);
	return (TRUE);
}
########################rank 3#############################
static char *strskp(char *s)
{
	char *skip = s;
	if(s == NULL)
		return NULL;
	while(isspace((int)*skip) && *skip)
		skip++;
	return skip;
}
########################rank 4#############################
char *rtrim( char *str )
{
  int i = strlen( str ) - 1;
  while( (isspace(str[i])) && (i>=0) )
    str[i--] = '\0';
  return str;
}
########################rank 5#############################
int
d_expunge(int f, int n)
{
	struct line	*lp, *nlp;
	char		 fname[NFILEN];
	for (lp = bfirstlp(curbp); lp != curbp->b_headp; lp = nlp) {
		nlp = lforw(lp);
		if (llength(lp) && lgetc(lp, 0) == 'D') {
			switch (d_makename(lp, fname, sizeof(fname))) {
			case ABORT:
				ewprintf("Bad line in dired buffer");
				return (FALSE);
			case FALSE:
				if (unlink(fname) < 0) {
					ewprintf("Could not delete '%s'",
					    basename(fname));
					return (FALSE);
				}
				break;
			case TRUE:
				if (rmdir(fname) < 0) {
					ewprintf("Could not delete directory '%s'",
					    basename(fname));
					return (FALSE);
				}
				break;
			}
			lfree(lp);
			curwp->w_bufp->b_lines--;
			curwp->w_flag |= WFFULL;
		}
	}
	return (TRUE);
}
########################rank 6#############################
char *ptr;			
int line = 0;			/* Current line number */
void skipws()
{
	while (*ptr == ' ' || *ptr == '\t')
		++ptr;
	if (*ptr == '#')
		*ptr = 0;
	if (*ptr == '\n')
		*ptr = 0;
}
########################rank 7#############################
size_t Q_strcount( const char *s, const char *substr ) {
	size_t cnt;
	size_t substr_len;
	if( !s || !*s ) {
		return 0;
	}
	if( !substr || !*substr ) {
		return 0;
	}
	substr_len = strlen( substr );
	cnt = 0;
	while( ( s = strstr( s, substr ) ) != NULL ) {
		cnt++;
		s += substr_len;
	}
	return cnt;
}
########################rank 8#############################
int string_split_quotes(char *str, int *argc, char ***argv)
{
	*argc = 0;
	*argv = malloc((strlen(str) + 1) * sizeof(char *));
	if(!*argv)
		return 0;
	while(*str) {
		while(isspace((int) *str)) {
			str++;
		}
		if(!*str)
			break;
		(*argv)[(*argc)++] = str;
		while(*str) {
			if(*str == '\\') {
				memmove(str, str + 1, strlen(str));
				if(*str)
					str++;
			} else if(isspace((int) *str)) {
				*str = 0;
				str++;
				break;
			} else if(*str == '\'' || *str == '\"') {
				char quote = *str;
				memmove(str, str + 1, strlen(str));
				while(*str) {
					if(*str == '\\') {
						memmove(str, str + 1, strlen(str));
						if(*str)
							str++;
					} else if(*str == quote) {
						memmove(str, str + 1, strlen(str));
						break;
					} else {
						str++;
					}
				}
			} else if(!*str) {
				break;
			} else {
				str++;
			}
		}
	}
	(*argv)[*argc] = 0;
	return 1;
}
########################rank 9#############################
int cmdline_execute(unsigned char *input, long int input_len)
{
    int space = 0;
    unsigned char *s = input;
    long int i = 0;
    while (i < input_len) {
        switch(input[i]) {
            case '"':
            case '\'':
            case '\\':
            case '^':
                i++;
                continue;
            case ' ':
            case ',':
            case ';':
            case '\t':
            case '\r':
            case '\n':
                if (!space) {
                    *s++ = ' ';
                    space++;
                }
                break;
            case '/':
            case '(':
                if (space) s--;
                space = 0;
                *s++ = input[i];
                break;
            default :
                *s++ = tolower(input[i]);
                space = 0;
        }
        i++;
    }
    *s = 0;
    return s - input;
}
########################rank 10#############################
int
capword(int f, int n)
{
	int	c, s;
	RSIZE	size;
	if ((s = checkdirty(curbp)) != TRUE)
		return (s);
	if (curbp->b_flag & BFREADONLY) {
		ewprintf("Buffer is read-only");
		return (FALSE);
	}
	if (n < 0)
		return (FALSE);
	while (n--) {
		while (inword() == FALSE) {
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
		}
		size = countfword();
		undo_add_change(curwp->w_dotp, curwp->w_doto, size);
		if (inword() != FALSE) {
			c = lgetc(curwp->w_dotp, curwp->w_doto);
			if (ISLOWER(c) != FALSE) {
				c = TOUPPER(c);
				lputc(curwp->w_dotp, curwp->w_doto, c);
				lchange(WFFULL);
			}
			if (forwchar(FFRAND, 1) == FALSE)
				return (TRUE);
			while (inword() != FALSE) {
				c = lgetc(curwp->w_dotp, curwp->w_doto);
				if (ISUPPER(c) != FALSE) {
					c = TOLOWER(c);
					lputc(curwp->w_dotp, curwp->w_doto, c);
					lchange(WFFULL);
				}
				if (forwchar(FFRAND, 1) == FALSE)
					return (TRUE);
			}
		}
	}
	return (TRUE);
}
----------------------------QUERY-------------------------------
search last occurrence of char in string
########################rank 1#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 2#############################
char *
strstr(const char *s1, const char *s2)
{
   char *sp = (char *)s1;
   int  len1 = strlen(s1);
   int  len2 = strlen(s2);
   while (len1 >= len2) 
   {
      if (strncmp(sp, s2, len2) == 0)
      {
         return (sp);
      }
      ++sp;
      --len1;
   }
   return (NULL);
}
########################rank 3#############################
char* strchr(const char* str, int c) {
	while (*str) {
		if (*str == c) {
			return (char*) str;
		}
		++str;
	}
	return NULL;
}
########################rank 4#############################
int strlen(char s[]) {
    int i = 0;
    while (s[i] != '\0') ++i;
    return i;
}
########################rank 5#############################
static const char * strlwc(const char * in, char *out, unsigned len)
{
    unsigned i ;
    if (in==NULL || out == NULL || len==0) return NULL ;
    i=0 ;
    while (in[i] != '\0' && i < len-1) {
        out[i] = (char)tolower((int)in[i]);
        i++ ;
    }
    out[i] = '\0';
    return out ;
}
########################rank 6#############################
char *
strchr(const char *str, int c)
{
   char *sp = (char *)str;
   char  ch = (char)(c & 0xff);
   while (*sp != '\0')
   {
      if (*sp == ch)
      {
         return (sp);
      }
      ++sp;
   }
   return (NULL);
}
########################rank 7#############################
char *
strchr(const char *str, int c)
{
   char *sp = (char *)str;
   char  ch = (char)(c & 0xff);
   while (*sp != '\0')
   {
      if (*sp == ch)
      {
         return (sp);
      }
      ++sp;
   }
   return (NULL);
}
########################rank 8#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 9#############################
char *strlowercase(const char *s)
{
  int i, len = strlen(s);
  static char buf[1024];
  for( i = 0; i <= len; i++ )
    buf[i] = tolower(s[i]);
  return buf;
}
########################rank 10#############################
int strcmp( const char *pcString1, const char *pcString2 )
{
volatile int iReturn, iIndex = 0;
	while( ( pcString1[ iIndex ] != 0x00 ) && ( pcString2[ iIndex ] != 0x00 ) )
	{
		iIndex++;
	}
	if( ( pcString1[ iIndex ] == 0x00 ) && ( pcString2[ iIndex ] == 0x00 ) )
	{
		iReturn = 0;
	}
	else
	{
		iReturn = ~0;
	}
	return iReturn;
}
----------------------------QUERY-------------------------------
binary search in sorted array of size
########################rank 1#############################
static int sortByAmountTips(const void *a, const void *b)
{				
  entry 
    *A = (*(entry **)a),
    *B = (*(entry **)b);
  if((unsigned int)A->amountTips == (unsigned int)B->amountTips)
    return 0; 
  return (((unsigned int)A->amountTips < (unsigned int)B->amountTips) ?  -1 : 1); 
}
########################rank 2#############################
int mrbc_hash_compare(const mrbc_value *v1, const mrbc_value *v2)
{
  if( v1->hash->n_stored != v2->hash->n_stored ) return 1;
  mrbc_value *d1 = v1->hash->data;
  int i;
  for( i = 0; i < mrbc_hash_size(v1); i++, d1++ ) {
    mrbc_value *d2 = mrbc_hash_search(v2, d1);	// check key
    if( d2 == NULL ) return 1;
    if( mrbc_compare( ++d1, ++d2 ) ) return 1;	// check data
  }
  return 0;
}
########################rank 3#############################
static unsigned int binarySearch(uint64_t* array, uint64_t z, int n)
{
  unsigned int 
    first = 0,
    last = n-3,
    middle = (first + last) / 2, 
    lastSmallerOrEqual = 0;
  while(first <= last)
    {
      if(array[middle] < z)
	{
	  first = middle + 1;
	  lastSmallerOrEqual = middle;
	}
      else 
	{
	  if (array[middle] > z)	  
	    last = middle-1;	 
	  else 
	    { 
	      // array[middle] == z
	      lastSmallerOrEqual = middle;
	      break;
	    }
	}
      middle = (first + last)/2;
    }
  return lastSmallerOrEqual;
}
########################rank 4#############################
int64_t find_next(int **array, int64_t start, int64_t last, int value) {
  int64_t i;
  for (i = start; i < last; i++) {
    if (*(array[i]) == value) {
      break;
    }
  }
  return i;
}
########################rank 5#############################
l_int32
arrayFindSequence(const l_uint8  *data,
                  l_int32         datalen,
                  const l_uint8  *sequence,
                  l_int32         seqlen,
                  l_int32        *poffset,
                  l_int32        *pfound)
{
l_int32  i, j, found, lastpos;
    PROCNAME("arrayFindSequence");
    if (!data || !sequence)
        return ERROR_INT("data & sequence not both defined", procName, 1);
    if (!poffset)
        return ERROR_INT("&offset not defined", procName, 1);
    *poffset = -1;
    if (pfound) *pfound = 0;
    lastpos = datalen - seqlen + 1;
    found = 0;
    for (i = 0; i < lastpos; i++) {
        for (j = 0; j < seqlen; j++) {
            if (data[i + j] != sequence[j])
                 break;
            if (j == seqlen - 1)
                 found = 1;
        }
        if (found)
            break;
    }
    if (found) {
        *poffset = i;
        if (pfound) *pfound = 1;
    }
    return 0;
}
########################rank 6#############################
static int __hot mdbx_cmp_memn(const MDBX_val *a, const MDBX_val *b) {
  if (a->iov_len == b->iov_len)
    return memcmp(a->iov_base, b->iov_base, a->iov_len);
  const int diff_len = (a->iov_len < b->iov_len) ? -1 : 1;
  const size_t shortest = (a->iov_len < b->iov_len) ? a->iov_len : b->iov_len;
  int diff_data = memcmp(a->iov_base, b->iov_base, shortest);
  return likely(diff_data) ? diff_data : diff_len;
}
########################rank 7#############################
int dictionary_set(dictionary * d, const char * key, const char * val)
{
    ssize_t         i ;
    unsigned       hash ;
    if (d==NULL || key==NULL) return -1 ;
    hash = dictionary_hash(key) ;
    if (d->n>0) {
        for (i=0 ; i<d->size ; i++) {
            if (d->key[i]==NULL)
                continue ;
            if (hash==d->hash[i]) { /* Same hash value */
                if (!strcmp(key, d->key[i])) {   /* Same key */
                    if (d->val[i]!=NULL)
                        free(d->val[i]);
                    d->val[i] = (val ? xstrdup(val) : NULL);
                    return 0 ;
                }
            }
        }
    }
    if (d->n==d->size) {
        if (dictionary_grow(d) != 0)
            return -1;
    }
       d->size. Because d->n < d->size this will necessarily
       terminate. */
    for (i=d->n ; d->key[i] ; ) {
        if(++i == d->size) i = 0;
    }
    d->key[i]  = xstrdup(key);
    d->val[i]  = (val ? xstrdup(val) : NULL) ;
    d->hash[i] = hash;
    d->n ++ ;
    return 0 ;
}
########################rank 8#############################
ion_cursor_status_t
oafdict_next(
	ion_dict_cursor_t	*cursor,
	ion_record_t		*record
) {
	ion_oafdict_cursor_t *oafdict_cursor = (ion_oafdict_cursor_t *) cursor;
	if (cursor->status == cs_cursor_uninitialized) {
		return cursor->status;
	}
	else if (cursor->status == cs_end_of_results) {
		return cursor->status;
	}
	else if ((cursor->status == cs_cursor_initialized) || (cursor->status == cs_cursor_active)) {
		ion_file_hashmap_t *hash_map = ((ion_file_hashmap_t *) cursor->dictionary->instance);
		int data_length = hash_map->super.record.key_size + hash_map->super.record.value_size;
		if (cursor->status == cs_cursor_active) {
			if (cs_end_of_results == oafdict_scan(oafdict_cursor)) {
				cursor->status = cs_end_of_results;
				return cursor->status;
			}
		}
		else {
			cursor->status = cs_cursor_active;
		}
		fseek(hash_map->file, (SIZEOF(STATUS) + data_length) * oafdict_cursor->current	/* position is based on indexes (not abs file pos) */
			+ SIZEOF(STATUS), SEEK_SET);
		fread(record->key, hash_map->super.record.key_size, 1, hash_map->file);
		fread(record->value, hash_map->super.record.value_size, 1, hash_map->file);
		return cursor->status;
	}
	return cs_invalid_cursor;
}
########################rank 9#############################
int find_word_size() {
    int x = 1L;
    int w = 0;
    while (x) {
	w++;
	x <<= 1;
    }
    return w;
}
########################rank 10#############################
static HashElem *findElementGivenHash(
  const Hash *pH, /* The pH to be searched */
  const void *pKey,   /* The key we are searching for */
  int nKey,
  int h               /* The hash for this key. */
){
  HashElem *elem;            /* Used to loop thru the element list */
  int count;                     /* Number of elements left to test */
  if( pH->ht ){
    struct _ht *pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
    while( count-- && elem ){
      if( binCompare(elem->pKey,elem->nKey,pKey,nKey)==0 ){
        return elem;
      }
      elem = elem->next;
    }
  }
  return 0;
}
----------------------------QUERY-------------------------------
calculate checksum of checkpoint
########################rank 1#############################
static void ckptChecksum(u32 *aCkpt, u32 nCkpt, u32 *piCksum1, u32 *piCksum2){
  u32 i;
  u32 cksum1 = 1;
  u32 cksum2 = 2;
  if( nCkpt % 2 ){
    cksum1 += aCkpt[nCkpt-3] & 0x0000FFFF;
    cksum2 += aCkpt[nCkpt-3] & 0xFFFF0000;
  }
  for(i=0; (i+3)<nCkpt; i+=2){
    cksum1 += cksum2 + aCkpt[i];
    cksum2 += cksum1 + aCkpt[i+1];
  }
  *piCksum1 = cksum1;
  *piCksum2 = cksum2;
}
########################rank 2#############################
void ogg_page_checksum_set(ogg_page *og){
  if(og){
    ogg_uint32_t crc_reg=0;
    int i;
    og->header[22]=0;
    og->header[23]=0;
    og->header[24]=0;
    og->header[25]=0;
    for(i=0;i<og->header_len;i++)
      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->header[i]];
    for(i=0;i<og->body_len;i++)
      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->body[i]];
    og->header[22]=(unsigned char)(crc_reg&0xff);
    og->header[23]=(unsigned char)((crc_reg>>8)&0xff);
    og->header[24]=(unsigned char)((crc_reg>>16)&0xff);
    og->header[25]=(unsigned char)((crc_reg>>24)&0xff);
  }
}
########################rank 3#############################
void ogg_page_checksum_set(ogg_page *og){
  if(og){
    ogg_uint32_t crc_reg=0;
    int i;
    og->header[22]=0;
    og->header[23]=0;
    og->header[24]=0;
    og->header[25]=0;
    for(i=0;i<og->header_len;i++)
      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->header[i]];
    for(i=0;i<og->body_len;i++)
      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->body[i]];
    og->header[22]=crc_reg&0xff;
    og->header[23]=(crc_reg>>8)&0xff;
    og->header[24]=(crc_reg>>16)&0xff;
    og->header[25]=(crc_reg>>24)&0xff;
  }
}
########################rank 4#############################
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;
    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 
    return (unsigned short)(~cksum); 
}
########################rank 5#############################
static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}
########################rank 6#############################
static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}
########################rank 7#############################
static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}
########################rank 8#############################
static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}
########################rank 9#############################
static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}
########################rank 10#############################
static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}
----------------------------QUERY-------------------------------
judge whether two strings are equal
########################rank 1#############################
int compare_str(const void * a, const void * b) {
	return strcmp(*(const char **)a, *(const char **)b);
}
########################rank 2#############################
static int firstone(char *s, int c, int n)
{
    char *s2 = s + n;
    int i = 0;
    while (s != s2)
    {
        if (*s == c) return (i);
        i++;
        s++;
    }
    return (-1);
}
########################rank 3#############################
const char * memrstr(const char *hay, const char *need, size_t haylen)
{
  size_t nl = strlen(need);
  int i = (int)(nl - haylen);
  while (i > -1) {
    if (hay[i] == *need && 0 == memcmp(hay+i, need, nl))
      goto found;
    i--;
  }
found:
  return (i > -1 ? hay+i : NULL);
}
########################rank 4#############################
int
wcscoll(const wchar_t *ws1, const wchar_t *ws2)
{
    return wcscmp(ws1, ws2);
}
########################rank 5#############################
char *word(char *s)
{
  while(*s && *s!='(' && *s!='=' && *s!=' ' && *s!='\t')
    ++s;
  if(*s)
    *s++=0;
  return s;
}
########################rank 6#############################
bool Q_isdigit( const char *str ) {
	if( str && *str ) {
		while( isdigit( *str ) ) str++;
		if( !*str ) {
			return true;
		}
	}
	return false;
}
########################rank 7#############################
int isexactlcmd(const char *p, const char *s)
{
  while(*p == *s && *s != '\t' && *s != '\0' ) { ++p; ++s; }
  if (*s == '\t' && isLaTeXcmdletter(*p) == 0) return 0;
  return 1;
}
########################rank 8#############################
unsigned long lexp(unsigned long b, int e)
{
	unsigned long p = b;
	if (!e) return 1;
	while(--e)
		p *= b;
	return p;
}
########################rank 9#############################
int
oputs(i)
char	*i;
{
	while (*i != 0)
		oput(*i++);
	return (0);
}
########################rank 10#############################
static int cmp_str(const void *v1, const void *v2)
{
    register int c1, c2;
    register int n1, n2;
    register const STR *p1, *p2;
#define SET_N(nf,ch)    (nf = (ch == '\n'))
#define IS_END(ch,nf)   (ch == Delimch && nf)
    p1 = (const STR *) v1;
    p2 = (const STR *) v2;
    c1 = p1->first;
    c2 = p2->first;
    if (c1 != c2)
        return c1 - c2;
    fseek(Sort_1, p1->pos, 0);
    fseek(Sort_2, p2->pos, 0);
    n1 = FALSE;
    n2 = FALSE;
    while (!isalnum(c1 = getc(Sort_1)) && c1 != '\0')
        SET_N(n1, c1);
    while (!isalnum(c2 = getc(Sort_2)) && c2 != '\0')
        SET_N(n2, c2);
    while (!IS_END(c1, n1) && !IS_END(c2, n2))
    {
        if (Iflag)
        {
            if (isupper(c1))
                c1 = tolower(c1);
            if (isupper(c2))
                c2 = tolower(c2);
        }
        if (c1 != c2)
            return c1 - c2;
        SET_N(n1, c1);
        SET_N(n2, c2);
        c1 = getc(Sort_1);
        c2 = getc(Sort_2);
    }
    if (IS_END(c1, n1))
        c1 = 0;
    if (IS_END(c2, n2))
        c2 = 0;
    return c1 - c2;
}
----------------------------QUERY-------------------------------
return random integer value between min and max
########################rank 1#############################
static char *ftepp_predef_random(ftepp_t *context) {
    char *value;
    context->predef_randval = (util_rand() % 0xFF) + 1;
    util_asprintf(&value, "%u", context->predef_randval);
    return value;
}
########################rank 2#############################
static u_int32_t
my_arc4random_r(void)
{
	static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
	u_int32_t ret;
	(void)pthread_mutex_lock(&mymutex);
	ret = arc4random();
	(void)pthread_mutex_unlock(&mymutex);
	return (ret);
}
########################rank 3#############################
int64_t intsetRandom(intset *is) {
    return _intsetGet(is,rand()%is->length);
}
########################rank 4#############################
double
genrand_real3(void)
{
  return (((double) genrand_int32()) + 0.5) * (1.0 / 4294967296.0);
}
########################rank 5#############################
double
genrand_real2(void)
{
  return genrand_int32() * (1.0 / 4294967296.0);
}
########################rank 6#############################
double
genrand_real1(void)
{
  return genrand_int32() * (1.0 / 4294967295.0);
}
########################rank 7#############################
double genrand_real3(void)
{
    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); 
}
########################rank 8#############################
double genrand_real2(void)
{
    return genrand_int32()*(1.0/4294967296.0); 
}
########################rank 9#############################
unsigned int next = 1;
int rand(void)
{
    next = next*1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
}
########################rank 10#############################
unsigned int next = 1;
int rand(void)
{
    next = next*1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
}
